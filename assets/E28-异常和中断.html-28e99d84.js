import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as r,c as a,d as o}from"./app-cdabc73c.js";const d="/assets/e8a49f09d1bb50e4d42fccd14d743ad6-e896796d.jpeg",t="/assets/272b21cc50572c208b4db4b8ef8276f7-f9528976.jpeg",n="/assets/da0117e669ebd2bd06c19beaf12d0da8-3f3901cb.jpeg",m={},s=o('<h1 id="_28-异常和中断-程序出错了怎么办" tabindex="-1"><a class="header-anchor" href="#_28-异常和中断-程序出错了怎么办" aria-hidden="true">#</a> 28 | 异常和中断：程序出错了怎么办？</h1><p>过去这么多讲，我们的程序都是自动运行且正常运行的。自动运行的意思是说，我们的程序和指令都是一条条顺序执行，你不需要通过键盘或者网络给这个程序任何输入。正常运行是说，我们的程序都是能够正常执行下去的，没有遇到计算溢出之类的程序错误。</p><p>不过，现实的软件世界可没有这么简单。一方面，程序不仅是简单的执行指令，更多的还需要和外部的输入输出打交道。另一方面，程序在执行过程中，还会遇到各种异常情况，比如除以 0、溢出，甚至我们自己也可以让程序抛出异常。</p><p>那这一讲，我就带你来看看，如果遇到这些情况，计算机是怎么运转的，也就是说，计算机究竟是如何处理异常的。</p><h2 id="异常-硬件、系统和应用的组合拳" tabindex="-1"><a class="header-anchor" href="#异常-硬件、系统和应用的组合拳" aria-hidden="true">#</a> 异常：硬件、系统和应用的组合拳</h2><p>一提到计算机当中的<strong>异常</strong>（Exception），可能你的第一反应就是 C++ 或者 Java 中的 Exception。不过我们今天讲的，并不是这些软件开发过程中遇到的“软件异常”，<em>而是和硬件、系统相关的“硬件异常”</em>。</p><p>当然，“软件异常”和“硬件异常”并不是实际业界使用的专有名词，只是我为了方便给你说明，和 C++、Java 中软件抛出的 Exception 进行的人为区分，你明白这个意思就好。</p><p>尽管，这里我把<em>这些硬件和系统相关的异常</em>，叫作“<em>硬件异常</em>”。但是，实际上，这些异常，既有来自硬件的，也有来自软件层面的。</p><p>比如，我们在硬件层面，当加法器进行两个数相加的时候，会遇到算术溢出；或者，你在玩游戏的时候，按下键盘发送了一个信号给到 CPU，CPU 要去执行一个现有流程之外的指令，这也是一个“异常”。</p><p>同样，来自软件层面的，比如我们的程序进行系统调用，发起一个读文件的请求。这样应用程序向系统调用发起请求的情况，一样是通过“异常”来实现的。</p><p><strong>关于异常，最有意思的一点就是，它其实是<em>一个硬件和软件组合到一起的处理过程</em>。异常的前半生，也就是<code>异常的发生和捕捉</code>，<em>是在硬件层面完成的</em>。但是异常的后半生，也就是说，<code>异常的处理</code>，<em>其实是由软件来完成的</em>。</strong></p><h3 id="异常代码-中断向量-系统里一个事件" tabindex="-1"><a class="header-anchor" href="#异常代码-中断向量-系统里一个事件" aria-hidden="true">#</a> 异常代码 = 中断向量 -&gt; 系统里一个事件</h3><p>计算机会为每一种可能会发生的异常，分配一个<mark>异常代码</mark>（Exception Number）。有些教科书会把异常代码叫作<mark>中断向量</mark>（Interrupt Vector）。异常发生的时候，<strong>通常是 CPU 检测到了一个特殊的信号</strong>。比如，你按下键盘上的按键，输入设备就会给 CPU 发一个信号。或者，正在执行的指令发生了加法溢出，同样，我们可以有一个进位溢出的信号。这些信号呢，在组成原理里面，我们一般叫作发生了<mark>一个事件</mark>（Event）。CPU 在检测到事件的时候，其实也就拿到了<mark>对应的异常代码</mark>。</p><p><strong>这些异常代码里，I/O 发出的信号的异常代码，是由操作系统来分配的，<em>也就是由软件来设定的</em>。而像加法溢出这样的异常代码，则是由 CPU 预先分配好的，<em>也就是由硬件来分配的</em>。这又是另一个软件和硬件共同组合来处理异常的过程。</strong></p><h3 id="异常表-中断向量表-异常处理程序" tabindex="-1"><a class="header-anchor" href="#异常表-中断向量表-异常处理程序" aria-hidden="true">#</a> 异常表 = 中断向量表 -&gt; 异常处理程序</h3><p>拿到异常代码之后，CPU 就会触发异常处理的流程。计算机在内存里，会保留一个<mark>异常表</mark>（Exception Table）。也有地方，把这个表叫作<mark>中断向量表</mark>（Interrupt Vector Table），好和上面的中断向量对应起来。这个异常表有点儿像我们在第 10 讲里讲的 GOT 表，存放的是<strong>不同的异常代码对应的<mark>异常处理程序</mark></strong>（Exception Handler）所在的地址。</p><h3 id="异常和中断的处理流程" tabindex="-1"><a class="header-anchor" href="#异常和中断的处理流程" aria-hidden="true">#</a> 异常和中断的处理流程</h3><p>我们的 CPU 在拿到了异常码之后，<em>会先把当前的程序执行的现场，保存到程序栈里面</em>，然后根据异常码查询，找到对应的异常处理程序，<strong>最后把后续指令执行的指挥权，交给这个异常处理程序</strong>。</p><img src="'+d+'" alt="img" style="zoom:25%;"><h3 id="日常开发也很常见" tabindex="-1"><a class="header-anchor" href="#日常开发也很常见" aria-hidden="true">#</a> 日常开发也很常见</h3><p>这样“<code>检测异常，拿到异常码，再根据 异常码 进行查表处理</code>”的模式，在日常开发的过程中是很常见的。</p><img src="'+t+`" alt="img" style="zoom:25%;"><p>比如说，现在我们日常进行的 Web 或者 App 开发，通常都是前后端分离的。前端的应用，会向后端发起 HTTP 的请求。当后端遇到了异常，通常会给到前端一个对应的错误代码。前端的应用根据这个错误代码，在应用层面去进行错误处理。在不能处理的时候，它会根据错误代码向用户显示错误信息。</p><div class="language-JAVA line-numbers-mode" data-ext="JAVA"><pre class="language-JAVA"><code>public class LastChanceHandler implements Thread.UncaughtExceptionHandler {
    @Override
    public void uncaughtException(Thread t, Throwable e) {
        // do something here - log to file and upload to    server/close resources/delete files...
    }
}
Thread.setDefaultUncaughtExceptionHandler(new LastChanceHandler());
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Java 里面，可以设定 <code>ExceptionHandler</code>，<em>来处理线程执行中的异常情况</em></p><p>再比如说，Java 里面，我们使用<code>一个线程池</code>去运行调度任务的时候，<em>可以指定一个异常处理程序</em>。对于各个线程在执行任务出现的异常情况，<em>我们是通过<code>异常处理程序</code>进行处理</em>，而不是在实际的任务代码里处理。这样，我们就把<mark>业务处理代码</mark>就和<mark>异常处理代码</mark>的流程分开了。</p><h2 id="异常的分类-中断、陷阱、故障和中止" tabindex="-1"><a class="header-anchor" href="#异常的分类-中断、陷阱、故障和中止" aria-hidden="true">#</a> 异常的分类：中断、陷阱、故障和中止</h2><p>我在前面说了，异常可以由硬件触发，也可以由软件触发。那我们平时会碰到哪些异常呢？下面我们就一起来看看。</p><h3 id="_1-中断-i-o-设备的输入" tabindex="-1"><a class="header-anchor" href="#_1-中断-i-o-设备的输入" aria-hidden="true">#</a> 1 中断：I/O 设备的输入</h3><p>第一种异常叫<strong>中断</strong>（<code>Interrupt</code>）。顾名思义，自然就是程序在执行到一半的时候，被打断了。这个打断执行的信号，<em>来自于 CPU 外部的 I/O 设备</em>。你在键盘上按下一个按键，就会对应触发一个相应的信号到达 CPU 里面。CPU 里面某个开关的值发生了变化，也就触发了一个中断类型的异常。</p><h3 id="_2-陷阱-程序主动触发的状态切换" tabindex="-1"><a class="header-anchor" href="#_2-陷阱-程序主动触发的状态切换" aria-hidden="true">#</a> 2 陷阱：程序主动触发的状态切换</h3><p>第二种异常叫<strong>陷阱</strong>（<code>Trap</code>）。陷阱，<em>其实是我们程序员“故意“主动触发的异常</em>。就好像你在程序里面打了一个断点，这个断点就是设下的一个&quot;陷阱&quot;。<em>当程序的指令执行到这个位置的时候</em>，就掉到了这个陷阱当中。然后，<em>对应的异常处理程序就会来处理这个&quot;陷阱&quot;当中的猎物</em>。</p><p>最常见的一类陷阱，发生在我们的应用程序调用系统调用的时候，也就是从程序的用户态切换到内核态的时候。我们在第 3 讲讲 CPU 性能的时候说过，可以用 Linux 下的 time 指令，去查看一个程序运行实际花费的时间，里面有在用户态花费的时间（user time），也有在内核态发生的时间（system time）。</p><p>我们的<em>应用程序</em>通过<em>系统调用</em>去读取文件、创建进程，<em>其实也是通过触发一次陷阱来进行的</em>。这是因为，<strong>我们用户态的应用程序没有权限来做这些事情，需要把对应的流程转交给有权限的异常处理程序来进行</strong>。（系统调用，陷入内核。）</p><h3 id="_3-故障-异常情况下的程序出错" tabindex="-1"><a class="header-anchor" href="#_3-故障-异常情况下的程序出错" aria-hidden="true">#</a> 3 故障：异常情况下的程序出错</h3><p>第三种异常叫<strong>故障</strong>（<code>Fault</code>）。它和陷阱的区别在于，陷阱是我们开发程序的时候刻意触发的异常，<em>而故障通常不是</em>。比如，我们在程序执行的过程中，进行加法计算发生了溢出，其实就是故障类型的异常。<em>这个异常不是我们在开发的时候计划内的</em>，也一样需要有对应的异常处理程序去处理。</p><p>故障和陷阱、中断的一个重要区别是，故障在异常程序处理完成之后，<em>仍然回来处理当前的指令</em>，而不是去执行程序中的下一条指令。<em>因为当前的指令因为故障的原因并没有成功执行完成</em>。</p><blockquote><p>故障：最典型的其实就是缺页故障（但是经常表达成缺页异常），当程序需要读取内存数据，而此时相应的数据并不在内存中的时候，会触发缺页故障。等缺页故障处理程序处理好的时候，此时重新回到故障发生的指令--即读取内存数据，此时内存中已经有这个数据啦，就不会再发生缺页故障了</p></blockquote><h3 id="_4-中止-出错之后无可挽回的退出程序" tabindex="-1"><a class="header-anchor" href="#_4-中止-出错之后无可挽回的退出程序" aria-hidden="true">#</a> 4 中止：出错之后无可挽回的退出程序</h3><p>最后一种异常叫<strong>中止</strong>（<code>Abort</code>）。与其说这是一种异常类型，<em>不如说这是故障的一种特殊情况</em>。当 CPU 遇到了故障，但是恢复不过来的时候，<em>程序就不得不中止了</em>。</p><h3 id="总结说明" tabindex="-1"><a class="header-anchor" href="#总结说明" aria-hidden="true">#</a> 总结说明：</h3><img src="`+n+'" alt="img" style="zoom:25%;"><p>在这四种异常里，</p><p>==<em>中断</em>==异常的信号来自<em>系统外部，而不是在程序自己执行的过程中</em>，所以我们称之为“<em>异步</em>”类型的异常。</p><p>而==<strong>陷阱</strong><mark>、</mark><strong>故障</strong><mark>以及</mark>中止==类型的异常，<code>是在程序执行的过程中发生的</code>，所以我们称之为“<code>同步</code>“类型的异常。</p><p>在处理异常的过程当中，无论是异步的==<em>中断</em><mark>，还是同步的</mark><strong>陷阱</strong><mark>和</mark><strong>故障</strong>==，我们都是采用<strong>同一套处理流程</strong>，也就是上面所说的，<strong>“保存现场、异常代码查询、异常处理程序调用“</strong>。</p><p>而<mark>中止</mark>类型的异常，其实是在故障类型异常的一种特殊情况。当故障发生，但是我们发现<code>没有异常处理程序能够处理</code>这种异常的情况下，<code>程序就不得不</code>进入中止状态，也就是最<code>终会退出当前的程序执行</code>。</p><h2 id="异常的处理-上下文切换" tabindex="-1"><a class="header-anchor" href="#异常的处理-上下文切换" aria-hidden="true">#</a> 异常的处理：上下文切换</h2><p>在实际的异常处理程序执行之前，CPU 需要去做一次“<em>保存现场</em>”的操作。这个保存现场的操作，和我在第 7 讲里讲解函数调用的过程非常相似。</p><p>因为切换到异常处理程序的时候，其实就好像是去调用一个异常处理函数。指令的控制权被切换到了另外一个&quot;函数&quot;里面，所以我们自然要把当前正在执行的指令去压栈。这样，我们才能在异常处理程序执行完成之后，<em>重新回到当前的指令继续往下执行</em>。</p><p>不过，切换到异常处理程序，比起函数调用，还是要更复杂一些。原因有下面几点。</p><ol><li>第一点，因为异常情况往往发生在程序正常执行的预期之外，比如中断、故障发生的时候。<br> 所以，除了本来程序压栈要做的事情之外，<br><strong>我们还需要把 CPU 内当前运行程序用到的所有寄存器，都放到栈里面</strong>。<br> 最典型的就是**<code>条件码寄存器</code>**里面的内容。</li><li>第二点，像陷阱这样的异常，<strong>涉及程序指令在用户态和内核态之间的切换</strong>。<br> 对应压栈的时候，<strong>对应的数据是压到<code>内核栈</code>里，而不是程序栈里</strong>。</li><li>第三点，像故障这样的异常，在异常处理程序执行完成之后。<br> 从栈里返回出来，继续执行的不是顺序的下一条指令，而是**<code>故障发生的当前指令</code>**。<br><strong>因为当前指令因为故障没有正常执行成功，必须重新去执行一次</strong>。</li></ol><p>所以，对于异常这样的处理流程，不像是顺序执行的指令间的函数调用关系。<em>而是更像两个不同的独立进程之间在 CPU 层面的切换</em>，所以这个过程我们称之为**<mark>上下文切换</mark>**（Context Switch）。</p><h2 id="总结延伸" tabindex="-1"><a class="header-anchor" href="#总结延伸" aria-hidden="true">#</a> 总结延伸</h2><p>这一讲，我给你讲了计算机里的“异常”处理流程。这里的异常可以分成==<em>中断</em><mark>、</mark><strong>陷阱</strong><mark>、</mark><strong>故障</strong><mark>、<mark>中止</mark>这样四种情况。这四种异常，分别对应着 <mark><em>I/O 设备的输入</em></mark>、</mark><strong>程序主动触发的状态切换</strong><mark>、</mark><strong>异常情况下的程序出错</strong><mark>以及</mark>出错之后无可挽回的退出程序==。</p><p>当 CPU 遭遇了异常的时候，计算机就需要有相应的应对措施。CPU 会通过“<em>查表法</em>”来解决这个问题。在硬件层面和操作系统层面，各自定义了所有 CPU 可能会遇到的<em>异常代码</em>，并且通过这个异常代码，在<em>异常表</em>里面查询相应的<em>异常处理程序</em>。<strong>在捕捉异常的时候</strong>，我们的<code>硬件 CPU</code> 在进行相应的操作，<strong>而在处理异常层面</strong>，则是由作为<code>软件的异常处理程序</code>进行相应的操作。</p><p>而在实际处理异常之前，计算机需要先去做一个“<em>保留现场</em>”的操作。有了这个操作，我们才能在异常处理完成之后，重新回到之前执行的指令序列里面来。这个保留现场的操作，和我们之前讲解指令的函数调用很像。但是，因为“异常”和函数调用有一个很大的不同，<em>那就是它的发生时间</em>。函数调用的压栈操作我们在写程序的时候完全能够知道，而“异常”发生的时间却很不确定。所以，“异常”发生的时候，我们称之为发生了一次“<em>上下文切换</em>”（Context Switch）。这个时候，除了普通需要压栈的数据外，计算机还需要把所有寄存器信息都存储到栈里面去。</p><h2 id="推荐阅读" tabindex="-1"><a class="header-anchor" href="#推荐阅读" aria-hidden="true">#</a> 推荐阅读</h2><p>关于异常和中断，《<code>深入理解计算机系统</code>》的第 8 章“异常控制流”部分，有非常深入和充分的讲解，推荐你认真阅读一下。</p><h2 id="课后思考" tabindex="-1"><a class="header-anchor" href="#课后思考" aria-hidden="true">#</a> 课后思考</h2><p>很多教科书和网上的文章，会把中断分成软中断和硬中断。你能用自己的话说一说，什么是软中断，什么是硬中断吗？它们和我们今天说的中断、陷阱、故障以及中止又有什么关系呢？</p><p>欢迎留言和我分享你的疑惑和见解。你也可以把今天的内容，分享给你的朋友，和他一起学习和进步。</p><blockquote><p>linux内核中有软中断和硬中断的说法。比如网卡收包时，<code>硬中断</code>对应的概念是中断，即网卡利用信号“告知”CPU有包到来，CPU执行中断向量对应的处理程序，即收到的包拷贝到计算机的内存，然后“通知”软中断有任务需要处理，中断处理程序返回；<code>软中断</code>是一个内核级别的进程（线程），没有对应到本次课程的概念，用于处理硬中断余下的工作，比如网卡收的包需要向上送给协议栈处理。</p><hr><p>网上搜到的思考题答案，分享给大家：<br><code>硬中断</code>由与系统相连的外设(比如网卡、硬盘)自动产生的。主要是用来通知操作系统系统外设状态的变化。<br><code>软中断</code>是一组静态定义的下半部分接口，可以在所有的处理器上同时执行，即使两个类型相同也可以。<br> 但是一个软中断不会抢占另外的一个软中断，唯一可以抢占软中断的只有硬中断。<br><em>为了满足实时系统的要求</em>，中断处理应该越快越好。编写驱动程序的时候，<em>一个中断产生之后</em>，内核在中断处理函数中可能需要完成很多工作。<em>但是中断处理函数的处理是关闭了中断的</em>。也就是说在响应中断时，系统不能再次响应外部的其它中断。这样的后果会造成有可能丢失外部中断。于是，linux内核设计出了一种架构，中断函数需要处理的任务分为两部分，<em>一部分在中断处理函数中执行</em>，这时系统关闭中断。<em>另外一部分在软件中断中执行</em>，这个时候开启中断，系统可以响应外部中断。<br> Linux为了实现这个特点，当中断发生的时候<em>硬中断</em>处理那些短时间，就可以完成的工作，而将那些处理事件比较长的工作，放到中断之后来完成，也就是<em>软中断</em>(softirq)来完成。</p><hr><p>异常表注册一般是操作系统在初始化的时候干的事，高级语言的try...catch一般是通过跳转指令来处理的，个人理解，处理的逻辑是一样的，但是层级和位置不一样</p><p>硬中断就是硬件向cpu发出的信号，包括时钟信号、触摸屏触摸信号等，软中断就是陷阱，是程序进入内核态的方法，用于切换cpu模式。</p><p>软中断：系统调用 硬中断：硬件中断<br> 软中断，是程序执行过程中产生的异常，对应同步异常，包含陷阱，故障，终止。<br> 硬中断，是硬件产生的中断，对应异步异常。<br> 软中断是由软件来触发，它属于同步的中断。一般用来完成一些特定任务：int 3调试断点，以及之前Linux的int 80h系统调用。<br> 硬件中断是硬件组件触发的，可能是CPU内部异常，也可能是io外设的。外设的中断属于异步，它可能会在CPU指令执行期间触发。</p></blockquote>',63),c=[s];function i(p,h){return r(),a("div",null,c)}const u=e(m,[["render",i],["__file","E28-异常和中断.html.vue"]]);export{u as default};
