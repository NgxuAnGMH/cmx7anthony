import{_ as p}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o as e,c as o,a as n,b as s,e as c,d as i}from"./app-cdabc73c.js";const l="/assets/fc499d518a5987fab2a73fa187ddcb25-1a0350b2.jpg",u="/assets/03f5114061236420faba2f7e2b4cd49d-efc03095.jpg",r="/assets/fb52cf3110e0d5cbe5c6e8b2d2a44887-37c64278.jpg",k="/assets/afae2dd6e864f6d5476952a4ab49eac1-ba53439b.jpg",d="/assets/30fef1f7d94c5750c6fd8d05eb9e883b-d1835ade.jpg",m="/assets/6b38a4008a85e97f86e93d8d8b785da7-0d376e3f.jpg",v={},b=n("h1",{id:"_32-io管理-linux如何管理多个外设",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_32-io管理-linux如何管理多个外设","aria-hidden":"true"},"#"),s(" 32｜IO管理：Linux如何管理多个外设？")],-1),_=n("p",null,"你好，我是 LMOS。",-1),f=n("p",null,"在上一节课中，我们通过对 IO Cache 的学习，知道了 IO Cache 缓存了 IO 设备的数据，这些数据经过 IO 调度器送给块层，进而发送给 IO 设备。",-1),g=n("p",null,"今天我们再往下一层探索，以 Linux 为例，看看 Linux 是如何管理多个 IO 外设的。我们先从例子出发，了解一下设备在 Linux 中的与众不同，然后看看设备分类及接口，分析一下应用开发人员应该如何使用它们，最后我会带你一起实现一个设备加深理解。",-1),h={href:"https://gitee.com/lmos/Geek-time-computer-foundation/tree/master/lesson32",target:"_blank",rel:"noopener noreferrer"},x=i(`<h2 id="文件和外设的关系" tabindex="-1"><a class="header-anchor" href="#文件和外设的关系" aria-hidden="true">#</a> 文件和外设的关系</h2><p>用几十行代码在 Linux 上读写一个文件，我们都很熟悉吧。若是不熟悉，百度、谷歌都可以让我们熟悉。</p><p>我们今天要写的这个小例子就是从读取一个文件开始的。想要读取文件，首先得知道文件在哪里，也就是需要知道文件路径名，知道了文件路径名，再进行“三步走”就可以：打开它、读取它、关闭它。一句话，open、read、close 一气呵成。</p><p>那么这个文件是什么呢，路径名如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&quot;/dev/input/event3&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>看了路径名，我们知道 enent3 文件在根目录下 dev 目录的 input 目录之下。从名称上看，这好像与设备、输入、事件有关系，我这里先卖个关子，看完后面的讲解，你自然就知道答案了。</p><p>我们先来搞清楚读取这个文件能得到什么数据，读取该文件得到的不是一个字符流，<em>而是由时间、类型、码值以及状态数据封装成的<mark>一个结构</mark></em>。每读取一次，就能得到一个这样的结构，该结构如下所示：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">input_event</span> <span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">timeval</span> time<span class="token punctuation">;</span> <span class="token comment">//时间</span>
  __u16 type<span class="token punctuation">;</span>
  __u16 code<span class="token punctuation">;</span>
  __s32 value<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个结构看上去好像是某个事件的信息，或者产生的数据。</p><p>现在我们知道了读什么文件，也知道了读取该文件能得到什么样的内容，接下来我们立刻编写代码练练手。让我们写代码来实现读写&quot;/dev/input/event3&quot;文件，如下所示：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">KB_DEVICE_FILE</span> <span class="token string">&quot;/dev/input/event3&quot;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> ret <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">input_event</span> in<span class="token punctuation">;</span>
  <span class="token keyword">char</span> <span class="token operator">*</span>kbstatestr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;弹起&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;按下&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">char</span> <span class="token operator">*</span>kbsyn<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;开始&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;键盘&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;结束&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">//第一步：打开文件</span>
  fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>KB_DEVICE_FILE<span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">&quot;打开文件失败&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token comment">//第二步：读取一个event事件包</span>
    ret <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>in<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">input_event</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">!=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">input_event</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">&quot;读取文件失败&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//第三步：解析event包</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>in<span class="token punctuation">.</span>type <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;------------------------------------\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;状态:%s 类型:%s 码:%d 时间:%ld\\n&quot;</span><span class="token punctuation">,</span> kbstatestr<span class="token punctuation">[</span>in<span class="token punctuation">.</span>value<span class="token punctuation">]</span><span class="token punctuation">,</span> kbsyn<span class="token punctuation">[</span>in<span class="token punctuation">.</span>type<span class="token punctuation">]</span><span class="token punctuation">,</span> in<span class="token punctuation">.</span>code<span class="token punctuation">,</span> in<span class="token punctuation">.</span>time<span class="token punctuation">.</span>tv_usec<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>in<span class="token punctuation">.</span>code <span class="token operator">==</span> <span class="token number">46</span><span class="token punctuation">)</span>
      <span class="token punctuation">{</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">//第四步：关闭文件</span>
  <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码逻辑很简单，首先打开了 /dev/input/event3 这个文件，然后在一个循环中反复读取该文件并打印出数据，读取错误和码值等于 46 时，就跳出循环，最后关闭该文件，程序退出。</p><p>接下来就是测试环节。我们用 VSCode 打开对应的工程目录，编译一下，然后运行。效果如下所示：</p><figure><img src="`+l+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>你按下键盘上一个键，终端中它就会输出一行，松开键又会输出一行，输出“按下”或“弹起”的状态、键盘码以及按下弹起所花费的时间，这些数据精确地反映了键盘按键动作。</p><p>一个文件就能反映键盘的动作和数据，难道不奇怪吗？你是不是猛然醒悟了，原来 /dev/input/event3 这个文件就代表键盘，<em>这个文件是特殊的设备文件，访问这种文件就是访问 IO 硬件设备</em>。其实，<mark>dev 目录</mark>下全部的文件都是<mark>设备文件</mark>，不知道你的脑海中是不是浮现出了熟悉的 Linux 设计哲学 —— 一切都是文件。</p><p><u>你可以在 dev 目录下找到系统的所有设备，它们都是以文件的形式存在的</u>。从这种角度看，这里的文件是抽象的，是一种资源对象的标识。从上面的例子，我们也可以看出，<u>设备的操作完全符合文件的操作方式</u>。</p><ol><li>设备输入、输出数据的操作对应了文件的读写，</li><li>设备的启动或者停止则对应文件的打开或关闭。</li></ol><p>说到这，你可能要反对我了：设备的操作不只是输入输出数据，还有设置设备功能、配置设备电源等操作么？例如设置声卡音量、设置处理器进入待机状态以减少功耗等等。</p><p>可是你别忘了，文件还有一个操作 —— <mark>ioctrl</mark>，<strong>通过它来给设备发送命令或者设置相关功能</strong>。这样一个设备的所有操作就和文件对上了。不过可不要想着用这种方案干坏事哦，比如获取别人输入的敏感信息。</p><h2 id="设备分类" tabindex="-1"><a class="header-anchor" href="#设备分类" aria-hidden="true">#</a> 设备分类</h2><p>设想一下，你需要管理你家里的日常用品，你通常会怎么做？你是不是首先会对这些物品进行分类。你可能会按物品的功能用途分类，也可能按物品归属于哪位家庭成员来分类。</p><p>对于 Linux 这个计算机大总管也是如此，什么设备有什么功能、是用来做什么的、有多少个这种类型的设备、它们接入系统的方式是什么……这些信息，Linux 都需要了解得非常清楚才可以。</p><p>在了解 Linux 如何对设备进行分类之前，我们应该先了解一下常规情况下系统中都有哪些设备。我为你画了一幅图，如下所示：</p><figure><img src="'+u+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>上图是一个典型的计算机系统，你先不管物理机器的结构和形式，逻辑上就是这样的。实际情况可能比图中有更多或者更少的总线和设备。</p><p>各种设备通过总线相连。这里我们只需要记住，计算机中有很多的设备，Linux 会把这些设备分成几类，分别是：<mark>网络设备</mark>、<mark>块设备</mark>、<mark>字符设备</mark>、<mark>杂项设备</mark>以及<mark>伪设备</mark>。具体情况你可以参考我后面梳理的示意图：</p><figure><img src="'+r+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="_1-网络设备" tabindex="-1"><a class="header-anchor" href="#_1-网络设备" aria-hidden="true">#</a> 1 网络设备</h3><p>我们先来看看网络设备。网络设备在 Linux 上被抽象成<mark>一个接口设备</mark>，相当于网线插口，任何网络通信都要经过<mark>网络接口</mark>。接口就是能与其他主机交换数据的设备，像是电子信号从网口流到另一个网口一样。</p><p>Linux 使用一套传输数据包的函数来与网络设备驱动程序通信，它们与字符设备和块设备或者文件的 read() 和 write() 接口不同，<u>所以网络设备在 Linux 中是一个独特的存在</u>。</p><p>一般情况下，接口对应于物理网卡，但也可能是纯软件实现的，比如输入 <code>ifconfig</code> 命令查看网口时，会输出一个 eth0、一个 lo 等信息，lo 就是<mark>网络回环（loopback）接口</mark>。Linux 会给每个网络接口分配一个唯一的名字，比如 eth0、eth1 等，方便其它软件访问这些接口，但这个名字在文件系统中并没有对应的文件名。</p><h3 id="_2-块设备" tabindex="-1"><a class="header-anchor" href="#_2-块设备" aria-hidden="true">#</a> 2 块设备</h3><p>然后，我们来看看<strong>块设备</strong>，块设备这种设备类型也是 Linux 下的一个大类。块设备的特点是<em>能按一块一块的方式传输数据，而且能随机访问设备中的任一地址</em>，具体是通过 /dev 目录下的文件系统节点来访问。</p><p>常见的块设备包括<strong>硬盘、flash、ssd、U 盘、SD 卡</strong>等。</p><p><u>块设备上通常能够安装<mark>文件系统</mark>，即能被格式化</u>。比如你的机器上有一块硬盘，硬盘上有 4 个分区。那么在 Linux 系统中的表现就是这样的：</p><img src="'+k+`" alt="img" style="zoom:25%;"><p>这些设备文件可以像访问普通文件一样使用，你只要计算好硬盘地址，就能把数据写入到硬盘扇区中。比方说，我们可以用 <code>cat /dev/sda1 &gt; sda1.bk</code> 命令，对硬盘的分区一进行备份。</p><h3 id="_3-字符设备" tabindex="-1"><a class="header-anchor" href="#_3-字符设备" aria-hidden="true">#</a> 3 字符设备</h3><p>然后我们来看看<strong>字符设备</strong>。字符设备也是 Linux 下的一个基础类设备，比如<strong>键盘、鼠标，串口，声卡</strong>等都属于字符设备。字符设备是<em>顺序访问的，不能随机访问</em>，它只能像是访问<em>字符数据字节流</em>一样被访问，只有在设备响应后才能读到相应信息，<u>这些功能由设备驱动程序保证和维护</u>。</p><p>字符设备的驱动程序通常要实现打开、关闭、读取和写入回调函数，供 Linux 使用。Linux 会将应用程序中的调用，转发给设备驱动程序的回调函数。字符设备的对应的文件名都在 /dev 目录下，每一个文件对应一个字符设备或者块设备。</p><h3 id="在-dev-目录-ls-l" tabindex="-1"><a class="header-anchor" href="#在-dev-目录-ls-l" aria-hidden="true">#</a> ##在 /dev 目录 ls-l</h3><p>我们在 /dev 目录下可以使用 <code>ls -l</code> 命令查看详细信息，</p><ol><li>第一个字母为“c”的即为字符设备文件，</li><li>第一个字母为“b”的即为块设备文件。</li></ol><p>最后我们说说<mark>杂项设备</mark>和<mark>伪设备</mark>，它们都是基于<em>字符设备</em>实现的，本质上是属于字符设备。而伪设备则与其它设备不同，<em>它不对应物理硬件，只是通过软件实现了一些功能</em>：比如读取 random 设备能产生一个随机数；再比如把数据写入 null 设备，数据会有去无回，直接被丢弃；还有通过读取 kmsg 设备，获取内核输出的信息。</p><h3 id="数据大小和传输方式" tabindex="-1"><a class="header-anchor" href="#数据大小和传输方式" aria-hidden="true">#</a> ##数据大小和传输方式</h3><p>现在我们已经搞清楚了：Linux 是根据<strong>设备传输数据大小和传输方式</strong>来对设备进行分类的，下面我们就可以亲手去创造一个设备了。</p><h2 id="创造一个设备" tabindex="-1"><a class="header-anchor" href="#创造一个设备" aria-hidden="true">#</a> 创造一个设备</h2><p>一个再普通不过的计算机系统中，也有种类繁多的设备。每种设备都有自己的编程控制方式，所以 Linux 内核才用分而治之的方法，把控制设备代码独立出来，形成内核驱动程序模块。</p><p>这些驱动程序模块由驱动开发人员或设备厂商开发，会按照 Linux 内核的规则来编写，并提供相应接口供 Linux 内核调用。这些模块既能和 Linux 内核静态链接在一起，也能动态加载到 Linux 内核，这样就实现了 Linux 内核和众多的设备驱动的解耦。</p><p>你可能已经想到了，<strong>一个驱动程序既可以是 Linux 内核的一个功能模块，也能代表或者表示一个设备是否存在。</strong></p><p>我们不妨再思考一个问题：Linux 内核所感知的设备，一定要与物理设备一一对应吗？</p><p>我们拿储存设备来举例，其实不管它是机械硬盘，还是 TF 卡，或者是一个设备驱动程序，它都可以向 Linux 内核表明它是储存设备。但是，它完全有可能申请一块内存空间来储存数据，不必访问真正的储存设备。所以，Linux 内核所感知的设备，并不需要和物理设备对应，这取决于驱动程序自身的行为。</p><p>现在我们就知道了，创造一个设备，等同于编写一个对应驱动程序。Linux 内核只是和驱动程序交互，而不需要系统中有真实存在的物理设备，只要驱动程序告诉 Linux 内核是什么设备就行。</p><p>明白了驱动程序的原理，我们这就来写一个驱动程序。先从 Linux 内核模块框架开始吧，代码如下所示：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span>
<span class="token comment">//开始初始化函数</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">miscdrv_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG <span class="token string">&quot;INIT misc dev\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//退出函数</span>
<span class="token keyword">static</span> <span class="token keyword">void</span>  __exit <span class="token function">miscdrv_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG <span class="token string">&quot;EXIT,misc\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token function">module_init</span><span class="token punctuation">(</span>miscdrv_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>miscdrv_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//版权信息和作者 </span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">&quot;GPL&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">&quot;LMOS&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你看，不到 20 行代码，就构成了一个 Linux 内核模块。</p><p>从这个例子我们可以发现，一个内核模块必须要具备两个函数：一个是开始初始化函数，在内核模块加载到 Linux 内核之后。首先就会调用该函数，它的作用通常是创造设备；另一个是退出函数，内核模块退出到 Linux 内核之前，首先就会调用该函数，用于释放系统资源。</p><p>有了 Linux 内核模块之后，我们现在还不能调用它，这是因为我们没有创造设备，对应用程序而言是无法使用的。那么怎么创建一个设备呢？</p><p>Linux 内核的驱动框架为我们提供了接口和方法，只需要按照接口标准调用它就行了。这里我们需要创造一个杂项设备，就需要调用 misc_register 函数。我们只要给这个函数提供一个杂项设备结构体作为参数，就能在 Linux 内核中创造并注册一个杂项设备。</p><p>代码如下所示：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DEV_NAME</span>  <span class="token string">&quot;miscdevtest&quot;</span></span>
<span class="token comment">//文件操作方法结构体</span>
<span class="token keyword">static</span> <span class="token keyword">const</span>  <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> misc_fops <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span>read     <span class="token operator">=</span> misc_read<span class="token punctuation">,</span>  <span class="token comment">//读回调函数</span>
  <span class="token punctuation">.</span>write    <span class="token operator">=</span> misc_write<span class="token punctuation">,</span> <span class="token comment">//写回调函数</span>
  <span class="token punctuation">.</span>release  <span class="token operator">=</span> misc_release<span class="token punctuation">,</span> <span class="token comment">//关闭回调函数</span>
    <span class="token punctuation">.</span>open     <span class="token operator">=</span> misc_open<span class="token punctuation">,</span>   <span class="token comment">//打开回调函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//杂项设备结构体</span>
<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">miscdevice</span>  misc_dev <span class="token operator">=</span>  <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>fops  <span class="token operator">=</span>  <span class="token operator">&amp;</span>misc_fops<span class="token punctuation">,</span>         <span class="token comment">//设备文件操作方法</span>
    <span class="token punctuation">.</span>minor <span class="token operator">=</span>  <span class="token number">255</span><span class="token punctuation">,</span>                <span class="token comment">//次设备号</span>
    <span class="token punctuation">.</span>name  <span class="token operator">=</span>  DEV_NAME<span class="token punctuation">,</span>           <span class="token comment">//设备名/dev/下的设备节点名</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">miscdrv_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">misc_register</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>misc_dev<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创造杂项设备</span>
  <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG <span class="token string">&quot;INIT misc dev\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对照这段代码，我们看到，Linux 用一个 miscdevice 结构体表示一个杂项设备，其实它内部包含了用于表示字符设备的 cdev 结构体，所以杂项设备就是字符设备。</p><p>其实 miscdevice 结构体还有很多成员，不过那些我们不用处理，只需要设置以下三个成员就行了：一是设备文件操作方法结构，它是一些函数指针；二是次设备号，我们设置成最大值，即 255，让系统自动处理；三是设备名称，就是在 dev 目录下的文件名。</p><p>完成上述操作，最后只要在 Linux 内核模块的初始化 miscdrv_init 函数中，调用 misc_register 函数就行了。</p><p>这里比较重要的是文件操作方法结构体中的<strong>回调函数</strong>，它们是完成设备功能的主要函数，应用程序对设备文件的打开、关闭、读、写等操作，都会被 Linux 内核分发调用到这些函数。</p><p>举例来说，在打开函数中，你可以让设备加电工作起来；而在读、写函数中，你可以向设备传输数据。Linux 内核并不在意你在这些函数做了什么，也不在乎这些操作是不是直接作用于物理设备，Linux 内核只在乎是否有这些函数或者这些函数的执行状态是什么。</p><p>下面我们就来写好这些函数，如下所示：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//读回调函数</span>
<span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">misc_read</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>pfile<span class="token punctuation">,</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>buff<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span>off<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG <span class="token string">&quot;line:%d,%s is call\\n&quot;</span><span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//写回调函数 </span>
<span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">misc_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>pfile<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>buff<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span>off<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG <span class="token string">&quot;line:%d,%s is call\\n&quot;</span><span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//打开回调函数</span>
<span class="token keyword">static</span> <span class="token keyword">int</span>  <span class="token function">misc_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>pinode<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>pfile<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG <span class="token string">&quot;line:%d,%s is call\\n&quot;</span><span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//关闭回调函数</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">misc_release</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>pinode<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>pfile<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG <span class="token string">&quot;line:%d,%s is call\\n&quot;</span><span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述各种操作的回调函数非常简单，都只调用了 printk 函数打印内核 log，这些 log 信息可以在 /dev/kmsg 设备文件中读取。</p><p>为了测试这个设备能否正常工作，我们还要写个应用程序对其访问，即对其进行打开、读、写、关闭这些操作，代码如下所示：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DEV_NAME</span> <span class="token string">&quot;/dev/miscdevtest&quot;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>
    <span class="token comment">//打开设备文件 O_RDWR,  O_RDONLY, O_WRONLY,</span>
    fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>DEV_NAME<span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;打开 :%s 失败!\\n&quot;</span><span class="token punctuation">,</span> DEV_NAME<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//写数据到设备</span>
    <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//从设备读取数据</span>
    <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//关闭设备 可以不调用，程序关闭时系统自动调用</span>
    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我替你把所有的代码都准备好了（可以从课程配套代码获取），我们在工程目录下 make 一下就可以编译好了。成功编译后，你会得到一个 miscdrv.ko，这是编译好的 Linux 内核模块文件；还有一个是 App 文件，这个是应用程序。</p><p>我们在测试之前，先打开一个终端，在其中输入 sudo cat /dev/kmsg，以便观察结果。然后再打开一个终端，在其中输入 sudo insmod miscdrv.ko，把 miscdrv.ko 这个 Linux 内核模块安装加载到系统中。加载好了我们输入 sudo app，就可以看结果了，如下图所示：</p><figure><img src="`+d+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>通过截图，我们看到右边终端通过读取 /dev/kmsg 设备输出了正确的结果，这说明我们的设备工作正常。只不过我们这个设备没有完成任何功能，也没有对应真正的物理设备，但是却真实地反映了设备的工作流程。</p><p>到这里我们已经理解了 Linux 管理设备的核心机制：贯彻一切皆文件的思想，Linux 内核会在相应目录下，建立特殊的文件节点，用文件的形式表示一个设备。而内核操控设备的方式，实质上就是把文件操作转发给对应的设备驱动程序回调函数来处理。</p><h2 id="重点回顾" tabindex="-1"><a class="header-anchor" href="#重点回顾" aria-hidden="true">#</a> 重点回顾</h2><p>今天的课程就要结束了，现在我们一起来回顾一下今天的重点。</p><p>首先我们从一个例子开始，写下了一个读取文件的应用程序。运行之后，我们一按下键盘，应用程序就能获取键盘数据，这证明了我们读取的文件是一个设备，间接地证明了 Linux 以文件的方式管理设备，操作设备与操作文件相同。</p><p>然后，我们一起探讨了 Linux 设备类型，还分析了不同设备的特性。Linux 按照设备的工作方式和数据传输类型，对市面上的各种设备做了分类，分成了字符设备、块设备、网络设备、杂项设备和伪设备。</p><p>最后，我们创造了一个杂项设备，了解了 Linux 如何感知设备、又是如何让应用程序访问到设备的。我们发现 Linux 用文件节点关联了 Linux 内核驱动程序模块，为了操控设备，内核会转发应用程序对文件的操作，以此来调用驱动程序中的回调函数。</p><figure><img src="'+m+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>这就是 Linux 管理多个 IO 设备的方式，但是 Linux 驱动模型远比今天课程所介绍的复杂得多，其中还有支持总线和支持设备热拔插的机制。如果你想详细了解 Linux 驱动模型的实现，可以阅读我的上一季课程《操作系统实战 45 讲》中的第二十八节课到三十一节课。</p><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题" aria-hidden="true">#</a> 思考题</h2><p>请问 Linux 网络通信的接口是什么？</p><p>期待你在留言区聊聊你的学习收获或者提出疑问，如果觉得这节课还不错，别忘了分享给身边更多的朋友。</p><blockquote><p>读写一个设备文件，运行不起来，一直阻塞在这行：ret = read(fd, &amp;in, sizeof(struct input_event));<br> 作者回复: 你要将键盘按下</p><hr><p>请问：对于一个驱动程序，Linux是在/dev目录下面创建一个文件来与之对应吗？<br> 作者回复: 不是</p><hr><p>dev下面有net文件夹和network_latency和network_throughput字符设备<br> 预估网络文件信息存储在内存上，上述文件构成设备登记函数！<br> 作者回复: 嗯嗯</p></blockquote>',88);function y(L,w){const a=t("ExternalLinkIcon");return e(),o("div",null,[b,_,f,g,n("p",null,[s("这节课的配套代码，"),n("a",h,[s("你可以从这里下载"),c(a)]),s("。话不多说，我们开始吧。")]),x])}const N=p(v,[["render",y],["__file","M32-Linux的IO设备管理.html.vue"]]);export{N as default};
