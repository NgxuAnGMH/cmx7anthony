import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r,o as t,c as s,a as e,b as a,e as o,d as l}from"./app-cdabc73c.js";const d="/assets/640-1691394076731-201-982513f5.png",c="/assets/640-1691394076731-202-b93e78ac.png",p="/assets/640-1691394076731-203-36e738d6.png",h="/assets/640-1691394076731-204-8f3dd0dd.png",u={},g=e("h1",{id:"_55-白泽带你读论文丨detecting-kernel-memory-leaks-in-specialized-modules",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_55-白泽带你读论文丨detecting-kernel-memory-leaks-in-specialized-modules","aria-hidden":"true"},"#"),a(" 55-白泽带你读论文丨Detecting Kernel Memory Leaks in Specialized Modules")],-1),f=e("p",null,"Detecting Kernel Memory Leaks in Specialized Modules with Ownership Reasoning",-1),m={href:"https://www-users.cs.umn.edu/~kjlu/papers/k-meld.pdf",target:"_blank",rel:"noopener noreferrer"},_=l('<h2 id="_1-introduction" tabindex="-1"><a class="header-anchor" href="#_1-introduction" aria-hidden="true">#</a> 1. Introduction</h2><p>内存泄漏是程序中的内存在被动态分配后，没有正确的释放而导致的。相比于用户态程序的内存漏洞，内核态的内存泄漏会带来更大的危害性。<em>这些未被正确释放的内存直到下一次重启前都无法被重新使用</em>，攻击者可以利用内核中的内存泄漏漏洞实现拒绝服务攻击。</p><p>相比于动态程序分析，静态分析技术可以获得更大的代码覆盖率，并且由于内核的特殊性，某些驱动程序的内存管理过程需要特定的硬件才能触发，这是动态程序分析无法覆盖的。因此作者采用了<mark>静态程序分析技术</mark>在内核中检测内存泄漏，在此过程中面临两个主要的挑战</p><p><strong>1）Specialized functions</strong></p><p>​ 内核的不同模块中存在大量定制化的内存管理函数，如果想要检测内存泄漏问题，那么首先就需要准确识别这些函数。</p><p><strong>2）Complicated and lengthy data flow</strong></p><p>​ 为了探索内存的分配位置以及对应的释放位置，需要对程序进行冗长且复杂的数据流分析。</p><p>现有的方法无法很好的解决这两个问题。在本文中，作者设计了一套新的方法用于识别定制化的内存管理函数和推测内存对象的所有权。</p><h2 id="_2-contribution" tabindex="-1"><a class="header-anchor" href="#_2-contribution" aria-hidden="true">#</a> 2. Contribution</h2><p>1）提出了一种基于模式匹配的定制化内存分配函数的识别方法</p><p>2）利用规则挖掘找到内存分配函数对应的内存释放函数</p><p>3）利用内存对象的所有权机制减少FP</p><p>4）设计了K-MELD工具，在Linux kernel中检测到了新的bug</p><h2 id="_3-overview" tabindex="-1"><a class="header-anchor" href="#_3-overview" aria-hidden="true">#</a> 3. Overview</h2><figure><img src="'+d+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>K-MELD整体架构如上图所示，</p><p>在pre-processing阶段将源码编译为<mark>LLVM IR中间代码</mark>。在此基础上提取代码的上下文信息以及结构信息，同时构建Call-graph。</p><p>Alloc/Dealloc detection阶段，作者结合对内存分配函数的观察分析，总结出一个内存分配函数应该遵循的通用模式，利用这一规则从内核代码中获取到所有内存分配函数的集合。</p><p>在识别到内存分配函数的基础上，利用内核代码编写时遵循的error handling特性，在代码出错分支处识别到对应的内存释放函数。</p><p>Ownership reasoning阶段，作者通过逃逸分析处理内存对象的向上传递，利用消费者检测向下推测内存对象的释放点，实现了对内存对象的所有权推定。</p><p>最后在Bug detection阶段，作者在所有的error handling path中利用模式匹配的方式，检测内存是否被正确释放，任何存在内存分配但是没有出现对应内存释放操作的路径都会被认为存在潜在的内存泄漏风险。</p><h2 id="_4-allocation-and-deallocation-identification" tabindex="-1"><a class="header-anchor" href="#_4-allocation-and-deallocation-identification" aria-hidden="true">#</a> 4. Allocation and deallocation identification</h2><h3 id="a-identifying-allocation-fois" tabindex="-1"><a class="header-anchor" href="#a-identifying-allocation-fois" aria-hidden="true">#</a> <strong>A. Identifying Allocation(FOIS)</strong></h3><p>作者经过观察总结出一个内存分配函数所具有的4个属性，分别是</p><ul><li>1）函数必须返回一个指针</li><li>2）函数后紧跟一个空指针检查</li><li>3）返回的指针不是从其他指针中派生出来</li><li>4）指针对象在使用之前需要被初始化</li></ul><p>其中第三点主要是对内核中的getter函数进行过滤。作者利用use-finding前向数据流分析判断函数后是否存在一个空指针检查操作，利用后向数据流分析source-finding确定一个指针对象的来源。</p><h3 id="b-context-aware-rule-mining-for-deallocation-detection" tabindex="-1"><a class="header-anchor" href="#b-context-aware-rule-mining-for-deallocation-detection" aria-hidden="true">#</a> <em><strong>B. Context-aware Rule Mining for Deallocation Detection</strong></em></h3><p>由于内核代码中存在error handling的特性，每一条error handling path都大概率遵循&lt;call alloc, check, release, return&gt;的模式，当一条路径上的操作发生错误时，应该存在内存释放函数对已分配的内存对象进行释放。作者首先深度遍历CFG，收集所有error handling path，利用模式匹配的方式识别出对应的内存释放函数。</p><h2 id="_5-ownership-reasoning" tabindex="-1"><a class="header-anchor" href="#_5-ownership-reasoning" aria-hidden="true">#</a> 5. Ownership Reasoning</h2><p>内存所有权分析的目的在于找到每个内存对象应该被释放的位置</p><h3 id="a-path-sensitive-escape-analysis" tabindex="-1"><a class="header-anchor" href="#a-path-sensitive-escape-analysis" aria-hidden="true">#</a> <strong>A. Path-sensitive Escape Analysis</strong></h3><p>作者利用过程间分析，识别内存对象的逃逸情况。如果一个内存对象通过返回值、全局变量或是函数参数传递回caller，就认为出现一次内存逃逸，此时该内存对象的所有权会传递回caller函数。通过这种方式减少了FP的产生。</p><h3 id="b-consumer-function-path-profiling" tabindex="-1"><a class="header-anchor" href="#b-consumer-function-path-profiling" aria-hidden="true">#</a> <em><strong>B. Consumer function path profiling</strong></em></h3><p>消费者分析与逃逸分析类似。如果在一个子函数中对内存对象进行了释放操作，该子函数就会被识别为一个消费者，任何经过该子函数处理的内存对象都应该被认为不存在内存泄漏问题。利用这种方式减少了FP与FN。</p><h2 id="_6-detecting-bugs-using-mined-rules" tabindex="-1"><a class="header-anchor" href="#_6-detecting-bugs-using-mined-rules" aria-hidden="true">#</a> 6. Detecting bugs using mined rules</h2><p>在找到内存分配函数对应的释放函数后，利用模式&lt;call FOI, check,call release, return&gt;匹配所有的error handling path，如果有path上不存在对应的内存释放函数，并且不存在consumer function，就认为存在一个潜在的内存泄漏问题。</p><h2 id="_7-evaluation" tabindex="-1"><a class="header-anchor" href="#_7-evaluation" aria-hidden="true">#</a> 7.Evaluation</h2><p>作者针对5.2.13-stable版本的Linux内核进行了测试。使用<mark>allyesconfig</mark>将内核代码编译成<em>LLVM bitcode</em>，得到18074个LLVM IR bitcode 文件。实验运行在Intel Xeon 48核CPU服务器上，内存为256GB，系统为Ubuntu-18.04，LLVM版本为v8.0。</p><h3 id="a-set-of-allocations-and-associated-deallocations" tabindex="-1"><a class="header-anchor" href="#a-set-of-allocations-and-associated-deallocations" aria-hidden="true">#</a> <strong>A. Set of allocations and associated deallocations</strong></h3><p>作者在内核中识别出了4621个内存分配函数，其中有807个函数找到了对应的内存释放函数。其中由规则挖掘造成的内存释放函数匹配错误带来的误差仅在1.8%。在之后的实验中，作者对模式匹配的阈值进行测试，结果表明目前选取的系数0.6在TP数与FP数之间取得了较好的平衡。</p><figure><img src="'+c+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h3 id="b-found-bugs" tabindex="-1"><a class="header-anchor" href="#b-found-bugs" aria-hidden="true">#</a> <em><strong>B. Found bugs</strong></em></h3><p>K-MELD找到了458个内存泄漏漏洞，其中218个由人工确认为正确，误报率为52%。在提交给厂商后，获得了41个CVE编号。作者还对已有的17个CVE进行了测试，K-MELD检测到了其中的9个。</p><figure><img src="'+p+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h3 id="c-exploitability-analysis" tabindex="-1"><a class="header-anchor" href="#c-exploitability-analysis" aria-hidden="true">#</a> <em><strong>C. Exploitability analysis</strong></em></h3><p>由于通过静态分析的方式在内核中实现对内存泄漏漏洞的实际利用十分困难，作者在这里做了简化的实验，仅仅探索从入口函数到敏感函数的调用栈。</p><figure><img src="'+h+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h3 id="d-false-positive-analysis" tabindex="-1"><a class="header-anchor" href="#d-false-positive-analysis" aria-hidden="true">#</a> <em><strong>D. False positive analysis</strong></em></h3><p>作者对结果中的FP进行了分析，发现其中大部分是由Infeasible path造成的，想要解决这个问题作者认为需要引入under-constrained的符号化执行策略。同时部分驱动程序的内存释放函数的不正确匹配也带来了一定的FP。</p><h3 id="e-effectiveness-of-escape-and-consumer-function-analysis" tabindex="-1"><a class="header-anchor" href="#e-effectiveness-of-escape-and-consumer-function-analysis" aria-hidden="true">#</a> <em><strong>E. Effectiveness of escape and consumer function analysis</strong></em></h3><p>为了证明文章中提出的逃逸分析以及消费者分析的有效性，作者分别获得了在禁用这两种分析情况下生成的报告总数。发现禁用了逃逸分析后报告总数增加到1292个，禁用了消费者分析后报告数增加到1386个，人工随机检查20个后发现均为FP，证明了这两种分析的确是有效的。</p><h2 id="_8-conclusion" tabindex="-1"><a class="header-anchor" href="#_8-conclusion" aria-hidden="true">#</a> 8. Conclusion</h2><p><mark>内存泄漏漏洞</mark>是操作系统内核中的一个严重安全漏洞。在本文中，提出了K-MELD，一个有效的和可扩展的静态内核内存泄漏检测工具。K-MELD不仅可以在一般分配函数上检测内存泄漏错误，而且也可以在只有少数调用点的定制化分配函数上检测到内存泄漏。K-MELD首先通过结构感知和使用感知的方法识别分配函数，然后通过模式挖掘技术匹配对应的内存释放函数。同时K-MELD还会根据已分配内存对象的所有权来确定预期释放调用的位置，判断是否存在内存泄漏问题。<em>将K-MELD应用到Linux内核中，发现了218个新的内存泄漏漏洞，到目前为止有106个被开发者确认，并获得了41个CVE编号</em>。</p><h2 id="问题与思考" tabindex="-1"><a class="header-anchor" href="#问题与思考" aria-hidden="true">#</a> 问题与思考</h2><p>1）通过对操作序列进行rule-mining来找release函数，该方法是否有必要？为什么不直接对所有error path的最后一个操作分配对象的函数取交集作为release函数？</p><p>A：可能的原因：避免对分配对象进行复杂的数据流跟踪分析，作者的方法相当于用简单的数据流分析把最后一个操作分配对象的函数和对所有error path挖掘的序列结果做交叉检查，减少错误的数据流分析引入的误报</p><p>2）想了解内存漏洞检测问题的知识背景，这方面的静态研究方法有什么难点和局限性？</p><p>A：传统内核内存漏洞检测方法：</p><p>动态：fuzzing（syzkaller）+sanitizer（KASAN，KMSAN）。ASAN针对address access，使用shadow memory/redzone的机制，每次access检查是否合法；MSAN固定周期扫描内存里的obj，检查是否有obj没被使用也没被释放。<br> 好处是无FP，有真实PoC；缺点是覆盖率，kernel有很多driver，需要硬件支持。</p><p>静态：pattern/rule base。人工定义一些pattern、rule做扫描。局限性、难点：rule和pattern怎么来；rule造成的误报、漏报；应用rule的时候需要静态分析技术的支撑，各种技术的质量、准确性的局限。<br> 好处：覆盖率高；缺点：误报，没有PoC。</p><p>3）Conditional consumers的情况是怎么处理的？</p><p>A：一个函数在某些特定路径上才是consumer，如果考虑每一种情况都考虑就会路径爆炸。本文采用的方法是：利用函数中对子函数返回值的检查语句，将子函数执行情况仅归结为成功和失败两种情况，检测这两种情况下真正的consumer是哪个函数，从而确定对象内存应该由谁释放。</p><p>4）FOI的四个假设都是必要的吗？如果不是，有哪些是必要的，哪些不是。</p><p>A：不都是必要的，null check和初始化有一些函数是不会去做的，但是作者说在识别的时候，有40%的情况出现就可以了</p><p>5）文章里提到了FP的原因之一是infeasible path，infeasible 是如何定义的，有没有提出解决infeasible path的方法？</p><p>A：静态分析在进行路径探索的时候覆盖率较高，但是不会考虑该路径是否会被执行，某些不被执行的路径在静态分析的情况下也存在potential leak，所以会造成FP；作者提出了可以使用符号化执行去分析path是否feasible，但是代价很大。</p><p>6）论文附录中FOI-release list(Appendix)，大部分都是语意相反的，是否可以直接使用函数名的语意信息进行匹配呢，和文章所用的代码特征匹配相比，有什么优劣？(开放式问题)</p><p>A：现在有用NLP对函数名做语意分析来做识别的，但是需要和该方法做对比才知道优劣</p><p>7）采用了大量的启发式规则，有哪些导致FN的点？</p><p>A：- FOI不满足四个条件：不做null-check，作者设置阈值40%，只要在识别阶段至少有40%的情况下有null-check或初始化就够了(8页左下角)。- 在路径探索部分设置了路径深度限制和路径数量为1000(9页右上角)- CFG本身就是不准确的</p><p>8）FOI找不到对应的deallocator就一定不是alloc function吗，论文中有没有做对应的实验？</p><p>A：这个确实不一定，文章没有针对这个做实验，但是影响dealloctor识别的主要原因在rule mining算法上，作者在discussion中针对了算法进行了FN和FP的实验，最后将阈值定为0.6是最后的最优取舍</p><p>9）FP中infeasible path的具体含义？infeasible path的识别是不是太简单了，只有这一种情况的剪支吗？为什么不做更多的去除infeasible path的方法？</p><p>A：一般在内存分配后，会对内存分配的结果进行判断，如果为null则代表内存分配失败，在这条执行路径上自然也不会存在memory leak的问题，对这样的路径需要进行剪枝。可以使用under constrained symbolic exec更准确的识别infeasible path</p>',74);function b(x,k){const n=r("ExternalLinkIcon");return t(),s("div",null,[g,f,e("p",null,[a("论文链接："),e("a",m,[a("https://www-users.cs.umn.edu/~kjlu/papers/k-meld.pdf"),o(n)])]),_])}const F=i(u,[["render",b],["__file","55-白泽带你读论文丨Detecting Kernel Memory Leaks in Specialized Modules.html.vue"]]);export{F as default};
