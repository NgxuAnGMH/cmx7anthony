import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as r,c as a,d as m}from"./app-cdabc73c.js";const o="/assets/ce9d22a0dafa20b9574411b810c0aabf-9f211261.jpg",t="/assets/30c96ac2fd8a0deffcff86e7b66acf47-5b1bd77d.png",s="/assets/fd788de17028e8b1dbce58de5da31e38-44d007fa.jpeg",n="/assets/bb8c1c007f7263bee41b7c649304c722-cfa647d8.jpeg",d="/assets/4e66bafd713fed95a4957df71b3bd8a7-311db2a0.png",p={},c=m('<h1 id="_43-输入输出设备-我们并不是只能用灯泡显示-0-和-1" tabindex="-1"><a class="header-anchor" href="#_43-输入输出设备-我们并不是只能用灯泡显示-0-和-1" aria-hidden="true">#</a> 43 | 输入输出设备：我们并不是只能用灯泡显示“0”和“1”</h1><p>我们在前面的章节搭建了最简单的电路，在这里面，计算机的输入设备就是一个一个开关，输出设备呢，是一个一个灯泡。的确，早期发展的时候，计算机的核心是做“计算”。我们从“计算机”这个名字上也能看出这一点。不管是中文名字“计算机”，还是英文名字“Computer”，核心都是在”计算“这两个字上。不过，到了今天，这些“计算”的工作，更多的是一个幕后工作。</p><p>我们无论是使用自己的 PC，还是智能手机，大部分时间都是在和计算机进行各种“<em>交互操作</em>”。换句话说，就是在和输入输出设备打交道。这些输入输出设备也不再是一个一个开关，或者一个一个灯泡。你在键盘上直接敲击的都是字符，而不是“0”和“1”，你在显示器上看到的，也是直接的图形或者文字的画面，而不是一个一个闪亮或者关闭的灯泡。想要了解这其中的关窍，那就请你和我一起来看一看，计算机里面的输入输出设备。</p><h2 id="接口和设备-经典的适配器模式" tabindex="-1"><a class="header-anchor" href="#接口和设备-经典的适配器模式" aria-hidden="true">#</a> 接口和设备：经典的适配器模式</h2><p>我们在前面讲解计算机的五大组成部分的时候，我看到这样几个留言。</p><p>一个同学问，像<mark>蓝牙</mark>、<mark>WiFi 无线网卡</mark>这样的设备也是输入输出设备吗？还有一个同学问，我们的<mark>输入输出设备的寄存器</mark>在哪里？到底是在主板上，还是在硬件设备上？</p><p>这两个问题问得很好。其实你只要理解了这两个问题，也就理解输入输出设备是怎么回事儿了。</p><h2 id="_1-概念-总线-接口-设备" tabindex="-1"><a class="header-anchor" href="#_1-概念-总线-接口-设备" aria-hidden="true">#</a> 1 概念：总线-接口-设备</h2><p>实际上，输入输出设备，并不只是一个设备。大部分的输入输出设备，都有两个组成部分。第一个是它的==<strong>接口</strong><mark>（Interface），第二个才是</mark><strong>实际的 I/O 设备</strong>==（Actual I/O Device）。我们的硬件设备<em>并不是</em>直接接入到总线上和 CPU 通信的，<em>而是通过接口，用<code>接口</code>连接到总线上，再通过<code>总线</code>和 CPU 通信</em>。</p><img src="'+o+'" alt="img" style="zoom:25%;"><p>图片来源</p><p>SATA 硬盘，上面的整个绿色电路板和黄色的齿状部分就是<mark>接口电路</mark>，黄色齿状的就是<mark>和主板对接的接口</mark>，绿色的电路板就是<mark>控制电路</mark>。</p><h2 id="_2-硬件层面-接口-电路板" tabindex="-1"><a class="header-anchor" href="#_2-硬件层面-接口-电路板" aria-hidden="true">#</a> 2 硬件层面：接口-电路板</h2><p>你平时听说的<mark>并行接口</mark>（Parallel Interface）、<mark>串行接口</mark>（Serial Interface）、<mark>USB 接口</mark>，都是<em>计算机主板上内置的各个接口</em>。我们的实际硬件设备，比如，<mark><strong>使用并口的打印机</strong></mark>、<mark><strong>使用串口的老式鼠标</strong><mark>或者</mark><strong>使用 USB 接口的 U 盘</strong></mark>，都要插入到这些接口上，才能和 CPU 工作以及通信的。</p><p><em>接口本身就是<code>一块电路板</code></em>。CPU 其实<em>不是</em>和实际的硬件设备打交道，<em>而是和<code>这个接口电路板</code>打交道</em>。我们平时说的，<strong>设备里面有三类寄存器</strong>，其实都在<mark>这个设备的接口电路板</mark>上，而不在实际的设备上。</p><blockquote><p>这个电路板会做很多事情，emmm也可以理解为设备驱动程序主要就是对这个电路板的内容进行编解码转化</p></blockquote><h2 id="_3-接口电路中的寄存器" tabindex="-1"><a class="header-anchor" href="#_3-接口电路中的寄存器" aria-hidden="true">#</a> 3 接口电路中的寄存器</h2><p>那这三类寄存器是哪三类寄存器呢？它们分别是<mark>状态寄存器</mark>（Status Register）、 <mark>命令寄存器</mark>（Command Register）以及<mark>数据寄存器</mark>（Data Register），</p><p>除了内置在主板上的接口之外，<strong>有些接口可以集成在设备上</strong>。你可能都没有见过老一点儿的硬盘，我来简单给你介绍一下。</p><p>上世纪 90 年代的时候，大家用的硬盘都叫作 <strong>IDE 硬盘</strong>。这个 IDE 不是像 IntelliJ 或者 WebStorm 这样的软件开发集成环境（Integrated Development Environment）的 IDE，而是代表着<code>集成设备电路</code>（Integrated Device Electronics）。也就是说，设备的接口电路<em>直接在设备上，而不在主板上</em>。我们需要通过<em>一个线缆</em>，把集成了接口的设备<em>连接到主板上去</em>。</p><img src="'+t+'" alt="img" style="zoom:67%;"><p>我自己使用的 PC 的设备管理器</p><h2 id="_4-接口的控制协议" tabindex="-1"><a class="header-anchor" href="#_4-接口的控制协议" aria-hidden="true">#</a> 4 接口的控制协议</h2><p><strong>把接口和实际设备分离</strong>，这个做法实际上来自于计算机走向开放架构（Open Architecture）的时代。</p><p>当我们要对计算机升级，我们不会扔掉旧的计算机，直接买一台全新的计算机，<strong>而是可以单独升级硬盘这样的设备</strong>。我们把老硬盘从接口上拿下来，换一个新的上去就好了。<strong>各种输入输出设备的制造商，也可以根据<code>接口的控制协议</code></strong>，来设计和制造硬盘、鼠标、键盘、打印机乃至其他种种外设。正是这样的分工协作，带来了 PC 时代的繁荣。</p><h2 id="软件设计模式" tabindex="-1"><a class="header-anchor" href="#软件设计模式" aria-hidden="true">#</a> ##软件设计模式</h2><p>其实，在软件的设计模式里也有这样的思路。面向对象里的面向接口编程的接口，就是 Interface。如果你做 iOS 的开发，Objective-C 里面的 Protocol 其实也是这个意思。而 Adaptor 设计模式，更是一个常见的、用来解决不同外部应用和系统“适配”问题的方案。可以看到，计算机的软件和硬件，在逻辑抽象上，其实是相通的。</p><p>如果你用的是 Windows 操作系统，你可以打开设备管理器，里面有各种各种的 <strong>Devices</strong>（设备）、<strong>Controllers</strong>（控制器）、<strong>Adaptors</strong>（适配器）。这些，<em>其实都是对于输入输出设备<code>不同角度的描述</code></em>。</p><ol><li>被叫作 Devices，看重的是<mark>实际的 <strong>I/O 设备</strong>本身</mark>。</li><li>被叫作 Controllers，看重的是==<strong>输入输出设备接口里面的</strong> 控制电路==。</li><li>而被叫作 Adaptors，则是看重<mark>接口作为一个适配器</mark>后面可以插上<strong>不同的实际设备</strong>。</li></ol><h2 id="cpu-是如何控制-i-o-设备的" tabindex="-1"><a class="header-anchor" href="#cpu-是如何控制-i-o-设备的" aria-hidden="true">#</a> CPU 是如何控制 I/O 设备的？</h2><p>无论是<mark>内置在主板上的接口</mark>，还是<mark>集成在设备上的接口</mark>，除了<mark>三类寄存器</mark>之外，还有对应的<mark>控制电路</mark>。正是通过这个控制电路，CPU 才能通过向<em>这个接口电路板</em>传输信号，来控制实际的硬件。</p><p>我们先来看一看，硬件设备上的这些寄存器有什么用。这里，我拿我们平时用的打印机作为例子。</p><img src="'+s+'" alt="img" style="zoom:25%;"><p>首先是<mark>数据寄存器</mark>（Data Register）。CPU 向 I/O 设备写入需要传输的数据，比如要打印的内容是“GeekTime”，我们就要先发送一个“G”给到对应的 I/O 设备。</p><p>然后是<mark>命令寄存器</mark>（Command Register）。CPU 发送一个命令，告诉打印机，要进行打印工作。这个时候，打印机里面的控制电路会做两个动作。</p><ol><li>第一个，是去设置我们的状态寄存器里面的状态，把状态设置成 not-ready。</li><li>第二个，就是实际操作打印机进行打印。</li></ol><p>而<mark>状态寄存器</mark>（Status Register），就是告诉了我们的 CPU，现在设备已经在工作了，所以这个时候，CPU 你再发送数据或者命令过来，都是没有用的。直到前面的动作已经完成，状态寄存器重新变成了 ready 状态，我们的 CPU 才能发送下一个字符和命令。</p><p>当然，在实际情况中，打印机里通常不只有数据寄存器，还会有<mark>数据缓冲区</mark>。我们的 CPU 也不是真的一个字符一个字符这样交给打印机去打印的，而是一次性把整个文档传输到打印机的 <em>内存 或者 数据缓冲区</em> 里面一起打印的。不过，通过上面这个例子，相信你对 CPU 是怎么操作 I/O 设备的，应该有所了解了。</p><h2 id="信号和地址-发挥总线的价值" tabindex="-1"><a class="header-anchor" href="#信号和地址-发挥总线的价值" aria-hidden="true">#</a> 信号和地址：发挥总线的价值</h2><p>搞清楚了实际的 I/O 设备和接口之间的关系，一个新的问题就来了。那就是，我们的 CPU 到底要往总线上发送一个什么样的命令，才能和 I/O 接口上的设备通信呢？</p><p>CPU 和 I/O 设备的通信，一样是通过 CPU 支持的机器指令来执行的。</p><p>如果你回头去看一看第 5 讲，MIPS 的机器指令的分类，你会发现，我们<em>并没有</em>一种专门的和 I/O 设备通信的指令类型。那么，MIPS 的 CPU 到底是通过什么样的指令来和 I/O 设备来通信呢？</p><p>答案就是，<em>和访问我们的主内存一样，使用“<code>内存地址</code>”</em>。为了让已经足够复杂的 CPU 尽可能简单，计算机会把 I/O 设备的各个寄存器，以及 I/O 设备内部的内存地址，<em>都映射到主内存地址空间里来</em>。主内存的地址空间里，会给<code>不同的 I/O 设备</code>预留<code>一段一段的内存地址</code>。CPU 想要和这些 I/O 设备通信的时候呢，<em>就往这些地址发送数据</em>。这些地址信息，就是通过上一讲的<mark>地址线</mark>来发送的，而对应的数据信息呢，自然就是通过<mark>数据线</mark>来发送的了。</p><p>而我们的 <mark>I/O 设备</mark>呢，<em>就会监控<mark>地址线</mark></em>，并且在 CPU 往自己地址发送数据的时候，<em>把对应的<mark>数据线</mark>里面传输过来的数据</em>，接入到对应的设备里面的<mark>寄存器</mark>和<mark>内存</mark>里面来。CPU 无论是向 I/O 设备发送命令、查询状态还是传输数据，都可以通过这样的方式。这种方式呢，叫作<strong>内存映射 I/O</strong>（Memory-Mapped I/O，简称 MMIO）。</p><img src="'+n+'" alt="img" style="zoom:25%;"><p>那么，MMIO 是不是唯一一种 CPU 和设备通信的方式呢？<em>答案是否定的</em>。精简指令集 MIPS 的 CPU 特别简单，所以这里只有 MMIO。而我们有 2000 多个指令的 Intel X86 架构的计算机，自然可以设计专门的和 I/O 设备通信的指令，也就是 in 和 out 指令。</p><p>Intel CPU 虽然也支持 MMIO，不过它还可以通过特定的指令，来支持<strong>端口映射 I/O</strong>（Port-Mapped I/O，简称 PMIO）或者也可以叫<strong>独立输入输出</strong>（Isolated I/O）。</p><p>其实 PMIO 的通信方式和 MMIO 差不多，核心的区别在于，PMIO 里面访问的设备地址，不再是在内存地址空间里面，<em>而是一个专门的端口（Port）</em>。这个端口并不是指一个硬件上的插口，<em>而是和 CPU 通信的一个抽象概念</em>。</p><p>无论是 PMIO 还是 MMIO，<em>CPU 都会传送一条二进制的数据，给到 I/O 设备的对应地址</em>。设备自己本身的<mark>接口电路</mark>，再去解码这个数据。解码之后的数据呢，就会变成设备支持的一条指令，再去通过<mark>控制电路</mark>去操作实际的硬件设备。<strong>对于 CPU 来说，<em>它并不需要关心设备本身能够支持哪些操作</em>。它要做的，只是在总线上传输一条条数据就好了</strong>。</p><p>这个，其实也有点像我们在设计模式里面的 <mark>Command 模式</mark>。我们在总线上传输的，<mark>是一个个数据对象</mark>，然后各个接受这些对象的设备，再去根据对象内容，进行实际的解码和命令执行。</p><figure><img src="'+d+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>这是我计算机上，设备管理器里显卡设备的资源信息</p><p>这是一张我自己的显卡，在设备管理器里面的资源（Resource）信息。你可以看到，里面既有 <code>Memory Range</code>，这个就是设备对应映射到的<code>内存地址</code>，也就是我们上面所说的 MMIO 的访问方式。同样的，里面还有 <em>I/O Range</em>，这个就是我们上面所说的 PMIO，<em>也就是通过端口来访问 I/O 设备的地址</em>。最后，里面还有一个 <strong>IRQ</strong>，也就是会来自于这个设备的<strong>中断信号</strong>了。</p><h2 id="总结延伸" tabindex="-1"><a class="header-anchor" href="#总结延伸" aria-hidden="true">#</a> 总结延伸</h2><p>好了，讲到这里，不知道，现在你是不是可以把 CPU 的指令、总线和 I/O 设备之间的关系彻底串联起来了呢？我来带你回顾一下。</p><p>CPU 并不是发送一个特定的操作指令来操作不同的 I/O 设备。因为如果是那样的话，随着新的 I/O 设备的发明，我们就要去扩展 CPU 的指令集了。</p><p>在计算机系统里面，CPU 和 I/O 设备之间的通信，是这么来解决的。</p><p>首先，在 I/O 设备这一侧，我们把 I/O 设备拆分成，能和 CPU 通信的<mark>接口电路</mark>，以及实际的 <mark>I/O 设备</mark>本身。接口电路里面有对应的==<em>状态寄存器</em><mark>、</mark><em>命令寄存器</em><mark>、</mark><em>数据寄存器</em><mark>、</mark><em>数据缓冲区</em><mark>和</mark><em>设备内存</em><mark>等等。接口电路通过</mark><strong>总线</strong><mark>和 CPU 通信，接收来自 CPU 的指令和数据。而接口电路中的</mark><strong>控制电路</strong>==，再解码接收到的指令，实际去操作对应的硬件设备。</p><p>而在 CPU 这一侧，对 CPU 来说，它看到的并不是一个个特定的设备，而是一个个<mark>内存地址</mark>或者<mark>端口地址</mark>。<em>CPU 只是向<code>这些地址</code>传输数据或者读取数据</em>。所需要的指令和操作内存地址的指令其实没有什么本质差别。通过<code>软件层面</code>对于传输的命令数据的定义，<em>而不是提供特殊的新的指令</em>，来实际操作对应的 I/O 硬件。</p><h2 id="推荐阅读" tabindex="-1"><a class="header-anchor" href="#推荐阅读" aria-hidden="true">#</a> 推荐阅读</h2><p>想要进一步了解 CPU 和 I/O 设备交互的技术细节，我推荐你去看一看北京大学在 Coursera 上的视频课程，《<code>计算机组成</code>》第 10 周的内容。这个课程在 Coursera 上是中文的，而且可以免费观看。相信这一个小时的视频课程，对于你深入理解输入输出设备，会很有帮助。</p><h2 id="课后思考" tabindex="-1"><a class="header-anchor" href="#课后思考" aria-hidden="true">#</a> 课后思考</h2><p>我们还是回到，这节开始的时候同学留言的问题。如果你买的是一个带无线接收器的蓝牙鼠标，你需要把蓝牙接收器插在电脑的 USB 接口上，然后你的鼠标会和这个蓝牙接收器进行通信。那么，你能想一下，我们的 CPU 和蓝牙鼠标这个输入设备之间的通信是怎样的吗？</p><p>你可以好好思考一下，然后在留言区写下你的想法。当然，你也可以把这个问题分享给你的朋友，拉上他一起学习。</p><blockquote><p>以蓝牙鼠标接收器是USB接口为例。<br> 对于CPU来说，这只是总线上的一个普通的USB设备，与其他的U盘、USB网卡之类的USB接口设备没什么区别，这些设备只是通过USB协议讲自己的数据发送给操作系统，对于这些数据是什么，USB是不管的，USB蓝牙鼠标接收器和普通USB的鼠标在这一层的数据是一样的。<br> 对于操作系统来说，要使这些USB设备工作，就需要对发来的数据进行处理，处理数据的就是驱动程序，所以不同种类的USB设备需要不同的驱动程序。<br> 回过头来再看USB蓝牙鼠标接收器，鼠标产生的事件通过 蓝牙发送-&gt;蓝牙接受-&gt; USB发送-&gt; USB接受-&gt;驱动程序 这样的路径最终到达操作系统，这里面的蓝牙和USB仅仅只是传输数据的方式而已，换为其他的什么TCP/ IP传输也是一样的，其本质是将特定的数据传输给操作系统处理。</p><p>CPU只认插在电脑USB接口上的蓝牙接收器，而蓝牙接收器的和蓝牙鼠标之间是如何传输信息的，这我觉得又是另一个层面的知识！，但是对于我们的CPU来说，当蓝牙接收器接收到鼠标的命令的时候，将这个命令通过I/O接口和总线发送给CPU，CPU最后做出相应的回应，来控制对应的I/O设备，这里涉及到I/O接口的一个功能，那就是数据的转换！这也就是为什么很多不同的设别的发出的指令CPU都能够处理的原因！</p><p>上一讲的北桥IO芯片就是用来MMIO的，和ARM架构下的存储空间地址很类似。</p></blockquote>',65),i=[c];function k(g,h){return r(),a("div",null,i)}const U=e(p,[["render",k],["__file","G43-输入输出设备.html.vue"]]);export{U as default};
