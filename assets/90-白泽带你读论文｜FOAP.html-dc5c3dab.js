import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o as p,c as t,a,b as r,e as o,d as s}from"./app-cdabc73c.js";const l="/assets/640-1689484932818-27-255dd838.png",d="/assets/640-1689484932818-28-b39c64fe.png",c="/assets/640-1689484932818-29-8a5e7c02.png",h="/assets/640-1689484932818-30-dfc0ff08.png",g="/assets/640-1689484932818-31-358e5cd6.png",m="/assets/640-1689484932818-32-8f1a8ce3.png",P={},A=a("h1",{id:"_90-白泽带你读论文-foap",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#_90-白泽带你读论文-foap","aria-hidden":"true"},"#"),r(" 90-白泽带你读论文｜FOAP")],-1),f={href:"https://www.usenix.org/conference/usenixsecurity22/presentation/li-jianfeng",target:"_blank",rel:"noopener noreferrer"},k=s('<p>如需转载请注明出处，侵权必究。</p><p>**论文题目：**FOAP: Fine-Grained Open-World Android App Fingerprinting</p><p><strong>发表会议：Security 2022</strong></p><p>本文作者是JianFeng Li，来自香港理工大学Xiapu Luo教授团队。团队的主要研究方向是网络安全和隐私、区块链/智能合约等。</p><h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><p>加密技术已经被广泛应用于移动应用的通信中，但攻击者仍然能够通过==应用指纹攻击（App Fingerprinting Attacks，AF攻击）==这样的侧信道手段从加密流量中获取应用使用者的隐私信息（如识别出用户使用的应用或推断特定用户的行为）。目前的AF攻击技术主要是通过机器学习训练出的模型来进行流量的识别，但现有的工作存在两大问题：</p><p>一、误报问题。基于封闭世界假设（Closed World Assumption）下训练的模型在现实世界的开放世界设定（Open World Assumption）下的对于流量的识别是不精确的；</p><p>二、检测粒度较粗。现有的工作只能够从应用级（App-Level）去分析流量，因此无法分析得到用户更细粒度的敏感操作。</p><p>为了解决这些问题，本文提出了一种基于开放世界设定的、具备方法级（Method-Level）检测粒度的、多模型协同的AF攻击技术框架，即FOAP（Fine-grained Open world Android App Fingerprinting）。本文实现了FOAP的原型工具，并做了充足的实验评估，结果表明，FOAP具备比现有工具更高的准确性，<strong>且能够有效地完成细粒度的用户行为推断和用户隐私信息分析</strong>。</p><h2 id="af攻击" tabindex="-1"><a class="header-anchor" href="#af攻击" aria-hidden="true">#</a> AF攻击</h2><p>如图1所示，本文提到的AF攻击指的是攻击者通过技术手段在无线网络接入点（Wireless Access Point）嗅探通过该AP访问互联网的网络流量，并从这些流量中识别出其对应的应用或应用行为信息，进而推测出用户的行为或隐私信息的行为。<strong>在这里，网络流量被定义为一系列通过/源和目标地址、端口号作为唯一组合/以及使用的特定传输协议来标识的/套接字与套接字之间进行通信的数据包</strong>。本文主要研究基于<mark>TCP协议</mark>的网络流量。</p><ul><li>本文假设网络流量是被加密的，攻击者无法获取数据包的明文信息。</li><li>此外，本文还假设攻击者能够通过源地址获取到发出数据包的源设备但是无法根据目标地址获取目标设备。</li></ul><figure><img src="'+l+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图 1 AF攻击的威胁模型</p><blockquote><p>应用指纹攻击（App Fingerprinting Attacks，AF攻击）是一种通过分析网络流量或设备传输的数据包来识别和推断特定应用程序的攻击方法。</p><p>在互联网通信中，<em>每个应用程序都有其独特的行为模式和数据流量特征</em>。应用指纹攻击的目标是通过观察和分析这些特征来辨别目标设备上正在运行的特定应用程序，即确定应用程序的“指纹”。</p><p>应用指纹攻击通常涉及以下技术和方法：</p><ol><li><p>流量分析：攻击者收集大量的网络传输数据包，并分析这些数据包的特征，例如包大小、包频率、数据包到达时间间隔等。通过这些数据的分析，可以得出特定应用程序的行为模式和流量特征。</p></li><li><p>机器学习：攻击者使用机器学习算法和模型来对收集的数据进行训练和分析。这些模型可以从大量数据中学习和识别特定应用程序的流量特征，并在未来的流量中进行分类和识别。</p></li><li><p>元数据分析：攻击者可以利用传输的元数据，如IP地址、端口号、数据包长度等来进行应用指纹识别。某些应用程序在与服务器通信时会使用特定的IP地址、端口号或数据包长度，因此分析这些元数据可以帮助确定应用程序。</p></li></ol><p>应用指纹攻击可能会泄露用户的隐私，因为攻击者可以追踪和识别用户在网络上使用的特定应用程序，从而获得关于用户的个人和敏感信息。为了保护隐私和应对此类攻击，一些安全措施已经被提出，如使用加密通信、流量模糊化或混淆等手段来干扰应用指纹的识别。</p></blockquote><h2 id="数据包突发与入口点方法" tabindex="-1"><a class="header-anchor" href="#数据包突发与入口点方法" aria-hidden="true">#</a> 数据包突发与入口点方法</h2><p>数据包突发（Packet Burst）指的是网络流量中<em>一个时间间隔内发送的数据包的子序列</em>。比如给定<mark>一个时间阈值ε</mark>，如果数据流中的某些连续数据包的发送时间间隔<em>小于ε</em>，就称这些数据包构成<strong>一个数据包突发</strong>。</p><p>入口点方法（Entry Point Method，EP方法）指的是应用中用户在进行交互操作时会触发的入口方法。例如，当一个用户点击一个UI组件（比如按钮），这个组件便会触发一个特定的回调方法与服务器或者其他网络服务通信，该回调方法便可以看做是一个EP方法。</p><p>本文观察到，<em>当应用的一个EP方法被触发时，通常会形成数据包突发</em>。</p><h2 id="现有工作问题" tabindex="-1"><a class="header-anchor" href="#现有工作问题" aria-hidden="true">#</a> 现有工作问题</h2><p><strong>封闭世界假设和开放世界设定的矛盾与误报</strong></p><p>现有的主流AF技术将应用的识别问题作为==多分类问题（Multi-class Classification Problem）==来处理。这种训练方式其实是基于封闭世界假设的，即假定我们在进行AF攻击时遇到的产生流量的应用都是在训练模型过程中出现过的。但在开放世界设定中并非如此，如果作为负类的应用没有在训练过程中出现，误报的可能性同样会大大增加。所以，一项有效的AF技术应当是基于开放世界设定的，即能够很好地处理实际应用中由于非目标应用的出现对检测效果导致的干扰。</p><p><strong>现有工作的识别粒度问题</strong></p><p>现有的AF技术的识别粒度上的问题主要体现在只能做到粗略地识别网络流量来源于<em>哪个应用或安卓Activity（比如用户正在使用微信）</em>，而<u>不能确定用户进行哪些具体的操作</u>（比如用户正在进行朋友圈的评论）。然而，细粒度的分析是有必要的。更细粒度的分析能够让AF技术获取到更丰富的用户隐私信息，达到更好的攻击效果。此外，更细粒度的分析意味着能够在用户具体行为的识别上更精确，这能够对恶意行为的识别或隐私泄露检测的检测提供帮助。</p><h2 id="foap概述" tabindex="-1"><a class="header-anchor" href="#foap概述" aria-hidden="true">#</a> FOAP概述</h2><p>针对现有工作的问题，本文实现了一个名为<u>FOAP</u>的<mark>AF技术框架</mark>，该框架能在开放世界设定下完成<mark>方法级粒度</mark>的分析。</p><p>FOAP的核心做法大致能够分为两部分。</p><ol><li>在应用粒度的流量识别上，FOAP利用<strong>局部相似性</strong>（Local Similarity）和<strong>结构相似性</strong>（Structural Similarity）这两个量化标准先过滤掉与需要识别的应用相关性较低的网络流量，随后通过一个<strong>两级识别模型</strong>（Bilevel Recognition Model）对流量进行分析从而完成应用的识别；</li><li>在方法粒度的流量识别上，FOAP利用<strong>EP方法</strong>与<strong>数据包突发</strong>相关联的特性，对前一步中识别出的特定应用流量做进一步的分析完成方法级的流量识别。</li></ol><p>如图2所示，FOAP的实现可以被分为两个阶段：<strong>训练阶段</strong>和<strong>识别阶段</strong>。接下来，将对这两个阶段做详尽的讲解。</p><img src="'+d+'" alt="图片" style="zoom:150%;"><p>图2 FOAP的工作流程图（训练阶段被标为红色，识别阶段被标为蓝色）</p><h3 id="pcap文件" tabindex="-1"><a class="header-anchor" href="#pcap文件" aria-hidden="true">#</a> ###Pcap文件？</h3><blockquote><p>Pcap是一种用于在计算机网络中捕获和保存数据包的文件格式。它是“Packet Capture”的缩写，意味着数据包捕获。</p><p>Pcap文件通常包含从网络中捕获的数据包的详细信息，例如源IP地址、目的IP地址、数据包大小、时间戳等。这些信息可以用于网络分析、安全审计、网络故障排除以及开发和测试网络应用程序等方面。</p><p>Pcap文件可以使用各种工具和库进行创建和处理。一些常见的工具和库包括Wireshark（网络协议分析工具）、tcpdump（命令行网络抓包工具），以及libpcap（用于读写Pcap文件的C库）等。</p><p>使用Pcap文件，您可以重现网络通信过程、分析网络流量、查找潜在的网络问题、排查网络攻击等。此外，Pcap文件还被广泛用于网络安全研究、网络性能测试和开发网络应用程序等方面。</p><p>总之，Pcap是一种常用的文件格式，用于捕获、保存和分析网络数据包，以及进行各种与网络相关的活动。</p></blockquote><h2 id="foap训练阶段" tabindex="-1"><a class="header-anchor" href="#foap训练阶段" aria-hidden="true">#</a> FOAP训练阶段</h2><h3 id="给网络流量打标签" tabindex="-1"><a class="header-anchor" href="#给网络流量打标签" aria-hidden="true">#</a> 给网络流量打标签</h3><p>为了给收集的应用网络流量打标签，需要将<mark>网络流量</mark>和<mark>应用</mark>以及<mark>EP方法</mark>关联起来。为此，作者对操作系统中的<mark>Socket API</mark>进行了插桩，以获取每个TPC Socket对应的<mark>唯一的4维元组（源/目标端口，源/目标地址）<mark>以及Socket对应的</mark>PID和TID</mark>。</p><p>在应用和网络流量的关联上，基于安卓应用的包名会在*/proc/PID/cmdline文件*中记录的特性，作者通过在运行应用过程中获取到的Socket对应的PID去访问对应的文件获取相关信息，<em>从而完成了相应的网络流量和应用的关联</em>。</p><p>在EP方法和网络流量的关联上，基于安卓应用的Socket操作通常是在非-UI组件线程中进行的特性，作者总结了<mark>利用clone函数</mark>、<mark>利用Message机制</mark>和<mark>利用线程池</mark>三种不同的情况，并分别对三种情况做建模处理得到<mark>发送网络数据流过程中的方法调用堆栈</mark>，通过Socket对应的TID相匹配便可以完成网络流量和EP方法的关联。此外，针对UI回调方法为EP方法的情况，作者会利用资源ID（Resource ID）来帮助EP方法和UI组件完成关联。</p><h3 id="提取网络流量的特征向量" tabindex="-1"><a class="header-anchor" href="#提取网络流量的特征向量" aria-hidden="true">#</a> 提取网络流量的特征向量</h3><p>作者从五个方面基于123个关键特征为每个网络流量提取了123维的特征向量，用于后续的模型训练，特征包括：</p><ol><li>39项<strong>时间特征</strong>。作者考虑了双向和出入站数据包的到达情况。对于每一种情况，作者会提取数据包间间隔时间的平均值、最大值、最小值和标准差等；</li><li>51项<strong>数据包大小特征</strong>。作者同样分别考虑了双向和出入站数据包大小的统计信息，包括平均值、最大值、最小值等；</li><li>20项<strong>交互模式特征</strong>。这些特征是基于一个特定的函数来进行描述的，具体可见原文；</li><li>5项<strong>数据包速率特征</strong>。这些特征指的是一定时间窗口内数据包数量的平均值、最大值、最小值等；</li><li>8项<strong>一般特征</strong>。这些特征包括双向和出入站数据包的总量、入站/出栈数量的百分比等。</li></ol><p>在完成流量的打标和特征向量的提取后，用于训练模型的数据集便构建好了。他们会用于<mark>流量分段</mark>（Traffic Segmentation）、<mark>流量过滤</mark>（Traffic Filtering）、<mark>流量识别</mark>（Flow Recognition）和<mark>方法级用户行为识别</mark>（Method-Level User Action Identification）阶段的模型的训练上。</p><h2 id="foap识别阶段" tabindex="-1"><a class="header-anchor" href="#foap识别阶段" aria-hidden="true">#</a> FOAP识别阶段</h2><h3 id="应用级的流量识别" tabindex="-1"><a class="header-anchor" href="#应用级的流量识别" aria-hidden="true">#</a> 应用级的流量识别</h3><p>在开放世界设定下的挑战在于如何减少由于在模型训练过程中没见过的应用所导致的误报数量。为了解决这个问题，FOAP采取以下几步处理：</p><p>第一步是<mark>流量分段</mark>，其目的是将网络流量按照不同的时间段进行分割，从而使得某些时间段的网络流量段能够表征目标应用的活跃时间段，进而帮助完成非目标应用流量的过滤。</p><ol><li>首先，FOAP对于每个输入的网络流量都会提取相应的特征向量；</li><li>而后，FOAP会计算网络流量的局部相似性，该数据是通过比较网络流量的特征向量和目标应用程序的特征来完成的；</li><li>再后，作者会基于局部相似性将网络流量划分为不同的时间段。</li></ol><p>第二步是<mark>流量过滤</mark>，其目的是通过过滤掉与目标应用不相关的应用，筛选掉模型训练期间没有见过的应用的流量来帮助FOAP专注于与目标应用具有结构相似性的流量段，从而降低模型在开放世界设定下的误报问题。具体的实现可以分为以下三步：</p><ol><li>流模式挖掘。这里的流模式用于描述网络流量的特征，包括数据包的大小、时间间隔方向等；</li><li>结构相似性计算。结构相似性是用来表征某一流量段与目标应用在多个流模式的相似性的量化标准，作者利用第一步的量化数据通过一个特定的数学方程来计算结构相似性，具体的数学推倒请参阅论文原文。</li><li>过滤流量段。利用结构相似性，FOAP能够过滤掉与目标应用不相关的流量段，如图2中的Traffic Filtering模块所示。</li></ol><p>第三步是<mark>流量识别</mark>。尽管经过了流量过滤，得到的流量段当中仍然会包含来自后台服务和其他应用的网络流量。</p><ol><li>因此，为了不影响识别的准确性，FOAP会对每个网络流量进行特征向量和网络流量间的的上下文信息的提取。</li><li>随后，FOAP会利用这两类信息，使用一个双层识别模型来识别网络流量， <ol><li>该模型在第一层会使用特征向量来进行初步的识别，</li><li>在第二层使用上下文信息来做二次识别以进一步确保结果无误。</li></ol></li></ol><h3 id="方法级的流量识别" tabindex="-1"><a class="header-anchor" href="#方法级的流量识别" aria-hidden="true">#</a> 方法级的流量识别</h3><p>FOAP通过数据包突发与EP方法相关联的特性来帮助完成方法级的流量识别。这包括以下几个步骤：</p><ol><li>数据包突发信息提取。FOAP首先会将网络流量分解成一系列的数据包突发，并提取这些数据包突发的特征向量，同时将这些数据包突发和对应的EP方法和时间戳相关联；</li><li>突发的时空上下文信息提取。FOAP随后会对这些数据包突发的时空上下文信息进行提取并建模，以此更准确地反映这些数据包突发与特定用户操作的关系；</li><li>EP方法的迭代式推断。FOAP最后会使用一种迭代式的推断方法来识别触发这些网络突发的EP方法，具体的，FOAP首先回味每个数据包突发分配一个EP方法标签，然后再迭代过程中使用时空上下文来<strong>优化这些标签，直至标签收敛</strong>。</li></ol><p>完成后，FOAP便能够准确地识别网络流量中的EP方法，并将他们与具体的用户操作联系起来，从而窃取用户的隐私信息。</p><h2 id="实验评估" tabindex="-1"><a class="header-anchor" href="#实验评估" aria-hidden="true">#</a> 实验评估</h2><p>在整体的实验数据集的构建上，本文选取了谷歌应用商店中排名靠前的1000个应用进行测试。通过使用<mark>开源的自动化测试工具</mark>，作者在Google Pixel 2上生成了超过1.29TB的流量实例用于进行测试。</p><h3 id="应用流量识别效果评估" tabindex="-1"><a class="header-anchor" href="#应用流量识别效果评估" aria-hidden="true">#</a> 应用流量识别效果评估</h3><p>在本轮实验数据集的设置上，本文随机将收集到的流量实例分为两个子集，其中40个实例用于训练，10个实例用于测试。在构建训练数据集时，本文会随机选择nT个其他应用作为负样本参与其中；而在构建测试数据集时，本文会选取另外20个在训练过程中未出现的应用来参与其中。为了模拟人类的行为，在训练和测试流量实例的生成上，本文把人类使用不同应用的模拟过程视为泊松过程。</p><p>实验将FOAP与AppScanner这个当下主流的AF工具进行了对比。如表1所示，实验过程中，本文还更改了nT的数量来评估它对效果的影响。结果表明，FOAP在各项数据指标上都大幅优于AppScanner。</p><figure><img src="'+c+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>表1 应用流量识别效果</p><h3 id="ep方法识别效果评估" tabindex="-1"><a class="header-anchor" href="#ep方法识别效果评估" aria-hidden="true">#</a> EP方法识别效果评估</h3><p>作者测试了在给数据包突发定义的时间阈值ε的变化下，FOAP识别效果的差异，来评估EP方法的识别效果。如表2所示，识别的精度随着ε提高而提高；而回归率和F1-评分则是随着ε提高而减少。</p><figure><img src="'+h+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>表2 EP方法识别效果</p><h3 id="运行效率评估" tabindex="-1"><a class="header-anchor" href="#运行效率评估" aria-hidden="true">#</a> 运行效率评估</h3><p>运行时间评估实验中，本文使用了一台配备英特尔i7-7700 CPU处理器的台式计算机在单核模式下运行FOAP来评估其运行效率。各个阶段的运行时间如表3所示。</p><figure><img src="'+g+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>表3 FOAP的运行效率</p><h3 id="防御措施对foap的影响" tabindex="-1"><a class="header-anchor" href="#防御措施对foap的影响" aria-hidden="true">#</a> 防御措施对FOAP的影响</h3><p>本文实现了一个名为<em>AProxy</em>的<mark>流量混淆工具</mark>来评估防御措施对于FOAP的影响。结果如下图3：</p><figure><img src="'+m+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图3 AProxy对FOAP的影响</p><p>其中P+D(x)，表示混淆数据包的数量是正常数据包的x倍。可以看到，尽管FOAP的检测能力有所降低，其依旧能够保持较高的水平，可见FOAP在应对此类防御措施上有一定的鲁棒性。</p><h3 id="流量混淆工具" tabindex="-1"><a class="header-anchor" href="#流量混淆工具" aria-hidden="true">#</a> ###流量混淆工具？</h3><blockquote><p>流量混淆工具是一类用于通过改变网络通信流量的形式和特征，以绕过网络审查、防火墙或流量分析的工具。它们旨在保护用户的隐私、维护网络安全和绕过网络限制。</p><p>流量混淆工具的作用是隐藏真实的通信内容或者使通信流量看起来像正常的、不受限制的流量，从而防止监视者、防火墙或其他网络安全设备检测到特定的应用程序、协议或敏感数据。</p><p>这些工具通过使用各种技术和方法来实现流量混淆，例如：</p><ol><li><p><strong>加密和解密</strong>：流量混淆工具使用加密算法对通信数据进行加密，使其在网络上看起来像是随机的加密数据。这使得监视者无法轻易识别通信的内容和应用程序。</p></li><li><p><strong>基于代理的混淆</strong>：流量混淆工具通过使用代理服务器来转发网络流量，从而隐藏真实的源和目的地，并将流量混合在其他正常的流量中。这使得监视者难以追踪和过滤特定的应用程序或数据。</p></li><li><p><strong>流量伪装</strong>：流量混淆工具可以将通信流量伪装成看起来像其他正常流量的形式。例如，它们可以将通信流量伪装成看起来像Web浏览器或电子邮件流量，以规避流量分析和审查。</p></li><li><p><strong>协议欺骗</strong>：流量混淆工具可以修改通信流量的协议头部或其他标识信息，使其看起来像一个不受限制的通信协议或应用程序。这可以使其通过网络过滤和检测系统。</p></li></ol><p>这些工具可在各种操作系统和网络环境中使用，并由开源或商业提供方提供。然而，需要注意的是，使用流量混淆工具时应确保符合当地法律和网络政策，避免进行非法或恶意活动。</p></blockquote><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>本文首次提出了在开放世界设定下针对安卓应用的方法级粒度的AF技术，并在此基础上实现了对应的原型工具FOAP。实验表明，该方案的在应用粒度的识别上各方面性能全面优于目前最先进的AF工具<mark>AppScanner</mark>，同时在方法粒度的识别上具备优秀的效果。</p>',79);function F(u,O){const e=n("ExternalLinkIcon");return p(),t("div",null,[A,a("p",null,[a("a",f,[r("FOAP: Fine-Grained Open-World Android App Fingerprinting | USENIX"),o(e)])]),k])}const b=i(P,[["render",F],["__file","90-白泽带你读论文｜FOAP.html.vue"]]);export{b as default};
