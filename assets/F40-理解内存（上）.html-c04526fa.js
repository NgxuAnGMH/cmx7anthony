import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as s,o as n,c,a as e,b as a,e as o,d as m}from"./app-cdabc73c.js";const p="/assets/0cf2f08e1ceda473df71189334857cf0-1679021486508-49-0655ec9b.png",d="/assets/22bb79129f6363ac26be47b35748500f-e3abfd05.jpeg",i="/assets/07cd4c3344690055240f215404a286dd-5702ba42.jpeg",l="/assets/8190dc8a065b06786f26ece596a8e9c9-4ef02389.jpg",h="/assets/614034116a840ef565feda078d73cb76-0a452aae.jpeg",_="/assets/5ba17a3ecf3f9ce4a65546de480fcc4e-c4f78e3f.jpeg",g={},k=m('<h1 id="_40-理解内存-上-虚拟内存和内存保护是什么" tabindex="-1"><a class="header-anchor" href="#_40-理解内存-上-虚拟内存和内存保护是什么" aria-hidden="true">#</a> 40 | 理解内存（上）：虚拟内存和内存保护是什么？</h1><p>我们在专栏一开始说过，计算机有五大组成部分，分别是：运算器、控制器、存储器、输入设备和输出设备。如果说计算机最重要的组件，是承担了运算器和控制器作用的 CPU，那内存就是我们第二重要的组件了。内存是五大组成部分里面的存储器，我们的指令和数据，都需要先加载到内存里面，才会被 CPU 拿去执行。</p><p>专栏第 9 讲，我们讲了程序装载到内存的过程。可以知道，在我们日常使用的 Linux 或者 Windows 操作系统下，程序并不能直接访问物理内存。</p><img src="'+p+'" alt="img" style="zoom:50%;"><p>我们的内存需要被分成<mark>固定大小的页</mark>（Page），然后再通过<mark>虚拟内存地址</mark>（Virtual Address）到<mark>物理内存地址</mark>（Physical Address）的<strong>地址转换</strong>（Address Translation），才能到达实际存放数据的物理内存位置。而我们的程序看到的内存地址，都是虚拟内存地址。</p><p>既然如此，这些虚拟内存地址究竟是怎么转换成物理内存地址的呢？这一讲里，我们就来看一看。</p><h2 id="简单页表" tabindex="-1"><a class="header-anchor" href="#简单页表" aria-hidden="true">#</a> 简单页表</h2><p>想要把虚拟内存地址，映射到物理内存地址，最直观的办法，就是来建一张映射表。这个映射表，能够实现虚拟内存里面的页，到物理内存里面的页的<em>一一映射</em>。这个映射表，在计算机里面，就叫作<strong>页表</strong>（Page Table）。</p><p>页表这个地址转换的办法，会把一个内存地址分成<strong>页号</strong>（Directory）和<strong>偏移量</strong>（Offset）两个部分。这么说太理论了，我以一个 32 位的内存地址为例，帮你理解这个概念。</p><p>其实，<code>前面的高位</code>，就是内存地址的页号。<code>后面的低位</code>，就是内存地址里面的偏移量。做地址转换的页表，只需要保留虚拟内存地址的页号和物理内存地址的页号之间的映射关系就可以了。<code>同一个页里面的内存，在物理层面是连续的</code>。以一个页的大小是 4K 字节（4KB）为例，我们需要 20 位的高位，12 位的低位。</p><img src="'+d+'" alt="img" style="zoom:25%;"><p>总结一下，对于一个内存地址转换，其实就是这样三个步骤：</p><ol><li><p>把虚拟内存地址，切分成<strong>页号</strong>和<em>偏移量</em>的组合；</p></li><li><p>从<mark>页表</mark>里面，查询出虚拟页号，对应的<strong>物理页号</strong>；</p></li><li><p>直接拿<strong>物理页号</strong>，加上前面的<em>偏移量</em>，就得到了<mark>物理内存地址</mark>。</p></li></ol><img src="'+i+'" alt="img" style="zoom:25%;"><p>看起来这个逻辑似乎很简单，很容易理解，不过问题马上就来了。你能算一算，这样一个页表需要多大的空间吗？我们以 32 位的内存地址空间为例，你可以暂停一下，拿出纸笔算一算。</p><p>不知道你算出的数字是多少？32 位的内存地址空间，页表一共需要记录 2^20 个到物理页号的映射关系。这个存储关系，就好比一个 2^20 大小的数组。一个页号是完整的 32 位的 4 字节（Byte），这样一个页表就需要 4MB 的空间。听起来 4MB 的空间好像还不大啊，毕竟我们现在的内存至少也有 4GB，服务器上有个几十 GB 的内存和很正常。</p><img src="'+l+'" alt="img" style="zoom:25%;"><p><em>不过，这个空间可不是只占用一份哦。我们每一个进程，都有属于自己独立的虚拟内存地址空间</em>。这也就意味着，每一个进程都需要这样一个页表。不管我们这个进程，是个本身只有几 KB 大小的程序，还是需要几 GB 的内存空间，都需要这样一个页表。如果你用的是 Windows，你可以打开你自己电脑上的任务管理器看看，现在你的计算机里同时在跑多少个进程，用这样的方式，页表需要占用多大的内存。</p><p>这还只是 32 位的内存地址空间，现在大家用的内存，多半已经超过了 4GB，也已经用上了 64 位的计算机和操作系统。这样的话，用上面这个数组的数据结构来保存页面，内存占用就更大了。那么，我们有没有什么更好的解决办法呢？你可以先仔细思考一下。</p><h2 id="多级页表" tabindex="-1"><a class="header-anchor" href="#多级页表" aria-hidden="true">#</a> 多级页表</h2><p>仔细想一想，我们其实没有必要存下这 2^20 个物理页表啊。<em>大部分进程所占用的内存是有限的，需要的页也自然是很有限的</em>。我们只需要去存那些用到的页之间的映射关系就好了。如果你对数据结构比较熟悉，你可能要说了，那我们是不是应该用哈希表（Hash Map）这样的数据结构呢？</p><p>很可惜你猜错了：）。在实践中，我们其实采用的是一种叫作<mark>多级页表 MPT</mark>（Multi-Level Page Table）的解决方案。这是为什么呢？为什么我们不用哈希表而用多级页表呢？别着急，听我慢慢跟你讲。</p><p>我们先来看一看，一个进程的内存地址空间是怎么分配的。在整个进程的内存地址空间，通常是**“两头实、中间空”**。在程序运行的时候，内存地址从顶部往下，不断分配占用的<mark>栈的空间</mark>。而<mark>堆的空间</mark>，内存地址则是从底部往上，是不断分配占用的。</p><p>所以，在一个实际的程序进程里面，虚拟内存占用的地址空间，<em>通常是两段连续的空间</em>。而不是完全散落的随机的内存地址。而*<code>多级页表</code>，就特别适合这样的内存地址分布*。</p><p>我们以一个 4 级的多级页表为例，来看一下。同样一个虚拟内存地址，偏移量的部分和上面简单页表一样不变，但是<mark>原先的页号部分</mark>，我们把它拆成四段，从高到低，分成 4 级到 1 级这样 4 个页表索引。</p><img src="'+h+'" alt="img" style="zoom:25%;"><p>对应的，一个进程会有一个 4 级页表。我们先通过 4 级页表索引，找到 4 级页表里面对应的<mark>条目</mark>（Entry）。这个条目里存放的是一张 3 级<mark>页表所在的位置</mark>。4 级页面里面的每一个条目，都对应着一张 3 级页表，所以我们可能有多张 3 级页表。</p><p>找到对应这张 3 级页表之后，我们用 3 级索引去找到对应的 3 级索引的<mark>条目</mark>。3 级索引的条目再会指向一个 2 级<mark>页表</mark>。同样的，2 级页表里我们可以用 2 级索引（找到的<mark>条目</mark>）指向一个 1 级<mark>页表</mark>。</p><p>而最后一层的 1 级页表里面的<mark>条目</mark>，对应的数据内容就是==<strong>物理页号</strong>==了。在拿到了物理页号之后，我们同样可以用**“页号 + 偏移量”**的方式，来获取最终的物理内存地址。</p><p>我们可能有很多张 1 级页表、2 级页表，乃至 3 级页表。但是，因为实际的虚拟内存空间通常是连续的，我们很可能只需要很少的 2 级页表，甚至只需要 1 张 3 级页表就够了。</p><h2 id="多叉树-页表树" tabindex="-1"><a class="header-anchor" href="#多叉树-页表树" aria-hidden="true">#</a> 多叉树 页表树</h2><p>事实上，多级页表就像一个<mark>多叉树</mark>的数据结构，所以我们常常称它为**<mark>页表树</mark>**（Page Table Tree）。因为虚拟内存地址分布的连续性，<em>树的第一层节点的指针，很多就是空的，<code>也就不需要有对应的子树了</code></em>。所谓不需要子树，其实就是不需要对应的 2 级、3 级的页表。<em><strong>找到最终的物理页号</strong>，就好像通过一个特定的访问路径，走到树最底层的叶子节点</em>。</p><img src="'+_+'" alt="img" style="zoom:25%;"><h2 id="时间换空间-优化和代价" tabindex="-1"><a class="header-anchor" href="#时间换空间-优化和代价" aria-hidden="true">#</a> 时间换空间：优化和代价</h2><p>以这样的分成 4 级的多级页表来看，每一级如果都用 5 个比特表示。那么每一张某 1 级的页表，只需要 2^5=32 个条目。如果每个条目还是 4 个字节，那么一共需要 128 个字节。而一个 1 级索引表，对应 32 个 4KB 的也就是 128KB 的大小。一个填满的 2 级索引表，对应的就是 32 个 1 级索引表，也就是 4MB 的大小。</p><p>我们可以一起来测算一下，一个进程如果占用了 8MB 的内存空间，分成了 2 个 4MB 的连续空间。那么，它一共需要 2 个独立的、填满的 2 级索引表，也就意味着 64 个 1 级索引表，2 个独立的 3 级索引表，1 个 4 级索引表。一共需要 69 个索引表，每个 128 字节，<em>大概就是 9KB 的空间。比起 4MB 来说，只有差不多 1/500</em>。</p><p>不过，多级页表虽然节约了我们的存储空间，却带来了时间上的开销，所以它其实是一个“<code>以时间换空间</code>”的策略。原本我们进行一次地址转换，只需要访问一次内存就能找到物理页号，算出物理内存地址。但是，用了 4 级页表，我们就需要访问 4 次内存，才能找到物理页号了。</p><p>我们在前面两讲讲过，内存访问其实比 Cache 要慢很多。我们本来只是要做一个简单的地址转换，反而是一下子要多访问好多次内存。对于这个时间层面的性能损失，我们有没有什么更好的解决办法呢？那请你一定要关注下一讲的内容哦！</p><h2 id="总结延伸" tabindex="-1"><a class="header-anchor" href="#总结延伸" aria-hidden="true">#</a> 总结延伸</h2><p>好了，这一讲的内容差不多了，我们来总结一下。</p><p>我们从最简单的<strong><em>进行虚拟页号一一映射的</em>简单页</strong>表说起，仔细讲解了现在实际应用的<mark>多级页表</mark>。多级页表就像是一颗树。因为一个进程的内存地址<code>相对集中和连续</code>，所以采用这种<mark>页表树</mark>的方式，可以大大节省页表所需要的空间。而因为每个进程都需要一个独立的页表，这个空间的节省是非常可观的。</p><p>在优化页表的过程中，我们可以观察到，数组这样的紧凑的数据结构，以及树这样稀疏的数据结构，在时间复杂度和空间复杂度的差异。另外，纯粹理论软件的数据结构和硬件的设计也是高度相关的。</p><h2 id="推荐阅读" tabindex="-1"><a class="header-anchor" href="#推荐阅读" aria-hidden="true">#</a> 推荐阅读</h2><p>对于虚拟内存的知识点，你可以再深入读一读《<code>计算机组成与设计：硬件 / 软件接口</code>》的第 5.7 章节。如果你觉得还不过瘾，可以进一步去读一读《<code>What Every Programmer Should Know About Memory</code>》的第 4 部分，也就是 Virtual Memory。</p><h2 id="课后思考" tabindex="-1"><a class="header-anchor" href="#课后思考" aria-hidden="true">#</a> 课后思考</h2><p>在实际的虚拟内存地址到物理内存地址的地址转换的过程里，我们没有采用哈希表，而是采用了多级页表的解决方案。你能想一想，使用多级页表，对于哈希表有哪些优点，又有哪些缺点吗？</p><p>欢迎留言和我分享你的想法，如果觉得有收获，你也可以把这篇文章分享给你的朋友，和他一起学习和进步。</p>',47),f={href:"https://www.polarxiong.com/archives/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%A6%82%E4%BD%95%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98.html",target:"_blank",rel:"noopener noreferrer"},u=e("br",null,null,-1),b=e("p",null,"多级页表感觉就是对大量地址的分组，如果组还是太多就接着分组，一直到一个组数规模适中的程度。查找时逐层进行。由于地址空间是个杠铃结构，很多分组就不需要了，这样就大大节省了内存空间。",-1),B=e("br",null,null,-1),x={href:"https://blog.51cto.com/u_15352922/3742181",target:"_blank",rel:"noopener noreferrer"},A=e("p",null,"多级页表。利用程序把堆和栈分布于内存两端（为了保证堆和栈的可扩展能力）的特点，压缩高位虚拟地址（应为都是同样的，只需要记录一次）",-1),E=e("p",null,"多级树状页表既给整个逻辑内存的映射预留了空间，只给用到的内存分配资源用于映射，其他没有映射到的空间指向NULL，用时间来换空间。",-1),y=e("p",null,[a("多级页表省空间的原因是把简单页表切碎了 。"),e("br"),a(" 简单页表是一个大数组 ，数组的长度是2^20 ，总大小是40M。"),e("br"),a(" 多级页表是把数据切碎成32^4个数组，全部填满元素是40M。"),e("br"),a(" 时间换空间的思想，相当于要访问四次才能拿到最终的物理地址。")],-1),M=e("p",null,"与最近在啃的 《The linux programming interface》结合起来搞明白了不少问题，不过文中的 “程序” 换成 “进程”",-1);function w(P,T){const r=s("ExternalLinkIcon");return n(),c("div",null,[k,e("blockquote",null,[e("p",null,[a("找了半天终于搞明白为啥用多级页表可以节省内存空间了。总觉得加了四级占的空间更大了才对。有跟我存在一样疑惑的可以参看以下地址，说的很明白："),e("a",f,[a("https://www.polarxiong.com/archives/多级页表如何节约内存.html"),o(r)]),u,a(" 其他网友：太牛逼了大哥，get到了我的点，我就是一直迷惑为啥简单页表就得存储所有映射，改成分级页表就可以按需加载了，谢谢谢谢真的感谢，困扰了两天。按需加载是关键")]),b,e("p",null,[a("这篇文章图画的也不错，可以参考"),B,e("a",x,[a("https://blog.51cto.com/u_15352922/3742181"),o(r)])]),A,E,y,M])])}const z=t(g,[["render",w],["__file","F40-理解内存（上）.html.vue"]]);export{z as default};
