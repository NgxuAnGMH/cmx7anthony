import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as r,d as o}from"./app-cdabc73c.js";const s="/assets/24596e1e66d88c5d077b4c957d0d7f18-34063fb0.png",p="/assets/57211af3053ed621aeb903433c6c10d1-96a1461b.png",n="/assets/0cf2f08e1ceda473df71189334857cf0-0cab69fa.png",t={},d=o('<h1 id="√09-程序装载-640k内存-真的不够用么" tabindex="-1"><a class="header-anchor" href="#√09-程序装载-640k内存-真的不够用么" aria-hidden="true">#</a> √09 | 程序装载：“640K内存”真的不够用么？</h1><p>计算机这个行业的历史上有过很多成功的预言，最著名的自然是“摩尔定律”。当然免不了的也有很多“失败”的预测，其中一个最著名的就是，比尔·盖茨在上世纪 80 年代说的“640K ought to be enough for anyone”，也就是“640K 内存对哪个人来说都够用了”。</p><p>那个年代，微软开发的还是 DOS 操作系统，程序员们还在绞尽脑汁，想要用好这极为有限的 640K 内存。而现在，我手头的开发机已经是 16G 内存了，上升了一万倍还不止。那比尔·盖茨这句话在当时也是完全的无稽之谈么？有没有哪怕一点点的道理呢？这一讲里，我就和你一起来看一看。</p><h2 id="程序装载面临的挑战" tabindex="-1"><a class="header-anchor" href="#程序装载面临的挑战" aria-hidden="true">#</a> 程序装载面临的挑战</h2><p>上一讲，我们看到了如何通过链接器，把多个文件合并成一个最终可执行文件。在运行这些可执行文件的时候，我们其实是通过一个装载器，解析 ELF 或者 PE 格式的可执行文件。装载器会把对应的指令和数据加载到内存里面来，让 CPU 去执行。</p><p>说起来只是装载到内存里面这一句话的事儿，<em>实际上装载器需要满足两个要求</em>。</p><p><strong>第一，可执行程序加载后占用的内存空间应该是连续的</strong>。我们在第 6 讲讲过，执行指令的时候，程序计数器是顺序地一条一条指令执行下去。这也就意味着，这一条条指令需要连续地存储在一起。</p><p>**第二，我们需要同时加载很多个程序，并且不能让程序自己规定在内存中加载的位置。**虽然编译出来的指令里已经有了对应的各种各样的内存地址，但是实际加载的时候，我们其实没有办法确保，这个程序一定加载在哪一段内存地址上。因为我们现在的计算机通常会同时运行很多个程序，可能你想要的内存地址已经被其他加载了的程序占用了。</p><p>要满足这两个基本的要求，我们很容易想到一个办法。那就是我们可以在内存里面，找到一段连续的内存空间，然后分配给装载的程序，然后把这段连续的内存空间地址，和整个程序指令里指定的内存地址做一个映射。</p><p>我们把指令里用到的内存地址叫作<strong>虚拟内存地址</strong>（Virtual Memory Address），实际在内存硬件里面的空间地址，我们叫<strong>物理内存地址</strong>（Physical Memory Address）。</p><p><em>程序里有指令和各种内存地址，我们只需要关心虚拟内存地址就行了</em>。对于任何一个程序来说，它看到的都是同样的内存地址。我们维护一个虚拟内存到物理内存的映射表，这样实际程序指令执行的时候，会通过虚拟内存地址，找到对应的物理内存地址，然后执行。因为是连续的内存地址空间，所以我们只需要维护映射关系的起始地址和对应的空间大小就可以了。</p><h2 id="内存分段" tabindex="-1"><a class="header-anchor" href="#内存分段" aria-hidden="true">#</a> 内存分段</h2><p>这种找出一段连续的物理内存和虚拟内存地址进行映射的方法，我们叫<strong>分段</strong>（Segmentation）**。**这里的段，就是指系统分配出来的那个连续的内存空间。</p><img src="'+s+'" alt="img" style="zoom:50%;"><p>分段的办法很好，解决了程序本身不需要关心具体的物理内存地址的问题，但它也有一些不足之处，第一个就是<strong>内存碎片</strong>（Memory Fragmentation）的问题。</p><p>我们来看这样一个例子。我现在手头的这台电脑，有 1GB 的内存。我们先启动一个图形渲染程序，占用了 512MB 的内存，接着启动一个 Chrome 浏览器，占用了 128MB 内存，再启动一个 Python 程序，占用了 256MB 内存。这个时候，我们关掉 Chrome，于是空闲内存还有 1024 - 512 - 256 = 256MB。按理来说，我们有足够的空间再去装载一个 200MB 的程序。但是，这 256MB 的内存空间不是连续的，而是被分成了两段 128MB 的内存。因此，实际情况是，我们的程序没办法加载进来。</p><img src="'+p+`" alt="img" style="zoom:50%;"><p>当然，这个我们也有办法解决。解决的办法叫<strong>内存交换</strong>（Memory Swapping）。</p><p>我们可以把 Python 程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里面。不过读回来的时候，我们不再把它加载到原来的位置，而是紧紧跟在那已经被占用了的 512MB 内存后面。<code>这样，我们就有了连续的 256MB 内存空间</code>，就可以去加载一个新的 200MB 的程序。如果你自己安装过 Linux 操作系统，<em>你应该遇到过分配一个 swap 硬盘分区的问题。这块分出来的磁盘空间，其实就是专门给 Linux 操作系统进行内存交换用的</em>。</p><p><em>虚拟内存、分段，再加上内存交换，看起来似乎已经解决了计算机同时装载运行很多个程序的问题</em>。不过，你千万不要大意，这三者的组合仍然会遇到一个<mark>性能瓶颈</mark>。硬盘的访问速度要比内存慢很多，而每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。所以，如果内存交换的时候，交换的是一个很占内存空间的程序，这样整个机器都会显得卡顿。</p><h2 id="内存分页" tabindex="-1"><a class="header-anchor" href="#内存分页" aria-hidden="true">#</a> 内存分页</h2><p>既然问题出在内存碎片和内存交换的空间太大上，那么解决问题的办法就是，少出现一些内存碎片。另外，当需要进行内存交换的时候，让需要交换写入或者从磁盘装载的数据更少一点，这样就可以解决这个问题。这个办法，在现在计算机的内存管理里面，就叫作<strong>内存分页</strong>（Paging）。</p><p><strong>和分段这样分配一整段连续的空间给到程序相比，分页是把整个物理内存空间切成一段段固定尺寸的大小</strong>。而对应的程序所需要占用的虚拟内存空间，也会同样切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫<strong>页</strong>（Page）。从虚拟内存到物理内存的映射，不再是拿整段连续的内存的物理地址，而是按照一个一个页来的。页的尺寸一般远远小于整个程序的大小。在 Linux 下，我们通常只设置成 4KB。你可以通过命令看看你手头的 <em>Linux 系统设置</em>的页的大小。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ getconf PAGE_SIZE
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>由于内存空间都是预先划分好的，也就没有了不能使用的碎片，而只有被释放出来的很多 4KB 的页。即使内存空间不够，需要让现有的、正在运行的其他程序，通过内存交换释放出一些内存的页出来，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，让整个机器被内存交换的过程给卡住。</p><img src="`+n+'" alt="img" style="zoom:50%;"><p>更进一步地，<em>分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中</em>。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是只在程序运行中，<em>需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去</em>。</p><p>实际上，我们的操作系统，的确是这么做的。当要读取特定的页，却发现数据并没有加载到物理内存里的时候，就会触发一个来自于 CPU 的<strong>缺页错误</strong>（Page Fault）。我们的操作系统会捕捉到这个错误，然后将对应的页，从存放在硬盘上的虚拟内存里读取出来，加载到物理内存里。<em>这种方式，使得我们可以运行那些远大于我们实际物理内存的程序</em>。同时，这样一来，任何程序都不需要一次性加载完所有指令和数据，<em>只需要加载当前需要用到就行了</em>。</p><p>通过虚拟内存、内存交换和内存分页这三个技术的组合，我们最终得到了一个让程序不需要考虑实际的物理内存地址、大小和当前分配空间的解决方案。这些技术和方法，对于我们程序的编写、编译和链接过程都是透明的。这也是我们在计算机的软硬件开发中常用的一种方法，就是<strong>加入一个间接层</strong>。</p><p>通过引入虚拟内存、页映射和内存交换，我们的程序本身，就不再需要考虑对应的真实的内存地址、程序加载、内存管理等问题了。任何一个程序，都只需要把内存当成是一块完整而连续的空间来直接使用。</p><h2 id="总结延伸" tabindex="-1"><a class="header-anchor" href="#总结延伸" aria-hidden="true">#</a> 总结延伸</h2><p>现在回到开头我问你的问题，我们的电脑只要 640K 内存就够了吗？很显然，现在来看，比尔·盖茨的这个判断是不合理的，那为什么他会这么认为呢？因为他也是一个很优秀的程序员啊！</p><p>在虚拟内存、内存交换和内存分页这三者结合之下，你会发现，其实要运行一个程序，“必需”的内存是很少的。CPU 只需要执行当前的指令，极限情况下，内存也只需要加载一页就好了。再大的程序，也可以分成一页。每次，只在需要用到对应的数据和指令的时候，从硬盘上交换到内存里面来就好了。以我们现在 4K 内存一页的大小，640K 内存也能放下足足 160 页呢，也无怪乎在比尔·盖茨会说出“640K ought to be enough for anyone”这样的话。</p><p>不过呢，硬盘的访问速度比内存慢很多，所以我们现在的计算机，没有个几 G 的内存都不好意思和人打招呼。</p><p>那么，除了程序分页装载这种方式之外，我们还有其他优化内存使用的方式么？下一讲，我们就一起来看看“动态装载”，学习一下让两个不同的应用程序，共用一个共享程序库的办法。</p><h2 id="推荐阅读" tabindex="-1"><a class="header-anchor" href="#推荐阅读" aria-hidden="true">#</a> 推荐阅读</h2><p>想要更深入地了解代码装载的详细过程，推荐你阅读<u>《程序员的自我修养——链接、装载和库》的第 1 章和第 6 章</u>。</p><h2 id="课后思考" tabindex="-1"><a class="header-anchor" href="#课后思考" aria-hidden="true">#</a> 课后思考</h2><p>请你想一想，在 Java 这样使用虚拟机的编程语言里面，我们写的程序是怎么装载到内存里面来的呢？它也和我们讲的一样，是通过内存分页和内存交换的方式加载到内存里面来的么？</p><p>欢迎你在留言区写下你的思考和疑问，和大家一起探讨。你也可以把今天的文章分享给你朋友，和他一起学习和进步。</p><blockquote><p>jvm已经是上层应用，无需考虑物理分页，一般更直接是考虑对象本身的空间大小，物理硬件管理统一由承载jvm的操纵系统去解决吧。作者：完全正确。</p><p>思考题<br> 1、在 Java 这样使用虚拟机的编程语言里面，我们写的程序是怎么装载到内存里面来的呢？<br> 答：首先，我们编写的Java程序，即源代码<code>.java</code>文件经过编译生成字节码文件<code>.class</code>；<br> 然后，创建JVM环境，即查找和装载<code>libjvm.so</code>文件；<br> 最后，通过创建JVM实例，加载主类的字节码文件到系统给该JVM实例分配的内存中；<br> 2、它也和我们讲的一样，是通过内存分页和内存交换的方式加载到内存里面来的么？<br> 答：Java代码的执行需要JVM环境，JVM环境的创建就是查找和装载<code>libjvm.so</code>文件：装载<code>libjvm.so</code>是通过内存分页和内存交换的方式加载到内存的。<br> 字节码文件是通过类加载器加载到主类文件对应的JVM实例的内存空间中的，这一部分不是使用内存分页和内存交换的方式来管理的，使用的是JVM的内存分配策略来管理的；</p><p>JVM并不是一个系统级的程序啊，其实只是一个操作系统之上的应用程序，申请的这些heap size是确保自己只使用特定规模的资源啊</p><p>java中，程序是加载到虚拟机内存，装载到虚拟机内存的时候，是按对象加载，没有涉及内存分页和内存交换的问题，但是涉及了垃圾 回收，毕竟jvm内存是有限的，相当于这里的java 对象，类似内存分页中的每一页，jvm整个内存相当于计算机的内存<br> jvm可以当做是一个可运行的程序，java代码只是运行在这个程序上，而jvm运行时需要的内存，是靠承载jvm的操作系统去维护解决的，这个时候可能涉及内存交换和分页；</p><p>Java虚拟机也管理内存，但是这是在操作系统之上的，Java虚拟机和操作系统分页系统的关注点不同在于，Java虚拟机关注哪些对象可以释放，以及选择合适的释放时机，避免释放内存的时候消耗太多CPU资源。操作系统更关注物理内存的使用，释放内存是程序的事情。Java虚拟机看重CPU和内存两者的综合性能，操作系统还要考虑硬盘。两者的单位也不同，Java虚拟机管理内存的单位是对象，而操作系统使用的单位是页。两者的相似之处是都要考虑CPU资源，都要最大程度的减少碎片，都要最大限度地减少内存的拷贝。</p><p>jvm并不会把字节码翻译成C++代码，而是机器码，C++也是编译成机器码来执行</p><p>作者：JVM里面如何分配内存，这个连续空间不必须是在物理内存上，甚至不必须是在虚拟内存上。而只是 JVM 这个“虚拟机” 层面的连续空间上。当然有可能会被交换到swap上，因为对于操作系统来说，JVM也只是一个用户态的应用程序。</p><p>java程序首先会被翻译成.class文件，也就是字节码文件，然后通过jvm的解释器来解释成计算机可以识别的机器码！<br> Jvm实际上也是一个软件，拥有不同的版本，这也就是为什么java可以“一次编译，到处运行”，因为不同的平台都有对应的jvm，解释出来的机器码也就自然不一样，但是并不改变Java程序的本身<br> Jvm不需要考虑物理分页，考虑的一般是对象的空间大小！</p><p>你的Java程序的内存分配，其实是由JVM虚拟机控制的。JVM虚拟机对于操作系统和硬件来说是一个应用程序。<br> 所以从理论上来看，我们的Java程序其实并不知道JVM如何去管理内存，也不需要知道，这个也是虚拟机存在的意义。<br> 当然，在真实世界中，的确也有通过理解JVM的底层实现，来利用好在物理内存里面数据是如何分布的，来让程序有极限性能，典型的就是Disruptor。</p></blockquote>',41),i=[d];function c(m,h){return e(),r("div",null,i)}const v=a(t,[["render",c],["__file","√B09-程序装载.html.vue"]]);export{v as default};
