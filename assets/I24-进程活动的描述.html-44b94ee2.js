import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as a,d as t}from"./app-cdabc73c.js";const p="/assets/bb69be65d794c9105d57f3f0b7583499-8e8acf77.jpg",e="/assets/725580e605b20be40ac3e0b24d82d0b3-dd5db4e6.jpg",o="/assets/6577df8ebc8323fa9f34835371a4b268-3834195b.jpg",c="/assets/06504e64c34ff37794b259ecbd4364ba-34fc7f60.jpg",l="/assets/330a5c9553e4ce72bf4501bbae3ab9fe-69af13d3.jpg",i={},r=t('<h1 id="_24-活动的描述-到底什么是进程" tabindex="-1"><a class="header-anchor" href="#_24-活动的描述-到底什么是进程" aria-hidden="true">#</a> 24 | 活动的描述：到底什么是进程？</h1><p>你好，我是 LMOS。</p><p>在前面的课程里，我们已经实现了<strong>数据同步、hal 层的初始化，中断框架、物理内存、内存对象、虚拟内存管理</strong>，这些都是操作系统中最核心的东西。</p><p>今天，我再给你讲讲操作系统里一个层次非常高的组件——<strong>进程</strong>，而它又非常依赖于<strong>内存管理、中断、硬件体系结构</strong>。好在前面课程中，这些基础知识我们已经搞得清清楚楚，安排得明明白白了，所以我们今天理解进程就变得顺理成章。</p><h2 id="感受一下" tabindex="-1"><a class="header-anchor" href="#感受一下" aria-hidden="true">#</a> 感受一下</h2><p>在你看来，什么是进程呢？日常我们跟计算机打交道的时候，最常接触的就是一些应用程序，比如 Word、浏览器，你可以直观感受到它们的存在。而我们却很难直观感受到什么是进程，自然也就不容易描述它的模样与形态了。</p><p>其实，在我们启用 Word 这些应用时，操作系统在背后就会建立至少一个进程。虽然我们难以观察它的形态，但我们绝对可以通过一些状态数据来发现进程的存在。</p><p>在 Linux 的终端下输入 ps 命令， 我们就可以看到系统中有多少个进程了。如下图所示。</p><img src="'+p+'" alt="img" style="zoom:50%;"><p>这是进程吗？是的，不过这只是一些具体进程的数据，如<strong>创建进程和用户、进程 ID、使用 CPU 的百分比，进程运行状态，进程的建立时间、进程的运行时间、进程名等</strong>，这些数据综合起来就代表了一个进程。</p><p>也许看到这，你会呵呵一笑，觉得原来抽象的进程背后，不过是一堆数据而已，关于进程这就是我们能直观感受到的东西，这就完了吗？当然没有，我们接着往下看。</p><h2 id="什么是进程" tabindex="-1"><a class="header-anchor" href="#什么是进程" aria-hidden="true">#</a> 什么是进程</h2><p>如果你要组织一个活动怎么办？你首先会想到，这个活动的流程是什么，需要配备哪些人员和物资，中途要不要休息，活动当前进行到哪里了……如果你是个精明的人，你大概会用<strong>表格</strong>把这些信息记录下来。</p><p>同理，你运行一个应用程序时，操作系统也要记录这个应用程序<strong>使用多少内存，打开了什么文件，当有些资源不可用的时候要不要睡眠，当前进程运行到哪里了</strong>。操作系统把这些信息综合统计，存放在内存中，抽象为进程。</p><p>现在你就可以回答什么是进程了：</p><ul><li>进程是一个应用程序运行时刻的实例（<code>从进程的结构看</code>）；</li><li>进程是应用程序运行时所需资源的容器（<code>从进程的功能看</code>）；</li><li>甚至进程是一堆数据结构（<code>从操作系统对进程实现的角度来说</code>）。</li></ul><p>这也太简单了吧？对，进程的抽象概念就是这么简单。我知道这一定不能让你真正明白什么是进程，抽象的概念就是如此，你不在实践中设计并实现它，是很难真正明白的。下面我们先来细化设计。</p><h2 id="操作系统眼中的虚拟地址" tabindex="-1"><a class="header-anchor" href="#操作系统眼中的虚拟地址" aria-hidden="true">#</a> 操作系统眼中的虚拟地址</h2><p>首先，进程是一个应用程序运行时刻的实例，它的目的就是操作系统用于管理和运行多个应用程序的；其次，从前面我们实现的内存管理组件角度看，操作系统是给应用程序提供服务的。</p><p>所以，从这两个角度看，进程必须要有一个地址空间，这个地址空间至少包括两部分内容：一部分是内核，一部分是用户的应用程序。</p><p>最后，结合 x86 硬件平台对虚拟地址空间的制约，我给你画了一幅图，如下所示。</p><img src="'+e+'" alt="img" style="zoom:15%;"><p>进程结构示意图</p><p>上图中有 8 个进程，每个进程拥有 x86 CPU 的整个虚拟地址空间，这个虚拟地址空间被分成了两个部分，<code>上半部分是所有进程都共享的内核部分</code> ，里面放着一份内核代码和数据，下半部分是应用程序，分别独立，互不干扰。</p><p>还记得我们讲过的 x86 CPU 的特权级吗？</p><p>当 CPU 在 <mark>R0 特权级</mark>运行时，就运行在上半部分内核的地址空间中，当 CPU 在 <mark>R3 特权级</mark>时，就运行在下半部分的应用程序地址空间中。各进程的虚拟地址空间是相同的，它们之间物理地址不同，是由 <mark>MMU 页表</mark>进行隔离的，所以每个进程的应用程序的代码<strong>绝对不能随意访问</strong>内核的代码和数据。</p><h2 id="进程的结构" tabindex="-1"><a class="header-anchor" href="#进程的结构" aria-hidden="true">#</a> 进程的结构</h2><p>以上是整体结构，下面我们来细化一下进程需要实现哪些功能？</p><p>我们先从<strong>应用程序和内核的关系</strong>看。应用程序需要内核提供资源，而内核需要控制应用程序的运行。那么内核必须能够命令应用程序，让它<strong>随时中断（进入内核地址空间）或恢复执行</strong>，这就需要保存<mark>应用程序的机器上下文</mark>和<mark>它运行时刻的栈</mark>。</p><p>接着，我们深入<strong>内核提供服务的机制</strong>。众所周知，内核是这样提供服务的：通过停止应用程序代码运行，进入内核地址空间运行内核代码，然后返回结果。就像活动组织者会用表格备案一样，内核还需要记录<strong>一个应用程序都访问了哪些资源</strong>，比如打开了某个文件，或是访问了某个设备。而这样的“记录表”，我们就用“<strong><mark>资源描述符</mark></strong>”来表示。</p><p>而我们前面已经说了，进程是一个应用程序运行时刻的实例。那这样一来，一个细化的进程结构，就可以像下图这样设计。</p><p>图中表示了一个进程详细且必要的结构，<strong>其中带 * 号是每个进程(<code>在共享的内核区域中</code>)都有独立一份，有了这样的设计结构，多个进程就能并发运行了</strong>。前面这些内容还是纸上谈兵，你重点搞明白进程的概念和结构就行了。</p><img src="'+o+`" alt="img" style="zoom:15%;"><p>进程结构细化示意图</p><h2 id="实现进程" tabindex="-1"><a class="header-anchor" href="#实现进程" aria-hidden="true">#</a> 实现进程</h2><p>前面我们简单介绍了进程的概念和结构，之所以简单，是为了不在理论层面就把问题复杂化，这对我们实现 Cosmos 的进程组件没有任何好处。</p><p>但只懂理论还是空中阁楼，我们可以一步步在设计实现中，由浅到深地理解什么是进程。我们这就把前面的概念和设计，一步步落实到代码，设计出对应的数据结构。</p><h3 id="如何表示一个进程-krlthread-t-h" tabindex="-1"><a class="header-anchor" href="#如何表示一个进程-krlthread-t-h" aria-hidden="true">#</a> 如何表示一个进程: krlthread_t.h</h3><p>根据前面课程的经验，如果要在软件代码中表示一个什么东西时，就要设计出对应的数据结构。</p><p>那么对于一个进程，它有<strong>状态，id，运行时间，优先级，应用程序栈，内核栈，机器上下文，资源描述符，地址空间</strong>，我们将这些信息组织在一起，就形成了一个进程的数据结构。</p><p>下面我带你把它变成代码，在 <code>cosmos/include/knlinc/</code> 目录下建立一个 <code>krlthread_t.h</code> 文件，在其中写上代码，如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">s_THREAD</span>
<span class="token punctuation">{</span>
    <span class="token class-name">spinlock_t</span>  td_lock<span class="token punctuation">;</span>           <span class="token comment">//进程的自旋锁</span>
    <span class="token class-name">list_h_t</span>    td_list<span class="token punctuation">;</span>           <span class="token comment">//进程链表 </span>
    <span class="token class-name">uint_t</span>      td_flgs<span class="token punctuation">;</span>           <span class="token comment">//进程的标志</span>
    <span class="token class-name">uint_t</span>      td_stus<span class="token punctuation">;</span>           <span class="token comment">//进程的状态</span>
    <span class="token class-name">uint_t</span>      td_cpuid<span class="token punctuation">;</span>          <span class="token comment">//进程所在的CPU的id</span>
    <span class="token class-name">uint_t</span>      td_id<span class="token punctuation">;</span>             <span class="token comment">//进程的id</span>
    <span class="token class-name">uint_t</span>      td_tick<span class="token punctuation">;</span>           <span class="token comment">//进程运行了多少tick</span>
    <span class="token class-name">uint_t</span>      td_privilege<span class="token punctuation">;</span>      <span class="token comment">//进程的权限</span>
    <span class="token class-name">uint_t</span>      td_priority<span class="token punctuation">;</span>       <span class="token comment">//进程的优先级</span>
    <span class="token class-name">uint_t</span>      td_runmode<span class="token punctuation">;</span>        <span class="token comment">//进程的运行模式</span>
    <span class="token class-name">adr_t</span>       td_krlstktop<span class="token punctuation">;</span>      <span class="token comment">//应用程序内核栈顶地址</span>
    <span class="token class-name">adr_t</span>       td_krlstkstart<span class="token punctuation">;</span>    <span class="token comment">//应用程序内核栈开始地址</span>
    <span class="token class-name">adr_t</span>       td_usrstktop<span class="token punctuation">;</span>      <span class="token comment">//应用程序栈顶地址</span>
    <span class="token class-name">adr_t</span>       td_usrstkstart<span class="token punctuation">;</span>    <span class="token comment">//应用程序栈开始地址</span>
    <span class="token class-name">mmadrsdsc_t</span><span class="token operator">*</span> td_mmdsc<span class="token punctuation">;</span>         <span class="token comment">//地址空间结构</span>
    <span class="token class-name">context_t</span>   td_context<span class="token punctuation">;</span>        <span class="token comment">//机器上下文件结构</span>
    <span class="token class-name">objnode_t</span><span class="token operator">*</span>  td_handtbl<span class="token punctuation">[</span>TD_HAND_MAX<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//打开的对象数组</span>
<span class="token punctuation">}</span><span class="token class-name">thread_t</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 Cosmos 中，我们就使用 <strong>thread_t 结构</strong>的一个实例变量代表一个进程。</p><p><mark>进程的内核栈</mark>和<mark>进程的应用程序栈</mark>是两块内存空间，</p><p>进程的权限表示一个进程是<mark>用户进程</mark>还是<mark>系统进程</mark>。进程的权限不同，它们能完成功能也不同。</p><p>万事都有轻重缓急，进程也一样，进程有 64 个优先级，td_priority 数值越小优先级越高。td_handtbl 只是一个 objnode_t 结构的指针类型数组。</p><p>比方说，一个进程打开一个文件内核就会创建一个对应的 objnode_t 结构的实例变量，这个 objnode_t 结构的地址就保存在 td_handtbl 数组中。你可以这么理解：这个 objnode_t 结构就是<mark>进程打开资源的描述符</mark>。</p><h3 id="进程的地址空间" tabindex="-1"><a class="header-anchor" href="#进程的地址空间" aria-hidden="true">#</a> 进程的地址空间</h3><p>在 thread_t 结构中有个 mmadrsdsc_t 结构的指针，在这个结构中有<mark>虚拟地址区间结构</mark>和 <mark>MMU 相关的信息</mark>。mmadrsdsc_t 结构你应该很熟悉，在虚拟内存那节课中，我们学习过，今天我们再次复习一下，如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">s_MMADRSDSC</span>
<span class="token punctuation">{</span>
    <span class="token class-name">spinlock_t</span> msd_lock<span class="token punctuation">;</span>               <span class="token comment">//保护自身的自旋锁</span>
    <span class="token class-name">list_h_t</span> msd_list<span class="token punctuation">;</span>                 <span class="token comment">//链表</span>
    <span class="token class-name">uint_t</span> msd_flag<span class="token punctuation">;</span>                   <span class="token comment">//状态和标志</span>
    <span class="token class-name">uint_t</span> msd_stus<span class="token punctuation">;</span>
    <span class="token class-name">uint_t</span> msd_scount<span class="token punctuation">;</span>                 <span class="token comment">//计数，该结构可能被共享</span>
    <span class="token class-name">sem_t</span>  msd_sem<span class="token punctuation">;</span>                    <span class="token comment">//信号量</span>
    <span class="token class-name">mmudsc_t</span> msd_mmu<span class="token punctuation">;</span>                  <span class="token comment">//MMU页表相关的信息</span>
    <span class="token class-name">virmemadrs_t</span> msd_virmemadrs<span class="token punctuation">;</span>       <span class="token comment">//虚拟地址空间结构</span>
    <span class="token class-name">adr_t</span> msd_stext<span class="token punctuation">;</span>                   <span class="token comment">//应用的指令区的开始、结束地址</span>
    <span class="token class-name">adr_t</span> msd_etext<span class="token punctuation">;</span>
    <span class="token class-name">adr_t</span> msd_sdata<span class="token punctuation">;</span>                   <span class="token comment">//应用的数据区的开始、结束地址</span>
    <span class="token class-name">adr_t</span> msd_edata<span class="token punctuation">;</span>
    <span class="token class-name">adr_t</span> msd_sbss<span class="token punctuation">;</span>                    <span class="token comment">//应用初始化为0的区域开始、结束地址</span>
    <span class="token class-name">adr_t</span> msd_ebss<span class="token punctuation">;</span>
    <span class="token class-name">adr_t</span> msd_sbrk<span class="token punctuation">;</span>                    <span class="token comment">//应用的堆区的开始、结束地址</span>
    <span class="token class-name">adr_t</span> msd_ebrk<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token class-name">mmadrsdsc_t</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中，注释已经很清楚了，mmadrsdsc_t 结构描述了<strong>一个进程的完整的地址空间</strong>。</p><p>需要搞清楚的是：在常规情况下，新建一个进程就要建立一个 mmadrsdsc_t 结构，让 thread_t 结构的 td_mmdsc 的指针变量指向它。</p><h3 id="中断时-特权级切换-进程的机器上下文" tabindex="-1"><a class="header-anchor" href="#中断时-特权级切换-进程的机器上下文" aria-hidden="true">#</a> (中断时/特权级切换)进程的机器上下文</h3><p>进程的机器上下文分为几个部分，一部分是 CPU 寄存器，一部分是内核函数调用路径。</p><ol><li>CPU 的通用寄存器，是中断发生进入内核时，压入内核栈中的，</li><li>从中断入口处开始调用的函数，都是属于内核的函数。</li></ol><p>函数的调用路径就在内核栈中，整个过程是这样的：进程调度器函数会调用进程切换函数，完成切换进程这个操作，而**在进程切换函数中会保存栈寄存器的值。**好，下面我们来设计这样一个结构来保存这些信息。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">s_CONTEXT</span>
<span class="token punctuation">{</span>  
    <span class="token class-name">uint_t</span>       ctx_nextrip<span class="token punctuation">;</span> <span class="token comment">//保存下一次运行的地址</span>
    <span class="token class-name">uint_t</span>       ctx_nextrsp<span class="token punctuation">;</span> <span class="token comment">//保存下一次运行时内核栈的地址 </span>
    <span class="token class-name">x64tss_t</span><span class="token operator">*</span>    ctx_nexttss<span class="token punctuation">;</span> <span class="token comment">//指向tss结构</span>
<span class="token punctuation">}</span><span class="token class-name">context_t</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>context_t 结构中的字段不多，我们相对陌生的就是 x64tss_t 结构的指针，这个结构是 CPU 要求的一个结构，这个结构它本身的地址放在一个 GDT 表项中，由 CPU 的 tr 寄存器指向，tr 寄存器中的值是 GDT 中 x64tss_t 结构项对应的索引。x64tss_t 结构的代码如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// cosmos/hal/x86/halglobal.c</span>
<span class="token comment">// 每个CPU核心一个tss </span>
<span class="token function">HAL_DEFGLOB_VARIABLE</span><span class="token punctuation">(</span><span class="token class-name">x64tss_t</span><span class="token punctuation">,</span>x64tss<span class="token punctuation">)</span><span class="token punctuation">[</span>CPUCORE_MAX<span class="token punctuation">]</span><span class="token punctuation">;</span> 

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">s_X64TSS</span>
<span class="token punctuation">{</span>
    <span class="token class-name">u32_t</span> reserv0<span class="token punctuation">;</span> <span class="token comment">//保留</span>
    <span class="token class-name">u64_t</span> rsp0<span class="token punctuation">;</span>  <span class="token comment">//R0特权级的栈地址</span>
    <span class="token class-name">u64_t</span> rsp1<span class="token punctuation">;</span>  <span class="token comment">//R1特权级的栈地址，我们未使用</span>
    <span class="token class-name">u64_t</span> rsp2<span class="token punctuation">;</span>  <span class="token comment">//R2特权级的栈地址，我们未使用</span>
    <span class="token class-name">u64_t</span> reserv28<span class="token punctuation">;</span><span class="token comment">//保留</span>
    <span class="token class-name">u64_t</span> ist<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//我们未使用</span>
    <span class="token class-name">u64_t</span> reserv92<span class="token punctuation">;</span><span class="token comment">//保留</span>
    <span class="token class-name">u16_t</span> reserv100<span class="token punctuation">;</span><span class="token comment">//保留</span>
    <span class="token class-name">u16_t</span> iobase<span class="token punctuation">;</span>   <span class="token comment">//我们未使用</span>
<span class="token punctuation">}</span><span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span>packed<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">x64tss_t</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>CPU 在发生中断时，会根据中断门描述里的目标段选择子，<code>进行必要的特权级切换</code></strong>，特权级的切换就必须要切换栈，CPU 硬件会自己把当前 rsp 寄存器保存到内部的临时寄存器 tmprsp；然后从 x64tss_t 结构体中找出对应的栈地址，装入 rsp 寄存器中；接着，再把当前的 ss、tmprsp、rflags、cs、rip，依次压入当前 rsp 指向的栈中。</p><h2 id="建立进程" tabindex="-1"><a class="header-anchor" href="#建立进程" aria-hidden="true">#</a> 建立进程</h2><p>之前我们已经设计好了进程相关的数据结构，现在我们要讨论如何建立一个新的进程了。建立进程非常简单，就是在内存中建立起对应的数据结构的实例变量。</p><p>但是对进程来说，并不是建立 <strong>thread_t 结构</strong>的实例变量就完事了，还要建立<mark>进程的应用程序栈</mark>和<mark>进程的内核栈</mark>，<mark>进程地址空间</mark>等。下面我们一起来实现建立进程的功能。</p><h3 id="建立进程接口" tabindex="-1"><a class="header-anchor" href="#建立进程接口" aria-hidden="true">#</a> 建立进程接口</h3><p>我们先从建立进程的接口开始写起，先在 <code>cosmos/kernel/</code> 目录下新建一个文件 <code>krlthread.c</code>，在其中写上一个函数。接口函数总是简单的，代码如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token class-name">thread_t</span> <span class="token operator">*</span><span class="token function">krlnew_thread</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>filerun<span class="token punctuation">,</span> <span class="token class-name">uint_t</span> flg<span class="token punctuation">,</span> <span class="token class-name">uint_t</span> prilg<span class="token punctuation">,</span> <span class="token class-name">uint_t</span> prity<span class="token punctuation">,</span> <span class="token class-name">size_t</span> usrstksz<span class="token punctuation">,</span> <span class="token class-name">size_t</span> krlstksz<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">size_t</span> tustksz <span class="token operator">=</span> usrstksz<span class="token punctuation">,</span> tkstksz <span class="token operator">=</span> krlstksz<span class="token punctuation">;</span>
    <span class="token comment">//对参数进行检查，不合乎要求就返回NULL表示创建失败</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>filerun <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> usrstksz <span class="token operator">&gt;</span> DAFT_TDUSRSTKSZ <span class="token operator">||</span> krlstksz <span class="token operator">&gt;</span> DAFT_TDKRLSTKSZ<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>prilg <span class="token operator">!=</span> PRILG_USR <span class="token operator">&amp;&amp;</span> prilg <span class="token operator">!=</span> PRILG_SYS<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>prity <span class="token operator">&gt;=</span> PRITY_MAX<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//进程应用程序栈大小检查，大于默认大小则使用默认大小</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>usrstksz <span class="token operator">&lt;</span> DAFT_TDUSRSTKSZ<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        tustksz <span class="token operator">=</span> DAFT_TDUSRSTKSZ<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//进程内核栈大小检查，大于默认大小则使用默认大小</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>krlstksz <span class="token operator">&lt;</span> DAFT_TDKRLSTKSZ<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        tkstksz <span class="token operator">=</span> DAFT_TDKRLSTKSZ<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//是否建立内核进程</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>KERNTHREAD_FLG <span class="token operator">==</span> flg<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">krlnew_kern_thread_core</span><span class="token punctuation">(</span>filerun<span class="token punctuation">,</span> flg<span class="token punctuation">,</span> prilg<span class="token punctuation">,</span> prity<span class="token punctuation">,</span> tustksz<span class="token punctuation">,</span> tkstksz<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//是否建立普通进程</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>USERTHREAD_FLG <span class="token operator">==</span> flg<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">krlnew_user_thread_core</span><span class="token punctuation">(</span>filerun<span class="token punctuation">,</span> flg<span class="token punctuation">,</span> prilg<span class="token punctuation">,</span> prity<span class="token punctuation">,</span> tustksz<span class="token punctuation">,</span> tkstksz<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中的 krlnew_thread 函数的流程非常简单，对参数进行合理检查，其参数从左到右分别是应用程序启动运行的地址、创建标志、进程权限和进程优先级、进程的应用程序栈和内核栈大小。</p><p>进程对栈的大小有要求，如果小于默认大小 8 个页面就使用默认的栈大小，最后根据创建标志确认是建立<mark>内核态进程</mark>还是建立<mark>普通进程</mark>。</p><h2 id="建立内核进程" tabindex="-1"><a class="header-anchor" href="#建立内核进程" aria-hidden="true">#</a> 建立内核进程</h2><p>你一定在想，什么是内核进程？其实内核进程就是<strong>用进程的方式去运行一段内核代码，那么这段代码就可以随时暂停或者继续运行，又或者和其它代码段并发运行，只是这种进程<code>永远不会</code>回到进程应用程序地址空间中去，<code>只会</code>在内核地址空间中运行。</strong></p><p>下面我来写代码实现建立一个内核态进程，如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token class-name">thread_t</span> <span class="token operator">*</span><span class="token function">krlnew_kern_thread_core</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>filerun<span class="token punctuation">,</span> <span class="token class-name">uint_t</span> flg<span class="token punctuation">,</span> <span class="token class-name">uint_t</span> prilg<span class="token punctuation">,</span> <span class="token class-name">uint_t</span> prity<span class="token punctuation">,</span> <span class="token class-name">size_t</span> usrstksz<span class="token punctuation">,</span> <span class="token class-name">size_t</span> krlstksz<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">thread_t</span> <span class="token operator">*</span>ret_td <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token class-name">bool_t</span> acs <span class="token operator">=</span> FALSE<span class="token punctuation">;</span>
    <span class="token class-name">adr_t</span> krlstkadr <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token comment">//分配内核栈空间</span>
    krlstkadr <span class="token operator">=</span> <span class="token function">krlnew</span><span class="token punctuation">(</span>krlstksz<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>krlstkadr <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//建立thread_t结构体的实例变量</span>
    ret_td <span class="token operator">=</span> <span class="token function">krlnew_thread_dsc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret_td <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span><span class="token comment">//创建失败必须要释放之前的栈空间</span>
        acs <span class="token operator">=</span> <span class="token function">krldelete</span><span class="token punctuation">(</span>krlstkadr<span class="token punctuation">,</span> krlstksz<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>acs <span class="token operator">==</span> FALSE<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//设置进程权限 </span>
    ret_td<span class="token operator">-&gt;</span>td_privilege <span class="token operator">=</span> prilg<span class="token punctuation">;</span>
    <span class="token comment">//设置进程优先级</span>
    ret_td<span class="token operator">-&gt;</span>td_priority <span class="token operator">=</span> prity<span class="token punctuation">;</span>
    <span class="token comment">//设置进程的内核栈顶和内核栈开始地址</span>
    ret_td<span class="token operator">-&gt;</span>td_krlstktop <span class="token operator">=</span> krlstkadr <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token class-name">adr_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span>krlstksz <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ret_td<span class="token operator">-&gt;</span>td_krlstkstart <span class="token operator">=</span> krlstkadr<span class="token punctuation">;</span>
    <span class="token comment">//初始化进程的内核栈</span>
    <span class="token function">krlthread_kernstack_init</span><span class="token punctuation">(</span>ret_td<span class="token punctuation">,</span> filerun<span class="token punctuation">,</span> KMOD_EFLAGS<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//加入进程调度系统</span>
    <span class="token function">krlschdclass_add_thread</span><span class="token punctuation">(</span>ret_td<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//返回进程指针</span>
    <span class="token keyword">return</span> ret_td<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码的逻辑非常简单，首先分配一个内核栈的内存空间，接着创建 thread_t 结构的实例变量，然后对 thread_t 结构体的字段进行设置，最后，初始化进程内核栈把这个新进程加入到进程的调度系统之中，下面来一步步写入实现这些逻辑的代码。</p><h3 id="创建-thread-t-结构" tabindex="-1"><a class="header-anchor" href="#创建-thread-t-结构" aria-hidden="true">#</a> 创建 thread_t 结构</h3><p>创建 thread_t 结构，其实就是分配一块内存用于存放 thread_t 结构的实例变量。类似这样的操作我们课程里做过多次，相信现在你已经能驾轻就熟了。下面我们来写代码实现这个操作，如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//初始化context_t结构</span>
<span class="token keyword">void</span> <span class="token function">context_t_init</span><span class="token punctuation">(</span><span class="token class-name">context_t</span> <span class="token operator">*</span>initp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    initp<span class="token operator">-&gt;</span>ctx_nextrip <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    initp<span class="token operator">-&gt;</span>ctx_nextrsp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">//指向当前CPU的tss</span>
    initp<span class="token operator">-&gt;</span>ctx_nexttss <span class="token operator">=</span> <span class="token operator">&amp;</span>x64tss<span class="token punctuation">[</span><span class="token function">hal_retn_cpuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//返回进程id其实就thread_t结构的地址</span>
<span class="token class-name">uint_t</span> <span class="token function">krlretn_thread_id</span><span class="token punctuation">(</span><span class="token class-name">thread_t</span> <span class="token operator">*</span>tdp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">uint_t</span><span class="token punctuation">)</span>tdp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//初始化thread_t结构</span>
<span class="token keyword">void</span> <span class="token function">thread_t_init</span><span class="token punctuation">(</span><span class="token class-name">thread_t</span> <span class="token operator">*</span>initp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">krlspinlock_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>initp<span class="token operator">-&gt;</span>td_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">list_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>initp<span class="token operator">-&gt;</span>td_list<span class="token punctuation">)</span><span class="token punctuation">;</span>
    initp<span class="token operator">-&gt;</span>td_flgs <span class="token operator">=</span> TDFLAG_FREE<span class="token punctuation">;</span>
    initp<span class="token operator">-&gt;</span>td_stus <span class="token operator">=</span> TDSTUS_NEW<span class="token punctuation">;</span><span class="token comment">//进程状态为新建</span>
    initp<span class="token operator">-&gt;</span>td_cpuid <span class="token operator">=</span> <span class="token function">hal_retn_cpuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    initp<span class="token operator">-&gt;</span>td_id <span class="token operator">=</span> <span class="token function">krlretn_thread_id</span><span class="token punctuation">(</span>initp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    initp<span class="token operator">-&gt;</span>td_tick <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    initp<span class="token operator">-&gt;</span>td_privilege <span class="token operator">=</span> PRILG_USR<span class="token punctuation">;</span><span class="token comment">//普通进程权限</span>
    initp<span class="token operator">-&gt;</span>td_priority <span class="token operator">=</span> PRITY_MIN<span class="token punctuation">;</span><span class="token comment">//最高优先级</span>
    initp<span class="token operator">-&gt;</span>td_runmode <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    initp<span class="token operator">-&gt;</span>td_krlstktop <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    initp<span class="token operator">-&gt;</span>td_krlstkstart <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    initp<span class="token operator">-&gt;</span>td_usrstktop <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    initp<span class="token operator">-&gt;</span>td_usrstkstart <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    initp<span class="token operator">-&gt;</span>td_mmdsc <span class="token operator">=</span> <span class="token operator">&amp;</span>initmmadrsdsc<span class="token punctuation">;</span><span class="token comment">//指向默认的地址空间结构</span>

    <span class="token function">context_t_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>initp<span class="token operator">-&gt;</span>td_context<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//初始化td_handtbl数组</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">uint_t</span> hand <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> hand <span class="token operator">&lt;</span> TD_HAND_MAX<span class="token punctuation">;</span> hand<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        initp<span class="token operator">-&gt;</span>td_handtbl<span class="token punctuation">[</span>hand<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//创建thread_t结构</span>
<span class="token class-name">thread_t</span> <span class="token operator">*</span><span class="token function">krlnew_thread_dsc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">//分配thread_t结构大小的内存空间</span>
    <span class="token class-name">thread_t</span> <span class="token operator">*</span>rettdp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">thread_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">krlnew</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">thread_t</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>rettdp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//初始化刚刚分配的thread_t结构</span>
    <span class="token function">thread_t_init</span><span class="token punctuation">(</span>rettdp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> rettdp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>相信凭你现在的能力，上述代码一定是超级简单的。不过我们依然要注意这样几点。</p><p>首先，我们以 thread_t 结构的地址作为进程的 ID，这个 ID 具有唯一性；其次，我们目前没有为一个进程分配 mmadrsdsc_t 结构体，而是指向了默认的地址空间结构 initmmadrsdsc；最后，hal_retn_cpuid 函数在目前的情况下永远返回 0，这是因为我们使用了一个 CPU。</p><h3 id="初始化内核栈" tabindex="-1"><a class="header-anchor" href="#初始化内核栈" aria-hidden="true">#</a> 初始化内核栈</h3><p>为什么要初始化进程的内核栈呢？</p><p>你也许会想，进程的内核栈无非是一块内存，其实只要初始化为 0 就好。当然不是这么简单，我们初始化进程的内核栈，其实是为了在进程的内核栈中放置一份 CPU 的寄存器数据。</p><p>这份 CPU 寄存器数据是一个进程机器上下文的一部分，当一个进程开始运行时，我们将会使用“pop”指令从进程的内核栈中弹出到 CPU 中，这样 CPU 就开始运行进程了，CPU 的一些寄存器是有位置关系的，所以我们要定义一个结构体来操作它们，如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">s_INTSTKREGS</span>
<span class="token punctuation">{</span>
    <span class="token class-name">uint_t</span> r_gs<span class="token punctuation">;</span>
    <span class="token class-name">uint_t</span> r_fs<span class="token punctuation">;</span>
    <span class="token class-name">uint_t</span> r_es<span class="token punctuation">;</span>
    <span class="token class-name">uint_t</span> r_ds<span class="token punctuation">;</span>  <span class="token comment">//段寄存器</span>
    <span class="token class-name">uint_t</span> r_r15<span class="token punctuation">;</span>
    <span class="token class-name">uint_t</span> r_r14<span class="token punctuation">;</span>
    <span class="token class-name">uint_t</span> r_r13<span class="token punctuation">;</span>
    <span class="token class-name">uint_t</span> r_r12<span class="token punctuation">;</span>
    <span class="token class-name">uint_t</span> r_r11<span class="token punctuation">;</span>
    <span class="token class-name">uint_t</span> r_r10<span class="token punctuation">;</span>
    <span class="token class-name">uint_t</span> r_r9<span class="token punctuation">;</span>
    <span class="token class-name">uint_t</span> r_r8<span class="token punctuation">;</span>
    <span class="token class-name">uint_t</span> r_rdi<span class="token punctuation">;</span>
    <span class="token class-name">uint_t</span> r_rsi<span class="token punctuation">;</span>
    <span class="token class-name">uint_t</span> r_rbp<span class="token punctuation">;</span>
    <span class="token class-name">uint_t</span> r_rdx<span class="token punctuation">;</span> <span class="token comment">//通用寄存器</span>
    <span class="token class-name">uint_t</span> r_rcx<span class="token punctuation">;</span>
    <span class="token class-name">uint_t</span> r_rbx<span class="token punctuation">;</span>
    <span class="token class-name">uint_t</span> r_rax<span class="token punctuation">;</span>
    <span class="token class-name">uint_t</span> r_rip_old<span class="token punctuation">;</span><span class="token comment">//程序的指针寄存器</span>
    <span class="token class-name">uint_t</span> r_cs_old<span class="token punctuation">;</span><span class="token comment">//代码段寄存器</span>
    <span class="token class-name">uint_t</span> r_rflgs<span class="token punctuation">;</span> <span class="token comment">//rflags标志寄存</span>
    <span class="token class-name">uint_t</span> r_rsp_old<span class="token punctuation">;</span><span class="token comment">//栈指针寄存器</span>
    <span class="token class-name">uint_t</span> r_ss_old<span class="token punctuation">;</span> <span class="token comment">//栈段寄存器</span>
<span class="token punctuation">}</span><span class="token class-name">intstkregs_t</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>intstkregs_t 结构中，每个字段都是 8 字节 64 位的，因为 x86 CPU 在长模式下 rsp 栈指针寄存器始终 8 字节对齐。栈是向下伸长的（从高地址向低地址）所以这个结构是反向定义（相对于栈）如果你不理解这个寄存器位置，可以回到中断处理那节课复习一下。</p><p>intstkregs_t 结构已经定义好了，下面我们来写代码初始化内核栈，如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">krlthread_kernstack_init</span><span class="token punctuation">(</span><span class="token class-name">thread_t</span> <span class="token operator">*</span>thdp<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>runadr<span class="token punctuation">,</span> <span class="token class-name">uint_t</span> cpuflags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">//处理栈顶16字节对齐</span>
    thdp<span class="token operator">-&gt;</span>td_krlstktop <span class="token operator">&amp;=</span> <span class="token punctuation">(</span><span class="token operator">~</span><span class="token number">0xf</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    thdp<span class="token operator">-&gt;</span>td_usrstktop <span class="token operator">&amp;=</span> <span class="token punctuation">(</span><span class="token operator">~</span><span class="token number">0xf</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//内核栈顶减去intstkregs_t结构的大小</span>
    <span class="token class-name">intstkregs_t</span> <span class="token operator">*</span>arp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">intstkregs_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>thdp<span class="token operator">-&gt;</span>td_krlstktop <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">intstkregs_t</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//把intstkregs_t结构的空间初始化为0</span>
    <span class="token function">hal_memset</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>arp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">intstkregs_t</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//rip寄存器的值设为程序运行首地址 </span>
    arp<span class="token operator">-&gt;</span>r_rip_old <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint_t</span><span class="token punctuation">)</span>runadr<span class="token punctuation">;</span>
    <span class="token comment">//cs寄存器的值设为内核代码段选择子 </span>
    arp<span class="token operator">-&gt;</span>r_cs_old <span class="token operator">=</span> K_CS_IDX<span class="token punctuation">;</span>
    arp<span class="token operator">-&gt;</span>r_rflgs <span class="token operator">=</span> cpuflags<span class="token punctuation">;</span>
    <span class="token comment">//返回进程的内核栈</span>
    arp<span class="token operator">-&gt;</span>r_rsp_old <span class="token operator">=</span> thdp<span class="token operator">-&gt;</span>td_krlstktop<span class="token punctuation">;</span>
    arp<span class="token operator">-&gt;</span>r_ss_old <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">//其它段寄存器的值设为内核数据段选择子</span>
    arp<span class="token operator">-&gt;</span>r_ds <span class="token operator">=</span> K_DS_IDX<span class="token punctuation">;</span>
    arp<span class="token operator">-&gt;</span>r_es <span class="token operator">=</span> K_DS_IDX<span class="token punctuation">;</span>
    arp<span class="token operator">-&gt;</span>r_fs <span class="token operator">=</span> K_DS_IDX<span class="token punctuation">;</span>
    arp<span class="token operator">-&gt;</span>r_gs <span class="token operator">=</span> K_DS_IDX<span class="token punctuation">;</span>
    <span class="token comment">//设置进程下一次运行的地址为runadr</span>
    thdp<span class="token operator">-&gt;</span>td_context<span class="token punctuation">.</span>ctx_nextrip <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint_t</span><span class="token punctuation">)</span>runadr<span class="token punctuation">;</span>
    <span class="token comment">//设置进程下一次运行的栈地址为arp</span>
    thdp<span class="token operator">-&gt;</span>td_context<span class="token punctuation">.</span>ctx_nextrsp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint_t</span><span class="token punctuation">)</span>arp<span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码没什么难点，就是第 7 行我要给你解释一下，arp 为什么要用内核栈顶地址减去 intstkregs_t 结构的大小呢？</p><p>C 语言处理结构体时，从结构体第一个字段到最后一个字段，这些字段的地址是从下向上（地址从低到高）伸长的，而栈正好相反，所以要减去 intstkregs_t 结构的大小，为 intstkregs_t 结构腾出空间，如下图所示。</p><img src="`+c+`" alt="img" style="zoom:15%;"><p>内核态进程结构</p><p>因为我们建立的是内核态进程，所以上面初始化的内核栈是不能返回到进程的应用程序空间的。而如果要返回到进程的应用程序空间中，内核栈中的内容是不同的，但是内核栈结构却一样。</p><p>下面我们动手写代码，初始化返回进程应用程序空间的内核栈。请注意，初始化的还是内核栈，只是内容不同，代码如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">krlthread_userstack_init</span><span class="token punctuation">(</span><span class="token class-name">thread_t</span> <span class="token operator">*</span>thdp<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>runadr<span class="token punctuation">,</span> <span class="token class-name">uint_t</span> cpuflags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">//处理栈顶16字节对齐</span>
    thdp<span class="token operator">-&gt;</span>td_krlstktop <span class="token operator">&amp;=</span> <span class="token punctuation">(</span><span class="token operator">~</span><span class="token number">0xf</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    thdp<span class="token operator">-&gt;</span>td_usrstktop <span class="token operator">&amp;=</span> <span class="token punctuation">(</span><span class="token operator">~</span><span class="token number">0xf</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//内核栈顶减去intstkregs_t结构的大小</span>
    <span class="token class-name">intstkregs_t</span> <span class="token operator">*</span>arp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">intstkregs_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>thdp<span class="token operator">-&gt;</span>td_krlstktop <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">intstkregs_t</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//把intstkregs_t结构的空间初始化为0</span>
    <span class="token function">hal_memset</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>arp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">intstkregs_t</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//rip寄存器的值设为程序运行首地址 </span>
    arp<span class="token operator">-&gt;</span>r_rip_old <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint_t</span><span class="token punctuation">)</span>runadr<span class="token punctuation">;</span>
    <span class="token comment">//cs寄存器的值设为应用程序代码段选择子 </span>
    arp<span class="token operator">-&gt;</span>r_cs_old <span class="token operator">=</span> U_CS_IDX<span class="token punctuation">;</span>
    arp<span class="token operator">-&gt;</span>r_rflgs <span class="token operator">=</span> cpuflags<span class="token punctuation">;</span>
    <span class="token comment">//返回进程应用程序空间的栈</span>
    arp<span class="token operator">-&gt;</span>r_rsp_old <span class="token operator">=</span> thdp<span class="token operator">-&gt;</span>td_usrstktop<span class="token punctuation">;</span>
    <span class="token comment">//其它段寄存器的值设为应用程序数据段选择子</span>
    arp<span class="token operator">-&gt;</span>r_ss_old <span class="token operator">=</span> U_DS_IDX<span class="token punctuation">;</span>
    arp<span class="token operator">-&gt;</span>r_ds <span class="token operator">=</span> U_DS_IDX<span class="token punctuation">;</span>
    arp<span class="token operator">-&gt;</span>r_es <span class="token operator">=</span> U_DS_IDX<span class="token punctuation">;</span>
    arp<span class="token operator">-&gt;</span>r_fs <span class="token operator">=</span> U_DS_IDX<span class="token punctuation">;</span>
    arp<span class="token operator">-&gt;</span>r_gs <span class="token operator">=</span> U_DS_IDX<span class="token punctuation">;</span>
    <span class="token comment">//设置进程下一次运行的地址为runadr</span>
    thdp<span class="token operator">-&gt;</span>td_context<span class="token punctuation">.</span>ctx_nextrip <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint_t</span><span class="token punctuation">)</span>runadr<span class="token punctuation">;</span>
    <span class="token comment">//设置进程下一次运行的栈地址为arp</span>
    thdp<span class="token operator">-&gt;</span>td_context<span class="token punctuation">.</span>ctx_nextrsp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint_t</span><span class="token punctuation">)</span>arp<span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中初始化进程的内核栈，所使用的段选择子指向的是应用程序的代码段和数据段，这个代码段和数据段它们特权级为 R3，CPU 正是根据这个代码段、数据段选择子来切换 CPU 工作特权级的。这样，CPU 的执行流就可以返回到进程的应用程序空间了。</p><h2 id="建立普通进程" tabindex="-1"><a class="header-anchor" href="#建立普通进程" aria-hidden="true">#</a> 建立普通进程</h2><p>在建立进程的接口函数 krlnew_thread 的流程中，会根据参数 flg 的值，选择调用不同的函数，来建立不同类型的进程。</p><p>前面我们已经写好了建立内核进程的函数，接下来我们还要写好建立普通进程的函数，如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token class-name">thread_t</span> <span class="token operator">*</span><span class="token function">krlnew_user_thread_core</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>filerun<span class="token punctuation">,</span> <span class="token class-name">uint_t</span> flg<span class="token punctuation">,</span> <span class="token class-name">uint_t</span> prilg<span class="token punctuation">,</span> <span class="token class-name">uint_t</span> prity<span class="token punctuation">,</span> <span class="token class-name">size_t</span> usrstksz<span class="token punctuation">,</span> <span class="token class-name">size_t</span> krlstksz<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">thread_t</span> <span class="token operator">*</span>ret_td <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token class-name">bool_t</span> acs <span class="token operator">=</span> FALSE<span class="token punctuation">;</span>
    <span class="token class-name">adr_t</span> usrstkadr <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> krlstkadr <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token comment">//分配应用程序栈空间</span>
    usrstkadr <span class="token operator">=</span> <span class="token function">krlnew</span><span class="token punctuation">(</span>usrstksz<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>usrstkadr <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//分配内核栈空间</span>
    krlstkadr <span class="token operator">=</span> <span class="token function">krlnew</span><span class="token punctuation">(</span>krlstksz<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>krlstkadr <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">krldelete</span><span class="token punctuation">(</span>usrstkadr<span class="token punctuation">,</span> usrstksz<span class="token punctuation">)</span> <span class="token operator">==</span> FALSE<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//建立thread_t结构体的实例变量</span>
    ret_td <span class="token operator">=</span> <span class="token function">krlnew_thread_dsc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//创建失败必须要释放之前的栈空间</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret_td <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        acs <span class="token operator">=</span> <span class="token function">krldelete</span><span class="token punctuation">(</span>usrstkadr<span class="token punctuation">,</span> usrstksz<span class="token punctuation">)</span><span class="token punctuation">;</span>
        acs <span class="token operator">=</span> <span class="token function">krldelete</span><span class="token punctuation">(</span>krlstkadr<span class="token punctuation">,</span> krlstksz<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>acs <span class="token operator">==</span> FALSE<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//设置进程权限 </span>
    ret_td<span class="token operator">-&gt;</span>td_privilege <span class="token operator">=</span> prilg<span class="token punctuation">;</span>
    <span class="token comment">//设置进程优先级</span>
    ret_td<span class="token operator">-&gt;</span>td_priority <span class="token operator">=</span> prity<span class="token punctuation">;</span>
    <span class="token comment">//设置进程的内核栈顶和内核栈开始地址</span>
    ret_td<span class="token operator">-&gt;</span>td_krlstktop <span class="token operator">=</span> krlstkadr <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token class-name">adr_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span>krlstksz <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ret_td<span class="token operator">-&gt;</span>td_krlstkstart <span class="token operator">=</span> krlstkadr<span class="token punctuation">;</span>
    <span class="token comment">//设置进程的应用程序栈顶和内核应用程序栈开始地址</span>
    ret_td<span class="token operator">-&gt;</span>td_usrstktop <span class="token operator">=</span> usrstkadr <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token class-name">adr_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span>usrstksz <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ret_td<span class="token operator">-&gt;</span>td_usrstkstart <span class="token operator">=</span> usrstkadr<span class="token punctuation">;</span>
    <span class="token comment">//初始化返回进程应用程序空间的内核栈</span>
    <span class="token function">krlthread_userstack_init</span><span class="token punctuation">(</span>ret_td<span class="token punctuation">,</span> filerun<span class="token punctuation">,</span> UMOD_EFLAGS<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//加入调度器系统</span>
    <span class="token function">krlschdclass_add_thread</span><span class="token punctuation">(</span>ret_td<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> ret_td<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>和建立内核进程相比，建立普通进程有两点不同。</p><ol><li>第一，<strong>多分配了一个应用程序栈</strong>。因为内核进程不会返回到进程的应用程序空间，所以不需要应用程序栈，<strong>而普通进程则需要</strong>；</li><li>第二，在最后调用的是 <strong>krlthread_userstack_init 函数</strong>，该函数初始化返回进程应用程序空间的内核栈，这在前面已经介绍过了。</li></ol><p>到此为止，我们建立进程的功能已经实现了。但是最后将进程加入到<mark>调度系统</mark>的函数，我们还没有写，这个函数是进程调度器模块的函数，我们下节课再讨论。</p><h2 id="重点回顾" tabindex="-1"><a class="header-anchor" href="#重点回顾" aria-hidden="true">#</a> 重点回顾</h2><p>这节课我们用最简洁的方式了解了进程以及如何建立一个进程，我来为你梳理一下今天的课程重点。</p><p>首先，我们在 Linux 系统上，用 ps 命令列出 Linux 系统上所有的进程，直观的感受了一下什么进程，从理论上了解了一下进程的结构。</p><p>然后我们把进程相关的信息，做了归纳整理，设计出一系列相应的数据结构，这其中包含了表示进程的数据结构，与进程相关内存地址空间结构，还有进程的机器上下文数据结构。这些数据结构综合起来就表示了进程。</p><p>最后进入建立进程的环节。有了进程相关的数据结构就可以写代码建立一个进程了，我们的建立进程的接口函数，既能建立普通进程又能建立内核进程，而建立进程的过程无非是创建进程结构体、分配进程的内核栈与应用程序栈，并对进程的内核栈进行初始化，最后将进程加入调度系统，以便后面将进程投入运行。</p><img src="`+l+'" alt="img" style="zoom:15%;"><p>进程建立流程图</p><p>很多理论书籍总是在开头就花大量篇幅讲进程，但你却很难搞懂，这是为什么呢？第一，他们在用抽象方法讲解抽象概念，对初学者很不友好；第二，讲解顺序不对，想搞懂进程，需要前置知识，它是一个高层次的组件。</p><p>相信经过前面章节的学习，你现在理解进程会轻松自如。</p><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题" aria-hidden="true">#</a> 思考题</h2><p>请问，各个进程是如何共享同一份内核代码和数据的？</p><p>欢迎你在留言区和我交流，相信通过积极参与，你将更好地理解这节课的内容。也欢迎你把这节课分享给你的朋友，说不定可以帮他真正弄懂什么是进程。</p><p>好，我是 LMOS，我们下节课见！</p>',114),u=[r];function k(d,m){return s(),a("div",null,u)}const b=n(i,[["render",k],["__file","I24-进程活动的描述.html.vue"]]);export{b as default};
