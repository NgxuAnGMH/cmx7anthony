import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o as c,c as d,a,b as e,e as o,d as p}from"./app-cdabc73c.js";const s="/assets/8d1410fcc68ede106a609afabea1170e-ee93d456.png",l="/assets/d37841d17dc6672cb124e6218935472c-6ebcec35.jpg",n="/assets/faab4196dbca450563405265d84a7844-a7aae67d.jpg",m="/assets/035055e71e7a470a1d18893348663f56-78a2c0aa.jpg",h="/assets/093a57b413007743380e135285706676-bd84fae7.jpg",u="/assets/d076cb9f6309cbd67e95445feac7d8b2-e585fdff.jpg",g="/assets/6de0d99911dbf463ff5aafca637abff1-17d91235.jpg",k={},f=p('<h1 id="加餐02-学习攻略-一-大数据-云计算-究竟怎么学" tabindex="-1"><a class="header-anchor" href="#加餐02-学习攻略-一-大数据-云计算-究竟怎么学" aria-hidden="true">#</a> 加餐02 | 学习攻略（一）：大数据&amp;云计算，究竟怎么学？</h1><p>你好，我是 LMOS。</p><p>上节课，我带你了解了云计算中 IAAS 层的技术。结合云计算的分层架构，下面一层就是 PaaS，PaaS 与 IaaS 相似，区别在于云服务提供商还提供了操作系统和数据库。</p><p>这节课，我们就一起了解一下云计算 PaaS 层的<em>大数据体系</em>吧。什么是大数据呢？其实这是早在 1980 年出版的图书《第三次浪潮》里就预见到的一种场景，而具体到工程落地层面，就不得不提到 Google 的“三驾马车”。</p><p>今天这节课，我想从需求角度，和你讨论一下在工程上为什么要这样设计。</p><h2 id="gfs-的核心问题" tabindex="-1"><a class="header-anchor" href="#gfs-的核心问题" aria-hidden="true">#</a> GFS 的核心问题</h2><p>我们先从谷歌文件系统 GFS 开始说起。</p><p>顾名思义，这个系统是用来储存文件的。你可能觉得，存文件听起来好像不难呀？</p><p>我们可以仔细思考一下，存文件会有什么难度呢？先让我们停下手头的工作，看看自己电脑上的硬盘空间还有多大，500G 还是 1TB、5TB？</p><p>没错，<strong>空间容量</strong>就是我们遇到的第一个门槛，单台电脑的存储空间确实不是无限大的。</p><p>接下来，我们找出一份大一点的文件，把它复制到另一个目录，看看复制速度如何？这里就碰到了第二个问题——<strong>文件写入速度</strong>。一般来说，<mark>机械盘硬盘</mark>的最高写入速度是 200MB/s 左右，而<mark>固态硬盘</mark>的写入速度是 3000MB/s 左右。</p><p>试想一下，如果我们有 1TB 的数据写入硬盘（就算真的有一块 1TB 空间的固态硬盘可以使用）那我们也至少需要 4 天时间，数据才能完全写入完毕。</p><p>还有一个生活中常见的问题，你遇到过电脑故障、死机或者硬盘坏掉的情况么？是的，在普通 PC 机器运行的过程中，故障其实是常态。你平常用家里的网络打网游时遇到过丢包、掉线、卡顿之类的情况么？没错，<strong>网络故障</strong>确实也是我们要考虑的问题。</p><p>那么到底怎样才能设计一套文件系统，同时满足以下条件呢：</p><ol><li><p><em>容量“无限”大；</em></p></li><li><p><em>对大容量的数据读写性能高；</em></p></li><li><p><em>遇到软硬件问题时，系统可靠性也很高。</em></p></li></ol><p>这里就要用到问题切分和并行化的思想了，这些我们在第四十节课也讲过。</p><p>比如想要解决文件比较大的问题，就我们可以考虑把它切分成很多份。切分完了之后，我们还得想到鸡蛋（文件）放在一个篮子里，遇到故障“全军覆没”的风险。为此，咱们就得多搞几台机器，多存几份呗。</p><p>还担心存的比较慢？那我们就把多个文件并行存储到不同的硬盘上，这样就不会受到磁盘写入速度的限制了。</p><p>说到这里，你现在是不是已经跃跃欲试，想要开始实现一套分布式文件系统啦？别着急，让我们先把刚刚讨论到的设计思路梳理一下：</p><ul><li><p>首先，为了不给使用者应用程序增加太多负担，我们还是希望用户能像以前单机读写文件一样通过简单的 API 就能完成文件读写。这时候，我们就需要抽象出<u>一套统一的客户端 client，提供给用户使用</u>。</p></li><li><p>其次，<u>是切分成很多份文件。GFS 会把每一份文件叫做一个 chunk</u>，这个 chunk 大小的默认值是 64MB，这比操作系统上的文件系统要大一些，这么做为了减少 GFS client 和 GFS master 的交互次数、提升文件读取性能。同时，为了保障可靠性，GFS 还会为每个 chunk 保留三个副本。</p></li><li><p>但是这里还有个问题没解决，文件都切成很多份存到很多机器上了，我们怎么知道哪一个 chunk 存到哪里去了呢？这时候，我们就需要把<u>这种 chunk 分片文件映射到存储位置、原始文件名、权限之类的关联</u>关系抽象出来，我们把这类用来找数据的数据叫做<strong>元数据信息</strong>。</p></li></ul><p>那么元数据存在哪里好一点？</p>',21),_={href:"https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/gfs-sosp2003.pdf",target:"_blank",rel:"noopener noreferrer"},b=p('<figure><img src="'+s+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>GFS架构图</p><h2 id="mapreduce-的分分合合" tabindex="-1"><a class="header-anchor" href="#mapreduce-的分分合合" aria-hidden="true">#</a> MapReduce 的分分合合</h2><p>接下来，我们再说说 MapReduce。</p><p>我们首先要搞清楚 MapReduce 是什么，当看到 MapReduce 时，你可能感觉它是一个概念，但其实不然，MapReduce 应该是 Map、Reduce，是两个概念，即<mark>映射</mark>和<mark>归约</mark>。</p><p>用软件实现这两个概念，就会形成 Map、Reduce 两个操作，落实到代码中可能是两个<mark>接口函数</mark>、或者<mark>库</mark>，又或者是<mark>进程</mark>。我们可以把这些东西，<em>理解成一套编程模型</em>。</p><h3 id="_1-map" tabindex="-1"><a class="header-anchor" href="#_1-map" aria-hidden="true">#</a> 1 Map</h3><p>那么什么是 Map 呢？Map 字面意思为映射，但本质是拆分。</p><p>接下来，我们以汽车为例，看一下我们把一辆完好的汽车执行 Map 操作之后的状态，如下图所示：</p><figure><img src="'+l+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>从上图可以看出，执行 map 操作时，汽车首先作为输入，然后标记出汽车的各种零部件，最后汽车被拆分成各种零件。</p><p>现在。让我们切换一下视角，把这辆汽车转换成用户的大规模数据，于是就变成了对一个大数据进行标记，然后拆分成许多小数据的过程，这就是 MapReduce 中的 Map 操作。</p><h3 id="_2-reduce" tabindex="-1"><a class="header-anchor" href="#_2-reduce" aria-hidden="true">#</a> 2 Reduce</h3><p>什么又是 Reduce 呢？Reduce 的字面意思为归约，是 Map 操作是逆向操作，其本质是合并。同样地，我们以汽车为例，看看一辆被 Map 操作的汽车，在 Reduce 的操作下，会变成什么样子。如下图所示：</p><figure><img src="'+n+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>我们可以看到，执行 Reduce 操作时，是之前把 Map 汽车产生的各个零件作为输入，然后进行各种零部件的组装，最后合并生成汽车，或者是更高级的类汽车产品。</p><p>同样地，把这辆汽车各种零部件换成用户 Map 后的各种小数据，就相当于合并许多个小数据，然后生成原来的大数据或者对数据进行更高级的处理，这就是 MapReduce 中 Reduce 操作的作用。</p><h3 id="_3-六大步骤" tabindex="-1"><a class="header-anchor" href="#_3-六大步骤" aria-hidden="true">#</a> 3 六大步骤</h3><p>我们刚刚把一台车子进行了一大波 MapReduce 操作，这台车子就变成了变形金刚了，哈哈。 举个例子，理解了 MapReduce 的原理之后，我们再来看一下它的六大步骤。</p><p>如果你是家大型汽车生产厂家， 你拥有许多不同类型的汽车设计方案（<code>Input</code>），还拥有许多汽车零件供应商，不同的汽车零件供应商会主动挑选不同的汽车零件（<code>Split</code>），挑选好之后你就把汽车生产方案进行拆解（<code>Map</code>）。</p><p>之后，再把不同的零件下发到不同供应商的生产车间生产（<code>Shuffle</code>），最后要能根据不同的顾客需求，取用不同的零件拼装成最终的汽车，这就是 <code>Reduce</code>。拼装好汽车之后，会放到售卖部那边等待客户取货（<code>Ticket</code>），这个过程是 <code>Finalize</code>。</p><p>所以 MapReduce 是六大过程，简单来说，就是 <strong>Input、Split、Map、Shuffle、Reduce 和 Finalize</strong>。那么这六大步骤又是怎样被一套框架管理起来的呢？答案其实还是老大（Master）带着小弟（Worker）干活。</p><p>下面，我们结合 MapReduce 的架构图，分析一下它的工作原理。</p><figure><img src="'+m+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>我们的用户程序要想使用 MapReduce，必须要链接 MapReduce 库。有了 MapReduce 库就可以进行 Map、Reduce 操作了。</p><p>用户程序运行后先声明数据有多少，然后需要将它们拆分成一些 Mapper 和 Reducer 来执行。假如把数据分成 n 份，那就要找 n 个 Mapper 来处理。这时会产生许多 Worker，这些 Worker 有的是执行 Map 操作的，有的 Worker 是执行 Reduce 操作的。</p><p>最重要的是还会产生一个 <strong>Master Worker</strong>，它与其他 Worker 的等级是相同的，它会调度其它 Worker 运行，<em>并作为<u>用户的代理</u>来协调整个过程，让用户可以做其他事情</em>。</p><p>Master Worker 会让一个 Worker 去处理 0 号数据，另一个 Worker 负责处理 1 号数据等等，这就是分配数据的过程。每个 Worker 都会在本地处理数据，并把结果写入缓存或硬盘。当执行 Map 操作的 Worker 完成任务后，Master Worker 会让执行 Reduce 操作的 Worker 去获取数据。</p><p>他们会从各个 Worker 那里获取需要的数据，并在本地完成 Reduce 操作，最后将结果写入最终的文件中，这就是 Finalize。这个过程其实就是前面说过的六个步骤。</p><h2 id="bigtable" tabindex="-1"><a class="header-anchor" href="#bigtable" aria-hidden="true">#</a> BigTable</h2><p>最后一驾马车就是 BigTable。在说它之前，我们先聊聊表。</p><p>请和我一起思考一下，什么是表呢？为了更好理解，我们可以抄出 Excel 这个神器，来仔细认识一下表的基本构成：</p><img src="'+h+'" alt="img" style="zoom:25%;"><p>不难发现，表是由一个又一个的格子构成的，而每一个格子里的内容，又能通过行和列的坐标定位到。</p><p>这时候我们不妨联想一下，是不是我们只需要存储足够多的格子，就可以存储各种各样的表啦。那么光有行、列和格子里内容就足够了么？</p><p>并非如此，别忘了格子里的内容还有可能会修改。比如上图中的 B1 单元格里的 Linux 版本需要从 1.0.5 更新到 1.0.6，因此还需要记录格子的时间。</p><h3 id="_1-key-value" tabindex="-1"><a class="header-anchor" href="#_1-key-value" aria-hidden="true">#</a> 1 key-value</h3><p>没错，BigTable 其实也是这样的思路，<mark>BigTable</mark> 把每个格子的数据都抽象成了 <mark>Key Value 的键值对</mark>的格式。其中，<mark>key</mark> 是由<em>行</em>（row:string）、<em>列</em>（column:string）、<em>时间戳</em>（time:int64）这三部分构成的，而 <mark>Value</mark> 则是用 <em>string</em> 来存储的。</p><h3 id="_2-需要支持的特殊功能" tabindex="-1"><a class="header-anchor" href="#_2-需要支持的特殊功能" aria-hidden="true">#</a> 2 需要支持的特殊功能</h3><p>这样的 Key Value 数据结构有没有让你联想到什么？其实它就类似于我们数据结构中常用的 <mark>HashMap</mark>。但这个 HashMap 有点特殊，因为它还要支持后面这几种功能：</p><ol><li><p>给定几个 key，能够快速返回小于或者等于某个 key 的那个数据。</p></li><li><p>给定 key1 和 key2，可以返回 key3 值中最高的数据。</p></li><li><p>key 也可以只给前缀格式 prefix，返回所有符合前缀的值。</p></li><li><p>这个“HashMap”在读、写性能上，都要相对比较好。</p></li><li><p>这个“HashMap”要能持久化，因为数据不能丢。</p></li></ol><h3 id="_3-采取的具体数据结构" tabindex="-1"><a class="header-anchor" href="#_3-采取的具体数据结构" aria-hidden="true">#</a> 3 采取的具体数据结构</h3><p>有了上述功能的约束，你是不是感觉一时半会儿还真没想出来，要怎么设计这个数据结构？</p><p>其实 Google 已经把这个数据结构设计好了，这个数据结构叫做 <mark>SSTable</mark>，具体实现确实有些复杂，但好在有官方开源的单机实现——<mark>LevelDB</mark>。后面还有基于 LevelDB 演进升级的 <mark>RocksDB</mark>，也是一个不错的项目，感兴趣的话可以自行了解。</p><p>现在，我们有了把表化简成小格子，再把每个格子使用 Key Value 结构存储到了单机的“HashMap”数据结构上。接下来，我们还得想清楚，如何让单机的“HashMap”数据结构变成可以分布式运算的。</p><p>这时候，我们就可以把前面这个思路做进一步抽象，你可以结合后面的示意图看一下，具体是抽象成了三层：</p><img src="'+u+'" alt="img" style="zoom:33%;"><ol><li><p>首先，对于每个表，我们都需要保存这个表的元数据。（<em>Metadata of Table</em>）</p></li><li><p>其次如果随着数据增长，表变得比较大了，我们需要具备自动切分这张表的能力。切分表的最小单位我们叫做 Tablet，也就是说，<strong>一张表会对应一个或多个 Tablet</strong>。</p></li><li><p>具体到每一个 Tablet，我们是基于一个或多个单机的“HashMap”数据结构，也就是 <u>SSTable</u> 来实现的；</p></li><li><p>而每一个 SSTable 中存储的，又是一堆用 <mark>Key Value</mark> 格式表示的<mark>单元格</mark>。</p></li></ol><p>对应到服务上，我们又可以套用前面讲的老大带小弟干活（主从架构）的思路，把一个或者多个 Tablet 交给 Tablet Server 这一类小弟（服务）来干活儿。而老大（Master）主要负责为 Tablet 服务器分配 Tablets、检测新加入的或者过期失效的 Tablet 服务器、对 Tablet 服务器进行负载均衡、对保存在 GFS 上的文件做垃圾收集、处理和模式相关的修改操作（比如建立表和列族）。</p><p>理清了思路，你再来看看后面这张架构图，是不是就很容易理解了呢？</p><figure><img src="'+g+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2><p>今天，我们主要了解了现代云计算 PAAS 层中，大数据体系的由来。其中最核心的就是谷歌的三驾马车，即谷歌文件系统 GFS、面向大型集群的简化数据处理 MapReduce、BigtTable 结构化数据的分布式存储系统。</p><p>GFS（Google 文件系统）是一种分布式文件系统，它为 Google 的大型数据处理应用提供了数据存储和访问功能；MapReduce 是一种编程模型，它允许开发人员更方便地处理大量数据；而 BigTable 是一种高性能的分布式存储系统，它可以处理海量的结构化数据。</p><p>如果学过今天内容，你还觉得意犹未尽，想要更深入地学习这三种技术，建议阅读谷歌相关的论文和文档，并尝试去做一下 <code>mit 6.824 分布式系统课程</code> 提供的课后练习。</p><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题" aria-hidden="true">#</a> 思考题</h2><p>推荐你在课后能搜索 GFS、MapReduce、BigTable 这三篇原始论文阅读一下，结合今天学到的设计过程的思路，进一步思考这么设计的优点和缺点分别是什么，还有什么改进空间？</p><p>欢迎你在评论区和我交流讨论，如果觉得这节课内容还不错，也可以转发给你的朋友，一起学习进步。</p>',58);function M(R,S){const r=t("ExternalLinkIcon");return c(),d("div",null,[f,a("p",null,[e("聪明的你可能已经想到了，我们可以给这些服务器分一下类，让老大 master 带着小弟 chunkserver 来干活儿，元数据比较重要，所以咱们就交给老大来保管。有了这些思路，相信你再看 "),a("a",_,[e("GFS 论文"),o(r)]),e("中的架构图时，就会感觉清晰很多。")]),b])}const y=i(k,[["render",M],["__file","Q48-大数据基础（一）.html.vue"]]);export{y as default};
