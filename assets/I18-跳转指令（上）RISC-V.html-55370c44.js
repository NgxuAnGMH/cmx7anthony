import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{r as s,o as l,c as r,a,b as i,e as d,d as t}from"./app-cdabc73c.js";const p="/assets/51b1c0668bc479c53d7c382e27b5b27b-fc5f5cfa.jpg",c="/assets/d9d8d6e9af31bfab42b1373e0ef4d8eb-98acc8b1.jpg",m="/assets/0307336c210c4e3dayyc806b7b7e3048-9485155a.jpg",o="/assets/62acdb4fb770706a6cd00aacb7b10fb0-b12e3372.jpg",u="/assets/9052204ac3659c792d2839f578333684-f464800c.jpg",g="/assets/815d11b5e132d81394972f56faf873b2-5bb41be7.jpg",b="/assets/662e31d923a22760226deac72f00fbac-03f9a387.jpg",v="/assets/cefedce2892f208a06b5yy1b07b85a8c-f9c8a7f2.jpg",j="/assets/51b0de8f80708709d25dfa463ae9d310-1b3c575c.jpg",f="/assets/9cd3052dd467580b88fa996d71d4c4fd-68a73c54.jpg",_="/assets/f9cd469ec5ed0bf565e43c1b2de015eb-2f03669a.jpg",x={},h=a("h1",{id:"_18-risc-v指令精讲-三-跳转指令实现与调试",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#_18-risc-v指令精讲-三-跳转指令实现与调试","aria-hidden":"true"},"#"),i(" 18｜RISC-V指令精讲（三）：跳转指令实现与调试")],-1),k=a("p",null,"你好，我是 LMOS。",-1),C=a("p",null,"在第五节课，我们曾经提到 RV32I 有两种跳转指令，即无条件跳转指令和有条件的跳转指令。",-1),P=a("p",null,"不过，前面我们只是简单了解了跳转指令长什么样，并没有深入讲解。接下来的两节课，我们就好好研究一下跳转指令的原理，挨个指令做调试。",-1),y={href:"https://gitee.com/lmos/Geek-time-computer-foundation/tree/master/lesson18~19",target:"_blank",rel:"noopener noreferrer"},S=t(`<h2 id="为什么要有跳转指令" tabindex="-1"><a class="header-anchor" href="#为什么要有跳转指令" aria-hidden="true">#</a> 为什么要有跳转指令</h2><p>我们不妨回忆一下：C 语言中 if、for、goto 等流程控制语句都是如何实现的？还有 C 语言的函数是如何调用和返回的？</p><p>通过前面的学习，我们了解到 CPU 执行指令是由 PC 寄存器指向的。每次执行完指令，CPU 的 PC 寄存器就会自动增加一条指令大小的数值，使之指向下一条指令，如此循环，这就导致 CPU 只能在 PC 寄存器的引导下顺序地执行指令，而 C 语言函数就是一条条指令组成的。显然，只靠这样的机制，C 语言无法实现流程控制和函数的调用与返回。</p><p>如果现在有一种机制，它能够修改 CPU 里 PC 寄存器的值，或者根据特定的条件来修改 CPU 的 PC 寄存器的值，让 PC 寄存器能指向特定的内存地址，读取里面的指令并运行。这样，上述问题就会迎刃而解了。</p><p>让我用一段 C 语言代码为例，给你分解一下这个原理，如下所示：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        sum<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中，for 函数包含了条件流程控制和循环流程控制。在编译过程中，C 语言编译器会将它拆分为三段，伪代码如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>add:
    int sum = 0;
    int i = 0;
label1:
    i &lt; 100 = false goto lable2
    sum++;
    i++;
    goto label1
lable2:
    return sum;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上伪代码中的 goto 用来修改 CPU 的 PC 寄存器的值，使之指向 lable1 或者 lable2，这样 CPU 才能执行不同的代码段，从而实现流程控制。<strong>这里的 goto 语句就对应着后面要讲的跳转指令。</strong></p><p>说到这里，如果你能再次想起图灵机的读头在那条无限的纸带上跳来跳去的情景，就说明你已经深刻理解了代码的执行原理。</p><figure><img src="`+p+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="risc-v-的跳转指令格式" tabindex="-1"><a class="header-anchor" href="#risc-v-的跳转指令格式" aria-hidden="true">#</a> RISC-V 的跳转指令格式</h2><p>前面我们说了，CPU 必须依赖某个机制修改 PC 寄存器的值，让程序能够跳转执行，达到程序流程控制的目的。</p><p>这个机制离不开 CPU 提供的跳转指令，只要执行跳转指令就能修改 PC 寄存器了。在研究无条件跳转指令之前，我们先来看看 RISC-V 的跳转指令格式，它对应的汇编语句格式如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>指令助记符 目标寄存器，源操作数1，源操作数2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>对于无条件跳转指令来说，<strong>指令助记符可以是 jal 和 jalr，目标寄存器可以是任何通用寄存器，而源操作数 1 可以是任何通用寄存器，源操作数 2 可以是任何通用寄存器和立即数。</strong></p><p>为什么是目标寄存器而不是 PC 寄存器呢？继续往下看，我会带你找到答案。</p><h2 id="无条件跳转指令-jal-指令" tabindex="-1"><a class="header-anchor" href="#无条件跳转指令-jal-指令" aria-hidden="true">#</a> 无条件跳转指令：jal 指令</h2><p>我们先来看看 jal 指令，这是一条无条件的跳转并链接的指令。它的汇编代码书写形式如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>jal rd，imm
#jal 无条件的跳转并链接的指令
#rd 目标寄存器
#imm 立即数
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中，rd 可以是任何通用寄存器。立即数 imm 为 20 位二进制数据。有的文档里会把 imm 称为偏移，为了课程前后文的一致性，我们继续沿用立即数的叫法。</p><p>jal 完成的操作用伪代码描述如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>rd = pc + 4；
pc = pc + 符号扩展（imm &lt;&lt; 1）
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>对照代码不难发现，jal 指令首先把 pc+4，即下一条指令地址送给了 rd，然后把 PC 寄存器中的 32 位无符号数据加上 imm&lt;&lt;1，并且进行<strong>符号位扩展</strong>（因为指令总是 2 或者 4 字节地址对齐的，所以最低位永远为 0），再送给 PC 寄存器。这样就实现了程序的跳转。</p><p>接下来，我们一起写代码验证一下。</p><p>为了方便调试，我们的代码组织结构是这样的：写一个 main.c 文件，在里面写上 main 函数，因为这是链接器所需要的。然后我们需要再写一个 jal.S 文件，用汇编在里面写上 jal_ins 函数。</p><p>类似的操作前面两节课反复试验过，就不过多重复了。代码如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>.text
.global jal_ins
jal_ins:
    jal a0，imm_l1              #a0=add x0，x0，x0的地址，跳转到imm_l1地址处开始运行
    add x0，x0，x0              #相当于nop，什么也不做
    add x0，x0，x0
imm_l1:
    jal a0，imm_l2              #a0=imm_l2的地址，跳转到imm_l2地址处开始运行
imm_l2:
    jr ra                       #函数返回
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我已经把 jal_ins 函数为你写好了。第一条指令跳转到 imm_l1 地址处开始运行，a0 寄存器保存下一条指令的地址，即 add x0，x0，x0 的地址。</p><p>这条指令没什么实际的实现，x0 是个只读寄存器，始终返回 0。imm_l1 地址处又是一条跳转指令，跳转到 jr ra 指令地址，即 imm_l2 处开始运行。a0 等于 imm_l2 的地址，也会作为函数的返回值返回。</p><p>你可以用 VSCode 打开工程目录，按下“F5”键调试一下。首先，我们把断点停在 jal a0，imm_l1 指令处，效果如下所示：</p><figure><img src="`+c+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>上图中的状态是执行 jal a0，imm_l1 指令之前，pc 寄存器指向 0x10174 地址，这个地址对应的正是这条 jal a0， imm_l1 指令。</p><p>我们一旦单步调试，程序代码就会跳到 jal a0，imm_l2 指令处，pc + 12 等于 0x10180，a0 等于 0x10178，状态如下所示：</p><figure><img src="'+m+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>果不其然，a0 等于 0x10178，而 pc 等于 0x10180，正是 jal a0，imm_l2 指令。</p><p>我们继续做单步调试，程序代码会跳到 jr ra 指令处，pc + 4 等于 0x10184，a0 也会等于 0x10184，存放 jr ra 指令的地址，而 a0 作为函数的返回值进行返回，也就是 jal_ins 函数最后一条指令的地址。</p><p>我们再次进行单步调试，程序将会回到 main 函数中，并打印出返回值，如下所示：</p><figure><img src="'+o+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>可以看到，上图中输出的结果确实是符合预期的，这说明 jal 指令的功能确实跟我们前面描述的一致，能够无条件跳转并链接。</p><h2 id="无条件跳转指令-jalr-指令" tabindex="-1"><a class="header-anchor" href="#无条件跳转指令-jalr-指令" aria-hidden="true">#</a> 无条件跳转指令：jalr 指令</h2><p>让我们加把劲！在 jal.S 文件中再写一个函数——jalr_ins 函数。在这个函数中，我们用 jalr 指令实现函数调用，具体就是给 jalr_ins 函数传递一个函数指针，通过这个函数指针调用这个函数。</p><p>写代码之前，我们先来了解一下 jalr 指令，它同样是一条无条件的跳转并链接的指令。jalr 指令与 jal 指令字面上的不同点，无非就是多了一个字母“r”，这个“r”表示寄存器，相当于 jal 指令的寄存器版本，能够通过寄存器传递跳转地址。</p><p>jalr 的汇编代码书写形式如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>jalr rd，rs1，imm
#jalr 无条件的跳转并链接的指令
#rd 目标寄存器
#rs 源寄存器1
#imm 立即数
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中 rd、rs1 可以是任何通用寄存器，立即数 imm 为 12 位二进制数据。jalr 完成的操作用伪代码描述如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>rd = pc + 4；
pc = (rs1 + 符号扩展(imm &lt;&lt; 1)) &amp; 0xfffffffe
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>对比之后我们不难发现，以上代码中和 jal 相同的地方是，开始第一步由 jalr 指令把 pc+4，即下一条指令地址送给 rd。</p><p>而不同之处是，jalr 指令的下一步操作<strong>会让 rs1 中的 32 位无符号数据加上 imm&lt;&lt;1，并且进行符号位扩展后与上 0xfffffffe</strong>，这也是为了指令要以 2 字节或者 4 字节地址对齐，所以最低位必须为 0，形成一个地址值。完成以上过程后，这个地址值会送给 pc，从而实现程序的跳转。</p><p>下面我们一起写代码验证一下。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>.global jalr_ins
jalr_ins:
    addi sp，sp，-16            #在栈中分配16字节的空间
    sw  ra，0(sp)               #保存ra寄存器到栈中
    jalr ra，a0，0              #ra = lw ra，0(sp)指令的地址，跳转到a0+0的地址处开始运行
    lw ra，0(sp)                #从栈中恢复ra寄存器
    addi sp，sp，16             #回收栈中分配的16字节的空间
    jr ra                       #函数返回
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码 3~4 行和 6~7 行代码的作用是，在栈中分配和回收内存空间的指令，用于保存和恢复 ra 寄存器的内容。</p><p>因为在第 5 行代码中，跳转别的代码中运行，正是用 ra 寄存器来保存地址的，然而在跳转到 jalr_ins 函数处运行的时候，同样是使用 ra 寄存器保存返回地址的，如果不保存和恢复 ra 寄存器，jalr_ins 函数将无法返回。</p><p>现在我们调试一下，如下所示：</p><figure><img src="`+u+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>上图中是执行 jalr ra，a0，0 指令之前的状态，a0 寄存器中的值是 0x101a0，这正是 testjalr 函数的地址。这条指令能完成类似函数调用的功能，我们一旦单步调试，程序就会跳到 testjalr 函数内部开始运行，状态如下所示：</p><figure><img src="'+g+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>由上图可知，jalr_ins 函数确实调用了 testjalr 函数，也打印出了 testjalr 的地址。下一步将要执行 testjalr 函数的返回语句，会返回 jalr_ins 函数的地址。</p><p>我们继续做单步调试，看看能不能返回到 jalr_ins 函数中，如下所示：</p><figure><img src="'+b+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>调试结果验证了确实如此，代码流程再次回到了 jalr_ins 函数中。在 jalr_ins 函数中，我们恢复了之前的 ra 寄存器，a0 寄存器中保存着 testjalr 函数的返回值，即 jalr_ins 函数的地址。</p><p>继续单步调试，代码流程就会回到 main 函数。</p><figure><img src="'+v+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>如上图所示，main 函数中继续打印出了 jalr_ins 函数的地址，这个结果是正确的，代码流程也符合预期。</p><p>通过调试，我们已经了解了 jal、jalr 指令的功能细节。</p><p>下面，我们来看看 jal_ins 函数和 jalr_ins 函数的二进制数据。其实我们调试 bug 或者做逆向工程，很多时候都需要研究机器码，正好借这次研究指令的机会，我们一起练习一下怎么分析。</p><p>我们打开终端，切换到工程目录下，输入命令：riscv64-unknown-elf-objdump -d ./main.elf &gt; ./main.ins，就会得到 main.elf 的反汇编数据文件 main.ins。打开这个文件，就会看到 jal_ins 函数和 jalr_ins 函数的二进制数据，我的操作截图如下所示：</p><figure><img src="'+j+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>上图中的反汇编代码中使用了一些伪指令，比如 ret 的机器码是 0x00008067，它就是 jr ra，但是 jr ra 也是伪指令，实际的指令是 jalr x0，ra，0 指令，伪指令是为了方便汇编编程人员才使用的。</p><p>我们再来说说上图中的机器码，0x0040056f 为 jal a0，imm_l2（0x10184），0x000500e7 为 jalr ra，a0，0，图里的 jalr a0 就是 jalr ra，a0，0 。</p><p>我们继续拆分 jal 指令和 jalr 指令的各位段的数据，看看它们具体是如何编码的。你不妨结合后面的示意图来理解：</p><figure><img src="'+f+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>jal 指令与 jalr 指令是靠操作码区分的。jal 指令的立即数部分编码非常乱，这部分跟芯片设计有关，就不深入讨论了，其数据正常组合起来是 0b00000000000000000010，这个二进制数据左移 1 位等于十六进制数据 0x4。为什么是这样呢？</p><p>回到前面看看 jal 指令的操作，你就明白了：<strong>pc+4 正好是 imm_l2 的地址即 0x10184，而 jalr 指令编码非常简单，12 位立即数为 0，源寄存器是 a0，目标寄存器是 ra，x1 寄存器的编码就是 1。</strong></p><p>到这里，jal 指令与 jalr 指令我们就讲完了。它们都是无条件跳转指令，并且都可以保存跳转指令的下一条指令的地址，用于返回。但 jal 指令与 jalr 指令跳转的地址大小范围有差别，这主要取决于它们地址数据的编码形式和计算方式。jal 指令是用当前 pc 值加上 20 位立即数，jalr 指令是通用寄存器加上 11 位立即数。</p><h2 id="重点回顾" tabindex="-1"><a class="header-anchor" href="#重点回顾" aria-hidden="true">#</a> 重点回顾</h2><p>说到这里，这节课的内容就告一段落了，我来给你做个总结。</p><p>因为不管什么程序都不能永无止境地顺序运行下去，所以需要控制程序流程，对数据进行比较判断，根据结果执行相应的动作。这就需要程序能够跳转，所以，一套指令集里就必须要有跳转指令来支持。</p><p>跳转指令又分成有条件跳转指令和无条件跳转指令。我们按照先易后难的顺序，这节课重点研究了无条件的跳转指令，一共是两条指令，即 jal 指令和 jalr 指令。它们在跳转的同时还能保存下一条指令的地址，这类指令常用来实现高级语言（如 C 语言）里的函数调用。</p><p>这节课的要点我给你准备了导图，你可以做个参考。调试验证环节，我建议你自己课后动手多多练习，加深印象。</p><figure><img src="'+_+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>下节课我们继续研究有条件跳转指令，敬请期待。</p><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题" aria-hidden="true">#</a> 思考题</h2><p>既然已经有 jal 指令了，为什么还需要 jalr 指令呢？</p><p>期待你在留言区记录收获或疑问，认真思考和主动练习都能让你加深印象。如果感觉这节课还不错，也推荐你把这节课分享给更多朋友。</p><blockquote><p>jal指令只能跳转基于pc寄存器的地址，即pc+x<br> 而jalr可以跳转到自定义寄存器的地址，更加灵活<br> 作者回复: 嘿嘿 是的</p><hr><p>jalr多了一个源寄存器，既可以与jal交换使用组成类似偏移地址加基地址进行分页跳转（模仿x86，可4kb一个分页），还有一个重要功能就是，jalr的立即数可变为jal的操作码加目标寄存器（实现jalr-jal），jal的立即数可变为jalr的操作码加目标寄存器加功能加源寄存器！<br> 这样设计的好处方便cpu自动化，提升效率（流水线不停转，交替使用减少去内存取指令浪费的时间，方便一次性执行完一个细分项目，如线程）<br> 作者回复: 对啊 你思考的很深入</p><hr><p>为什么在我的main.c文件中能设置断点，而在jal.S 中却不能设置断点，需要在vscode中安装什么插件吗？<br> 作者回复: 需要符号 jal.S 中 你设置在标号处就行了</p><hr><p>老师，请教下， “我们一旦单步调试，程序代码就会跳到 jal a0，imm_l2 指令处，pc + 12 等于 0x10180，a0 等于 0x10178，” 这一句中的12是怎么计算的，跟前面说的符号扩展怎么对应的，这一点没搞明白， （ “pc = pc + 符号扩展（imm &lt;&lt; 1）”） 这里的imm是什么，左移了一位，是imm左移一位变成了12吗，我是硬看的汇编代码中间隔了3条指令要偏移12<br> 作者回复: 链接器根据 指令大小 计算的</p><hr><p>课后思考题：<br> jal的立即数只有20位，加上2字节对齐。只能寻址当前指令前后大约1MB的地址空间。<br> 故而有jalr指令存在的必要。（不知道对不对😂）<br> 作者回复: 对的</p></blockquote>',86);function z(V,I){const e=s("ExternalLinkIcon");return l(),r("div",null,[h,k,C,P,a("p",null,[i("这节课我们从源头说起，弄明白为什么需要有跳转指令存在，然后再熟悉一下无条件跳转指令。至于有条件跳转指令，我们放在下节课继续学习。这节课代码，"),a("a",y,[i("你可以从这里下载"),d(e)]),i("。")]),S])}const R=n(x,[["render",z],["__file","I18-跳转指令（上）RISC-V.html.vue"]]);export{R as default};
