import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as o,d}from"./app-cdabc73c.js";const r="/assets/49f3a9b1ae2972ac5c6cfca7731bf12d-f94ceab6.jpeg",c="/assets/37ba6c453e530660cecbbfcf56a3ecef-2ed94f06.jpeg",i="/assets/153f8d5e4a4363399133e1d7d9052804-718460a5.jpeg",t={},p=d('<h1 id="_24-冒险和预测-三-cpu里的-线程池" tabindex="-1"><a class="header-anchor" href="#_24-冒险和预测-三-cpu里的-线程池" aria-hidden="true">#</a> 24 | 冒险和预测（三）：CPU里的“线程池”</h1><p>过去两讲，我为你讲解了通过<mark>增加资源</mark>、<mark>停顿等待</mark>以及<mark>主动转发数据</mark>的方式，来解决结构冒险和数据冒险问题。</p><ul><li>对于结构冒险，由于限制来自于同一时钟周期不同的指令，要访问相同的硬件资源，解决方案是增加资源。</li><li>对于数据冒险，由于限制来自于数据之间的各种依赖，我们可以提前把数据转发到下一个指令。</li></ul><p>但是即便综合运用这三种技术，我们仍然会遇到不得不停下整个流水线，等待前面的指令完成的情况，也就是采用流水线停顿的解决方案。比如说，上一讲里最后给你的例子，即使我们进行了操作数前推，因为第二条加法指令依赖于第一条指令从内存中获取的数据，我们还是要插入一次 NOP 的操作。</p><figure><img src="'+r+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>那这个时候你就会想了，那我们能不能让后面没有数据依赖的指令，在前面指令停顿的时候先执行呢？</p><p>答案当然是可以的。毕竟，流水线停顿的时候，对应的电路闲着也是闲着。那我们完全可以先完成后面指令的执行阶段。</p><h2 id="填上空闲的-nop-上菜的顺序不必是点菜的顺序" tabindex="-1"><a class="header-anchor" href="#填上空闲的-nop-上菜的顺序不必是点菜的顺序" aria-hidden="true">#</a> 填上空闲的 NOP：上菜的顺序不必是点菜的顺序</h2><p>之前我为你讲解的，无论是流水线停顿，还是操作数前推，归根到底，只要前面指令的特定阶段还没有执行完成，后面的指令就会被“阻塞”住。</p><p>但是这个“阻塞”很多时候是没有必要的。因为尽管你的代码生成的指令是顺序的，但是如果后面的指令不需要依赖前面指令的执行结果，完全可以不必等待前面的指令运算完成。</p><p>比如说，下面这三行代码。</p><p>a = b + c</p><p>d = a * e</p><p>x = y * z</p><p>计算里面的 x ，却要等待 a 和 d 都计算完成，实在没啥必要。所以我们完全可以在 d 的计算等待 a 的计算的过程中，先把 x 的结果给算出来。</p><p>在流水线里，<em>后面的指令不依赖前面的指令</em>，那就不用等待前面的指令执行，<em>它完全可以先执行</em>。</p><figure><img src="'+c+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>可以看到，因为第三条指令并不依赖于前两条指令的计算结果，所以在第二条指令等待第一条指令的访存和写回阶段的时候，<em>第三条指令就已经执行完成了</em>。</p><p>这就好比你开了一家餐馆，顾客会排队来点菜。餐馆的厨房里会有洗菜、切菜、炒菜、上菜这样的各个步骤。后厨也是按照点菜的顺序开始做菜的。<em>但是不同的菜需要花费的时间和工序可能都有差别</em>。有些菜做起来特别麻烦，特别慢。比如做一道佛跳墙有好几道工序。我们没有必要非要等先点的佛跳墙上菜了，再开始做后面的炒鸡蛋。<em>只要有厨子空出来了，就可以先动手做前面的简单菜，先给客户端上去</em>。</p><p>这样的解决方案，在计算机组成里面，被称为<strong>乱序执行</strong>（Out-of-Order Execution，OoOE）。乱序执行，最早来自于著名的 IBM 360。相信你一定听说过《<code>人月神话</code>》这本软件工程届的经典著作，它讲的就是 IBM 360 开发过程中的“<code>人生体会</code>”。而 IBM 360 困难的开发过程，也少不了第一次引入乱序执行这个新的 CPU 技术。</p><h2 id="cpu-里的-线程池-理解乱序执行" tabindex="-1"><a class="header-anchor" href="#cpu-里的-线程池-理解乱序执行" aria-hidden="true">#</a> CPU 里的“线程池”：理解乱序执行</h2><p>那么，我们的 CPU 怎样才能实现乱序执行呢？是不是像玩俄罗斯方块一样，把后面的指令，找一个前面的坑填进去就行了？事情并没有这么简单。其实，从今天软件开发的维度来思考，<em>乱序执行好像是在指令的执行阶段，引入了一个“线程池”</em>。我们下面就来看一看，在 CPU 里，乱序执行的过程究竟是怎样的。</p><p>使用乱序执行技术后，CPU 里的流水线就和我之前给你看的 5 级流水线不太一样了。我们一起来看一看下面这张图。</p><img src="'+i+'" alt="img" style="zoom:25%;"><ol><li><strong>在取指令和指令译码的时候</strong>，乱序执行的 CPU 和其他使用流水线架构的 CPU 是一样的。它会一级一级<strong>顺序地</strong>进行取指令和指令译码的工作。</li><li>在指令译码完成之后，就不一样了。CPU 不会直接进行指令执行，<strong>而是进行一次指令分发</strong>，把指令发到一个叫作**<code>保留站</code>（Reservation Stations）**的地方。顾名思义，这个保留站，就像一个火车站一样。发送到车站的指令，就像是一列列的火车。</li><li>这些指令不会立刻执行，<em>而要等待它们所依赖的数据，传递给它们之后才会执行</em>。这就好像一列列的火车都要等到乘客来齐了才能出发。</li><li><em>一旦指令依赖的数据来齐了</em>，指令就可以交到后面的**<code>功能单元</code>（Function Unit，FU）**，其实就是 <mark>ALU</mark>，去执行了。我们有很多功能单元<em>可以并行运行</em>，但是不同的功能单元能够<em>支持执行的指令并不相同</em>。就和我们的铁轨一样，有些从上海北上，可以到北京和哈尔滨；有些是南下的，可以到广州和深圳。</li><li>指令执行的阶段完成之后，我们并不能立刻把结果写回到寄存器里面去，而是把结果再存放到一个叫作**<code>重排序缓冲区</code>（Re-Order Buffer，ROB）**的地方。</li><li>在重排序缓冲区里，<strong>我们的 CPU 会按照<em>取指令的顺序</em>，对指令的计算结果<em>重新排序</em></strong>。只有排在前面的指令都已经完成了，才会提交指令，完成整个指令的运算结果。</li><li>实际的指令的计算结果数据，并不是直接写到内存或者高速缓存里，而是先写入**<code>存储缓冲区</code>（Store Buffer）**，最终才会写入到<em>高速缓存</em>和<em>内存</em>里面。</li></ol><p>可以看到，在乱序执行的情况下，只有 <code>CPU 内部指令</code>的执行层面，可能是“<code>乱序</code>”的。只要我们能<em>在指令的译码阶段</em>正确地分析出指令之间的数据依赖关系，<strong>这个“<code>乱序</code>”就只会在互相没有影响的指令之间发生</strong>。</p><p><em>即便指令的执行过程中是乱序的</em>，我们在最终指令的计算结果写入到寄存器和内存之前，<em>依然会进行一次排序</em>，以确保所有指令在外部看来仍然是有序完成的。</p><h3 id="举例" tabindex="-1"><a class="header-anchor" href="#举例" aria-hidden="true">#</a> 举例</h3><p>有了乱序执行，我们重新去执行上面的 3 行代码。</p><ul><li>a = b + c</li><li>d = a * e</li><li>x = y * z</li></ul><p>里面的 d 依赖于 a 的计算结果，不会在 a 的计算完成之前执行。但是我们的 CPU 并不会闲着，因为 x = y * z 的指令同样会被分发到保留站里。因为 x 所依赖的 y 和 z 的数据是准备好的， 这里的乘法运算不会等待计算 d，而会先去计算 x 的值。</p><p>如果我们只有一个 FU 能够计算乘法，那么这个 FU 并不会因为 d 要等待 a 的计算结果，而被闲置，而是会先被拿去计算 x。</p><p>在 x 计算完成之后，d 也等来了 a 的计算结果。这个时候，我们的 FU 就会去计算出 d 的结果。然后在重排序缓冲区里，把对应的计算结果的提交顺序，仍然设置成 a -&gt; d -&gt; x，而计算完成的顺序是 x -&gt; a -&gt; d。</p><p>在这整个过程中，整个计算乘法的 FU 都没有闲置，这也意味着我们的 CPU 的吞吐率最大化了。</p><h3 id="线程池" tabindex="-1"><a class="header-anchor" href="#线程池" aria-hidden="true">#</a> 线程池</h3><p><em>整个乱序执行技术，就好像在指令的执行阶段提供一个“<code>线程池</code>”</em>。指令不再是顺序执行的，而是根据池里所拥有的资源，以及各个任务是否可以进行执行，进行动态调度。在执行完成之后，<em>又重新把结果在一个队列里面，按照指令的分发顺序重新排序</em>。<code>即使内部是“乱序”的</code>，但是在外部看起来，仍然是井井有条地顺序执行。</p><p>乱序执行，极大地提高了 CPU 的运行效率。核心原因是，<code>现代 CPU 的运行速度</code>比<code>访问主内存的速度</code>要快很多。如果完全采用顺序执行的方式，很多时间都会浪费在前面<em>指令等待获取内存数据</em>的时间里。CPU 不得不加入 NOP 操作进行空转。而现代 CPU 的流水线级数也已经相对比较深了，到达了 <code>14</code> 级。这也意味着，<em>同一个时钟周期内并行执行的指令数是很多的</em>。</p><p>而<mark>乱序执行</mark>，以及我们后面要讲的<mark>高速缓存</mark>，弥补了 <code>CPU</code> 和<code>内存</code>之间的性能差异。同样，也充分利用了较深的<code>流水行带来的并发性</code>，使得我们可以充分<code>利用 CPU 的性能</code>。</p><h2 id="总结延伸" tabindex="-1"><a class="header-anchor" href="#总结延伸" aria-hidden="true">#</a> 总结延伸</h2><p>好了，总结一下。这一讲里，我为你介绍了乱序执行，这个解决流水线阻塞的技术方案。<em>因为数据的依赖关系和指令先后执行的顺序问题，很多时候，流水线不得不“阻塞”在特定的指令上</em>。即使后续别的指令，并不依赖正在执行的指令和阻塞的指令，也不能继续执行。</p><p><code>而乱序执行</code>，则是在指令执行的阶段通过<strong>一个类似线程池的保留站</strong>，让系统自己去动态调度先执行哪些指令。这个动态调度巧妙地解决了流水线阻塞的问题。指令执行的先后顺序，不再和它们在程序中的顺序有关。<strong>我们只要保证不破坏数据依赖就好了</strong>。CPU 只要等到在指令结果的最终提交的阶段，<strong>再通过重排序的方式</strong>，确保指令“实际上”是顺序执行的。</p><h2 id="推荐阅读" tabindex="-1"><a class="header-anchor" href="#推荐阅读" aria-hidden="true">#</a> 推荐阅读</h2><p>想要更深入地了解 CPU 的乱序执行的知识，我们就不能局限于组成原理，而要深入到体系结构中去了。你可以读一下《<code>计算机体系结构：量化研究方法</code>》的 3.4 和 3.5 章节。</p><p>想要了解乱序执行为什么可行，你可以看看 Wikipedia 上，乱序执行所依赖的Tomasulo 算法。这个算法，也是在 IBM 360 时代引入的。</p><h2 id="课后思考" tabindex="-1"><a class="header-anchor" href="#课后思考" aria-hidden="true">#</a> 课后思考</h2><p>在现代 Intel 的 CPU 的乱序执行的过程中，只有指令的执行阶段是乱序的，后面的内存访问和数据写回阶段都仍然是顺序的。这种保障内存数据访问顺序的模型，叫作<code>强内存模型</code>（Strong Memory Model）。你能想一想，我们为什么要保障内存访问的顺序呢？在前后执行的指令没有相关数据依赖的情况下，为什么我们仍然要求这个顺序呢？</p><p>欢迎留言和我分享你的疑惑和见解。你也可以把今天的内容，分享给你的朋友，和他一起学习和进步。</p><blockquote><p>应该是数据一致性问题，多核访问相同的内存。但是有自己的缓存，寄存器。强内存模型可以保证数据的一致性<br> 作者回复: 👍</p><p>请问，多线程情况下，加volatile关键字，不但会禁止指令重排序，也会禁止CPU乱序执行么？<br> 网友回复：我的理解，volatile关键字禁止指令重排序，禁止的是加了关键字的那一段指令，等于告诉CPU这一部分不要重排序；但是其余的指令是否重排序，CPU是会根据规则判断，如果认为没有前后数据依赖，还是会进行重排序的。volatile是给编译器看的，阻止编译乱序，但执行乱序是管不了的。</p></blockquote>',48),m=[p];function n(s,l){return a(),o("div",null,m)}const f=e(t,[["render",n],["__file","D24-冒险和预测（三）.html.vue"]]);export{f as default};
