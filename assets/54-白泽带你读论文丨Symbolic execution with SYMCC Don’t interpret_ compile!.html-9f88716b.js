import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as a,o as n,c as r,a as e,b as i,e as c,d as s}from"./app-cdabc73c.js";const l="/assets/640-1691395222661-213-64d21ac8.png",p="/assets/640-1691395222662-214-645e5c3c.png",h="/assets/640-1691395222662-215-14742731.png",d="/assets/640-1691395222662-216-09e73db8.png",m="/assets/640-1691395222662-217-8814fdc9.png",C={},g=e("h1",{id:"_54-白泽带你读论文丨symbolic-execution-with-symcc-don-t-interpret-compile",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_54-白泽带你读论文丨symbolic-execution-with-symcc-don-t-interpret-compile","aria-hidden":"true"},"#"),i(" 54-白泽带你读论文丨Symbolic execution with SYMCC: Don’t interpret, compile!")],-1),u={href:"https://www.usenix.org/conference/usenixsecurity20/presentation/poeplau",target:"_blank",rel:"noopener noreferrer"},_=s('<p>Symbolic execution with SYMCC: Don’t interpret, compile!</p><p>本文发表在Usenix Security 20，第一作者是来自EURECOM的Sebastian Poeplau。</p><h2 id="background" tabindex="-1"><a class="header-anchor" href="#background" aria-hidden="true">#</a> Background</h2><p>随着SAT和SMT求解方面的进步，符号执行逐渐成为软件测试中的重要手段。符号化执行工具一般包含三个模块：执行器、符号化后端、分叉和调度，而执行器的速度缓慢是符号化执行技术的一个主要瓶颈。现有符号化执行工作根据执行器可分为两类，基于IR的符号化执行和无IR的符号化执行。</p><p>基于IR的符号化执行工具的代表包括<mark>angr</mark>，<mark>KLEE</mark>等，他们先将需要分析的程序转换为IR，再对IR进行解释执行，并生成计算操作的符号表达式，符号化后端对表达式进行推理求解。</p><ol><li>这种方式的优点是容易实现和维护，只需要处理包含几十条不同指令的IR指令集；<br> 另一个优点是可扩展性好，对于不同架构的目标程序都可以进行分析。</li><li>缺点是解释执行的速度比native执行慢得多；此外，对于未进行环境建模的外部库函数，解释器将无法继续执行。</li></ol><p>以QSYM为代表的无IR的符号化执行直接执行未修改的机器代码，并在运行时进行动态二进制插桩，在执行计算操作时hook当前指令，用动态二进制插桩调用构建符号化表达式的函数。</p><p>这种方式的主要优点是速度快，尽快运行时插桩也存在一定开销，但比解释执行快得多；另外，其鲁棒性较基于IR的符号执行好，对于外部库函数，无IR的方式可以直接进行具体执行。</p><p>缺点是实现复杂，CPU机器指令集可能有上千条指令，且比IR指令集更复杂；另一个问题是架构依赖性，机器代码的插桩是机器依赖的工作，若向其他架构进行扩展也需要非常大量的工作。</p><h2 id="overview" tabindex="-1"><a class="header-anchor" href="#overview" aria-hidden="true">#</a> Overview</h2><p>本文针对有源码情况下的符号执行，结合两类符号执行的优势，提出了新的解决方案SYMCC：<em>SYMCC采用编译时插桩的策略</em>。</p><p>SYMCC首先将源代码编译成LLVM IR，然后在LLVM IR上进行插桩，将调用函数构建符号化表达式的指令插入IR中，再将IR编译为二进制文件，直接对二进制机器码进行执行，而不需解释IR的过程。SYMCC结合了基于IR和无IR的符号化执行的优点，既保留了简单的实现，又独立于架构，同时显著提高了目标程序的执行速度。</p><figure><img src="'+l+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>在SYMCC实现中使用了以下技术：</p><p><strong>1. Concreteness checks</strong></p><p>为了进一步降低符号执行开销，避免符号执行过程中符号变量爆炸的问题，SYMCC包含Concreteness checks部分，核心思想是在调用符号后端前进行数据识别。主要包含两个部分，</p><ol><li>编译时检查：在编译过程中识别常量，常量永远不会被符号化；</li><li>运行时检查：在运行过程中对参与计算的变量进行检查，仅当至少一个输入是符号值的情况下会调用符号后端。</li></ol><p><strong>2. Shadow memory</strong></p><p>Shadow memory维护一块内存用于存储程序中的数据与其符号表达式的映射，以便快速访问。具体来说，当需要使用之前分配过内存的数据的符号表达式时可直接到shadow memory中进行查找。有一种特殊情况：局部变量对应的表达式直接存到局部变量中，在代码生成过程中会与常规数据进行相同的处理。SYMCC在shadow memory的设计上没有创新，相反，它的查询复杂度还是比较高的。作者之所以没有采用O(nLogn)的算法，是因为他觉得自己的符号值比较少，不需要特别在查询算法上进行优化。</p><h2 id="evaluation" tabindex="-1"><a class="header-anchor" href="#evaluation" aria-hidden="true">#</a> Evaluation</h2><p>作者分别在benchmark和真实软件上进行了实验。</p><ol><li>首先在benchmark上测试多种符号执行工具的运行时间。</li></ol><p>纯执行情况下，SYMCC效率优于QSYM和KLEE；在符号执行的情况下，SYMCC总体来说具有更高的效率。</p><figure><img src="'+p+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><ol start="2"><li>在benchmark上测试SYMCC、KLEE和QSYM的覆盖率，SYMCC优于KLEE，和QSYM差距不大。</li></ol><figure><img src="'+h+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>分析可能的原因包括：</p><ul><li>– 比KLEE覆盖率更高：由于symbolic backend差异导致SYMCC执行速度快，能够到达更高的覆盖率</li><li>– 和QSYM差距不大：各自有最优的处理情况</li><li>•SYMCC由高级语言代码中生成符号表达式，某些情况下更容易求解</li><li>•QSYM在低级语言上分析，可能更容易在机器码层次上提高覆盖率</li></ul><ol start="3"><li>作者分别在OpenJPEG、libarchive和tcpdump上对SYMCC和QSYM与AFL结合进行了测试</li></ol><figure><img src="'+d+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><figure><img src="'+m+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>实验表明，SYMCC比QSYM在真实软件中的符号执行速度更快，同时在hybrid fuzz上表现更好，在三个软件的两个中能够达到更高的覆盖率。</p><h2 id="discussion" tabindex="-1"><a class="header-anchor" href="#discussion" aria-hidden="true">#</a> Discussion</h2><h3 id="strength" tabindex="-1"><a class="header-anchor" href="#strength" aria-hidden="true">#</a> <strong>Strength</strong></h3><ol><li>实现简单，只需处理IR指令集</li><li>可扩展性好，使用IR作为插桩目标，独立于架构，理论上支持任何能够转换为IR的目标源代码</li><li>鲁棒性好，可以对外部库进行插桩使外部库也可进行符号化执行，对于未插桩的外部库也可以简单地进行具体执行，不需复杂环境建模</li></ol><h3 id="limitation" tabindex="-1"><a class="header-anchor" href="#limitation" aria-hidden="true">#</a> <strong>Limitation</strong></h3><p>SYMCC不能分析只有二进制可执行文件的程序，需要从源码编译开始或至少有一个bitcode文件。</p><h2 id="总结与分析" tabindex="-1"><a class="header-anchor" href="#总结与分析" aria-hidden="true">#</a> 总结与分析</h2><ol><li>在调度算法上，<mark>klee</mark>和<mark>angr</mark>都采取的是对不同路径进行fork来探索，但是<mark>SYMCC</mark>使用concolic，是由于concolic在进行符号执行时具有更高的效率。</li></ol><p>concolic的策略是指，在运行过程中仅沿着所给的输入执行一次，遇到需要求解的分支时会进行求解，得到一些新的input，之后喂给正在执行的fuzzer。（简单的解释concolic，concrete部分指的是当前的输入，对于当前输入来说，程序是具体执行的；但是遇到分支后，就开始进行symbolic部分）。而fork的策略指的是，给定一个input，会对其他所有的分支都进行探索（有点类似bfs和dfs），所以为了避免需要重新执行一遍之前的路径，这个策略会在分支点fork出所有的分支（其实就是为了记住当前的状态），并且根据一些调度策略来对不同的执行路径进行排序。总的来说，concolic的方法是现在比较主流的方法，因为可以避免路径爆炸问题。</p><ol start="2"><li>SYMCC和QSYM在不同场景下有各自的优势，因此在实验中二者coverage表现接近。</li></ol><p>Qsym会在执行指令时都下硬件中断，理论上来说SYMCC应该更快，更快就会导致探索的路径也越多，但是实验结果表明两者coverage接近，存在以下两种原因：</p><p>1）SYMCC从比QSYM更高级别的LLVM bitecode生成符号表达式，这有时 会导致SMT求解器更容易查询；</p><p>2）QSYM能够通过低级别的机器码生成测试用例，某些情况下更容易产生新覆盖率的case，SYMCC在IR级别可能无法做到。</p><ol start="3"><li>本文在IR层面对符号执行逻辑进行插桩，相比以往工作在源码层面插桩编译的相关工作具有更高的灵活性和适应性。</li></ol><p>符号执行的后台移到编译过层中，解决了符号执行中重要的速度问题；相比在高级语言处理，更具有灵活性；避免了对高级语言特性处理的困难，更容易具备多语言支持。</p><ol start="4"><li>在对concreteness check的evaluation中，存在使用了concreteness check后的运行时间反而增加的case，表明concretness check不能完全确保降低符号执行开销。</li></ol><p>concreteness check通过对每次调用符号执行后端之前进行检查参与计算的值是否是符号值，部分库中存在大量密集的符号运算，因此存在大量无效的concretness check操作，这种情况下进行concreteness check反而造成运行开销变大。</p>',48);function S(f,M){const o=a("ExternalLinkIcon");return n(),r("div",null,[g,e("p",null,[e("a",u,[i("Symbolic execution with SymCC: Don't interpret, compile! | USENIX"),c(o)]),i("。")]),_])}const k=t(C,[["render",S],["__file","54-白泽带你读论文丨Symbolic execution with SYMCC Don’t interpret_ compile!.html.vue"]]);export{k as default};
