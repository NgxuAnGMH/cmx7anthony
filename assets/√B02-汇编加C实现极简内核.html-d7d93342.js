import{_ as o}from"./cbd634cd5256e372bcbebd4b95f21b34-655b5b18.js";import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o as r,c as d,a as e,b as n,e as a,d as s}from"./app-cdabc73c.js";const p="/assets/1db2342da1abdc9f1f77e4c69a94d0dc-c4d5e1fc.png",u="/assets/f2d31ab7144bf309761711efa9d6d4bd-32b249f0.jpg",c="/assets/782ef574b96084fa44a33ea1f83146f5-899b19ce.jpg",b={},m=e("h1",{id:"√02-几行汇编几行c-实现一个最简单的内核",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#√02-几行汇编几行c-实现一个最简单的内核","aria-hidden":"true"},"#"),n(" √02 | 几行汇编几行C：实现一个最简单的内核")],-1),h=e("p",null,"你好，我是 LMOS。",-1),v=e("p",null,"我们知道，在学习许多编程语言一开始的时候，都有一段用其语言编写的经典程序——Hello World。这不过是某一操作系统平台之上的应用程序，却心高气傲地问候世界。",-1),g=e("p",null,"而我们学习操作系统的时候，那么也不妨撇开其它现有的操作系统，基于硬件，写一个最小的操作系统——Hello OS，先练练手、热热身，直观感受一下。",-1),_={href:"https://gitee.com/lmos/cosmos/tree/master/lesson02/HelloOS",target:"_blank",rel:"noopener noreferrer"},k=s('<p>请注意，这节课主要是演示思路，不要求你马上动手实现。<strong>详细的环境安装、配置我们到<u>第十节课</u>再详细展开</strong>。有兴趣上手的同学，可以参考留言区置顶的实验笔记探索。</p><h2 id="pc-机的引导流程" tabindex="-1"><a class="header-anchor" href="#pc-机的引导流程" aria-hidden="true">#</a> PC 机的引导流程</h2><p>看标题就知道，写操作系统要用汇编和 C 语言，尽管这个 Hello OS 很小，但也要用到两种编程语言。其实，现有的商业操作系统都是用这两种语言开发出来的。</p><p>先不用害怕，Hello OS 的代码量很少。</p><p>其实，我们也不打算从 PC 的引导程序开始写起，原因是目前我们的知识储备还不够，所以先借用一下 <mark>GRUB 引导程序</mark>，只要我们的 PC 机上安装了 Ubuntu Linux 操作系统，GRUB 就已经存在了。这会大大降低我们开始的难度，也不至于打消你的热情。</p><img src="'+p+'" alt="img"><p>那在写 Hello OS 之前，我们先要搞清楚 Hello OS 的引导流程，如下图所示：</p><img src="'+u+'" alt="img" style="zoom:15%;"><p>Hello OS引导流程图</p><p>简单解释一下，PC 机 BIOS 固件是固化在 PC 机主板上的 ROM 芯片中的，掉电也能保存，PC 机上电后的第一条指令就是 BIOS 固件中的，它负责<strong>检测和初始化 CPU、内存及主板平台</strong>，然后加载引导设备（大概率是硬盘）中的第一个扇区数据，到 0x7c00 地址开始的内存空间，再接着跳转到 0x7c00 处执行指令，在我们这里的情况下就是 GRUB 引导程序。</p>',10),f={href:"https://www.uefi.org",target:"_blank",rel:"noopener noreferrer"},x=s(`<h2 id="hello-os-引导汇编代码" tabindex="-1"><a class="header-anchor" href="#hello-os-引导汇编代码" aria-hidden="true">#</a> Hello OS 引导汇编代码</h2><p>明白了 PC 机的启动流程，下面只剩下我们的 Hello OS 了，我们马上就去写好它。</p><p>我们先来写一段汇编代码。这里我要特别说明一个问题：为什么不能直接用 C？</p><p><strong>C 作为通用的高级语言，不能直接操作特定的硬件，而且 C 语言的函数调用、函数传参，都需要用栈。</strong></p><p>栈简单来说就是一块内存空间，其中数据满足<strong>后进先出</strong>的特性，它由 CPU 特定的栈寄存器指向，所以我们要先用<em>汇编代码</em>处理好这些 C 语言的工作环境。</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>;彭东 @ 2021.01.09
MBT_HDR_FLAGS EQU 0x00010003
MBT_HDR_MAGIC EQU 0x1BADB002 ;多引导协议头魔数
MBT_HDR2_MAGIC EQU 0xe85250d6 ;第二版多引导协议头魔数
global _start ;导出_start符号
extern main ;导入外部的main函数符号
[section .start.text] ;定义.start.text代码节
[bits 32] ;汇编成32位代码
_start:
jmp _entry
ALIGN 8
mbt_hdr:
dd MBT_HDR_MAGIC
dd MBT_HDR_FLAGS
dd -(MBT_HDR_MAGIC+MBT_HDR_FLAGS)
dd mbt_hdr
dd _start
dd 0
dd 0
dd _entry
;以上是GRUB所需要的头
ALIGN 8
mbt2_hdr:
DD MBT_HDR2_MAGIC
DD 0
DD mbt2_hdr_end - mbt2_hdr
DD -(MBT_HDR2_MAGIC + 0 + (mbt2_hdr_end - mbt2_hdr))
DW 2, 0
DD 24
DD mbt2_hdr
DD _start
DD 0
DD 0
DW 3, 0
DD 12
DD _entry
DD 0
DW 0, 0
DD 8
mbt2_hdr_end:
;以上是GRUB2所需要的头
;包含两个头是为了同时兼容GRUB、GRUB2
ALIGN 8
_entry:
;关中断
cli
;关不可屏蔽中断
in al, 0x70
or al, 0x80
out 0x70,al
;重新加载GDT
lgdt [GDT_PTR]
jmp dword 0x8 :_32bits_mode
_32bits_mode:
;下面初始化C语言可能会用到的寄存器
mov ax, 0x10
mov ds, ax
mov ss, ax
mov es, ax
mov fs, ax
mov gs, ax
xor eax,eax
xor ebx,ebx
xor ecx,ecx
xor edx,edx
xor edi,edi
xor esi,esi
xor ebp,ebp
xor esp,esp
;初始化栈，C语言需要栈才能工作
mov esp,0x9000
;调用C语言函数main
call main
;让CPU停止执行指令
halt_step:
halt
jmp halt_step
GDT_START:
knull_dsc: dq 0
kcode_dsc: dq 0x00cf9e000000ffff
kdata_dsc: dq 0x00cf92000000ffff
k16cd_dsc: dq 0x00009e000000ffff
k16da_dsc: dq 0x000092000000ffff
GDT_END:
GDT_PTR:
GDTLEN dw GDT_END-GDT_START-1
GDTBASE dd GDT_START
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上的汇编代码（/lesson02/HelloOS/entry.asm）分为 4 个部分：</p><ol><li><p>代码 1~40 行，用汇编定义的 <mark>GRUB 的多引导协议头</mark>，其实就是<strong>一定格式的数据</strong>，<br> 我们的 Hello OS 是用 GRUB 引导的，当然要遵循 <strong>GRUB 的多引导协议标准</strong>，让 GRUB 能识别我们的 Hello OS。之所以有两个引导头，是为了<strong>兼容</strong> GRUB1 和 GRUB2。</p></li><li><p>代码 44~52 行，<mark>关掉中断</mark>，<strong>设定 CPU 的工作模式</strong>。你现在可能不懂，没事儿，后面 CPU 相关的课程我们会专门再研究它。</p></li><li><p>代码 54~73 行，<strong>初始化</strong> <mark>CPU 的寄存器</mark>和 <mark>C 语言的运行环境</mark>。</p></li><li><p>代码 78~87 行，GDT_START 开始的，是 <mark>CPU 工作模式所需要的数据</mark>，同样，后面讲 CPU 时会专门介绍。</p></li></ol><h2 id="hello-os-的主函数" tabindex="-1"><a class="header-anchor" href="#hello-os-的主函数" aria-hidden="true">#</a> Hello OS 的主函数</h2><p>到这，不知道你有没有发现一个问题? 上面的汇编代码调用了 main 函数，而在其代码中并没有看到其函数体，而是从外部引入了一个符号。</p><p>那是因为这个函数是用 C 语言写的在（/lesson02/HelloOS/main.c）中，最终它们分别由 <em>nasm</em> 和 <em>GCC</em> 编译成<mark>可链接模块</mark>，由 <mark>LD 链接器</mark>链接在一起，形成<mark>可执行的程序文件</mark>：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//彭东 @ 2021.01.09</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;vgastr.h&quot;</span></span>
<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Hello OS!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上这段代码，你应该很熟悉了吧？不过这不是应用程序的 main 函数，<strong>而是 Hello OS 的 main 函数</strong>。</p><p>其中的 printf 也不是应用程序库中的那个 printf 了，而是需要我们自己实现了。你可以先停下歇歇，再去实现 printf 函数。</p><h2 id="控制计算机屏幕" tabindex="-1"><a class="header-anchor" href="#控制计算机屏幕" aria-hidden="true">#</a> 控制计算机屏幕</h2><p>接着我们再看下<mark>显卡</mark>，这和我们接下来要写的代码有直接关联。</p><h3 id="_1-集显-核显-独显" tabindex="-1"><a class="header-anchor" href="#_1-集显-核显-独显" aria-hidden="true">#</a> 1 集显/核显/独显</h3><p>计算机屏幕显示往往是显卡的输出，显卡有很多形式：</p><ol><li>集成在主板的叫<mark>集显</mark>，</li><li>做在 CPU 芯片内的叫<mark>核显</mark>，</li><li>独立存在通过 PCIE 接口连接的叫<mark>独显</mark>， <ul><li>性能依次上升，价格也是。</li></ul></li></ol><p>独显的高性能是游戏玩家们所钟爱的，3D 图形显示往往要涉及顶点处理、多边形的生成和变换、纹理、着色、打光、栅格化等。而这些任务的计算量超级大，<strong>所以<mark>独显</mark>往往有自己的 RAM、多达几百个运算核心的处理器。因此独显不仅仅是可以显示图像，<em>而且可以执行大规模并行计算</em>，比如“挖矿”。</strong></p><h3 id="_2-字符模式-图形模式" tabindex="-1"><a class="header-anchor" href="#_2-字符模式-图形模式" aria-hidden="true">#</a> 2 字符模式/图形模式</h3><p>我们要在屏幕上显示字符，就要编程操作显卡。</p><p>其实无论我们 PC 上是什么显卡，它们都支持一种叫 <strong>VESA</strong> 的标准，这种标准下有两种工作模式：<mark>字符模式</mark>和<mark>图形模式</mark>。显卡们为了兼容这种标准，不得不自己提供一种叫 <mark>VGABIOS 的固件程序</mark>。</p><p>下面，我们来看看显卡的字符模式的工作细节。</p><p>它把屏幕分成 24 行，每行 80 个字符，把这（24*80）个位置映射到以 0xb8000 地址开始的内存中，每两个字节对应一个字符，其中一个字节是字符的 ASCII 码，另一个字节为字符的颜色值。如下图所示：</p><img src="`+c+'" alt="img" style="zoom:15%;"><p>计算机显卡文本模式</p><h3 id="_3-编程操作显卡" tabindex="-1"><a class="header-anchor" href="#_3-编程操作显卡" aria-hidden="true">#</a> 3 编程操作显卡</h3><p>明白了显卡的字符模式的工作细节，下面我们开始写代码。</p>',29),S=e("strong",null,"C 语言字符串是以 0 结尾的，其字符编码通常是 utf8，而 utf8 编码对 ASCII 字符是兼容的，即英文字符的 ASCII 编码和 utf8 编码是相等的",-1),B={href:"https://www.utf8.com/",target:"_blank",rel:"noopener noreferrer"},O=s(`<div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//彭东 @ 2021.01.09</span>
<span class="token keyword">void</span> <span class="token function">_strwrite</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> string<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">char</span><span class="token operator">*</span> p_strdst <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">0xb8000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//指向显存的开始地址</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>string<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token operator">*</span>p_strdst <span class="token operator">=</span> <span class="token operator">*</span>string<span class="token operator">++</span><span class="token punctuation">;</span>
    p_strdst <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> fmt<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">_strwrite</span><span class="token punctuation">(</span>fmt<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码很简单，printf 函数直接调用了 <code>_strwrite 函数</code>，而 _strwrite 函数正是<strong>将字符串里每个字符依次定入到 0xb8000 地址开始的显存中</strong>，而 p_strdst 每次加 2，这也是为了跳过字符的颜色信息的空间。</p><p>到这，Hello OS 相关的代码就写好了，下面就是编译和安装了。你可别以为这个事情就简单了，下面请跟着我去看一看。</p><h2 id="编译和安装-hello-os" tabindex="-1"><a class="header-anchor" href="#编译和安装-hello-os" aria-hidden="true">#</a> 编译和安装 Hello OS</h2><p>Hello OS 的代码都已经写好，这时就要进入安装测试环节了。在安装之前，我们要进行系统编译，即把每个代码模块编译最后链接成<code>可执行的二进制文件</code>。</p><p>你可能觉得我在小题大做，编译不就是输入几条命令吗，这么简单的工作也值得一说？</p><p>确实，对于我们 Hello OS 的编译工作来说特别简单，因为总共才三个代码文件，最多四条命令就可以完成。</p><p><em>但是以后我们 Hello OS 的文件数量会爆炸式增长</em>，一个成熟的商业操作系统<strong>更是多达几万个代码模块文件</strong>，几千万行的代码量，是这世间最复杂的软件工程之一。所以需要<mark>一个牛逼的工具</mark>来<code>控制这个巨大的编译过程</code>。</p><h2 id="make-工具" tabindex="-1"><a class="header-anchor" href="#make-工具" aria-hidden="true">#</a> make 工具</h2><p><code>make</code> 历史悠久，小巧方便，也是很多成熟操作系统编译所使用的<code>构建工具</code>。</p><h3 id="_1-原理" tabindex="-1"><a class="header-anchor" href="#_1-原理" aria-hidden="true">#</a> 1 原理</h3><p>在软件开发中，make 是一个工具程序，它读取一个叫<code>“makefile”</code>的文件，也是一种文本文件，这个文件中写好了<code>构建软件的规则</code>，它能根据这些规则<code>自动化</code>构建软件。</p><p>makefile 文件中规则是这样的：首先有一个或者多个<code>构建目标</code>称为“<code>target</code>”；目标后面紧跟着用于构建该目标<mark>所需要的文件</mark>，目标下面是构建该目标<mark>所需要的命令及参数</mark>。</p><ol><li>构建目标target</li><li>所需文件</li><li>所需的命令及参数</li></ol><p>与此同时，它也检查文件的依赖关系，如果需要的话，它会调用一些外部软件来完成任务。</p><p>第一次构建目标后，下一次执行 make 时，它会根据<code>该目标所依赖的文件是否更新</code>来决定是否编译该目标，如果所依赖的文件没有更新且该目标又存在，那么它便不会构建该目标。这种特性非常有利于编译程序源代码。</p><p>任何一个 Linux 发行版中都默认自带这个 make 程序，所以不需要额外的安装工作，我们直接使用即可。</p><p>为了让你进一步了解 make 的使用，接下来我们一起看一个有关 makefile 的例子：</p><div class="language-makefile line-numbers-mode" data-ext="makefile"><pre class="language-makefile"><code>CC <span class="token operator">=</span> gcc <span class="token comment">#定义一个宏CC 等于gcc</span>
CFLAGS <span class="token operator">=</span> -c <span class="token comment">#定义一个宏 CFLAGS 等于-c</span>
OBJS_FILE <span class="token operator">=</span> file.o file1.o file2.o file3.o file4.o <span class="token comment">#定义一个宏</span>
<span class="token builtin-target builtin">.PHONY</span> <span class="token punctuation">:</span> all everything <span class="token comment">#定义两个伪目标all、everything</span>
<span class="token target symbol">all</span><span class="token punctuation">:</span>everything <span class="token comment">#伪目标all依赖于伪目标everything</span>
<span class="token target symbol">everything</span> <span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>OBJS_FILE<span class="token punctuation">)</span> <span class="token comment">#伪目标everything依赖于OBJS_FILE，而OBJS_FILE是宏会被</span>
<span class="token comment">#替换成file.o file1.o file2.o file3.o file4.o</span>
<span class="token comment">#通用规则</span>
<span class="token target symbol">%.o</span> <span class="token punctuation">:</span> %.c
	<span class="token comment"># 所需要的命令及参数</span>
   <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> -o <span class="token variable">$@</span> <span class="token variable">$&lt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-例子" tabindex="-1"><a class="header-anchor" href="#_2-例子" aria-hidden="true">#</a> 2 例子</h3><p>我来解释一下这个例子：</p><ul><li><p>make 规定“<code>#</code>”后面为注释，make 处理 makefile 时会自动丢弃。</p></li><li><p>makefile 中可以定义宏，方法是<strong>在一个字符串后跟一个“=”或者“:=”符号</strong>，引用宏时要用“<code>$(宏名)</code>”，宏最终会在宏出现的地方替换成相应的字符串，</p><ul><li>例如：<code>$(CC)</code> 会被替换成 gcc，<code>$( OBJS_FILE)</code> 会被替换成 file.o file1.o file2.o file3.o file4.o。</li></ul></li><li><p><code>.PHONY</code> 在 makefile 中表示定义伪目标。所谓伪目标，就是它不代表一个真正的文件名，在执行 make 时可以指定这个目标来执行其所在规则定义的命令。但是伪目标可以依赖于另一个伪目标或者文件，</p><ul><li>例如：all 依赖于 everything，everything 最终依赖于 file.c file1.c file2.c file3.c file4.c。</li></ul></li><li><p>虽然我们会发现，everything 下面并没有相关的执行命令，但是下面有个<code>通用规则</code>：“%.o : %.c”。其中的“%”表示通配符，表示所有以“.o”结尾的文件依赖于所有以“.c”结尾的文件。</p><ul><li>例如：file.c、file1.c、file2.c、file3.c、file4.c，通过这个通用规则会自动转换为依赖关系：file.o: file.c、file1.o: file1.c、file2.o: file2.c、file3.o: file3.c、file4.o: file4.c。</li></ul></li><li><p>然后，针对这些依赖关系，分别会执行：<code>$(CC) $(CFLAGS) -o $@ $&lt;</code> 命令，当然最终会转换为：gcc –c –o xxxx.o xxxx.c，这里的“xxxx”表示一个具体的文件名。</p></li></ul><h2 id="编译过程" tabindex="-1"><a class="header-anchor" href="#编译过程" aria-hidden="true">#</a> 编译过程</h2><p>下面我们用一张图来描述我们 Hello OS 的编译过程，如下所示：</p><img src="`+o+`" alt="img" style="zoom:15%;"><p>Hello OS编译过程</p><h2 id="安装-hello-os" tabindex="-1"><a class="header-anchor" href="#安装-hello-os" aria-hidden="true">#</a> 安装 Hello OS</h2><p>经过上述流程，我们就会得到 <mark>Hello OS.bin 文件</mark>，但是我们还要让 <mark>GRUB</mark> 能够找到它，才能在计算机启动时加载它。这个过程我们称为<code>安装</code>，不过这里没有写安装程序，得我们手动来做。</p><p>经研究发现，GRUB 在启动时会加载<mark>一个 grub.cfg 的文本文件</mark>，根据其中的内容执行相应的操作，其中一部分内容就是启动项。</p><p>GRUB 首先会<strong>显示启动项到屏幕</strong>，然后让我们<strong>选择启动项</strong>，最后 GRUB 根据启动项对应的信息，<strong>加载 OS 文件到内存</strong>。</p><p>下面来看看我们 Hello OS 的启动项：</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>menuentry &#39;HelloOS&#39; {
     insmod part_msdos #GRUB加载分区模块识别分区
     insmod ext2 #GRUB加载ext文件系统模块识别ext文件系统
     set root=&#39;hd0,msdos4&#39; #注意boot目录挂载的分区，这是我机器上的情况
     multiboot2 /boot/HelloOS.bin #GRUB以multiboot2协议加载HelloOS.bin
     boot #GRUB启动HelloOS.bin
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你不知道你的 <strong>boot 目录挂载的分区</strong>，可以在 Linux 系统的终端下输入命令：<code>df /boot/</code>，就会得到如下结果：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>文件系统          1K-块    已用     可用      已用% 挂载点
/dev/sda4      <span class="token number">48752308</span> <span class="token number">8087584</span> <span class="token number">38158536</span>   <span class="token number">18</span>%    /
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>其中的“sda4”就是硬盘的第四个分区（硬件分区选择 MBR），但是 GRUB 的 menuentry 中不能写 sda4，而是要写“hd0,msdos4”，这是 GRUB 的命名方式，hd0 表示第一块硬盘，结合起来就是<strong>第一块硬盘的第四个分区</strong>。</p><p>把上面启动项的代码插入到你的 Linux 机器上的 <mark>/boot/grub/grub.cfg 文件</mark>末尾，然后把 <mark>Hello OS.bin 文件</mark>复制到 <mark>/boot/ 目录</mark>下，一定注意<strong>这里是追加不是覆盖</strong>。最后重启计算机，你就可以看到 Hello OS 的启动选项了。</p><p>选择 Hello OS，按下 Enter 键（或者重启按 ESC 键），这样就可以成功启动我们自己的 Hello OS 了。</p><h2 id="重点回顾" tabindex="-1"><a class="header-anchor" href="#重点回顾" aria-hidden="true">#</a> 重点回顾</h2><p>有没有很开心？我们终于看到我们自己的 OS 运行了，就算它再简单也是我们自己的 OS。下面我们再次回顾下这节课的重点。</p><p>首先，我们了解了从按下 PC 机电源开关开始，PC 机的引导过程。它从 CPU 上电，到加载 BIOS 固件，再由 BIOS 固件对计算机进行自检和默认的初始化，并加载 GRUB 引导程序，最后由 GRUB 加载具体的操作系统。</p><p>其次，就到了我们这节课最难的部分，即用汇编语言和 C 语言实现我们的 Hello OS。</p><ol><li>第一步，用汇编程序初始化 CPU 的寄存器、设置 CPU 的工作模式和栈，<br> 最重要的是<strong>加入了 GRUB 引导协议头</strong>；</li><li>第二步，切换到 C 语言，用 C 语言写好了<strong>主函数和控制显卡输出的函数</strong>，<br> 其间还了解了显卡的一些工作细节。</li><li>最后，就是编译和安装 Hello OS 了。我们用了 make 工具编译整个代码，其实 make 会根据一些规则调用具体的 nasm、gcc、ld 等编译器，然后形成 Hello OS.bin 文件，你把这个文件写复制到 boot 分区，写好 GRUB 启动项，这样就好了。</li></ol><p>这里只是上上手，下面我们还会去准备一些别的东西，然后就真正开始了。但你此刻也许还有很多问题没有搞清楚，比如重新加载 GDT、关中断等，先不要担心，我们后面会一一解决的。</p><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题" aria-hidden="true">#</a> 思考题</h2><p>以上 printf 函数定义，其中有个形式参数很奇怪，请你思考下：为什么是“…”形式参数，这个形式参数有什么作用？</p><p>欢迎你在留言区分享你的思考或疑问。</p><p>我是 LMOS，我们下节课见！</p><h2 id="评论区" tabindex="-1"><a class="header-anchor" href="#评论区" aria-hidden="true">#</a> 评论区</h2><h3 id="推荐参考资料" tabindex="-1"><a class="header-anchor" href="#推荐参考资料" aria-hidden="true">#</a> 推荐参考资料</h3>`,49),E={href:"https://www.gnu.org/software/grub/grub-documentation.html",target:"_blank",rel:"noopener noreferrer"},U=e("p",null,"作者回复: 你好，对的，这是GRUB文档",-1),H=e("hr",null,null,-1),G=e("p",null,[n("如果看过王爽老师的《汇编语言》和李忠老师的《X86汇编语言：从实模式到保护模式》，这段的理解将非常简单，建议大家可以配合使用"),e("br"),n(" 作者回复: 目前不需要搞懂 先感受一下，我后面课程也会介绍 的"),e("br"),n(" 其他网友：X86匯編：從實模式到保護模式 真的是極力推薦")],-1),C=e("hr",null,null,-1),R=e("p",null,"建议参考Linux 1.0.0版本的boot. S",-1),w=e("p",null,"作者回复: 也可以",-1),y=s('<h3 id="细碎的流程点-一些坑" tabindex="-1"><a class="header-anchor" href="#细碎的流程点-一些坑" aria-hidden="true">#</a> 细碎的流程点（一些坑）</h3><h4 id="_01-最好用virtualbox-ubuntu" tabindex="-1"><a class="header-anchor" href="#_01-最好用virtualbox-ubuntu" aria-hidden="true">#</a> 01 最好用VirtualBox-Ubuntu</h4><blockquote><p>为了学习这一课，恶补了很多内容:<br> 1、没有用过linux，特意在电脑上装了win10和ubuntu双系统，从零开始学习shell命令;<br> 2、从零开始搭建C开发环境，学习配置vim，虽然最终选择了更容易上手的vs code;<br> 3、学习如何写makefile，如何应用gcc，nasm等等工具;<br> 4、学习磁盘分区的知识，知道了MBR，GPT，知道了BIOS，UEFI，grub2;<br> 5、因为一条multiboot2 /boot/HelloOS.bin无法找到file，需要改为multiboot2 /HelloOS.bin才能成功，在安装上折腾了许久。 最终因为我的电脑采用了UEFI，而且无法切回传统的bios，很遗憾没有看到&quot;HelloOS&quot;，不过仍然感谢老师，真的收获了很多。</p><p>作者回复: 可以用虚拟机啊</p><p>其他网友：不知道老铁成功了吗，但是我也是这种情况，将multiboot2改成multiboot就行了</p><p>其他网友：如果是用uefi的该怎么改一下呢</p><p>其他网友：同学你好，请教下用WSL2怎么完成helloos呢？不知道对应到boot目录那块应该怎么去配置，非常感谢😁</p><hr><p>我用multipass轻量级虚拟机，没试验出来</p><p>编辑回复: 不是所有虚拟机都支持哦，你可以参考下留言区的实验记录分析，或者等第十课起环境配置部分按课程推荐虚拟机尝试。</p><hr><p>老师，为什么我用VMWare安装HelloOS.bin之后，虚拟机直接崩溃了呢。提示信息：“发生错误，导致虚拟COU进入关闭状态，如果虚拟机外部发生此错误，则可能已导致物理计算机重新启动......”</p><p>编辑回复: 推荐用vobx，vmware无法完全模拟~</p><hr><p>在linux mint 20.0中做的，前面编译，设置GRUB都正常，开机也出现“HelloOS”的GRUB启动项，但是选择启动项后，没有显示出“Hello World！”，系统进入黑屏。</p><p>作者回复: 看看你的机器是不是 GRUB</p></blockquote><h4 id="_02-virtualbox共享文件夹" tabindex="-1"><a class="header-anchor" href="#_02-virtualbox共享文件夹" aria-hidden="true">#</a> 02 VirtualBox共享文件夹</h4>',4),I={href:"https://www.youtube.com/watch?v=YSLNqXxyUtk",target:"_blank",rel:"noopener noreferrer"},T=e("p",null,"编辑回复: 感谢分享！",-1),q=s('<h4 id="_03-前置实验工具" tabindex="-1"><a class="header-anchor" href="#_03-前置实验工具" aria-hidden="true">#</a> 03 前置实验工具</h4><blockquote><p>10月30号凌晨完成了我的第一个HelloOS操作系统，我在完成这个作业后，回顾遇到的最大的坑，是刚安装的ubuntu里没有安装这个作业需要的各个程序，<br> 比如：nasm、make、gcc。<br> nasm （安装指令：sudo apt-get install nasm）<br> make （安装指令：sudo apt install make）<br> gcc （安装指令：sudo apt-get install gcc）<br> 把环境搭建准备充分，然后再根据课程里老师说的一步一步操作，<br> 遇到问题时，多到留言区看看已经完成的同学的分享里有没有正好你遇到的问题，<br> 如果没有，可以在百度里搜索，根据线索尝试解决。</p><p>作者回复: 哈哈 从初始化那里开始讲了怎么安装这些软件</p><hr><p>如何安装Id编译器？直接make Makefile看不到编译后的结果</p><p>作者回复: apt-get install ld</p><hr><p>为啥用nasm和gcc,ld搭配，不用as啊 有什么考虑么</p><p>作者回复: nasm写纯汇编 更好</p><hr></blockquote><h4 id="_04-timeout设置" tabindex="-1"><a class="header-anchor" href="#_04-timeout设置" aria-hidden="true">#</a> 04 timeout设置</h4><blockquote><p>我现在虚拟机开机就是直接进去HelloOS怎么办，没有grub界面能够选择从哪里启动。。。怎么办</p><p>编辑回复: grub中有个timeout 让其等于5秒,或者启动上按住shift键</p><hr><p>实验成功了，但是重新启动之后不会出现grub界面，而是默认进入HelloOS，请问要怎么显示grub命令选项啊</p><p>作者回复: grub中有个timeout 让其等于5秒,或者启动上按住shift键</p><hr></blockquote><h4 id="_05-grub-传统模式-uefi-黑屏" tabindex="-1"><a class="header-anchor" href="#_05-grub-传统模式-uefi-黑屏" aria-hidden="true">#</a> 05 GRUB/传统模式/UEFI（黑屏）</h4>',5),A=e("p",null,"怎么判断自己机器是否uefi，如果真的是uefi，如何执行HelloOS，往上找资料没有找到解决方案",-1),M={href:"https://github.com/Ruijie-Qin/CosmosExpEnv",target:"_blank",rel:"noopener noreferrer"},D=s("<hr><p>老师好，课件中的grub引导协议头是针对x86架构的，那其他架构的grub引导协议头该从什么地方查看呢</p><p>作者回复: GRUB 手册</p><hr><p>请教下各位，在grub阶段还没有加载系统，为啥有ext2文件系统，难道是grub自带的吗</p><p>作者回复: grub自己能被别 文件系统</p><hr><p>今天折腾了一下午，终于把HelloOS选项整出来了，但是我的点击选项进去也是黑屏， 我的电脑是UFEI，搭建环境 vmware16+ubuntu20， 右键看虚拟机的高级选项是BIOS，大佬能解答一下是怎么回事吗？一头雾水中。。。</p><p>编辑回复: 请设置GRUB转成传统模式，不支持UEFI。</p><hr><p>分区是gpt在uefi模式下启动的grub这个脚本支持吗 目前在调试过程中一直报找不到内核</p><p>作者回复: 不支持 UEFI</p><hr><p>我按照步骤可以看到grub增加的菜单项，但是进入后报grub_register_extcmd_lockdown</p><p>作者回复: 是不是 传统版本的GRUB</p><hr><p>UEFI的电脑进入helloOS后就是黑屏有啥解决办法吗</p><p>作者回复: 切换到传统模式</p><hr><p>我用VMware + Ubuntu 搭建HelloOS可以成功的打印HellOS,但学习后一些课程后,发现需要用ubuntu+虚拟机的环境,我用以前的电脑改成ubuntu系统,重新搭建HellOS,其他的都完成了,但最后一步选择HellOS打印内容时,打印的内容没有, 是不是实体机上哪个配置没配好?</p><p>作者回复: 实体机是否是UEFI</p><hr><p>感谢前面留言的各位同学，最终终于显示 Hello OS! 了，很是开心！ 最关键的一步，但是没搞清楚为什么。 把 /boot/grub/grub.cfg 文件中的 multiboot2 /boot/HelloOS.bin 改成 multiboot /HelloOS.bin 再次进入就显示 Hello OS! 了，而不是黑屏了。</p><p>作者回复: grub1吧</p>",24),F=s(`<h4 id="_06-lds文件-链接器脚本" tabindex="-1"><a class="header-anchor" href="#_06-lds文件-链接器脚本" aria-hidden="true">#</a> 06 lds文件：链接器脚本</h4><blockquote><p>想把内核编译成功还需要一个hello.lds文件，在配套代码里有这个文件，但是文稿里并没有对这个进行说明，老师可以讲一下这个文件的作用和里面代码的含义吗？</p><p>作者回复: 这是链接脚本 文件 参考 ld手册</p><hr><p>老师asm文件你讲解了结构，hello.lds 能不能大致讲解下 感觉与程序装载到内存中的布局有点关系</p><p>作者回复: 是的 ，lds是ld链接器脚本，用于组织二进制文件的内存布局的</p><hr><p>hello.lds 是什么作用的？</p><p>作者回复: 你好，这是链接脚本，ld链接器需要根据这个文件内容进行链接elf格式文件的</p><p>其他网友：链接器脚本，用于指导链接过程中程序段的布局</p><hr><p>hello.lds是要依据什么编写呢？</p><p>作者回复: 自己根据硬件定义</p><hr><p>Ubuntu16.04 64位上运行make，出现以下错误，麻烦老师看一下该如何修改啊🙏🙏 entry.asm:30: warning: dword data exceeds bounds ld：无法打开链接脚本文件 hello.lds：没有那个文件或目录 Makefile:37: recipe for target &#39;HelloOS.elf&#39; failed make: *** [HelloOS.elf] Error 1</p><p>作者回复: 看看有没有lds文件</p><hr><p>请问 Hello.lds 怎么来的？</p><p>作者回复: 自己的写的 链接脚本</p><hr><p>平时时间不多，折腾了好几天，终于可以启动看到Hello OS了。感谢老师和同学们的留言。 还有一些编译的参数不明白，感觉-w-orphan-labels是忽略符号引用，不知道对吗？ hello.lds 怎么来的也不明白，还有那个HelloOS.map在哪里？</p><p>作者回复: 你好， lds 文件 是链接器脚本 ，map文件是链接器 链接时输出的</p></blockquote><h4 id="_07-wsl2-wsl1" tabindex="-1"><a class="header-anchor" href="#_07-wsl2-wsl1" aria-hidden="true">#</a> 07 WSL2 &amp; WSL1</h4><blockquote><p>使用wsl2可以实现吗，还有个问题，这些代码文件使用vim写下来吗。看完这个，还是不太懂操作流程的具体情况怎么做</p><p>编辑回复: 你可以直接下载老师给的配套代码，再试着自己动手与创新。WSL2没法当做物理机用，需要个QEMU，可以参考下置顶的“pedro东哥”的分享记录。 另外，欢迎加入微信群（详情页有写加入链接），跟同学交流讨论哈。</p><hr><p>请问有用WSL2的同学吗，WSL2和正常的linux虚拟机不大一样啊，没有自带的grab...</p><p>作者回复: 是的</p><hr><p>纯小白<br> 问题1：wsl环境下找不到grub.cfg<br> 问题2：把grub安装到虚拟磁盘用virtual box启动显示COULD NOT READ BOOT MEDIUM<br> 作者回复: 问题1：wsl不行<br> 问题2：可能虚拟硬盘格式不对</p></blockquote><h4 id="_08-分区表-gpt-mbr-msdos-挂载" tabindex="-1"><a class="header-anchor" href="#_08-分区表-gpt-mbr-msdos-挂载" aria-hidden="true">#</a> 08 分区表/GPT/MBR/msdos（挂载）</h4><blockquote><p>老师，请问对于ssd该怎么写挂在分区呢？我的是dev/nvme0n1p11，按文中思路修改了序号，但选择后，grub报找不到，无法加载。</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>menuentry &#39;HelloOS&#39; {
     insmod part_msdos #GRUB加载分区模块识别分区
     insmod ext2 #GRUB加载ext文件系统模块识别ext文件系统
     set root=&#39;hd0,msdos11&#39;  #注意boot目录挂载的分区
     multiboot2 /boot/HelloOS.bin #GRUB以multiboot2协议加载HelloOS.bin
     boot #GRUB启动HelloOS.bin
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>作者回复: 分区表是 DBR 还是 GPT ?</p><p>网友回复：谢谢老师，我知道怎么回事了</p><hr><p>在ubuntu-22.04.1中,这段代码需修改为如下</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>menuentry &#39;HelloOS&#39; {
     insmod part_gpt #GRUB加载分区模块识别分区
     insmod ext2 #GRUB加载ext文件系统模块识别ext文件系统
     set root=&#39;hd0,gpt4&#39; #注意boot目录挂载的分区，这是我机器上的情况
     multiboot2 /boot/HelloOS.bin #GRUB以multiboot2协议加载HelloOS.bin
     boot #GRUB启动HelloOS.bin
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>作者回复: 你是 gpt 分区吧</p><hr><p>环境：ubuntu1~18.04，问题汇总如下：<br> 1、make: nasm: Command not found<br> apt-get install nasm<br> 2、启动没有选择界面<br> 修改/etc/default/grub中GRUB_TIMEOUT=0为GRUB_TIMEOUT=30 GRUB_TIMEOUT_STYLE=hidden修改为menu<br> 3、选择界面没有HelloOS<br> 进入grub命令行，找到正确的分区，再次修改.cfg文件，完成。<br> ps:我用df /boot/ 得出的结果是 /dev/sda2,和老师的对比后，想当然的填写为hd0,msdos2，实则不然，是hd0,gpt2!</p><p>作者回复: 你是 GPT分区</p><hr><p>答案copy自chartGPT：</p><p>在硬盘分区中，&quot;msdos&quot;是一种分区表类型，也称为MBR（Master Boot Record）分区表。MBR是一种旧的、基于BIOS的分区方案，它将硬盘分成四个主分区或三个主分区和一个扩展分区。每个主分区或扩展分区可以包含一个逻辑卷<code>[1][2][3]</code>。在Linux系统中，MBR通常用于引导操作系统，并且GRUB引导程序支持MBR格式的硬盘[4]。与MBR相对应的是GPT（GUID Partition Table）格式，它是一种新的、基于UEFI的分区方案，支持更大的磁盘容量和更多的分区<code>[1][2]</code>.</p><hr><p>用了虚拟机 virtual box 成功。但是 set root = &#39;hd0,gtp2&#39;, 而不是msdos2。 希望老师解释一下。谢谢。</p><p>作者回复: 因为你这是GPT分区模式</p><hr><p>写完grub.cfg之后是不是除了保存，还要update-grub呀，所有步骤都做了，但是选系统的时候还是看不到HelloOS. 但是我发现运行sudo update-grub之后我的改动就消失了，怎么办</p><p>编辑回复: msdoc6改成gpt6试试，也建议分享一下你的配置和进展，这样有助于其他人参考哈～</p></blockquote><h4 id="_09-bios流程" tabindex="-1"><a class="header-anchor" href="#_09-bios流程" aria-hidden="true">#</a> 09 BIOS流程</h4><blockquote><p>一、电脑开机按钮触发，BIOS开始工作<br> 二、BIOS检测和初始化CPU、内存、硬盘、主板，为C程序运行初始化必要的寄存器、栈、堆等<br> 三、BIOS从硬盘的第一扇区(512KB)拷贝引导程序到0x7c00内存位置（0x7c00是因为世界上第一台电脑的BIOS写入的内存地址就是0x7c00，之后的所有电脑为了兼容，就一直用这个内存地址了，总之，这个地址是写死的）<br> 四、将寄存器的值指向0x7c00</p><p>问：如何确定第一扇区<br> 答：当检测硬盘是，找到512字节的最后两个字节是0x55 0xaa 才确定这是第一扇区，也就是第一启动区</p><p>问：第一扇区的代码是干啥的？<br> 答：加载操作系统内核的，并且跳转到加载的地方<br> 作者回复: 问：如何确定第一扇区<br> 答：需要硬盘驱动根据ATA标准 驱动硬盘控制器 确定第一个扇区 0x55,0xaa是引导程序的标志，不一定是第一个扇区的标志</p><hr><p>编程主要步骤：<br> 1、汇编程序：用于初始化栈；<br> 2、C语言的主函数和字符输出函数；<br> 3、编写makefile，使用make工具进行编译；<br> 4、修改启动项，执行HelloOS</p><p>PC机的引导流程：PC机加电-&gt;加载PC机BIOS固件中的引导程序，这里是GRUB引导程序-&gt;GRUB引导（1.检测和初始化CPU内存和主板平台；2.加载引导设备中的第一个扇区数据到0x7c00处，然后跳到0x7c00处）-&gt;系统启动。<br> 作者回复: 是的</p></blockquote><h4 id="_10-注意grub-cfg备份快照" tabindex="-1"><a class="header-anchor" href="#_10-注意grub-cfg备份快照" aria-hidden="true">#</a> 10 注意grub.cfg备份快照</h4><blockquote><p>老师你好，我好像按照评论区同学的操作成功运行了，非常开心。但是我现在虚拟机已启动就是Hello OS !心情由开心又跌落到了谷底，如果我不能打开我的虚拟机，将非常难受，请问一下你知道怎么解决吗？非常感谢！</p><p>作者回复: 你是把 GRUB.cfg 文件覆盖了吧</p><p>其他网友：修改/etc/default/grub 文件后执行 update-grub 会覆盖/boot/grub/grub.cfg，所以同学们一定记住了，只能在update-grub 命令之后 给grub.cfg 文件添加启动项（menuentry）。 如果没快照备份建议重装吧，下回先存快照。</p><p>其他网友：你说的对，是的，现在看来只能重装了。在此给各位同学提个醒。</p><hr><p>有个小问题，就是grub.cfg里，无论我写multiboot 还是multiboot2 貌似都不影响启动，有高手给解惑下么？</p><p>作者回复: 因为我的imghead.asm文件中，包含了multiboot和multiboot2两个引导头，所以可以兼容</p><hr><p>只成功了一半。可惜不能发图片，现在我只能看到Hello OS ，进不去我的ubuntu了(vm虚拟机)</p><p>作者回复: 别灰心，一步步慢慢的来</p><p>其他网友：我恢复快照了，哈哈哈，实验之前做了个快照，我也是始终退不出来了，mac里面的parallels</p><p>其他网友：看小伙伴们的评论解决了，按住esc可以进grub菜单，然后选择系统。温馨提示，请最好不要将grub.cfg内容放到ubuntu前面</p><hr><p>打开/boot/grub/grub.cfg之后发现grub.cfg允许定义custom的配置，所以把琼配置放到/boot/grub/custom.cfg也可以，验证有效。</p><p>作者回复: 6666，探索精神可嘉</p><hr><p>重启VM后为什么只有HELLO OS弹出来，没有GRUB显示啊，然后现在打开虚拟机都进不了ubuntu…</p><p>作者回复: 你肯定是覆盖了grub.cfg 的其它数据了</p><hr><p>我在台式机上(Ubuntu系统)按照教程来做，由于我有四块硬盘，虽然在grub命令行里边，确定了HelloOS.bin就是在(hd3,msdos2)/boot/下面，但是grub启动选择HelloOS以后，死活都是说找不到(hd3,msdos2)。然后换了一台windows笔记本，里面装了Ubuntu虚拟机，按照教程做以后，成功了。。。最终没搞明白，到底是哪里有问题。</p><p>作者回复: 那是grub.cfg配置的问题</p><hr></blockquote><h3 id="环境搭建-偏总结" tabindex="-1"><a class="header-anchor" href="#环境搭建-偏总结" aria-hidden="true">#</a> 环境搭建（偏总结）</h3><h4 id="_0-只会java怎么办" tabindex="-1"><a class="header-anchor" href="#_0-只会java怎么办" aria-hidden="true">#</a> 0 只会Java怎么办</h4>`,12),L=e("br",null,null,-1),P={href:"https://blog.csdn.net/chenchengwudi/article/details/116707122%EF%BC%89%EF%BC%8C%E7%84%B6%E5%90%8E%E4%B8%8B%E8%BD%BD%E4%BA%86%E8%80%81%E5%B8%88%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%8C%E6%9C%80%E7%BB%88%E5%B1%85%E7%84%B6%E8%BF%98%E6%98%AF%E8%B7%91%E5%87%BAHello",target:"_blank",rel:"noopener noreferrer"},N=e("br",null,null,-1),V=e("br",null,null,-1),j=e("br",null,null,-1),W=e("br",null,null,-1),$=e("br",null,null,-1),z=e("br",null,null,-1),Q=e("br",null,null,-1),Y=e("br",null,null,-1),K=e("br",null,null,-1),X=e("br",null,null,-1),J=e("br",null,null,-1),Z=s(`<p>其他网友：多谢，你是这么多的回答中，唯一一个能够全部看懂的。<br> 补充一句，分享给大家，在写hd0,msdos3的时候，可以往文件上边翻一翻，看看里面写的是不是gpt3.与环境中自带的部分为准。我就是这样解决的。</p><p>其他网友：刚看完第二课，完全没看懂，本来想放弃了刷到了你，决定再坚持一下</p><p>其他网友：太感谢了，小白从没用过linux，要不是老哥的帮助我可能就放弃了</p><hr><p>其他网友：我使用的vm+ubuntu20.4，發現</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>menuentry &#39;HelloOS&#39; { 
    insmod part_msdos  
    set root=&#39;hd0,msdos4&#39; #注意boot目录挂载的分区，这是我机器上的情况 
    multiboot2 /boot/HelloOS.bin 
    boot }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>需要修改成：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>menuentry &#39;HelloOS&#39; { 
    insmod part_gpt  
    set root=&#39;hd0,gpt4&#39; #注意boot目录挂载的分区，这是我机器上的情况 
    multiboot2 /boot/HelloOS.bin 
    boot }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><p>Command &#39;make&#39; not found, but can be installed with:<br> sudo apt install make # version 4.2.1-1.2, or<br> sudo apt install make-guile # version 4.2.1-1.2<br> 这是啥意思？<br> 其他网友：你的系统没有安装make软件，所以无法使用此命令，按照下面的提示，输入那一串代码sudo apt install make # version 4.2.1-1.2安装完成，就可以了。</p><hr><p>你有遇到过这个问题吗？<br> ld: cannot represent machine \`i386&#39;<br> 其他网友：是m1处理器吗，我的也报这样的错误，请问是怎么解决的</p>`,12),ee=e("h4",{id:"_1-不在物理机上-用qemu模拟",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_1-不在物理机上-用qemu模拟","aria-hidden":"true"},"#"),n(" 1 不在物理机上，用QEMU模拟")],-1),ne={href:"https://github.com/xymeng16/helloOS%EF%BC%8C%E4%B8%8D%E6%83%B3%E6%B7%B1%E7%A9%B6%E7%9B%B4%E6%8E%A5make",target:"_blank",rel:"noopener noreferrer"},se=s(`<p>作者回复: 666666</p><hr><p>不想在物理机上搞的同学们，可以参考一下我的 repo。如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> clone https://gitee.com/gaopedro/pos
<span class="token builtin class-name">cd</span> pos 
<span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> umount_image
<span class="token function">make</span> qemu
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，在 linux 操作系统下操作，记得下载 qemu，如：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> qemu
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样就可以直接在 qemu 上跑出 hello world了~</p><p>网友自己补充更正：有一个地方写错了，应该是: make update_image，不是: make umount_image</p><p>作者回复: 很牛啊</p><hr><p>其他网友：用qemu就没那感觉了<br> 其他网友：要的不是感觉，要的是能方便快速的建立环境学习</p><hr><p>输入这个命令之后，出现了这个问题有大佬帮忙看看嘛<br> make qemu<br> WARNING: Image format was not specified for &#39;floppy.img&#39; and probing guessed raw.<br> Automatically detecting the format is dangerous for raw images, write operations on block 0 will be restricted.<br> Specify the &#39;raw&#39; format explicitly to remove the restrictions.<br> VNC server running on 127.0.0.1:5900</p>`,13),le=e("br",null,null,-1),ae={href:"https://stackoverflow.com/questions/47235461/how-to-resolve-specify-the-raw-format-explicitly-to-remove-the-restrictions",target:"_blank",rel:"noopener noreferrer"},oe=s("<p>其他网友：这个提示是qemu没有支持SDL，需要下载库。或者可以下载个vnc viewer看也行</p><hr><p>请问执行sudo apt-get install qemu后，qemu指令和qemu-system-i386指令都不存在是为什么？再执行一遍install qemu,提示是qemu is already the newest version (1:4.2-3ubuntu6.14).0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.用的是win10的wsl，发行版是ubuntu20.04.2</p><p>其他网友：可以试试在命令行中打上 qemu 然后再按 tab 键试试，可能这个架构下的命令有所改变，找到了再替换makefike</p><p>其他网友：我也遇到了这个问题，原因是qemu的发展导致qemu需要分几个包来安装, 需要再安装对应架构下的包, 如: apt install -y qemu-system-x86<br> 其他网友：请问哪里看mips是不是也有对应的包呢？<br> 其他网友：把命令中的x86换成misp就可以了</p><hr><p>hello, 看了你的makefile，然后了解了一下qemu，因为是头一次听说这个东西，所以我有一些疑问，还请解答一下，万分感谢，疑问如下：<br> 你的Makefile里，update_image部分，用到了一个floppy.img，我理解这是用于模拟软盘挂载的，也就是将helloOS系统放到这个软盘里，然后通过qemu模拟软盘的挂载来达到启动系统的目的，那么这个floppy.img文件是哪里来的呢？ 是随便找一个空文件，命名成这样，然后把系统放进去就可以吗？ 还是说有特别的格式？</p><p>其他网友：你理解的是对的，这个软盘就是模拟启动盘，但是这个软盘不是随便做的，而且根据具体规则来做的，具体做法可以Google，软盘已经差不多被淘汰了，但有时还是比较有用的</p><hr><p>make &amp;&amp; make update_image<br> mount: /mnt/kernel: mount point does not exist.<br> make: *** [Makefile:48: update_image] Error 32</p><p>其他网友：先 sudo mkdir /mnt/kernel<br> 其他网友：还是显示<br> umount: /mnt/kernel: not mounted.<br> make: *** [Makefile:54：umount_image] 错误 32</p><p>其他网友：老哥最后怎么解决的，我这边一直提示Operation not permitted<br> 其他网友：试试把子系统升级到wsl2<br> 其他网友：直接注释掉，就可以跑了，但是wsl要升级到wsl2，并支持gui</p>",12),te=e("h4",{id:"_2-虚拟机实验模拟",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_2-虚拟机实验模拟","aria-hidden":"true"},"#"),n(" 2 虚拟机实验模拟")],-1),ie=e("br",null,null,-1),re={href:"https://blog.csdn.net/chenchengwudi/article/details/116707122",target:"_blank",rel:"noopener noreferrer"},de=e("br",null,null,-1),pe=s("<p>其他网友：很棒，谢谢。 引导界面部分正好解决了我的问题。</p><p>其他网友：感谢大佬, 引导部分也解决了我的问题, 假如是Ubuntu20最新版进入GRUB启动项, 可以在<code>/etc/default/grub</code>设置<code>GRUB_TIMEOUT_STYLE=menu</code>和<code>GRUB_TIMEOUT=10</code>, 取消<code>GRUB_TERMINAL=console</code>的注释, 然后执行<code>sudo update-grub</code>, 最后再去<code>/boot/grub/grub.cfg</code>添加<code>menuentry</code></p><p>其他网友：感谢感谢，很有用，我刚开始还设置了<code>/etc/default/grub</code>文件中的GRUB_CMDLINE_LINUX_DEFAULT=&quot;text&quot;,结果就一直进不了Hello OS，后来又改成 GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash&quot; 就可以了</p><p>其他网友：请教一下，为什么我把<code>GRUB_TERMINAL=console</code>的注释取消掉之后，点击进入helloOS,提示WARNING: no console will be avaiable to OS</p><hr><p>grub文件 是只读文件，折腾了一会，修改不了，求助求助<br> 其他网友：grub文件 是只读文件，折腾了一会，修改不了，求助求助</p><hr><p>我遇到了一个问题就是先把menuentry 添加到grub.cfg中 然后执行了update-grub 发现我添加的那端代码没有了,然后我再次添加上之后,不执行update-grub后 重启就可以了</p><hr><p>我遇到了一个问题就是先把menuentry 添加到grub.cfg中 然后执行了update-grub 发现我添加的那端代码没有了,然后我再次添加上之后,不执行update-grub后 重启就可以了<br> 其他网友：可以改的 开机按shifit 选择启动项</p><hr><p>使用virtualbox+ ubuntu16.04版本，创建新的启动bin时，由于/dev/sda1挂载点是/boot，所以在设置multiboot2项时，需要修改为/HelloOS.bin，目录中不能再添加boot路径</p><hr><p>VMware虚拟机中使用Ubuntu16.04 32位机器测试，64位是长模式。<br> 上述环境常见问题：<br> 1\\insmode ext？不知道填几？<br> 先df /boot 找到/dev?/sda?, 然后mount | grep /dev?/sda? 可以找到ext？<br> 2\\配置/boot/grub/grub.cfg，不知道set root=‘hdx,msdosx’<br> 使用df /boot 后会出现/dev？/sda？ dev后面无信息就是0，代表第一块硬盘，1-代表第二块硬盘。sdax，?代表第几扇区，对应填到上面就行<br> 3\\重启后没有grub选择框<br> 修改/etc/default/grub 配置文件注释掉grub_default和grub_hidden_timeout<br> 然后sudo update-grub，<br> 此时再注意一下，修改过的/boot/grub/grub.cfg需要重新添加HelloOS的启动项。</p><p>作者回复: 是的</p><hr><p>项目完成中遇见的问题：</p><p>1、重启机器后无法进入GRUB界面<br> 问题描述：我在安装Ubuntu20的联想笔记本物理机上进行实验，多次重启，均无法进入GRUB界面。</p>",18),ue=e("br",null,null,-1),ce={href:"https://blog.csdn.net/chenchengwudi/article/details/116707122%EF%BC%89%EF%BC%8C%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9/etc/default/grub%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE%EF%BC%8C%E5%B0%A4%E5%85%B6%E6%98%AFGRUB%E7%95%8C%E9%9D%A2%E6%98%BE%E7%A4%BA%E6%97%B6%E9%97%B4GRUB_TIMEOUT%E5%AD%97%E6%AE%B5%E5%80%BC%EF%BC%8C%E6%88%91%E6%96%87%E4%BB%B6%E4%B8%AD%E9%BB%98%E8%AE%A4%E4%B8%BA0%EF%BC%8C%E6%84%8F%E5%91%B3%E7%9D%80GRUB%E7%95%8C%E9%9D%A2%E6%98%BE%E7%A4%BA%E6%97%B6%E9%97%B4%E4%B8%BA0%EF%BC%8C%E6%89%80%E4%BB%A5%E6%97%A0%E6%B3%95%E8%BF%9B%E5%85%A5%EF%BC%8C%E4%BF%AE%E6%94%B9%E5%80%BC%E4%B8%BA30%E5%90%8E%E5%8F%AF%E6%AD%A3%E5%B8%B8%E8%BF%9B%E5%85%A5%E3%80%82",target:"_blank",rel:"noopener noreferrer"},be=e("p",null,[n("2、在GRUB界面选择HelloOS选项，报错secure boot forbids loading module from ....."),e("br"),n(" 问题描述：在选择HelloOS作为启动的操作系统后，有两条报错信息，其中一条是ecure boot禁止加载。几秒后自动回到GRUB初始界面。")],-1),me=e("br",null,null,-1),he={href:"https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=958894%E6%9C%89%E7%B1%BB%E4%BC%BC%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0%EF%BC%8C%E5%85%B6%E4%B8%AD%E6%8F%90%E4%BE%9B%E7%9A%84%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF%E6%98%AF%E5%9C%A8BIOS%E4%B8%AD%E4%BF%AE%E6%94%B9security%E4%B8%AD%E7%9A%84secure",target:"_blank",rel:"noopener noreferrer"},ve=e("h4",{id:"_3-docker的demo-一键版",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_3-docker的demo-一键版","aria-hidden":"true"},"#"),n(" 3 Docker的demo/一键版")],-1),ge=e("br",null,null,-1),_e={href:"https://github.com/vizv/learn_os/tree/master/hello-os",target:"_blank",rel:"noopener noreferrer"},ke=s("<p>克隆仓库后在 hello-os 目录里</p><p>只编译链接并创建镜像：<br> make hello-os.img</p><p>编译链接并创建镜像后用 QEMU 启动磁盘镜像：<br> make</p><p>编辑回复: 6666，佩服佩服，感谢你的分享！教学相长，期待之后课程里，你还有更多的输出。<br> 其他网友：你这个docker版本太好了~~感谢分享<br> 其他网友：加了 Dockerfile 可以跑在任何平台了，用 curses 作为 QEMU 显示模式理论上可以在 WSL 里跑（保证窗口有 25 行否则看不见输出），添加了汇编和链接脚本的注释和相关资料方便学习。<br> 顺便提示下在 QEMU 的 curses 显示中可以用 Alt+2 切换到控制台用 q 或者 quit 命令退出<br> 其他网友：不只是docker，而且还不是 grub 的引导，而是 MBR 引导，这是真看进去了<br> 其他网友：666666 mac 平台也可以 感谢感谢 哈哈哈<br> 其他网友：我Mac系统，用你这个docker版本，几分钟就跑起来demo了，上面另一个同学的版本我搞了半天没搞定。。mac下的 ld 和 cc 感觉和 Linux下还是不太一样。。。</p><hr>",5),fe={href:"https://github.com/danie1Lin/HardLowWorld",target:"_blank",rel:"noopener noreferrer"},xe=e("p",null,"作者回复: 精英",-1),Se=e("h4",{id:"_4-虚拟机again",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_4-虚拟机again","aria-hidden":"true"},"#"),n(" 4 虚拟机Again")],-1),Be=s("<p>终于试成功了，超开心！<br> &#39;Hello OS&#39;<br> 我是使用虚拟机<br> df /boot/<br> 显示的是<br> Filesystem 1K-blocks Used Available Use% Mounted on<br> /dev/vda1 50633164 1340568 49276212 3% /</p><p>一直遇到 error : file &#39;/boot/HelloOS.bin&#39; not found<br> 后来看到网上有文章介绍grub rescue的模式，<br> 在grub boot menu里运行command line, 在boot menu按&#39;c&#39;可进到grub的互动模式<br> grub&gt;<br> grub&gt; ls<br> (hd0, gpt15) (hd0, gpt14) (hd0, gpt1)<br> 可看到多个分区，一个个确认，直到能正确看到/boot/下的档案表示这个分区是正确的分区<br> 不正确的分区<br> grub&gt; ls (hd0,gpt15)/boot<br> unknown filesystem<br> 一直到能正确显示档案系统<br> grub&gt; ls (hd0,gtp1)/boot</p><p>重新开机到原来linux kernel的选项<br> 编辑<br> /boot/grub/grub.cfg<br> 以我的虚拟机的设定<br> set root=&#39;hd0, gpt1&#39;<br> 存档，重开机<br> 大功告成！</p><p>编辑回复: 太赞了，不但自己实战，还分享给大伙经验了，良性循环，666</p><p>其他网友：解决了我的问题 我的是挂载点是 /dev/nvme1n1p6 用你的方法找到了正确配置</p><p>其他网友：也适用其他 linux 的方式，也是进入 grub 命令行，然后echo $prefix 可以直接看出挂载的盘，可以 ls 进入，进入后如果没有 boot 可以将 HelloOS.bin 复制到其他地方</p><p>其他网友：牛，对grub不熟悉，刚才浪费好多时间。</p><hr>",8),Oe={href:"https://zhuanlan.zhihu.com/p/373996858",target:"_blank",rel:"noopener noreferrer"},Ee=s("<p>作者回复: 谢谢</p><hr><p>Ubuntu20.04添加grub方法。</p><p>1\\修改/etc/default/grub， <code>GRUB_TIMEOUT_STYLE=hidden</code>改为<code>GRUB_TIMEOUT_STYLE=menu</code>，然后修改<code>GRUB_TIMEOUT=10</code>，然后记得把<code>GRUB_TERMINAL=console</code>反注释掉(去掉前边的#)，否则可能不显示grub菜单。</p><p>2\\添加该节对应的菜单到<code>/etc/grub.d/40_custom</code>中。</p><p>3\\执行<code>sudo update-grub</code>，重启。</p><hr><p>更换为Ubuntu镜像，首次尝试20.04版本，但是发现Parallel Tools安装不上，网上有个解释的是kernel版本过高，建议更换成16.04。</p><p>使用Ubuntu 16.04版本，遇到了两个问题:</p><p>1）/boot/grub/grub.cfg是只读状态，是通过update-grub更新的。所以在<br> /etc/grub.d/40_custom加入启动选项命令，并且执行update-grub，查看/etc/grub/grub.cfg中已更新</p><p>2）reboot之后grub没有停顿，编辑/etc/default/grub，注释<code>GRUB_HIDDEN_TIMEOUT=0</code>这一行重新启动就可以看到菜单了。进入菜单，果然可以看见Hello OS</p><p>建议老师可以建议一个环境，比如ubuntu的版本。<br> 作者回复: 好的</p><hr><p>虚拟机系统用的Ubuntu20.04，设置开机进入grub引导界面，需要修改配置文件/etc/default/grub 1.grub_timeout_style=hidden 注释掉<br> 2.GRUB_TIMEOUT=30, 设置为30<br> 3.grub_cmdline_linux_default 修改为text<br> 保存之后，执行 sudo update-grub2 。<br> 然后根据文章内容，进行HelloOS的安装。</p><p>作者回复: 你好，这也可以</p>",15),Ue=s(`<h4 id="_5-m1的mac电脑" tabindex="-1"><a class="header-anchor" href="#_5-m1的mac电脑" aria-hidden="true">#</a> 5 M1的Mac电脑</h4><blockquote><p>我在 M1 上跑成功了（@Shinymimiq 的基础上，感谢），不需要切换到 x86 的 homebrew<br> 也不需要使用 Rosetta 转义的 iTerm2，去官网下载预览版的 iTem2，支持 arm64</p><p>安装的 nasm 和 gcc 以及 ld 以及 qemu 等都是 arm64 架构上的可执行程序，性能大幅提升</p><p>我的环境配置：<br> ASM := /opt/homebrew/Cellar/nasm/2.15.05/bin/nasm<br> CC := /opt/homebrew/Cellar/x86_64-elf-gcc/11.1.0/bin/x86_64-elf-gcc<br> LD := /opt/homebrew/Cellar/x86_64-elf-binutils/2.36.1/bin/x86_64-elf-ld</p><p>速度比 @Shinymimiq 的要快一个数量级，这个 hello os 编译+启动不到 200ms</p><p>在 M1 上又可以愉快地玩耍了~~<br> 作者回复: 666</p><hr><p>我测试了一下M1的Mac也是能跑起了HelloOS的，虽然坑比较多。我大致总结了一下步骤：</p><p>首先需要安装x86版的homebrew<br> 用Rosetta 打开iTerm<br> 然后安装x86的homebrew<br><code>arch -x86_64 /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&quot;</code></p><p>接下来是重点, Apple自带的C/C++工具链是clang，外加用的linker和GUN linker不兼容，没办法使用课程中提供的linker script，所以我们需要编译安装x86的gcc工具链，顺便可以把nasm和qemu给装了</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>/usr/local/bin/brew tap nativeos/i386-elf-toolchain
/usr/local/bin/brew install i386-elf-binutils i386-elf-gcc nasm qemu
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>安装完成之后确认一下我们的gcc和ld</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>/usr/local/Cellar/i386-elf-gcc/9.2.0/bin/i386-elf-gcc
/usr/local/Cellar/i386-elf-binutils/2.31/bin/i386-elf-ld
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来的步骤我参考了Viz的评论，代码是在<br><code>https://github.com/vizv/learn\\_os/tree/master/hello-os</code></p><p>可以手动修改Makefile里面的宏</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>ASM := /usr/local/Cellar/nasm/2.15.05/bin/nasm
CC  := /usr/local/Cellar/i386-elf-gcc/9.2.0/bin/i386-elf-gcc
LD  := /usr/local/Cellar/i386-elf-binutils/2.31/bin/i386-elf-ld
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>顺带一提，我使用iTerm跑还需要在qemu命令上加上-nographic，不然好像没法退出</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>qemu-system-x86_64 -nographic -curses -drive &#39;file=$&lt;,format=raw,index=0,media=disk&#39;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后直接<code>make all</code>就可以运行我们的hello-os了</p><p>作者回复: 你好，感谢你的分享，m1的同学有福了</p><p>其他网友：补充下，objcopy也要替换成/usr/local/Cellar/i386-elf-binutils/2.31/bin/i386-elf-objcopy,mac 默认是不带的</p><p>其他网友：按照这个我的intel黑苹果也跑起来了，怒赞</p><hr><p>感谢，补充一下我遇到的问题</p><p>在 m1 上 使用 /usr/local/bin/brew 会报以下的错误</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>/usr/local/bin/brew <span class="token function">install</span> i386-elf-gcc
Error: Cannot <span class="token function">install</span> <span class="token keyword">in</span> Homebrew on ARM processor <span class="token keyword">in</span> Intel default prefix <span class="token punctuation">(</span>/usr/local<span class="token punctuation">)</span><span class="token operator">!</span>
Please create a new installation <span class="token keyword">in</span> /opt/homebrew using one of the
<span class="token string">&quot;Alternative Installs&quot;</span> from:
  https://docs.brew.sh/Installation
You can migrate your previously installed formula list with:
  brew bundle dump
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>需要将 <code>/usr/local/bin/brew</code> 改为 <code>arch -x86_64 brew</code> 才能生效.即:</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>arch <span class="token parameter variable">-x86_64</span> brew <span class="token function">install</span> i386-elf-gcc
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><hr><p>## 环境：<br> macOS 10.15.7 + VirtualBox 6.1.22 + ubuntu-20.04.2<br> ## GRUB启动项配置/boot/grub/grub.cfg</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>menuentry &#39;HelloOS&#39; {
    insmod part_gpt
    insmod ext2
    set root=&#39;hd0,gpt2&#39;
    multiboot2 /HelloOS.bin
    boot
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>## 其他<br> ### 确认分区信息方法<br> root@workstation:~# df /boot/<br> Filesystem 1K-blocks Used Available Use% Mounted on<br> /dev/sda2 999320 108196 822312 12% /boot<br> root@workstation:~# parted<br> GNU Parted 3.3<br> Using /dev/sda<br> Welcome to GNU Parted! Type &#39;help&#39; to view a list of commands.<br> (parted) print<br> Model: ATA VBOX HARDDISK (scsi)<br> Disk /dev/sda: 32.2GB<br> Sector size (logical/physical): 512B/512B<br> Partition Table: gpt<br> Disk Flags:</p><p>Number Start End Size File system Name Flags<br> 1 1049kB 2097kB 1049kB bios_grub<br> 2 2097kB 1076MB 1074MB ext4<br> 3 1076MB 32.2GB 31.1GB</p><p>可见/dev/sda2 挂在/boot而不是/，分区表为GPT而不是MBR<br> ### 方便进入GRUB启动菜单/etc/default/grub<br> #GRUB_TIMEOUT_STYLE=hidden<br> GRUB_TIMEOUT=10<br> 作者回复: 大写66666</p></blockquote><h4 id="_6-boot挂载-分区-路径-填坑记录" tabindex="-1"><a class="header-anchor" href="#_6-boot挂载-分区-路径-填坑记录" aria-hidden="true">#</a> 6 boot挂载/分区/路径/填坑记录</h4><blockquote><p>补充两个我遇到的坑：<br> 1、如何确定boot挂载的分区，参考Geek_993581提供的方法，在grub命令行里确认。<br> set root=&#39;hd0,msdos4&#39; #注意boot目录挂载的分区，修改为自己的分区。<br> 我自己的是（hd0,gpt2）。<br> 把insmod part_msdos 修改为 part_gpt。<br> 2、很多同学遇到说HelloOS.bin找不到<br> 这个就是要确认boot的挂在路径是/还是/boot</p><p>文件系统 1K-块 已用 可用 已用% 挂载点<br> /dev/sda4 48752308 8087584 38158536 18% /<br> 如果跟老师一样，不用修改。<br> 但是如果挂载点是/boot，需要把路径改为multiboot2 /HelloOS.bin<br> 当然你也可以在grub命令行里面确认，<br> 如果ls (hd0,gpt2)/boot 找不到boot目录，就 ls (hd0,gpt2)/，如果能看到HelloOS.bin,说明grub把boot设为root，路径前面不需要加boot了。</p><p>作者回复: 你是对的 正确<br> 其他网友：超棒! 解决了我的问题!<br> 其他网友：我是vmware ubuntu18 ，按照上面的改完终于可以了<br> 其他网友：我用的centos，遇到这个问题了，感谢老哥！！<br> 其他网友：谢谢，在fedora运行时需要这样处理<br> 其他网友：跟你的情况一模一样，感谢避坑！</p><hr><p>在输入df /boot/ 时，要注意下【挂载点】的值是/还是/boot，东哥这里是/；如果是/boot，就要注意在修改/boot/grub/grub.cfg文件时，multiboot2这一项直接填写/HelloOS.bin即可，而不需要在前面加/boot了，因为/boot被划分为单独的分区了，即： multiboot2 /HelloOS.bin #GRUB以multiboot2协议加载HelloOS.bin</p><p>此外，还可以参考楼上Geek_993581的回答去验证HelloOS.bin的位置</p><p>编辑回复: 感谢老铁的优质分享！</p><p>其他网友：谢谢，刚刚遇到了这个问题，启动之后提示/boot/HelloOS.bin不存在，再看挂载点是/boot，根据评论内容改为/HelloOS.bin解决了该问题</p><hr><p>补充一点对于内核文件路径设定的方案。<br> 尝试过@Vic， @陈诚 ， 的方案。<br> 进入过grub模式查看硬盘下的路径，但是仍然遇到error : file &#39;/boot/HelloOS.bin&#39; not found的问题。</p><p>因此，我这边参考了grub.cfg里面，“Ubuntu”的设置：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>menuentry &#39;Ubuntu&#39; --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option &#39;gnulinux-simple-c2b35b75-3fa4-4021-b628-65742342045e&#39; {
        insmod gzio
        insmod part_msdos
        insmod ext2
        set root=&#39;hd0,msdos1&#39;
        initrd  /initrd.img-4.4.0-57-generic
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以发现，默认载入时就已经以/boot为根目录， 因此，我也照葫芦画瓢，没有额外设定/boot目录。</p><p>重新启动，就可以成功运行HelloOS内核了。</p><p>作者回复: 是的 要看看你的boot目录的挂载路径</p><hr><p>按照陈诚同学教程，以及遇到问题搜索答案的方针(很庆幸有互联网的存在)，最后终于把HelloOS给搞出来啦;)<br> 有一点我想表达的是(自己通过动手实践得出的):<br> multiboot2后面的地址 /boot/HelloOS.bin这个路径，应该是在grub命令行里面，进入相应硬盘分区以后，<br> 找到的HelloOS.bin文件的路径(比如我的文件是放在/boot/目录下面，但是开机进入grub命令行模式里，<br> 在(hd0,gpt2)/这个目录下显示HelloOS.bin文件的)；<br> #ps<br> 贴一个我在/boot/grub/grub.cfg文件中添加的配置：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>menuentry &#39;HelloOS&#39; {
     insmod part_gpt #我这里的是gpt分区，所以这里也改了一下
     insmod ext2 #GRUB加载ext文件系统模块识别ext文件系统
     set root=&#39;hd0,gpt2&#39; #注意boot目录挂载的分区，这是我机器上的情况
     multiboot2 /HelloOS.bin #我这里的配置没有/boot，原因是在(hd0,gpt2)/里面就没有boot文件夹
     boot #GRUB启动HelloOS.bin
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>作者回复: 66666，加油</p><hr><p>我的硬盘分区(hd0,msdos1)下看不到 /boot/ /root/ /sys/ 等目录，直接看到/boot 目录下的文件， 我把multiboot2 /boot/HelloOS.bin改为multiboot2 /HelloOS.bin可以启动helloOS，老师这是怎么回事？</p><p>作者回复: 这是因为 分区 挂载 问题</p><hr><p>编译完后要把bin文件放到/boot下才能生效</p><p>作者回复: 对的</p></blockquote><h4 id="_7-其他重要补充解释-注意事项" tabindex="-1"><a class="header-anchor" href="#_7-其他重要补充解释-注意事项" aria-hidden="true">#</a> 7 其他重要补充解释/注意事项</h4>`,5),He=e("p",null,[n("有几点要注意的："),e("br"),n(" 1、注意写bruf.cfg时要用 sudo 命令"),e("br"),n(" 2、使用 df /boot/ 命令查看即可，按着教程来就行"),e("br"),n(" 3、注意在重启或关机后，开机时使劲狂按ESC键才可以进入选项界面"),e("br"),n(" 作者回复: 也可以把timeout 数值 改大一点")],-1),Ge=e("hr",null,null,-1),Ce=e("br",null,null,-1),Re=e("br",null,null,-1),we=e("br",null,null,-1),ye={href:"https://blog.csdn.net/yjj350418592/article/details/121759907?spm=1001.2014.3001.5501",target:"_blank",rel:"noopener noreferrer"},Ie=e("br",null,null,-1),Te=e("br",null,null,-1),qe=e("br",null,null,-1),Ae=e("br",null,null,-1),Me=e("br",null,null,-1),De=e("br",null,null,-1),Fe=s(`<hr><p>环境是VMware15.5+Ubuntu18.04（大部分评论都看了呢）<br> grub.cfg文件最后插入：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> menuentry &#39;HelloOS&#39; {
    insmod part_msdos  #没问题
    insmod ext2
    set root=&#39;hd0,msdos1&#39; #注意boot目录挂载的分区，这是我机器上的情况  :/dev/sda1
    multiboot2 /boot/HelloOS.bin
    boot
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过ls /sys/firmware/efi 看是BIOS启动（百度）<br> 没出现任何报错，重启后没有显示Helloos 选项<br> 编辑回复: 不支持EFI，你换下传统模式</p><hr><p>试了5次 😐😓😳🤣🤩终于输出了Hello OS!, 实验环境 VMFusion + Ubuntu20.04.2.0，参考了一些其他同学的记录，其中修改/etc/default/grub 文件后执行 update-grub 会覆盖/boot/grub/grub.cfg，所以同学们一定记住了，只能在update-grub 命令之后 给grub.cfg 文件添加启动项（menuentry）.</p><p>作者回复: 哈哈</p><hr><p>终于出了Hello OS!其中遇到两个坑<br> 1、同很多人遇到的boot的挂在路径问题<br> 2、使用 multiboot2能跑起来，但是什么都不显示，换成使multiboot就可以了，这是为什么，是我环境缺了什么吗，求教<br> 作者回复: 有可能 是用了 EFI 模式的GRUB</p><hr><p>实际上boot目录只是一个目录，helloos文件可以放到其它目录，只要把grub.cfg里面相应位置改下就行了。把内核文件放到boot目录是一个既定的做法，目录下面有个vmlinuz-xxx就是Ubuntu的内核镜像。另外grub本身带有ext驱动，所以可以访问文件系统，取出你的内核镜像执行。</p><p>编辑回复: 对的，666！期待你的更多精彩分享～</p><hr>`,13),Le=e("br",null,null,-1),Pe=e("br",null,null,-1),Ne=e("br",null,null,-1),Ve=e("br",null,null,-1),je=e("br",null,null,-1),We={href:"https://blog.csdn.net/qq_44641344/article/details/104355359?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-0&spm=1001.2101.3001.4242",target:"_blank",rel:"noopener noreferrer"},$e=s(`<p>作者回复: 谢谢</p><hr><p>实验注意几个关键问题。</p><p>1-、将作者提供的代码git到本地；</p><p>2-、安装nasm、gcc等工具，否则make不通过。随后执行“make -f Makefile”，得到HelloOs.bin；</p><p>3-、在/boot/grub/grub.cfg中添加如下引导内容：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>menuentry <span class="token string">&#39;HelloOS&#39;</span> <span class="token punctuation">{</span>
     insmod part_msdos <span class="token comment">#GRUB加载分区模块识别分区</span>
     insmod ext2 <span class="token comment">#GRUB加载ext文件系统模块识别ext文件系统</span>
     <span class="token builtin class-name">set</span> <span class="token assign-left variable">root</span><span class="token operator">=</span><span class="token string">&#39;hd0,msdos1&#39;</span> <span class="token comment">#注意boot目录挂载的分区，这是我机器上的情况</span>
     multiboot2 /boot/HelloOS.bin <span class="token comment">#GRUB以multiboot2协议加载HelloOS.bin</span>
     boot <span class="token comment">#GRUB启动HelloOS.bin</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>4-、其中set root=&#39;hd0,msdos1&#39;根据/boot挂载的实际情况填写，如我的机器是：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>  <span class="token comment">#其中set root=&#39;hd0,msdos1&#39;根据/boot挂载的实际情况填写，如我的机器是：</span>
  ubuntu@ubuntu-virtual-machine:~$ <span class="token function">df</span> /boot
  Filesystem     1K-blocks    Used Available Use% Mounted on
  /dev/sda1       <span class="token number">20509264</span> <span class="token number">7482912</span>  <span class="token number">11961496</span>  <span class="token number">39</span>% /
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>5-、将HelloOs.bin拷贝到/boot/目录；</p><p>6-、重启机器，vmvare长按shift进入引导页面，可以看到HelloOS，选择HelloOS进入。</p><p>作者回复: 对的</p><p>其他网友：谢谢 没有Linux基础是真的惨 编译半天啥都没看到 Ubuntu也没报错 bin文件就是出不来 安装完就出来了</p><hr><p>请问为什么我在grub menu选择HelloOS后没有打印&#39;Hello OS&#39; 而是黑屏。。</p><p>作者回复: 是不是 UEFI 的 BIOS</p><p>其他网友：把 /boot/grub/grub.cfg 文件中的 multiboot2 /boot/HelloOS.bin 改成 multiboot /HelloOS.bin 再次进入就显示 Hello OS! 了，而不是黑屏了。<br> 其他网友：感谢，我的照你的改了后也显示出来了</p><p>其他网友：是UEFI的BIOS，该怎样处理呢，或者是什么原因造成的呢<br> 编辑回复：需要在BIOS 设置中改为传统方式启动 ～ 不支持UEFI～</p><hr>`,19),ze={href:"https://blog.csdn.net/qq_33406883/article/details/106708621",target:"_blank",rel:"noopener noreferrer"},Qe=e("p",null,"作者回复: 实践出真知",-1),Ye=e("h4",{id:"_8-centos7相关",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_8-centos7相关","aria-hidden":"true"},"#"),n(" 8 CentOS7相关")],-1),Ke=s(`<p>我用的是CentOS 7虚拟机，有点不一样：<br> 环境说明：<br> gcc --version<br> gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-44)</p><p>[root@node01 ~]# cat /etc/redhat-release<br> CentOS Linux release 7.6.1810 (Core)</p><p>下面是添加HelloOS启动项的流程：<br> 1、在/etc/grub.d/40_custom文件中，添加HelloOS在grub2中的配置</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>#!/bin/sh
exec tail -n +3 $0
# This file provides an easy way to add custom menu entries.  Simply type the
# menu entries you want to add after this comment.  Be careful not to change
# the &#39;exec tail&#39; line above.
#以下是添加内容
menuentry &#39;HelloOS&#39; {
     insmod part_msdos #GRUB加载分区模块识别分区
     insmod ext2 #GRUB加载ext文件系统模块识别ext文件系统
     set root=&#39;hd0,msdos1&#39; #注意boot目录挂载的分区，这是我机器上的情况
     multiboot2 /HelloOS.bin #GRUB以multiboot2协议加载HelloOS.bin
     boot #GRUB启动HelloOS.bin
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2、重新生成/boot/grub2/grub.cfg文件<br> [root@node01 grub2]# grub2-mkconfig -o /boot/grub2/grub.cfg</p><p>3、重启VM，即可在grub引导项中看到多了HelloOS</p><p>作者回复: 你好，你这样操作也是对的</p><p>其他网友：那就不用更改40_custom了，直接在/boot/grub2/grub.cfg里改就行,也不用更新。</p><p>其他网友：很棒，我也用的是centOS 7, 配置按照楼主这样改就对了。一定要注意multiboot2 的路径不要额外加boot, 因为默认进去就是boot.</p><p>其他网友：第二步直接 update-grub2 就可以，省下指定路径了</p><hr><p>编程小白，希望各位老师同学帮忙分析看。。。<br> 测试遇到问题：进入启动引导页面可以看到新增的HelloOS，但是选择进入后，没有显示Hello OS! 没有显示任何东西，然后强制关闭才能退出。<br> 测试环境：VirtualBox + centos7<br> 初步分析：HelloOS.bin是按照gittee下载的文件直接编译生成的，应该不会有问题。grub.cfg是按照Freddy同学方式生成。<br> 不清楚问题出在哪了。<br> 可能是已经正常启动了，只不过VirtualBox 启动的centos虚拟机进入这个系统后不显示打印信息？</p><p>其他网友：可以将multiboot2 /boot/HelloOS.bin改为multiboot /boot/HelloOS.bin<br> 其他网友：感谢，困扰许久</p><hr><p>整理一下自己遇到的问题<br> 使用是centos7<br> 1.需要yum install nasm，然后再make -f Makefile<br> 2.安装在boot/grub中没有cfg文件，需要去/boot/grub2/gurb.cfg添加启动项。看到评论有修改/etc/grub.d/40_custom,再update-grub2的，这样多一步，可以直接在里面添加。<br> 3.选择HelloOS系统，进入黑屏，可能是因为是UEFI的BIOS,将启动项的multiboot2改成multiboot即可成功。<br> 作者回复: 是的</p><hr><p>virtualbox + centos 7.9 将multiboot2修改为 multiboot，成功打印 这是为什么</p><p>作者回复: centos的GRUB版本太老了，推荐用Ubuntu。</p><hr>`,19),Xe=e("br",null,null,-1),Je=e("br",null,null,-1),Ze={href:"https://ruglcc.blog.csdn.net/article/details/7814546?spm=1001.2101.3001.6650.12&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-12.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-12.no_search_link",target:"_blank",rel:"noopener noreferrer"},en=e("br",null,null,-1),nn=e("br",null,null,-1),sn=e("br",null,null,-1),ln=s(`<hr><p>问题： error : file &#39;/boot/HelloOS.bin&#39; not found<br> 环境：virtualBox(5.1.38) + centos_7.8.2003<br> 原因：</p><ol><li>os路径指定不对，该环境 磁盘分区直接挂载到 /boot目录下。</li><li>文件系统类型不对， 该环境是 xfs 文件类型。<br> 该环境下正常启动的menurntry:</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>menuentry &#39;HelloOS&#39; {
     insmod part_msdos
     insmod xfs
     set root=&#39;hd0,msdos1&#39;
     multiboot2 /HelloOS.bin
     boot
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>作者回复：666</p><hr><p>virtunalBox vm下 centos 7</p><p>grub2的配置文件是</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>menuentry &#39;HelloOS&#39; {
     insmod part_msdos #GRUB加载分区模块识别分区
     insmod xfs #GRUB加载ext文件系统模块识别ext文件系统
     set root=&#39;hd0,msdos1&#39; #注意boot目录挂载的分区，这是我机器上的情况
     multiboot2 /HelloOS.bin #GRUB以multiboot2协议加载HelloOS.bin
     boot #GRUB启动HelloOS.bin
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>能找到boot文件 但是没有hello os的输出<br> 作者回复: 是不是 uefi 模式</p><hr><p>把启动脚本的multiboot2 /boot/HelloOS.bin 改成multiboot /boot/HelloOS.bin就出来了。不过不明白道理</p><p>作者回复: centos吧 GRUB版本不同</p><hr>`,14),an={href:"https://blog.csdn.net/weixin_45941099/article/details/120356421",target:"_blank",rel:"noopener noreferrer"},on=s(`<p>作者回复: 6666 恭喜</p><hr><p>补充下我的centos 7.9版本遇到的一些坑<br> 1 将HelloOS.bin 文件复制到/boot目录<br> 2 vim /etc/grub.d/40_custom 编辑此文件，在文件后添加如下配置</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>menuentry <span class="token string">&#39;HelloOS&#39;</span> <span class="token punctuation">{</span>
     insmod part_msdos <span class="token comment">#GRUB加载分区模块识别分区</span>
     insmod xfs <span class="token comment">#GRUB加载xfs文件系统模块识别ext文件系统</span>
     <span class="token builtin class-name">set</span> <span class="token assign-left variable">root</span><span class="token operator">=</span><span class="token string">&#39;hd0,msdos1&#39;</span> <span class="token comment">#注意boot目录挂载的分区，这是我机器上的情况</span>
     multiboot /HelloOS.bin <span class="token comment">#GRUB以multiboot2协议加载HelloOS.bin</span>
     boot <span class="token comment">#GRUB启动HelloOS.bin</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3 更新grub配置： grub2-mkconfig -o /boot/grub2/grub.cfg</p><p>这样就ok了，重新启动，选择HelloOS就可以看到屏幕输出的 Hello OS! 了<br> 这里的坑就是centos 7.9 的文件系统从ext换成了xfs，然后multiboot2 应该换成multiboot<br> 作者回复: 哈哈 6666666</p><hr><p>我使用qemu + centos 7虚机的方式进行测试，centos 7用的是grub2。 这里要注意一点，由于把/boot所在分区设置为root，那么multiboot2 后跟的路径就不需要加/boot了。 所以最后的命令形式为: multiboot2 /HelloOS.bin 不确定这个路径问题是否和grub/grub2的处理有关。</p><p>作者回复: 没有关系的</p>`,9),tn=e("h4",{id:"_9-实验流程文字总结",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_9-实验流程文字总结","aria-hidden":"true"},"#"),n(" 9 实验流程文字总结")],-1),rn=s("<p>用汇编初始化处理器运行环境；用 C 语言写出利用显卡字符模式的输出显示代码；用 gcc 一并编译生成系统镜像；配置 grub 的引导运行自己做的 hello world 系统！</p><p>作者回复: 是的 ，你总结的很好</p><hr><p>也来交个作业<br> 既然是从0到1，建议像我一样的小白用户，全部代码自己动手写一遍，哪怕很多细节不懂，但从整体上会有一个感性认识，有了框架，后面慢慢补充相关知识，这样学的会更加牢固。<br> 那些折腾虚拟机直接copy老师的代码，是高手玩的，需要有足够的基本功才玩的转。小白一定要先练好自己的基本功，手动抄代码是练基本功非常好的方法，看一遍和写一遍感觉完全不一样。</p><p>操作系统算是比较难的了，开始学习之前，自己得先有些基本的知识储备。<br> 首先，要对Linux有基本概念，会在物理机上装Linux，知道Linux常用的命令，知道怎么在Linux里安装程序。</p><p>说下我的作业过程：<br> 一、个人PC上直接装的Linux，版本是ubuntu。</p><p>二、在自己的家目录下新建一个HelloOS文件夹，在里面新建5个文件，文件内容照着老师给的源码全部手抄一遍，一定要仔细，一个字母都不能差：</p><p>entry.asm （汇编文件，进行一些针对电脑硬件的操作）<br> main.c （我们自己这个操作系统的主函数源代码，里面就一个printf函数，功能是我们这个操作系统运行时显示的那句话）<br> vgastr.c （printf函数的具体实现代码，需要调用到显卡显存）<br> vgastr.h （主函数的头文件）<br> Makefile (make命令编译时遵照的格式文件)</p>",8),dn={href:"http://install.md",target:"_blank",rel:"noopener noreferrer"},pn=s(`<p>三、途中可能会遇到几个问题<br> 1 提示没有装nasm, 无法编译汇编文件 .asm，解决方法，直接根据系统提示，输入命令安装该程序<br> 2 提示make不是命令，无法编译，解决方法，直接根据系统提示，输入命令安装该程序<br> 3 源代码抄写错误，都会有提示具体在哪个文件哪一行，写错字符，缺少横杠，字符大小写等（我甚至都没有用编辑器，抄起来确实比较痛苦，但完成后的成就感也更大）</p><p>四、补充一个细节，确认完挂载点后，记得把helloOS.bin文件放到挂载点的目录下，要不然，即使grub.cfg配置写对了，仍然会提示找不到文件。</p><p>五、有个小问题没搞明白，为啥我生成的helloOS.bin 文件的首字母是小写的？我看别人的截图都是大写的，不过这个貌似不影响系统启动。</p><p>作者回复: 最后一个问题 看一下代码 可改的</p><hr><p>提供給大家參考我的配置 (可以成功看到 Hello OS!)：</p><p>$ df -h /boot/<br> Filesystem Size Used Avail Use% Mounted on<br> /dev/nvme0n1p1 468G 211G 234G 48% /</p><p>在 /boot/grub/grub.cfg 的配置如下:<br> ....<br> menuentry &#39;HelloOS&#39; {<br> insmod part_msdos<br> insmod ext2<br> set root=&#39;hd0,msdos1&#39;<br> multiboot2 /boot/HelloOS.bin<br> boot<br> }<br> ....</p><p>最後在開機時，按住 Esc ，進入到開機選單，應可以看到 HelloOS 選項，點下去後，畫面就會出現 &quot;Hello OS!&quot; 的字樣。<br> 作者回复: 牛逼</p><hr><p>Hello OS 实验步骤<br> 实验环境：VM + Ubuntu 20.04</p><ol><li><p>修改/etc/default/grub</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token assign-left variable">GRUB_TIMEOUT_STYLE</span><span class="token operator">=</span>menu
<span class="token assign-left variable">GRUB_TIMEOUT</span><span class="token operator">=</span><span class="token number">10</span>
<span class="token comment"># 取消GRUB_TERMINAL=console注释</span>
<span class="token assign-left variable">GRUB_TERMINAL</span><span class="token operator">=</span>console
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>把下面的代码复制，然后插入到/boot/grub/grub.cfg文件中</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>menuentry <span class="token string">&#39;HelloOS&#39;</span> <span class="token punctuation">{</span>
    insmod part_msdos
    insmod ext2
    <span class="token builtin class-name">set</span> <span class="token assign-left variable">root</span><span class="token operator">=</span><span class="token string">&#39;hd0,msdos5&#39;</span> <span class="token comment">#注意boot目录挂载的分区，这是我机器上的情况</span>
    multiboot2 /boot/HelloOS.bin
    boot
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>然后把HelloOS.bin文件复制到/boot/目录下（前提是把所给HelloOS进行编译为HelloOS.bin）</p></li><li><p>最后重启计算机就可以看到HelloOS启动选项了</p></li></ol><p>作者回复: 666666</p><hr>`,14),un={href:"https://blog.csdn.net/weixin_36012235/article/details/127287255",target:"_blank",rel:"noopener noreferrer"},cn=s("<p>作者回复: 6666</p><hr><p>用的VMware虚拟机里的Ubuntu20，需要先修改etc/default/grub里的几项属性为：<br> GRUB_TIMEOUT_STYLE=countdown<br> GRUB_TIMEOUT=10<br> GRUB_CMDLINE_LINUX_DEFAULT=&quot;text&quot;<br> 当然还能是别的值，这些只是我的个人选择。<br> 然后执行sudo update-grub<br> 然后去/boot/grub/grub.cfg中，将启动项的相关代码复制粘贴到文件末尾。在grub.cfg中还有其他的menuetry项，它们挂载的硬盘分区就是你要修改成的硬盘分区，复制粘贴一下就ok，不需要进grub命令行去看了。<br> 在终端输入命令 df /boot/ 看mount的路径，如果是/那么multiboot2后面的不变，如果是/boot那么multiboot2后面的/boot/去掉。<br> 将HelloOS.bin复制粘贴到/boot目录下。<br> 重启虚拟机，在出现倒计时(之前设置的countdown属性)的界面按下shift,就能进入Grub界面选择HelloOS。<br> 经过其他测试发现Ubuntu on Windows和Docker都不能用来做这个，sudo update-grub时会出现找不到canonical path的错误，应该是因为在OS层面没有实现隔离（Ubuntu on Windows相当于一个副系统，Docker更像是一个独立的进程），还是必须要用虚拟机。<br> 另外Virtual Box卡得一比，根本不好用......</p>",3),bn=s('<h3 id="感悟" tabindex="-1"><a class="header-anchor" href="#感悟" aria-hidden="true">#</a> 感悟</h3><blockquote><p>从开机选项中看到自己的OS，很有成就感。会一点C和make，gcc方面不熟，nasm和ld需要额外了解。grub.cfg文件的挂载分区，一个参考命令，也可以参考里面已经有的menuentry<br> 编辑回复: 太优秀了，再接再厉，这里带大家找找感觉。后面讲解更精彩，敬请期待。</p><hr><p>老师讲的详细，醍醐灌顶，后面会将如何用QEMU BOSCH之类的模拟器运行OS内容吗 ？</p><p>作者回复: 会的，敬请期待</p><hr><p>目前这个hello os还不能被称作操作系统，就是一个简单的裸机程序。</p><hr><p>学会了什么：跟着老师的课程还有置顶评论的博客（非常感谢分享）的指导，顺利的把自己的HelloO跑起来了 简单的了解了grub的作用 迷茫：感觉自己学会了点什么，同时也感觉对于系统是一知半解的，有很多的不明白，汇编看不懂，grub也不是特别明白 课程刚刚开始 要学的还有很多 前两节应该是老师通过一个简单的例子先勾下大家的兴趣 一起加油吧</p><p>编辑回复: 优秀。不过初入门一个上下左右都有很多牵扯的复杂网状系统的时候，一定要像张无忌学太极剑一样，只记住剑意，选择性忘记忽略一些细枝末节。不然的话，很可能就会被带跑偏，沉溺于一些奇奇怪怪暂时又不太重要的东西。 学习可以先抓主线，慢慢消化甚至优化细节。一起加油。</p><hr><p>拖拖拉拉的终于在2021年6月4日下午14：30分成功启动我自己的操作系统了。不容易啊，为了深刻体会第一节课和第二节课所涉及到的代码，去百度了二进制代码简介和基础原理，又手抄了常用汇编语言的助记符2张纸，还又找了C语言的相关教程看了基础部分一遍。感悟到这些部分的代码都是最少的语句完成必要的工作，没一句多余的废话。计算机真的是一个百玩不厌的世界。</p><p>作者回复: 你好，你真的是下了功夫了</p><hr><p>终于跑成功了，感谢 陈诚 Strangeen🚁 Vic提供的参考。</p><p>我是/boot文件夹直接挂载在sda2上，所以</p><p>multiboot2 /boot/HelloOS.bin #GRUB以multiboot2协议加载HelloOS.bin</p><p>这行要改成 multiboot2 /HelloOS.bin 才成功，</p><p>很有意思，感谢老师，期待下面老师继续带我飞<br> 作者回复: 加油</p></blockquote><h3 id="解惑" tabindex="-1"><a class="header-anchor" href="#解惑" aria-hidden="true">#</a> 解惑</h3><blockquote><p>我也是UEFI，最后可以在grub里选择HelloOS，进去也没有错误，但是没有显示helloOS。貌似也改不成传统启动。那后续还可以继续吗？</p><p>作者回复: 后面是用虚拟机的 没有关系 的</p><hr><p>makefile的例子里，OBJS_FILE里需要是.o才行，不然没法触发最后一条规则。另外最后一行是需要有tab缩进的</p><p>编辑回复: 感谢你的反馈呀，因为考虑到排版跟帮助用户抓重点，稿件中放的是关键代码。详细代码请参考Gitee。</p><hr><p>老师说每两个字节对应一个字符，其中一个字节是字符的 ASCII 码，另一个字节为字符的颜色值。但是printf 函数中，为了跳过颜色值字节是+2，为什么不是+1呢？</p><p>作者回复: 你好。因为那个指针类型是char类型，每次加一只增加一个字节，要跳过的话 就要 加二</p><hr><p>对于_strwrite方法的实现，虽然通过p_strdst += 2;直接跳过了对文字颜色的赋值，但是该字段默认值不是0，而是跟设备相关的初始值，例如VGABIOS的默认值应该是0x07（黑底白字）</p><p>作者回复: 是，你说的正确</p><hr><p>如何编译得到HelloOS.bin文件呢？是make main.c吗</p><p>作者回复: 直接 make 不带任何参数就行</p><hr><p>请问老师同学，这个汇编的代码，在所有平台上都是一样的吗？我想知道什么情况下需要修改汇编以适应架构</p><p>作者回复: 不同 处理器上的汇编代码是不同的</p></blockquote><h3 id="其他知识点" tabindex="-1"><a class="header-anchor" href="#其他知识点" aria-hidden="true">#</a> 其他知识点</h3><h4 id="_1-变长参数" tabindex="-1"><a class="header-anchor" href="#_1-变长参数" aria-hidden="true">#</a> 1 变长参数</h4><blockquote><p>先回答一下问题，...是GCC支持的变长参数，但目前printf这个函数并未使用变长参数，后面应该是结合format字符串来实现自己的printf函数达到与标准库中的一致。</p><p>作者回复: 是的 是的</p><hr><p>在printf 函数定义，其中有个形式参数很奇怪，请你思考下：为什么是“…”形式参数，这个形式参数有什么作用？ 答：这其实是C语言可变长参数的应用。对于x86来说，函数参数入栈顺序为从右往左，因此，在知道第一个参数地址之后，我们能够通过地址偏移获取其他参数。 并且在这种方式下，栈顶元素就是printf第一个需要打印的元素，方便显卡打印。</p><p>作者回复: 对 对对 厉害</p><hr><p>… 在很多语言中是可变参数。在函数调用使用堆栈的前提下，参数的提取是从后往前。所以可以通过第一个参数的地址，拿到后续参数。 不过这里 main 函数中 printf 只有一个传参，printf 实现中也没用到。感觉可能是后续扩充代码使用的。</p><p>作者回复: 对 对 对</p><hr><p>有个问题 c语言使用...可变参数不是要包含stdarg.h头文件吗</p><p>作者回复: 自己实现的 要什么头文件</p></blockquote><h4 id="_2-0x7c00地址" tabindex="-1"><a class="header-anchor" href="#_2-0x7c00地址" aria-hidden="true">#</a> 2 0x7c00地址</h4><blockquote><p>彭东老师你好 HelloOS跑成功了，但是还有一个小问题想请教一下。文中描述说PC机上电后的第一条指令后加载引导设备的数据，是直到0x7c00地址吗？还是从0x7c00地址开始，然后再跳转回去执行指令？</p><p>作者回复: 加载512byte到0x7c00开始的地址</p><hr><p>老师好，我有一点疑惑，为什么bios先把bootsect.s加载到0x07c00处，然后bootsect.s自己加载到0x90000处，而不是bios直接把它加载到0x90000处？</p><p>作者回复: bios的标准就是加载到0x7c00处</p><hr><p>0x7C00 由来的一种说法。当时，搭配的操作系统是86-DOS。这个操作系统需要的内存最少是32KB。我们知道，内存地址从0x0000开始编号，32KB的内存就是0x0000～0x7FFF。8088芯片本身需要占用0x0000～0x03FF，用来保存各种中断处理程序的储存位置。（主引导记录本身就是中断信号INT 19h的处理程序。）所以，内存只剩下0x0400～0x7FFF可以使用。为了把尽量多的连续内存留给操作系统，主引导记录就被放到了内存地址的尾部。由于一个扇区是512字节，主引导记录本身也会产生数据，需要另外留出512字节保存(自己 和 产生)。所以，它的预留位置就变成了：<br> 0x7FFF - 512 - 512 + 1 = 0x7C00<br> 作者回复: 哈哈 你是计算机历史学家</p><hr></blockquote><h4 id="_3-保护模式-vs-分页机制" tabindex="-1"><a class="header-anchor" href="#_3-保护模式-vs-分页机制" aria-hidden="true">#</a> 3 保护模式 vs 分页机制</h4>',10),mn=e("p",null,"老师，这里的0x7c00是不是实际物理内存地址，这个时候虚拟内存和物理内存是不是还没有做map",-1),hn=e("p",null,"作者回复: 是实际的物理地址 ，PC加电时 CPU工作在实模式下，所以不需要map",-1),vn=e("p",null,"其他网友：當然是物理地址，這個時候還在bios，還沒進保護模式，更別提虛擬内存了",-1),gn=e("hr",null,null,-1),_n=e("p",null,"请教您一个问题，开启保护模式和开启分页机制，是一回事吗？是不是开启分页机制以后才回存在虚拟内存的概念",-1),kn=e("p",null,"网友尼欧：保護模式和分頁不是一回事，首先進入保護模式，然後可以選擇開啓或者不開啓分頁機制。至於虛擬内存，我的理解是，虛擬内存是操作系統層面概念，是操作系統的一種内存管理機制，是對物理内存的抽象，可以使進程的地址空間跟物理内存解耦，跟開不開啓分頁沒有必然關係。只在保護模式下就可以實現虛擬内存，當然也可以選擇不實現，這取決於操作系統開發者的選擇。",-1),fn=e("br",null,null,-1),xn=e("br",null,null,-1),Sn={href:"https://blog.csdn.net/chenchengwudi/article/details/115408273",target:"_blank",rel:"noopener noreferrer"},Bn=s("<p>网友：首先，段機制無論在保護模式還是實模式都是生效的，這是cpu的基因決定的。還有，bios剛把引導程序加載到内存，還沒跳轉到0x7c00去執行，哪裏進了保護模式呢？还没有进入保护模式。這個時候還沒到helloOS，BIOS剛剛把GRUB加載到0x7c00，HelloOS還在GRUB後面。</p><hr><p>entry.asm里的jmp dword 0x8 :_32bits_mode这句代码，看跳转的方式CPU应该已经进入了保护模式，但是没有看到开启保护模式的代码？</p><p>作者回复: GRUB运行时就已经设置了保护模式了 我只是重新加载了GDT</p><hr><p>有一个疑问，汇编代码那里：<br> ;重新加载<br> GDTlgdt [GDT_PTR]<br> jmp dword 0x8 :_32bits_mode<br> 这里明明没有开启保护模式，为什么能这样跳转，而且经验证，也确实使用了gdt。<br> 但是实模式不是cs &lt;&lt; 4 + offset进行寻址吗？<br> 作者回复: 因为GRUB已经在保护模式下了</p>",6),On=s('<h4 id="_4-初始化c语言堆栈环境" tabindex="-1"><a class="header-anchor" href="#_4-初始化c语言堆栈环境" aria-hidden="true">#</a> 4 初始化C语言堆栈环境</h4><blockquote><p>初始化C语言堆栈环境，也就是初始化堆栈指针，为什么要强调是C语言的环境呢？汇编语言不需要用堆栈指针吗？C语言也会被编译汇编为汇编语言，那么为什么要说堆栈指针是C语言需要的环境呢？ （这个问题问得好像个杠精一样【笑哭】）</p><p>作者回复: 汇编语言 可以不用 只要不使用call指令 C语言是要处理函数调用和局部变量</p><p>其他网友：call指令会把ip的内容push到栈上， 然后jump到call的目标地址，所以用call的话也会用到堆栈。对应的还有ret，也会用到堆栈，它会pop 栈顶的数据出来，再跳转。</p><hr><p>老师你好，是因为c需要编译出来的汇编做不了硬件的一些配置所以才需要在一开始的时候用汇编吗</p><p>作者回复: 对的</p><p>其他网友：c語言不能直接讀寫端口和寄存器，對硬件設置需要讀寫相應的端口，所以只能用匯編了</p><hr><p>为什么要用汇编初始化c语言的栈环境，c语言编译成汇编之后不是有寄存器的分配吗</p><p>作者回复: C语言 编译出的汇编 就是需要栈的</p></blockquote><h4 id="_5-硬件映射到显存" tabindex="-1"><a class="header-anchor" href="#_5-硬件映射到显存" aria-hidden="true">#</a> 5 硬件映射到显存</h4><blockquote><p>为什么0xb8000代表的是显存而不是内存？</p><p>作者回复: 这地址是硬件映射到显存的</p><hr><p>舉手，我要問個問題，char* p_strdst = (char*)(0xb8000);//指向显存的开始地址，C語言中通過這句去讀寫顯存的時候，這裏的0xb8000是段内偏移還是綫性地址呢？在最終生成可執行文件的時候，C編譯器會對這個0xb8000做什麽轉換麽？比如轉換成某個段的基地址和段内偏移的形式？</p><p>作者回复: 这是线性地址 汇编代码已经切换到保护模式了</p><p>其他网友：我理解程序内的地址应该都是相对地址，是相对于代码段的偏移地址，只不过在段基址为0x0的情况下，线性地址（进程虚拟地址）等同于段内偏移地址</p><p>其他网友：我理解的作者回复的线性地址的意思，应该就是物理地址吧</p><p>其他网友：所有机器显存的的开始地址都是0xb8000吗？有的独立显卡自带显存</p></blockquote>',4);function En(Un,Hn){const l=i("ExternalLinkIcon");return r(),d("div",null,[m,h,v,g,e("p",null,[n("本节课的配套代码，你可以"),e("a",_,[n("从这里下载"),a(l)]),n("。")]),k,e("p",null,[n("当然，更先进的"),e("a",f,[n("UEFI BIOS"),a(l)]),n("则不同，这里就不深入其中了，你可以通过链接自行了解。")]),x,e("p",null,[n("这里先提个醒："),S,n("（关于"),e("a",B,[n("utf8编码"),a(l)]),n("你可以自行了解）。")]),O,e("blockquote",null,[e("p",null,[n("GRUB 相关文档: "),e("a",E,[n("https://www.gnu.org/software/grub/grub-documentation.html"),a(l)])]),U,H,G,C,R,w]),y,e("blockquote",null,[e("p",null,[n("补一个virtualbox共享文件夹的教程视频，可以省去很多时间。"),e("a",I,[n("https://www.youtube.com/watch?v=YSLNqXxyUtk"),a(l)])]),T]),q,e("blockquote",null,[A,e("p",null,[n("编辑回复: 看看BIOS的启动选项。在BIOS 设置中查找，真的是uefi ，就支持不了，你要改为 传统方式启动 。 实在不会搭建环境，参考下助教的快速通道版本："),e("a",M,[n("https://github.com/Ruijie-Qin/CosmosExpEnv"),a(l)])]),D]),F,e("blockquote",null,[e("p",null,[n("我是小白，只会java，没学过c，当时也只是抱着了解下操作系统的想法报了课程，学到第2课，发现完全听不懂..."),L,n(" 不过跟着课程和陈诚的博客走（"),e("a",P,[n("https://blog.csdn.net/chenchengwudi/article/details/116707122），然后下载了老师的代码，最终居然还是跑出Hello"),a(l)]),n(" OS!来了，虽然还不太明白汇编、Makefile、hello.lds代码的含义..."),N,n(" 看来又多了一份学下去的信心了！"),V,n(" 我是在mac pro(os 10.15.6)上使用parallel安装的ubuntu kylin 18.04，这里我要对像我这样的小白说3个点："),j,n(" 1、安装nasm，才能执行make"),W,n(" 先安装nasm：sudo apt-get install -y nasm"),$,n(" 然后在HelloOS目录下执行：make -f Makefile"),z,n(" 就可以得到HelloOS.bin文件了"),Q,n(" 2、一定要按照陈诚的博客的2.1中配置下启动项，不然无法选择HelloOS菜单"),Y,n(" 先修改文件：/etc/default/grub"),K,n(" 然后执行：sudo update-grub"),X,n(" 3、menuentry直接添加到grub.cfg文件的末尾即可"),J,n(" 作者回复: 你太用功了")]),Z]),ee,e("blockquote",null,[e("p",null,[n("P.S. 不想每次改完程序重启看效果的同学可以考虑用qemu来boot kernel，之前有两个同学给了solution，但是好像一个制作引导镜像的步骤有点问题，另一个没用grub，用的自定义的bootloader。我follow老师的课程做了个grub版的（包括怎么制作引导镜像）放在了github上 "),e("a",ne,[n("https://github.com/xymeng16/helloOS，不想深究直接make"),a(l)]),n(" qemu-grub就可以用，想深究的话脚本也都在repo里面~之后我会把联合gdb调试的脚本也加进去，方便找bug...")]),se,e("p",null,[n("其他网友：我也遇到了，虽然没有影响但还是想理解，查到这个答案应该能解惑。"),le,n(" 链接："),e("a",ae,[n("https://stackoverflow.com/questions/47235461/how-to-resolve-specify-the-raw-format-explicitly-to-remove-the-restrictions"),a(l)])]),oe]),te,e("blockquote",null,[e("p",null,[n("写了一个关于这节课实验的笔记，VMware + Ubuntu 16.04环境，供大家参考"),ie,e("a",re,[n("https://blog.csdn.net/chenchengwudi/article/details/116707122"),a(l)]),de,n(" 作者回复: 666666")]),pe,e("p",null,[n("解决方法："),ue,n(" 通过Strangeen同学的评论，找到了陈诚的博客（"),e("a",ce,[n("https://blog.csdn.net/chenchengwudi/article/details/116707122），通过修改/etc/default/grub文件中的相关设置，尤其是GRUB界面显示时间GRUB_TIMEOUT字段值，我文件中默认为0，意味着GRUB界面显示时间为0，所以无法进入，修改值为30后可正常进入。"),a(l)])]),be,e("p",null,[n("解决方法："),me,n(" 通过网络检索，在"),e("a",he,[n("https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=958894有类似问题描述，其中提供的解决思路是在BIOS中修改security中的secure"),a(l)]),n(' boot值，我使用的笔记本通过F2进入BIOS，禁用掉该值（设置为DISABLE），然后保存退出BIOS，进入GRUB后选择HelloOS即可正常打印 "Hello OS!"')])]),ve,e("blockquote",null,[e("p",null,[n("我也搞了份不需要 GRUB 可以直接用 QEMU 或者其他虚拟机软件跑的版本"),ge,e("a",_e,[n("https://github.com/vizv/learn_os/tree/master/hello-os"),a(l)])]),ke,e("p",null,[e("a",fe,[n("https://github.com/danie1Lin/HardLowWorld"),a(l)]),n(" 直接用 vagrant 一键完成 hello OS 在 virtual box的 provision 只想看结果的小伙伴可以试试😂")]),xe]),Se,e("blockquote",null,[Be,e("p",null,[n("写了一个基于Vmare和Ubuntu16.04的详细教程，只要手头有电脑就可以运行，大家可以看看： "),e("a",Oe,[n("https://zhuanlan.zhihu.com/p/373996858"),a(l)])]),Ee]),Ue,e("blockquote",null,[He,Ge,e("p",null,[n("上个月看了专栏，没有实操。今天开了虚拟机开搞，终于搞定第一个案例。"),Ce,n(" 4个易错点如下："),Re,n(" 1，ubuntu虚拟机没有grub问题。"),we,n(" 参见："),e("a",ye,[n("https://blog.csdn.net/yjj350418592/article/details/121759907?spm=1001.2014.3001.5501"),a(l)]),Ie,n(" 2, make不能生成HelloOS.bin文件，nasm报错，是虚拟机没有安装nasm问题。"),Te,n(" ubuntu的话，直接sudo apt install nasm即可解决。"),qe,n(" 3，启动硬盘分区的问题。东哥已讲，一定要修改对的启动分区。"),Ae,n(" 4，HelloOS.bin的文件位置问题。"),Me,n(" 启动的bin文件路径一定要与添加的grub.cfg追加内容的bin文件路径一致。"),De,n(" 作者回复: 是的")]),Fe,e("p",null,[n("将自己遇到的几个小问题总结下，希望能帮助到其他同学（linux新手）"),Le,n(" 1、将HelloOs.bin移动到boot文件夹时无权限"),Pe,n(" 解决办法：打开终端，运行命令sudo nautilus就可以打开一个管理员权限的文件管理器"),Ne,n(" 2、df/boot/失效"),Ve,n(" 解决办法：df-h 查看所有文件挂载，找到boot即可"),je,n(" 3、nasm安装，参考教程"),e("a",We,[n("https://blog.csdn.net/qq_44641344/article/details/104355359?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-0&spm=1001.2101.3001.4242"),a(l)])]),$e,e("p",null,[n("虚拟机成功引导出了HelloOS，打个卡。 遇到的坑： 第一个是我的grub选单并不会出现，参照"),e("a",ze,[n("https://blog.csdn.net/qq_33406883/article/details/106708621"),a(l)]),n(" 这里配置之后出现了 第二个，我在grub.cfg上做的配置，往往会莫名其妙消失。其实是因为我运行了update-grub，/boot/grub/grub.cfg会重新生成。 第三个，老师给出的硬盘引导位置，要根据自己的情况来看。我用kvm创建的虚拟机，使用 fdisk -l /dev/vda 可以看到disklabel type：gpt。这样的话set root='hd0,msdos4' 这里就要改成 'hd0,gpt2' (我这里/boot是挂载到/dev/vda2上的）")]),Qe]),Ye,e("blockquote",null,[Ke,e("p",null,[n("vmware+centos7 实践过程中遇到问题："),Xe,n(" （1）make编译的时候发现nasm未安装，yum install nasm安装解决；"),Je,n(" （2）makefile语法规则不是很明白，还需要学些一下，参考"),e("a",Ze,[n("https://ruglcc.blog.csdn.net/article/details/7814546?spm=1001.2101.3001.6650.12&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-12.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-12.no_search_link"),a(l)]),en,n(" （3）grub.cfg配置，中set root设置的问题，导致找不到HelloOS.bin，通过留言区解决，但grub配置的语法规则也没有搞清楚，还需要继续看；"),nn,n(" （4）multiboot2无法加载HelloOS.bin，导致启动时看不到HelloOS! 后在评论区看到有相同的问题，修改为multiboot后问题解决，但未明白根本原因为啥multiboot2无法加载！"),sn,n(" 作者回复: GRUB版本问题")]),ln,e("p",null,[n("参考了大家的评论，我成功在开机启动项看到了HelloOS的选项。 我的环境是Centos7,gcc7.8，有兴趣的可以看看我的笔记，欢迎指正。（很喜欢留言区讨论分享的氛围） 这是我的博客笔记："),e("a",an,[n("https://blog.csdn.net/weixin_45941099/article/details/120356421"),a(l)])]),on]),tn,e("blockquote",null,[rn,e("p",null,[e("a",dn,[n("install.md"),a(l)]),n(" (确切的说，这是一段代码，有没有这个文件都行，把代码补充到/boot/grub/grub.cfg 文件的末尾，目的是更新grub 引导程序的配置文件，让grub能找到我们的helloOS，评论里出现最多的找不到文件的问题，基本都是这段代码没写对，更确切说，就是那一句 multiboot2 /boot 或改为 multiboot2 / )")]),pn,e("p",null,[n("这是我参考了其他同学的留言后的操作实践： "),e("a",un,[n("https://blog.csdn.net/weixin_36012235/article/details/127287255"),a(l)])]),cn]),bn,e("blockquote",null,[mn,hn,vn,gn,_n,kn,e("p",null,[n("网友陈诚：1、在X86体系结构中，开启保护模式和开启分页机制是分开的，可以仅开启保护保护模式"),fn,n(" 2、严格意义上说，开启保护模式后，就会基于段寄存器构建保护模式，整个时候的地址就已经是虚拟的了，只是Linux中一般通过映射整个地址空间来绕过段机制"),xn,n(" 可以参考这篇笔记："),e("a",Sn,[n("https://blog.csdn.net/chenchengwudi/article/details/115408273"),a(l)])]),Bn]),On])}const wn=t(b,[["render",En],["__file","√B02-汇编加C实现极简内核.html.vue"]]);export{wn as default};
