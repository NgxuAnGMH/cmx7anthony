import{_ as h}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o as d,c as p,a,b as e,e as t,d as n}from"./app-cdabc73c.js";const c={},o=n('<h1 id="温故知新-思考题参考答案-二" tabindex="-1"><a class="header-anchor" href="#温故知新-思考题参考答案-二" aria-hidden="true">#</a> 温故知新｜思考题参考答案（二）</h1><p>你好，我是编辑小新。今天是大年初二，首先祝你春节愉快。</p><p>今天是我们第二次答疑课。上一次加餐，我们公布了课程前半部分的思考题参考答案。这次我们把后面课程的思考题答案也公布出来。建议你自行思考之后，再对答案，每节课都附上了超链接，方便你跳转回顾。</p><h2 id="第二十三节课" tabindex="-1"><a class="header-anchor" href="#第二十三节课" aria-hidden="true">#</a> 第二十三节课</h2><p>Q：你觉得链接器使用的地址是物理内存地址，还是虚拟内存地址？</p><p>A：可以是物理内存地址也可以是虚拟内存地址，<em>当 CPU 没有 MMU、PMU 等内存管理单元时</em>，就是物理内存地址，否则就是虚拟地址。</p><h2 id="第二十四节课" tabindex="-1"><a class="header-anchor" href="#第二十四节课" aria-hidden="true">#</a> 第二十四节课</h2><p>Q：请问页表数据究竟放在什么地方呢？</p><p>A：页表数据由操作系统构造，放在物理内存中，将其地址写入 MMU 的相关寄存器中。</p><h2 id="第二十五节课" tabindex="-1"><a class="header-anchor" href="#第二十五节课" aria-hidden="true">#</a> 第二十五节课</h2><p>Q：你觉得堆、栈空间是虚拟内存空间吗？如果是，请问是在什么时候分配的物理内存呢？</p><p>A：堆和栈都是虚拟内存空间，只是等到访问到具体虚拟地址产生了<mark>缺页异常中断</mark>，系统才会分配物理内存。</p><h2 id="第二十六节课" tabindex="-1"><a class="header-anchor" href="#第二十六节课" aria-hidden="true">#</a> 第二十六节课</h2><p>Q：请简单说一下写时复制和请求调页的区别。</p><p>A：写时复制是，多个应用以只读方式共享物理内存页面，任一应用写入时就分配新的物理内存页并进行复制。请示调页是应用访问自己虚拟内存时，发生缺页异常（物理内存页面不存在）而分配一个新的物理内存页面，供应用使用。</p><h2 id="第二十七节课" tabindex="-1"><a class="header-anchor" href="#第二十七节课" aria-hidden="true">#</a> 第二十七节课</h2><p>Q：Golang 有了 mcentral 结构，可以查找到 mspan 结构，为什么还要建立 mcache 结构呢？</p><p>A：因为 mcache 是每个 P 独有的，mcentral 是全局的，直接访问 mcache 不用加锁，会导致并行性下降。</p><h2 id="第二十八节课" tabindex="-1"><a class="header-anchor" href="#第二十八节课" aria-hidden="true">#</a> 第二十八节课</h2><p>Q：多个不同的进程可以包含相同的程序吗，为什么？</p><p>A：可以。因为一个程序在输入不同的数据就能得到不同的执行结果，因而构成不同的进程；但是在执行过程中，程序代码区段是不能发生改变的，可以参考 fork。</p><h2 id="第二十九节课" tabindex="-1"><a class="header-anchor" href="#第二十九节课" aria-hidden="true">#</a> 第二十九节课</h2><p>Q：请概述一下管道和信号这两种通信机制的不同。</p><p>A：管道属于<em>数据流通信</em>，信号属于<em>控制流通信</em>。</p><h2 id="第三十节课" tabindex="-1"><a class="header-anchor" href="#第三十节课" aria-hidden="true">#</a> 第三十节课</h2><p>Q：进程间通信哪些是同步的，哪些是异步的？</p><p>A：信号是异步的，其它三种通信方式既可以同步，也可以异步，创建的时候可以设置相关的标志。</p><h2 id="第三十一节课" tabindex="-1"><a class="header-anchor" href="#第三十一节课" aria-hidden="true">#</a> 第三十一节课</h2><p>Q：操作系统为什么要开发 IO Cache？</p><p>A：其实 IO Cache 的存在，是为了缓解外设速度不同或者慢速的外设带来的系统性能问题。</p><h2 id="第三十二节课" tabindex="-1"><a class="header-anchor" href="#第三十二节课" aria-hidden="true">#</a> 第三十二节课</h2><p>Q：请问 Linux 网络通信的接口是什么？</p><p>A：Socket 套节字接口是 Linux 上 TCP/IP 网络接口 API，应用程序使用套节字 API 访问网络，而不是读写文件的方法。</p><h2 id="第三十三节课" tabindex="-1"><a class="header-anchor" href="#第三十三节课" aria-hidden="true">#</a> 第三十三节课</h2><p>Q：请说一说 iostat 与 iotop 的不同之处？</p><p>A：关注点不同，iostat 关注系统全局，而 iotop 关注点是单个进程。</p><h2 id="第三十四节课" tabindex="-1"><a class="header-anchor" href="#第三十四节课" aria-hidden="true">#</a> 第三十四节课</h2><p>Q：一般 Linux 上的文件系统都有哪些内部结构？</p><p>A：超级块、目录结构、inode 节点、数据块。</p><h2 id="第三十五节课" tabindex="-1"><a class="header-anchor" href="#第三十五节课" aria-hidden="true">#</a> 第三十五节课</h2><p>Q：请问 Ext3 文件系统的超级块放在硬盘分区的第几个扇区中。</p><p>A：第二个到第三个扇区。</p><h2 id="第三十六节课" tabindex="-1"><a class="header-anchor" href="#第三十六节课" aria-hidden="true">#</a> 第三十六节课</h2><p>Q：请问 inode 号是对应于硬盘分区全局，还是相对于块组的？</p><p>A：inode 号对应于硬盘分区全局。</p><h2 id="第三十七节课" tabindex="-1"><a class="header-anchor" href="#第三十七节课" aria-hidden="true">#</a> 第三十七节课</h2><p>Q：浏览器的多进程模型下，进程之间是如何通信的呢？</p><p>A：利用 legacy IPC 和 mojo，在不同平台下的实现是不同的。</p><h2 id="第三十八节课" tabindex="-1"><a class="header-anchor" href="#第三十八节课" aria-hidden="true">#</a> 第三十八节课</h2><p>Q：为什么 JS 代码会阻塞页面渲染？从浏览器设计的角度看，浏览器可以做哪些操作来进行优化？在开发前端应用过程中又可以做哪些优化呢？</p><p>A：</p><p><strong>为什么 JS 代码会阻塞页面渲染</strong></p><p>由于 JS 代码会修改 DOM 元素，渲染进程中的渲染线程和 JS 线程是互斥的。假如 JS 修改了一个元素的属性，但是渲染进程还没渲染到该元素，那 JS 修改属性就会失败。所以，<em>把他们定为互斥是很有必要的</em>。</p><p><strong>浏览器可以做哪些操作来进行优化</strong></p><p>Chrome 浏览器做了很多优化，<em>其中一个主要的优化是预解析操作</em>。当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，<em>预解析线程会提前下载这些文件</em>。</p><p><strong>在开发前端应用过程中可以做哪些优化</strong></p><p>可以使用 CDN 来加速 JavaScript 文件的加载，<em>压缩 JavaScript 文件的体积</em>。另外，如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript <em>脚本设置为异步加载</em>，通过 async 或 defer 来标记代码.</p><p>async 和 defer 虽然都是异步的，不过还有一些差异，</p><ol><li>使用 async 标志的脚本文件一旦加载完成，会立即执行；</li><li>而使用了 defer 标记的脚本文件，需要等到 DOMContentLoaded 事件之后执行。</li></ol><p>在解析的过程中，JavaScript 代码可能会出现操作 CSS 的逻辑，所以在执行 JavaScript 之前，需要先解析 JavaScript 语句之上所有的 CSS 样式。<em>所以如果代码里引用了外部的 CSS 文件，<u>那么在执行 JavaScript 之前</u>，还需要等待外部的 CSS 文件下载完成并解析生成 CSSOM 对象之后，才能执行 JavaScript 脚本</em>。</p><p>因此我们知道，JavaScript 会<u>阻塞 DOM 生成</u>，而 CSS样式文件 又会<u>阻塞 JavaScript 的执行</u>，所以在实际的工程中，需要重点关注 <mark>JavaScript文件</mark> 和 CSS<mark>样式表文件</mark>，以免不当影响到页面性能。</p><h2 id="第三十九节课" tabindex="-1"><a class="header-anchor" href="#第三十九节课" aria-hidden="true">#</a> 第三十九节课</h2><p>Q：V8 在执行 JS 的过程中可以做哪些性能优化？</p><p>A：核心就是利用 JIT 进行优化，<em>一边将代码编译成机器码，一边执行这些机器码</em>，适用于 JS 这种动态的解释型语言。</p><h2 id="第四十节课" tabindex="-1"><a class="header-anchor" href="#第四十节课" aria-hidden="true">#</a> 第四十节课</h2><p>Q：今天，我们学习了在计算机系统中常用的并行化、异步化和调度这三种通用的设计思想，那么请你思考一下，自己工作、生活中还有哪些场景用到了这些思想呢？</p><p>A：开放问题，答案不唯一。存储比较大的文件，就会用到并行化思想，详情可以参考加餐 02 的内容。</p><h2 id="第四十一节课" tabindex="-1"><a class="header-anchor" href="#第四十一节课" aria-hidden="true">#</a> 第四十一节课</h2><p>Q：这节课，我们学习了池化、分层、缓存这三招内功心法，请你思考一下在你的日常工作中有没有哪里用到了这几类设计思想呢？</p><p>A：开放问题，答案不唯一。CaaS 通常被认为是 IaaS 的一种以容器为载体的子集，它介于 IaaS 和 PaaS 之间，它起到了屏蔽底层系统 IaaS，支撑并丰富上层应用平台 PaaS 的作用。这里就体现了分层思想。关于 CaaS，可以参考加餐 04 了解。</p><h2 id="第四十二节课" tabindex="-1"><a class="header-anchor" href="#第四十二节课" aria-hidden="true">#</a> 第四十二节课</h2><p>Q：请你思考一下，eBPF 如果被误用，有没有可能带来新的安全问题呢？</p><p>A：因为 eBPF 代码运行在内核态，并且拥有了从网络到文件系统等很多功能，<em>所以其实也是可以被用来实现成 rootkit 后门的</em>。</p>',73),s={href:"https://github.com/kris-nova/boopkit",target:"_blank",rel:"noopener noreferrer"},l=a("h2",{id:"加餐-01",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#加餐-01","aria-hidden":"true"},"#"),e(" 加餐 01")],-1),m=a("p",null,"Q：WebVirtCloud 是如何把页面上创建虚拟机的操作传递给 libvirt 的，并找出对应的关键代码呢？",-1),S=a("p",null,"A：你可以阅读 vrtManager 目录下的代码，可以看得出 WebVirtCloud 最终也是把各种 WebUI 中的操作。转换成 libvirt API 的调用，通过这种方式来实现虚拟机的管理。",-1),u=a("p",null,"以上就是今天的全部内容了，希望能对你有所帮助！如果你有更多问题，还是请你在留言区中提出。",-1);function f(_,x){const r=i("ExternalLinkIcon");return d(),p("div",null,[o,a("p",null,[e("感兴趣的同学可以看一下"),a("a",s,[e("这个开源项目"),t(r)]),e("，它是一个典型的利用 eBPF 实现开启任意端口、反弹 shell 任意执行命令的后门程序。这意味着，攻与防的技术始终是在对抗中逐渐演进的，当 eBPF 程序被恶意利用的时候，其实也会引发更深层次的安全风险。")]),l,m,S,u])}const J=h(c,[["render",f],["__file","P44-参考答案（二）.html.vue"]]);export{J as default};
