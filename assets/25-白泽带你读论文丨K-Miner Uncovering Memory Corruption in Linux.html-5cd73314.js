import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as a,o as t,c as s,a as e,b as r,e as i,d as p}from"./app-cdabc73c.js";const c="/assets/640-1691479428677-105-0258c2e2.png",d="/assets/640-1691479428678-106-b745df59.png",m="/assets/640-1691479428678-107-e2788106.png",l="/assets/640-1691479428678-108-62701e55.png",g={},_=e("h1",{id:"_25-白泽带你读论文丨k-miner-uncovering-memory-corruption-in-linux",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_25-白泽带你读论文丨k-miner-uncovering-memory-corruption-in-linux","aria-hidden":"true"},"#"),r(" 25-白泽带你读论文丨K-Miner: Uncovering Memory Corruption in Linux")],-1),u=e("h1",{id:"k-miner-uncovering-memory-corruption-in-linux",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#k-miner-uncovering-memory-corruption-in-linux","aria-hidden":"true"},"#"),r(),e("strong",null,"K-Miner: Uncovering Memory Corruption in Linux")],-1),h=e("p",null,"论文链接：",-1),f={href:"https://www.ndss-symposium.org/wp-content/uploads/2018/02/ndss2018_05A-1_Gens_paper.pdf",target:"_blank",rel:"noopener noreferrer"},k={href:"https://github.com/ssl-tud/k-miner",target:"_blank",rel:"noopener noreferrer"},x=p('<p>本文发表在ISOC Network and Distributed System Security Symposium（NDSS）2018，第一作者是来自达姆施塔特工业大学的David Gens。</p><h2 id="_1-主要内容" tabindex="-1"><a class="header-anchor" href="#_1-主要内容" aria-hidden="true">#</a> <strong>1 主要内容</strong></h2><p><mark>内存损坏</mark>（memory corruption）漏洞是操作系统中数量出现比较多的一类漏洞，包括dangling pointers, use-after-free等。但是，目前对于该类型的漏洞检测还存在比较大的空白，主要依靠操作系统引入的许多运行时的机制（比如控制流完整性CFI）来进行被动防御，这些机制并不能消除造成内存损坏的根本原因。</p><p>此外，动态分析技术，比如模糊测试（fuzz），难以检测有复杂嵌套关系的漏洞。相比之下，静态分析技术不仅能在代码中找到bug具体的发生原因，而且能够挖掘更多fuzz难以发现的漏洞。然而，当前在操作系统内核做静态分析的工作都<strong>局限于做局部、过程内的检测</strong>，<em>主要的原因是内核的代码量非常大，如果做大规模检测会出现路径爆炸、资源消耗激增等问题</em>。</p><p>为了解决这些问题，作者提出了一种基于<code>LLVM</code>的静态分析框架：<mark>K-Miner</mark>，</p><blockquote><p>其采用了过程间的数据流分析、大规模的指针分析和结合全局上下文的敏感分析等技术，基于系统调用的接口对内核源代码进行分割，从而实现对内核源代码进行静态分析，挖掘代码中的内存损坏漏洞。最后作者使用K-Miner分析发现了2个新的CVE漏洞。</p></blockquote><h2 id="_2-设计与实现" tabindex="-1"><a class="header-anchor" href="#_2-设计与实现" aria-hidden="true">#</a> <strong>2 设计与实现</strong></h2><figure><img src="'+c+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h3 id="三流程" tabindex="-1"><a class="header-anchor" href="#三流程" aria-hidden="true">#</a> 三流程</h3><p>如图是K-Miner的设计架构图，K-Miner是基于<mark>LLVM</mark>和==SVF（过程间静态数值流分析）==的静态分析框架，主要包含以下三个工作流程：</p><p>（1）K-Miner首先接收两个输入，一个是内核代码，另一个是内核的配置文件，这个配置文件记录了一些内核特性，用来告诉前端解析器，哪些内核模块需要编译，哪些模块不需要编译。编译器根据这两个输入去构建抽象语法树（AST）,并把它转化为中间表示语言（IR）,作为后续的输入。</p><p>（2）把上一步得到的IR作为输入，去遍历所有系统调用，对于每一个系统调用，K-Miner会生成辅助后面分析的数据结构，比如<mark>调用图(CG)</mark>、<mark>控制流图(CFG)</mark>、<mark>指针分析图（PAG）</mark>、==数值流图（VFG）==等，有了这些结果，就可以对每一个系统调用进行相应的漏洞分析。</p><p>（3）对于第二步中的分析结果，如果检测到有内存漏洞，则在这一阶段中产生相应的分析报告，包含相应的内核版本、配置文件、系统调用以及程序执行路径等。</p><figure><img src="'+d+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h3 id="四步骤" tabindex="-1"><a class="header-anchor" href="#四步骤" aria-hidden="true">#</a> 四步骤</h3><p>整个工具核心的分析流程大概分为四步：</p><p><strong>（1）Kernel Memory Context Pre-Analysis</strong>: 首先对要分析的内核上下文进行一些预处理，包括初始化内核的上下文信息、跟踪堆分配的信息、建立系统调用的上下文信息。</p><p><strong>（2）Per-Syscall Value-Flow Analysis</strong>: 然后对内核的每个系统调用做独立的分析。为了获得更加精确的系统调用的上下文，作者通过分析函数调用图确定函数指针的可达性，并结合流敏感的指针分析技术进一步进行约束，最后结合全局内核上下文进行分析，得到较为精简的每一个系统调用的可达函数的集合，从而得到一个更加完整、精确的上下文。</p><p><strong>（3）Analysis Sanitizer</strong>: 在拿到足够多的上下文信息后，这一步会从漏洞挖掘角度做一个精确的数据流分析，以减少工具的误报。文章以检测dangling pointer为例，结合VFG图、PAG图等信息，寻找某个局部结点（也就是局部变量）存在无效的引用并找到对该结点的引用对象，如果找到这样的引用，就表明它是一个悬空指针漏洞。最后将该漏洞所经过的路径信息和相应的结点等保存下来，以便后续处理。</p><p><strong>（4）Reporting Engine</strong>:  对上一步输出的漏洞信息进行简单的去重以及格式等处理，输出最后的漏洞报告。</p><h2 id="_3-实验与分析" tabindex="-1"><a class="header-anchor" href="#_3-实验与分析" aria-hidden="true">#</a> <strong>3 实验与分析</strong></h2><p>作者选择了五个版本的Linux内核代码进行测试，总共测试了300多个系统调用，测试的漏洞类型为DP（Dangling Pointer）、 UAF（Use After Free）和DF（Double Free）。</p><p>（1）<em>工具测试时间评估</em>：结果表明，对于分析每一个系统调用，K-Miner平均大约需要25分钟测试时间。</p><figure><img src="'+m+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>（2）<em>工具内存消耗评估</em>：结果表明，对于分析每一个系统调用，K-Miner平均使用内存在8.7G到13.2G之间，最大值达到26G。由于作者采用了对内核进行分割分析的思想，所以最终的内存消耗还是在可接受的范围的。</p><figure><img src="'+l+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>（3）<em>漏洞挖掘结果</em>：结果表明，K-Miner总计发现了29个可能的漏洞，以及539个疑似的警告。根据工具的结果结合人工分析，作者发现了两个真实的漏洞（CVE-2014-3153、CVE-2015-8962）。另外在人工分析中，作者发现大部分结果为工具误报，特别是UAF类型的误报偏高，作者提到有一部分原因是因为检查是否为NULL这种条件分支也会被识别为潜在的UAF。</p><h2 id="_4-评价" tabindex="-1"><a class="header-anchor" href="#_4-评价" aria-hidden="true">#</a> <strong>4 评价</strong></h2><p>K-Miner是第一个对系统内核进行数值流分析的框架，它能对内核进行大规模的、精确的过程间的静态分析，并能够找到内核中存在的内存损坏漏洞。</p><p>不过从文章最后的实验结果可以看到，工具出现的误报情况仍比较严重，而文章花了比较大篇幅介绍的一系列为了降低fp采用的策略也并没有在实验部分体现其优劣。</p><p>另外，工具的分析也并没有覆盖整个kernel，而是以syscall作为入口，且一次只能分析一个。这样会忽略掉一些情况。比如一些驱动模块，并不会被实现为syscall，而是偏底层实现，比如被作为符号导出到内核镜像使用。</p><p>但总的来说，作者提出的对内核代码按系统调用进行划分的思想，在当时确实<em>有效地解决了</em>内核静态分析中的重要难题-<em>路径爆炸</em>，对后面的工作有一个启示作用。</p>',32);function y(b,M){const n=a("ExternalLinkIcon");return t(),s("div",null,[_,u,h,e("p",null,[e("a",f,[r("https://www.ndss-symposium.org/wp-content/uploads/2018/02/ndss2018_05A-1_Gens_paper.pdf"),i(n)])]),e("p",null,[r("开源项目地址："),e("a",k,[r("https://github.com/ssl-tud/k-miner"),i(n)])]),x])}const L=o(g,[["render",y],["__file","25-白泽带你读论文丨K-Miner Uncovering Memory Corruption in Linux.html.vue"]]);export{L as default};
