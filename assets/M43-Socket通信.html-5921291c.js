import{_ as s}from"./plugin-vue_export-helper-c27b6911.js";import{o as n,c as a,d as e}from"./app-cdabc73c.js";const c="/assets/997e39e5574252ada22220e4b3646dda-af51b877.png",o="/assets/0ef257133471e95bd334383e0155fda4-0fe539ef.png",t="/assets/283b0e1c21f0277ba5b4b5cbcaca03b2-7cec5804.png",p="/assets/d34e667d1c3340deb8c82a2d44f2a65c-bdea30af.png",d={},i=e(`<h1 id="_43-socket通信-遇上特大项目-要学会和其他公司合作" tabindex="-1"><a class="header-anchor" href="#_43-socket通信-遇上特大项目-要学会和其他公司合作" aria-hidden="true">#</a> 43 | Socket通信：遇上特大项目，要学会和其他公司合作</h1><p>上一篇预习文章说了这么多，现在我们终于可以来看一下，在应用层，我们应该如何使用 socket 的接口来进行通信。</p><p>如果你对 socket 相关的网络协议原理不是非常了解，建议你先去看一看上一篇的预习文章，再来看这一篇的内容，就会比较轻松。</p><p>按照前一篇文章说的分层机制，我们可以想到，<code>socket 接口</code>大多数情况下操作的是<code>传输层</code>，更底层的协议不用它来操心，这就是分层的好处。</p><p>在传输层有两个主流的协议 TCP 和 UDP，所以我们的 socket 程序设计也是主要操作这两个协议。这两个协议的区别是什么呢？通常的答案是下面这样的。</p><ul><li>TCP 是面向连接的，UDP 是面向无连接的。</li><li>TCP 提供可靠交付，无差错、不丢失、不重复、并且按序到达；UDP 不提供可靠交付，不保证不丢失，不保证按顺序到达。</li><li>TCP 是面向<code>字节流</code>的，发送时发的是一个流，没头没尾；UDP 是面向<code>数据报</code>的，一个一个地发送。</li><li>TCP 是可以提供流量控制和拥塞控制的，既防止对端被压垮，也防止网络被压垮。</li></ul><p>这些答案没有问题，但是没有到达本质，也经常让人产生错觉。例如，下面这些问题，你看看你是否了解？</p><ul><li>所谓的连接，容易让人误以为，使用 TCP 会使得两端之间的通路和使用 UDP 不一样，那我们会在沿途建立一条线表示这个连接吗？</li><li>我从中国访问美国网站，中间这么多环节，我怎么保证连接不断呢？</li><li>中间有个网络管理员拔了一根网线不就断了吗？我不能控制它，它也不会通知我，我一个个人电脑怎么能够保持连接呢？</li><li>还让我做流量控制和拥塞控制，我既管不了中间的链路，也管不了对端的服务器呀，我怎么能够做到？</li><li>按照网络分层，TCP 和 UDP 都是基于 IP 协议的，IP 都不能保证可靠，说丢就丢，TCP 怎么能够保证呢？</li><li>IP 层都是一个包一个包地发送，TCP 怎么就变成流了？</li></ul><h2 id="数据结构-功夫在两端" tabindex="-1"><a class="header-anchor" href="#数据结构-功夫在两端" aria-hidden="true">#</a> 数据结构 功夫在两端</h2><p>从本质上来讲，所谓的**<code>建立连接</code><strong>，其实是为了在客户端和服务端维护连接，而</strong><code>建立 一定的数据结构 来维护双方交互的状态</code><strong>，并用这样的数据结构来</strong><code>保证面向连接的特性</code>**。TCP <strong>无法左右</strong>中间的任何通路，也没有什么虚拟的连接，<strong>中间的通路</strong>根本意识不到两端使用了 TCP 还是 UDP。</p><p>所谓的**<code>连接</code><strong>，就是</strong><code>两端 数据结构 状态的协同，两边的状态能够对得上</code>**。符合 TCP 协议的规则，就认为连接存在；两面状态对不上，连接就算断了。</p><p>**<code>流量控制</code>和<code>拥塞控制</code>**其实就是<code>根据</code>收到的对端的网络包，<code>调整</code>两端数据结构的状态。TCP 协议的设计理论上认为，这样调整了数据结构的状态，就能进行流量控制和拥塞控制了，其实在通路上是不是真的做到了，谁也管不着。</p><p>所谓的**<code>可靠</code>**，也是两端的数据结构做的事情。</p><ul><li><strong>不丢失</strong>其实是数据结构在“点名”，</li><li><strong>顺序到达</strong>其实是数据结构在“排序”，</li><li><strong>面向数据流</strong>其实是数据结构将零散的包，按照顺序捏成一个流发给应用层。</li></ul><blockquote><p>总而言之，“连接”两个字让人误以为功夫在通路，<code>其实功夫在两端</code>。</p></blockquote><h2 id="socket-对象的构造-格式化-还未bind绑定" tabindex="-1"><a class="header-anchor" href="#socket-对象的构造-格式化-还未bind绑定" aria-hidden="true">#</a> socket 对象的构造 / 格式化 还未bind绑定</h2><p>当然，无论是用 socket 操作 TCP，还是 UDP，我们首先都要调用 socket 函数。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">socket</span><span class="token punctuation">(</span><span class="token keyword">int</span> domain<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span> protocol<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// socket 返回的是一个int</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>socket 函数用于创建一个 socket 的<code>文件描述符</code>，唯一标识<code>一个 socket</code>。我们把它叫作文件描述符，因为在内核中，我们会创建类似文件系统的数据结构，并且后续的操作都有用到它。</p><blockquote><p>中间的通路根本意识不到两端使用了TCP/UDP，socket是用来实现定制化的。</p><p>原理是通过维护两端的数据结构，在传输过程中实现特定的要求。</p><p>也因此socket对象的构造，就是在构造能够满足这种要求的数据结构？</p><ul><li>设置第三层网络协议</li><li>设置第五层（应用程序）发送和接收的数据格式。</li><li>设置第四层传输协议</li></ul><p>socket返回的是一个int。</p></blockquote><p>socket 函数有三个参数。</p><ul><li><code>domain</code>：表示使用什么 IP 层协议。【要满足第3层，具体是什么网络协议？】 <ul><li><mark>AF_INET</mark> 表示 IPv4，</li><li><mark>AF_INET6</mark> 表示 IPv6。</li></ul></li><li><code>type</code>：表示 socket 类型。【设置第五层（应用程序）发送和接收的数据格式。】 <ul><li><mark>SOCK_STREAM</mark>，顾名思义就是 TCP 面向流的，</li><li><mark>SOCK_DGRAM</mark> 就是 UDP 面向数据报的，</li><li><mark>SOCK_RAW</mark> 可以直接操作 IP 层，或者非 TCP 和 UDP 的协议。例如 ICMP。</li></ul></li><li><code>protocol</code> 表示的协议，【要满足第4层，具体是什么传输协议？】 <ul><li>包括 <mark>IPPROTO_TCP</mark>、<mark>IPPTOTO_UDP</mark>。</li></ul></li></ul><p>通信结束后，我们还要<code>像关闭文件一样</code>，关闭 socket。</p><h2 id="针对-tcp-应该如何编程" tabindex="-1"><a class="header-anchor" href="#针对-tcp-应该如何编程" aria-hidden="true">#</a> <strong>针对 TCP 应该如何编程？</strong></h2><p>接下来我们来看，针对 TCP，我们应该如何编程。</p><img src="`+c+`" alt="img" style="zoom:33%;"><h3 id="tcp-服务端-bind-sockfd-port-ip" tabindex="-1"><a class="header-anchor" href="#tcp-服务端-bind-sockfd-port-ip" aria-hidden="true">#</a> TCP 服务端 bind(sockfd, port, IP)</h3><p><mark>TCP 的服务端</mark>要先监听一个端口，一般是先调用 <code>bind</code> 函数，给这个 socket 赋予<code>一个端口</code>和 <code>IP 地址</code>。</p><p>其中，<code>sockfd</code> 是上面我们创建的 socket <mark>文件描述符</mark>。</p><blockquote><p>socket对象已经创建，格式化定制了协议的具体细节。</p><p>但是还需要bind绑定： 1. port端口 2. IP地址</p></blockquote><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// ==TCP 的服务端==要先监听一个端口，一般是先调用 \`bind\` 函数，给这个 socket 赋予\`一个端口\`和 \`IP 地址\`。</span>
<span class="token keyword">int</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span><span class="token class-name">socklen_t</span> addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// \`sockfd\` 是上面我们创建的 socket 文件描述符。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>服务端所在的服务器可能有多个网卡、多个地址，可以选择监听在一个地址，也可以监听 <code>0.0.0.0</code> 表示所有的地址都监听。<mark>服务端</mark>一般要绑定监听在一个众所周知的端口上，例如，<code>Nginx</code> 一般是 80，<code>Tomcat</code> 一般是 8080。</p><p>客户端要访问服务端，肯定事先要知道服务端的端口。无论是电商，还是游戏，还是视频，如果你仔细观察，会发现都有一个这样的端口。可能你会发现，客户端不需要 bind，因为浏览器嘛，随机分配一个端口就可以了，只有你主动去连接别人，别人不会主动连接你，没有人关心客户端监听到了哪里。</p><h3 id="socket绑定port-ip所需要设置的数据结构" tabindex="-1"><a class="header-anchor" href="#socket绑定port-ip所需要设置的数据结构" aria-hidden="true">#</a> ##socket绑定port&amp;IP所需要设置的数据结构</h3><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// ++++++++++++++++++++++++++++++++++++++++ 以下是一些数据结构</span>
<span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> <span class="token punctuation">{</span>
  __kernel_sa_family_t  sin_family<span class="token punctuation">;</span>  <span class="token comment">/* Address family    */</span>
  __be16    sin_port<span class="token punctuation">;</span>  <span class="token comment">/* Port number      */</span>
  <span class="token keyword">struct</span> <span class="token class-name">in_addr</span>  sin_addr<span class="token punctuation">;</span>  <span class="token comment">/* Internet address    */</span>

  <span class="token comment">/* Pad to size of \`struct sockaddr&#39;. */</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">char</span>    __pad<span class="token punctuation">[</span>__SOCK_SIZE__ <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">short</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">-</span>
      <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">in_addr</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">in_addr</span> <span class="token punctuation">{</span>
  __be32  s_addr<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 <code>sockaddr_in</code> 结构中，</p><ul><li><code>sin_family</code> 设置为 AF_INET，表示 IPv4；</li><li><code>sin_port</code> 是端口号；</li><li><code>sin_addr</code> 是 IP 地址。</li></ul><h3 id="区分-大端-小端" tabindex="-1"><a class="header-anchor" href="#区分-大端-小端" aria-hidden="true">#</a> ##区分 大端 小端</h3><blockquote><p>如果你看上面代码中的数据结构，里面的变量名称都有“<code>be</code>”两个字母，代表的意思是“<code>big-endian</code>”。</p><p>如果在网络上传输超过 1 Byte 的类型，就要区分**<code>大端</code><strong>（Big Endian）和</strong><code>小端</code>**（Little Endian）。</p></blockquote><p>假设，我们要在 32 位 4 Bytes 的一个空间存放整数 1，很显然只要 1 Byte 放 1，其他 3 Bytes 放 0 就可以了。那问题是，最后一个 Byte 放 1 呢，还是第一个 Byte 放 1 呢？或者说，1 作为最低位，应该放在 32 位的最后一个位置呢，还是放在第一个位置呢？</p><p>最低位放在最后一个位置，我们叫作小端，最低位放在第一个位置，叫作大端。TCP/IP 栈是按照大端来设计的，而 x86 机器多按照小端来设计，因而发出去时需要做一个转换。</p><h3 id="建立-tcp-连接【s-c的设置】" tabindex="-1"><a class="header-anchor" href="#建立-tcp-连接【s-c的设置】" aria-hidden="true">#</a> 建立 TCP 连接【S/C的设置】</h3><p>接下来，就要建立 TCP 的连接了，也就是著名的三次握手，其实就是将客户端和服务端的状态通过三次网络交互，达到初始状态是<code>协同的状态</code>。下图就是三次握手的序列图以及对应的状态转换。</p><img src="`+o+'" alt="img" style="zoom:33%;"><h3 id="_1-tcp-服务端-listen-sockfd" tabindex="-1"><a class="header-anchor" href="#_1-tcp-服务端-listen-sockfd" aria-hidden="true">#</a> 1. TCP 服务端 listen(sockfd)</h3><p>接下来，<mark>TCP 服务端</mark>要调用 <code>listen</code> 进入 <mark>LISTEN 状态</mark>，等待客户端进行连接。</p><blockquote><p><code>【内核态】</code>连接的建立过程，也即三次握手，是 TCP 层的动作，<code>是在内核完成的</code>，应用层不需要参与。</p></blockquote><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// 接下来，==TCP 服务端==要调用 listen 进入 LISTEN 状态，等待客户端进行连接。</span>\n<span class="token keyword">int</span> <span class="token function">listen</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">int</span> backlog<span class="token punctuation">)</span><span class="token punctuation">;</span>\n			<span class="token comment">// `sockfd` 是上面我们创建的 socket 文件描述符。</span>\n<span class="token comment">// 返回也是int				// 服务端 listen 得到 `用于监听的socket` 的文件描述符</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-tcp-服务端-accept-sockfd-port-ip" tabindex="-1"><a class="header-anchor" href="#_2-tcp-服务端-accept-sockfd-port-ip" aria-hidden="true">#</a> 2. TCP 服务端 accept(sockfd, port, IP)</h3><p>接着，<mark>TCP 服务端</mark>只需要调用 <code>accept</code>，等待内核完成了<code>至少一个连接</code>的建立，才返回。</p><ul><li><p><code>如果没有一个连接</code>完成了三次握手，accept 就一直等待；</p></li><li><p>如果有多个客户端发起连接，并且在内核里面完成了多个三次握手，<code>建立了多个连接</code>，这些连接会被放在一个队列里面。</p><blockquote><p>这个队列存在于内核，并且每个连接都是不同的端口号。</p></blockquote></li><li><p>accept 会从<code>队列</code>里面取出一个来进行处理。</p></li><li><p>如果想进一步处理其他连接，需要调用多次 accept，所以 accept <mark>往往在一个循环里面</mark>。</p></li></ul><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// ==TCP 服务端==只需要调用 `accept`，等待内核完成了`至少一个连接`的建立，才返回。</span>\n<span class="token keyword">int</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> <span class="token class-name">socklen_t</span> <span class="token operator">*</span>addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// 返回也是int				// 服务端 accept 返回 `用于传输的 socket` 的文件描述符；</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-tcp-客户端-connect-sockfd-port-ip" tabindex="-1"><a class="header-anchor" href="#_3-tcp-客户端-connect-sockfd-port-ip" aria-hidden="true">#</a> 3. TCP 客户端 connect(sockfd, port, IP)</h3><p>接下来，<mark>TCP 客户端</mark>可以通过 <code>connect</code> 函数发起连接。</p><p>我们先在参数中指明要连接的 <code>IP 地址</code>和<code>端口号</code>，然后<code>发起</code>三次握手。</p><blockquote><p><code>【内核态】</code>内核会给客户端分配<mark>一个临时的端口</mark>。</p></blockquote><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// ==TCP 客户端==可以通过 `connect` 函数发起连接。</span>\n<span class="token keyword">int</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> <span class="token class-name">socklen_t</span> addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span>\n								<span class="token comment">// 在参数中指明要连接的 `IP 地址`和`端口号`，然后`发起`三次握手。</span>\n<span class="token comment">// 返回也是int				// 客户端 connect 得到 `用于传输的 socket` 的文件描述符；</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="监听socket-已连接socket" tabindex="-1"><a class="header-anchor" href="#监听socket-已连接socket" aria-hidden="true">#</a> 监听socket ≠ 已连接socket</h3><p>一旦握手成功，服务端的 accept 就会返回另一个 socket。</p><p>这里需要注意的是，监听的 socket 和真正用来传送数据的 socket，是两个 socket，一个叫作**<code>监听 socket</code><strong>，一个叫作</strong><code>已连接 socket</code>**。成功连接建立之后，双方开始通过 <code>read</code> 和 <code>write</code> 函数来读写数据，<code>就像往 一个文件流 里面写东西一样</code>。</p><h2 id="针对-udp-应该如何编程" tabindex="-1"><a class="header-anchor" href="#针对-udp-应该如何编程" aria-hidden="true">#</a> <strong>针对 UDP 应该如何编程？</strong></h2><p>接下来我们来看，针对 UDP 应该如何编程。</p><img src="'+t+`" alt="img" style="zoom:33%;"><p>UDP 是<code>没有连接</code>的，所以<code>不需要</code>三次握手，也就不需要调用 listen 和 connect，但是 UDP 的交互仍然需要 IP 地址和端口号，因而也需要 <code>bind</code>。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token class-name">ssize_t</span> <span class="token function">sendto</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> len<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>dest_addr<span class="token punctuation">,</span> <span class="token class-name">socklen_t</span> addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">ssize_t</span> <span class="token function">recvfrom</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> len<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>src_addr<span class="token punctuation">,</span> <span class="token class-name">socklen_t</span> <span class="token operator">*</span>addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于 UDP 来讲，<code>没有所谓的连接维护</code>，也没有所谓的连接的发起方和接收方，<code>甚至都不存在客户端和服务端的概念</code>，大家就都是客户端，也同时都是服务端。只要有一个 socket，<code>多台机器就可以任意通信</code>，不存在哪两台机器是属于一个连接的概念。因此，<strong><code>每一个 UDP 的 socket 都需要 bind</code></strong>。每次通信时，调用 <code>sendto</code> 和 <code>recvfrom</code>，都要传入 IP 地址和端口。</p><h2 id="总结时刻" tabindex="-1"><a class="header-anchor" href="#总结时刻" aria-hidden="true">#</a> <strong>总结时刻</strong></h2><p>这一节我们讲了网络协议的基本原理和 socket 系统调用，这里请你重点关注 TCP 协议的系统调用。</p><p>通过学习，我们知道，socket 系统调用是<code>用户态</code>和<code>内核态</code>的接口，网络协议的四层以下都是在内核中的。很多的书籍会讲如何开发一个<code>高性能的 socket 程序</code>，但是这不是我们这门课的重点，所以我们主要看内核里面的机制就行了。</p><p>因此，你需要记住 TCP 协议的 socket 调用的过程。我们接下来就按照这个顺序，依次回忆一下这些系统调用到内核都做了什么：</p><ul><li>服务端和客户端都调用 socket，得到<code>文件描述符</code>；</li><li>服务端调用 listen，<code>进行监听</code>；</li><li>服务端调用 accept，<code>等待客户端连接</code>；</li><li>客户端调用 connect，<code>连接服务端</code>；</li><li>服务端 accept 返回<code>用于传输的 socket</code> 的文件描述符；【<code>用于监听的socket</code> 使命已经完成，】</li><li>客户端调用 write 写入数据；</li><li>服务端调用 read 读取数据。</li></ul><img src="`+p+'" alt="img" style="zoom:33%;"><h2 id="课堂练习" tabindex="-1"><a class="header-anchor" href="#课堂练习" aria-hidden="true">#</a> <strong>课堂练习</strong></h2><p>请你根据今天讲的 socket 系统调用，写一个简单的 socket 程序来传输一个字符串。</p><p>欢迎留言和我分享你的疑惑和见解 ，也欢迎可以收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习和进步。</p><h2 id="课后讨论" tabindex="-1"><a class="header-anchor" href="#课后讨论" aria-hidden="true">#</a> 课后讨论</h2><p>『连接功夫在两端，而不在通路。通过两端的底层sock结构体维持状态信息。』<br> 作者回复：两个socket，两个数据结构保存不同的状态。</p><p>原来0000，是指监听一个服务器的全部网卡，soga<br> 网友回复：是所有IP哦，不是一个服务器全部网卡</p><p>TCP面向连接，HTTP无状态总是搞混，问一下基于TCP的HTTP为什么不设置一个状态依赖的东西，要靠cookie和session来帮忙呢？这个UDP上学的时候知道实时通话视频会用到，丢包丢多了是不是就是我们感觉“卡卡的”掉帧的情况。<br> 网友回复：http如果是有状态的，各种中间件缓存啥的不好搞了。</p><p>其实我对tcp和udp的理解就是tcp协议栈由分段maxsegment(握手阶段的附加)，自己尽量来处理最大MTU问题，尽量防止ip分片，对端网络层组包，从而导致的tcp应用使用协议需要考虑处理分包，粘包。<br> 作者回复: 可以offload给硬件</p>',80),l=[i];function r(k,u){return n(),a("div",null,l)}const h=s(d,[["render",r],["__file","M43-Socket通信.html.vue"]]);export{h as default};
