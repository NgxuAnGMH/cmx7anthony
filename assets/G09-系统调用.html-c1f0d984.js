import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as l,o as i,c,a as n,b as s,e,d as p}from"./app-cdabc73c.js";const o="/assets/566299fe7411161bae25b62e7fe20506-974577e0.jpg",r="/assets/1fc62ab8406c218de6e0b8c7e01fdbd7-4ba80177.jpg",d="/assets/868db3f559ad08659ddc74db07a9a0a5-569aecf5.jpg",u={},_=p(`<h1 id="_09-系统调用-公司成立好了就要开始接项目" tabindex="-1"><a class="header-anchor" href="#_09-系统调用-公司成立好了就要开始接项目" aria-hidden="true">#</a> 09 | 系统调用：公司成立好了就要开始接项目</h1><p>上一节，系统终于进入了用户态，公司由一个“皮包公司”进入正轨，可以开始接项目了。</p><p>这一节，我们来解析 Linux 接项目的办事大厅是如何实现的，这是因为后面介绍的每一个模块，都涉及系统调用。站在系统调用的角度，层层深入下去，就能从某个系统调用的场景出发，了解内核中各个模块的实现机制。</p><p>有的时候，我们的客户觉得，直接去办事大厅还是不够方便。没问题，Linux 还提供了 glibc 这个中介。它更熟悉系统调用的细节，并且可以封装成更加友好的接口。你可以直接用。</p><h2 id="glibc-对系统调用的封装" tabindex="-1"><a class="header-anchor" href="#glibc-对系统调用的封装" aria-hidden="true">#</a> <strong>glibc 对系统调用的封装</strong></h2><p>我们以最常用的系统调用 open，打开一个文件为线索，看看系统调用是怎么实现的。这一节我们仅仅会解析到从 glibc 如何调用到内核的 open，至于 open 怎么实现，怎么打开一个文件，留到文件系统那一节讲。</p><p>现在我们就开始在用户态进程里面调用 open 函数。</p><p>为了方便，大部分用户会选择使用中介，也就是说，调用的是 glibc 里面的 open 函数。这个函数是如何定义的呢？</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token class-name">mode_t</span> mode<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在 glibc 的源代码中，有个文件 syscalls.list，里面列着所有 glibc 的函数对应的系统调用，就像下面这个样子：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">File name Caller  Syscall name    Args    Strong name Weak names</span></span>
open    <span class="token operator">-</span>  open    Ci<span class="token operator">:</span>siv  __libc_open __open open
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>`,11),k={href:"http://make-syscall.sh",target:"_blank",rel:"noopener noreferrer"},v=p(`<p>glibc 还有一个文件 syscall-template.S，使用上面这个宏，定义了这个系统调用的调用方式。</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>T_PSEUDO (SYSCALL_SYMBOL, SYSCALL_NAME, SYSCALL_NARGS)
    ret
T_PSEUDO_END (SYSCALL_SYMBOL)

#define T_PSEUDO(SYMBOL, NAME, N)    PSEUDO (SYMBOL, NAME, N)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的 PSEUDO 也是一个宏，它的定义如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">PSEUDO</span><span class="token expression"><span class="token punctuation">(</span>name<span class="token punctuation">,</span> syscall_name<span class="token punctuation">,</span> args<span class="token punctuation">)</span>                      </span><span class="token punctuation">\\</span>
  <span class="token expression"><span class="token punctuation">.</span>text<span class="token punctuation">;</span>                                      </span><span class="token punctuation">\\</span>
  <span class="token expression"><span class="token function">ENTRY</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span>                                    </span><span class="token punctuation">\\</span>
    <span class="token expression"><span class="token function">DO_CALL</span> <span class="token punctuation">(</span>syscall_name<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>                         </span><span class="token punctuation">\\</span>
    <span class="token expression">cmpl $<span class="token operator">-</span><span class="token number">4095</span><span class="token punctuation">,</span> <span class="token operator">%</span>eax<span class="token punctuation">;</span>                               </span><span class="token punctuation">\\</span>
    <span class="token expression">jae SYSCALL_ERROR_LABEL</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>里面对于任何一个系统调用，会调用 DO_CALL。这也是一个宏，这个宏 32 位和 64 位的定义是不一样的。</p><h2 id="_32-位系统调用过程" tabindex="-1"><a class="header-anchor" href="#_32-位系统调用过程" aria-hidden="true">#</a> <strong>32 位系统调用过程</strong></h2><p>我们先来看 32 位的情况（i386 目录下的 sysdep.h 文件）。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/* Linux takes system call arguments in registers:
  syscall number  %eax       call-clobbered
  arg 1    %ebx       call-saved
  arg 2    %ecx       call-clobbered
  arg 3    %edx       call-clobbered
  arg 4    %esi       call-saved
  arg 5    %edi       call-saved
  arg 6    %ebp       call-saved
......
*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">DO_CALL</span><span class="token expression"><span class="token punctuation">(</span>syscall_name<span class="token punctuation">,</span> args<span class="token punctuation">)</span>                           </span><span class="token punctuation">\\</span>
    <span class="token expression">PUSHARGS_</span><span class="token punctuation">##</span><span class="token expression">args                               </span><span class="token punctuation">\\</span>
    <span class="token expression">DOARGS_</span><span class="token punctuation">##</span><span class="token expression">args                                 </span><span class="token punctuation">\\</span>
    <span class="token expression">movl $<span class="token function">SYS_ify</span> <span class="token punctuation">(</span>syscall_name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>eax<span class="token punctuation">;</span>                          </span><span class="token punctuation">\\</span>
    <span class="token expression">ENTER_KERNEL                                  </span><span class="token punctuation">\\</span>
    <span class="token expression">POPARGS_</span><span class="token punctuation">##</span><span class="token expression">args</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里，我们将请求参数放在寄存器里面，根据系统调用的名称，得到系统调用号，放在寄存器 eax 里面，然后执行 ENTER_KERNEL。</p><p>在 Linux 的源代码注释里面，我们可以清晰地看到，这些寄存器是如何传递系统调用号和参数的。</p><p>这里面的 ENTER_KERNEL 是什么呢？</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">define</span> <span class="token macro-name">ENTER_KERNEL</span> <span class="token expression"><span class="token keyword">int</span> $<span class="token number">0x80</span></span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>int 就是 interrupt，也就是“中断”的意思。int $0x80 就是触发一个软中断，通过它就可以陷入（trap）内核。</p><p>在内核启动的时候，还记得有一个 trap_init()，其中有这样的代码：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token function">set_system_intr_gate</span><span class="token punctuation">(</span>IA32_SYSCALL_VECTOR<span class="token punctuation">,</span> entry_INT80_32<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这是一个软中断的陷入门。当接收到一个系统调用的时候，entry_INT80_32 就被调用了。</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>ENTRY(entry_INT80_32)
        ASM_CLAC
        pushl   %eax                    /* pt_regs-&gt;orig_ax */
        SAVE_ALL pt_regs_ax=$-ENOSYS    /* save rest */
        movl    %esp, %eax
        call    do_syscall_32_irqs_on
.Lsyscall_32_done:
......
.Lirq_return:
  INTERRUPT_RETURN
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过 push 和 SAVE_ALL 将当前用户态的寄存器，保存在 pt_regs 结构里面。</p><p>进入内核之前，保存所有的寄存器，然后调用 do_syscall_32_irqs_on。它的实现如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token function">do_syscall_32_irqs_on</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token operator">*</span>regs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">thread_info</span> <span class="token operator">*</span>ti <span class="token operator">=</span> <span class="token function">current_thread_info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> nr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>regs<span class="token operator">-&gt;</span>orig_ax<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>nr <span class="token operator">&lt;</span> IA32_NR_syscalls<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    regs<span class="token operator">-&gt;</span>ax <span class="token operator">=</span> ia32_sys_call_table<span class="token punctuation">[</span>nr<span class="token punctuation">]</span><span class="token punctuation">(</span>
      <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>regs<span class="token operator">-&gt;</span>bx<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>regs<span class="token operator">-&gt;</span>cx<span class="token punctuation">,</span>
      <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>regs<span class="token operator">-&gt;</span>dx<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>regs<span class="token operator">-&gt;</span>si<span class="token punctuation">,</span>
      <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>regs<span class="token operator">-&gt;</span>di<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>regs<span class="token operator">-&gt;</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">syscall_return_slowpath</span><span class="token punctuation">(</span>regs<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这里，我们看到，将系统调用号从 eax 里面取出来，然后根据系统调用号，在系统调用表中找到相应的函数进行调用，并将寄存器中保存的参数取出来，作为函数参数。如果仔细比对，就能发现，这些参数所对应的寄存器，和 Linux 的注释是一样的。</p><p>根据宏定义，#define ia32_sys_call_table sys_call_table，系统调用就是放在这个表里面。至于这个表是如何形成的，我们后面讲。</p><p>当系统调用结束之后，在 entry_INT80_32 之后，紧接着调用的是 INTERRUPT_RETURN，我们能够找到它的定义，也就是 iret。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">INTERRUPT_RETURN</span>                <span class="token expression">iret</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>iret 指令将原来用户态保存的现场恢复回来，包含代码段、指令指针寄存器等。这时候用户态进程恢复执行。</p><h2 id="小总结" tabindex="-1"><a class="header-anchor" href="#小总结" aria-hidden="true">#</a> 小总结</h2><p>这里我总结一下 32 位的系统调用是如何执行的。</p><img src="`+o+`" alt="img" style="zoom:33%;"><h2 id="_64-位系统调用过程" tabindex="-1"><a class="header-anchor" href="#_64-位系统调用过程" aria-hidden="true">#</a> <strong>64 位系统调用过程</strong></h2><p>我们再来看 64 位的情况（x86_64 下的 sysdep.h 文件）。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/* The Linux/x86-64 kernel expects the system call parameters in
   registers according to the following table:
    syscall number  rax
    arg 1    rdi
    arg 2    rsi
    arg 3    rdx
    arg 4    r10
    arg 5    r8
    arg 6    r9
......
*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">DO_CALL</span><span class="token expression"><span class="token punctuation">(</span>syscall_name<span class="token punctuation">,</span> args<span class="token punctuation">)</span>                </span><span class="token punctuation">\\</span>
  <span class="token expression">lea <span class="token function">SYS_ify</span> <span class="token punctuation">(</span>syscall_name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>rax<span class="token punctuation">;</span>                </span><span class="token punctuation">\\</span>
  <span class="token expression">syscall</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>和之前一样，还是将系统调用名称转换为系统调用号，放到寄存器 rax。这里是真正进行调用，不是用中断了，而是改用 syscall 指令了。并且，通过注释我们也可以知道，传递参数的寄存器也变了。</p><p>syscall 指令还使用了一种特殊的寄存器，我们叫<strong>特殊模块寄存器</strong>（Model Specific Registers，简称 MSR）。这种寄存器是 CPU 为了完成某些特殊控制功能为目的的寄存器，其中就有系统调用。</p><p>在系统初始化的时候，trap_init 除了初始化上面的中断模式，这里面还会调用 cpu_init-&gt;syscall_init。这里面有这样的代码：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token function">wrmsrl</span><span class="token punctuation">(</span>MSR_LSTAR<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span>entry_SYSCALL_64<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>rdmsr 和 wrmsr 是用来读写特殊模块寄存器的。MSR_LSTAR 就是这样一个特殊的寄存器，当 syscall 指令调用的时候，会从这个寄存器里面拿出函数地址来调用，也就是调用 entry_SYSCALL_64。</p><p>在 arch/x86/entry/entry_64.S 中定义了 entry_SYSCALL_64。</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>ENTRY(entry_SYSCALL_64)
        /* Construct struct pt_regs on stack */
        pushq   $__USER_DS                      /* pt_regs-&gt;ss */
        pushq   PER_CPU_VAR(rsp_scratch)        /* pt_regs-&gt;sp */
        pushq   %r11                            /* pt_regs-&gt;flags */
        pushq   $__USER_CS                      /* pt_regs-&gt;cs */
        pushq   %rcx                            /* pt_regs-&gt;ip */
        pushq   %rax                            /* pt_regs-&gt;orig_ax */
        pushq   %rdi                            /* pt_regs-&gt;di */
        pushq   %rsi                            /* pt_regs-&gt;si */
        pushq   %rdx                            /* pt_regs-&gt;dx */
        pushq   %rcx                            /* pt_regs-&gt;cx */
        pushq   $-ENOSYS                        /* pt_regs-&gt;ax */
        pushq   %r8                             /* pt_regs-&gt;r8 */
        pushq   %r9                             /* pt_regs-&gt;r9 */
        pushq   %r10                            /* pt_regs-&gt;r10 */
        pushq   %r11                            /* pt_regs-&gt;r11 */
        sub     $(6*8), %rsp                    /* pt_regs-&gt;bp, bx, r12-15 not saved */
        movq    PER_CPU_VAR(current_task), %r11
        testl   $_TIF_WORK_SYSCALL_ENTRY|_TIF_ALLWORK_MASK, TASK_TI_flags(%r11)
        jnz     entry_SYSCALL64_slow_path
......
entry_SYSCALL64_slow_path:
        /* IRQs are off. */
        SAVE_EXTRA_REGS
        movq    %rsp, %rdi
        call    do_syscall_64           /* returns with IRQs disabled */
return_from_SYSCALL_64:
  RESTORE_EXTRA_REGS
  TRACE_IRQS_IRETQ
  movq  RCX(%rsp), %rcx
  movq  RIP(%rsp), %r11
    movq  R11(%rsp), %r11
......
syscall_return_via_sysret:
  /* rcx and r11 are already restored (see code above) */
  RESTORE_C_REGS_EXCEPT_RCX_R11
  movq  RSP(%rsp), %rsp
  USERGS_SYSRET64
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里先保存了很多寄存器到 pt_regs 结构里面，例如用户态的代码段、数据段、保存参数的寄存器，然后调用 entry_SYSCALL64_slow_pat-&gt;do_syscall_64。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>__visible <span class="token keyword">void</span> <span class="token function">do_syscall_64</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token operator">*</span>regs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">thread_info</span> <span class="token operator">*</span>ti <span class="token operator">=</span> <span class="token function">current_thread_info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> nr <span class="token operator">=</span> regs<span class="token operator">-&gt;</span>orig_ax<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span><span class="token punctuation">(</span>nr <span class="token operator">&amp;</span> __SYSCALL_MASK<span class="token punctuation">)</span> <span class="token operator">&lt;</span> NR_syscalls<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                regs<span class="token operator">-&gt;</span>ax <span class="token operator">=</span> sys_call_table<span class="token punctuation">[</span>nr <span class="token operator">&amp;</span> __SYSCALL_MASK<span class="token punctuation">]</span><span class="token punctuation">(</span>
                        regs<span class="token operator">-&gt;</span>di<span class="token punctuation">,</span> regs<span class="token operator">-&gt;</span>si<span class="token punctuation">,</span> regs<span class="token operator">-&gt;</span>dx<span class="token punctuation">,</span>
                        regs<span class="token operator">-&gt;</span>r10<span class="token punctuation">,</span> regs<span class="token operator">-&gt;</span>r8<span class="token punctuation">,</span> regs<span class="token operator">-&gt;</span>r9<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">syscall_return_slowpath</span><span class="token punctuation">(</span>regs<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 do_syscall_64 里面，从 rax 里面拿出系统调用号，然后根据系统调用号，在系统调用表 sys_call_table 中找到相应的函数进行调用，并将寄存器中保存的参数取出来，作为函数参数。如果仔细比对，你就能发现，这些参数所对应的寄存器，和 Linux 的注释又是一样的。</p><p>所以，无论是 32 位，还是 64 位，都会到系统调用表 sys_call_table 这里来。</p><p>在研究系统调用表之前，我们看 64 位的系统调用返回的时候，执行的是 USERGS_SYSRET64。定义如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">USERGS_SYSRET64</span>        <span class="token punctuation">\\</span>
  <span class="token expression">swapgs<span class="token punctuation">;</span>          </span><span class="token punctuation">\\</span>
  <span class="token expression">sysretq<span class="token punctuation">;</span></span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里，返回用户态的指令变成了 sysretq。</p><h2 id="小总结-1" tabindex="-1"><a class="header-anchor" href="#小总结-1" aria-hidden="true">#</a> 小总结</h2><p>我们这里总结一下 64 位的系统调用是如何执行的。</p><img src="`+r+`" alt="img" style="zoom:33%;"><h2 id="系统调用表" tabindex="-1"><a class="header-anchor" href="#系统调用表" aria-hidden="true">#</a> <strong>系统调用表</strong></h2><p>前面我们重点关注了系统调用的方式，都是最终到了系统调用表，但是到底调用内核的什么函数，还没有解读。</p><p>现在我们再来看，系统调用表 sys_call_table 是怎么形成的呢？</p><p>32 位的系统调用表定义在 <code>arch/x86/entry/syscalls/syscall_32.tbl</code> 文件里。例如 open 是这样定义的：</p><div class="language-tcl line-numbers-mode" data-ext="tcl"><pre class="language-tcl"><code>5  i386  open      sys_open  compat_sys_open
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>64 位的系统调用定义在另一个文件 <code>arch/x86/entry/syscalls/syscall_64.tbl</code> 里。例如 open 是这样定义的：</p><div class="language-tcl line-numbers-mode" data-ext="tcl"><pre class="language-tcl"><code>2  common  open      sys_open
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>第一列的数字是系统调用号。可以看出，32 位和 64 位的系统调用号是不一样的。第三列是系统调用的名字，第四列是系统调用在内核的实现函数。不过，它们都是以 sys_ 开头。</p><p>系统调用在内核中的实现函数要有一个声明。声明往往在 include/linux/syscalls.h 文件中。例如 sys_open 是这样声明的：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>asmlinkage <span class="token keyword">long</span> <span class="token function">sys_open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>filename<span class="token punctuation">,</span>
                                <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token class-name">umode_t</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>真正的实现这个系统调用，一般在一个.c 文件里面，例如 sys_open 的实现在 fs/open.c 里面，但是你会发现样子很奇怪。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>open<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> filename<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> flags<span class="token punctuation">,</span> <span class="token class-name">umode_t</span><span class="token punctuation">,</span> mode<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">force_o_largefile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                flags <span class="token operator">|=</span> O_LARGEFILE<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">do_sys_open</span><span class="token punctuation">(</span>AT_FDCWD<span class="token punctuation">,</span> filename<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>SYSCALL_DEFINE3 是一个宏系统调用最多六个参数，根据参数的数目选择宏。具体是这样定义的：</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>#define SYSCALL_DEFINE1(name, ...) SYSCALL_DEFINEx(1, _##name, __VA_ARGS__)
#define SYSCALL_DEFINE2(name, ...) SYSCALL_DEFINEx(2, _##name, __VA_ARGS__)
#define SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(3, _##name, __VA_ARGS__)
#define SYSCALL_DEFINE4(name, ...) SYSCALL_DEFINEx(4, _##name, __VA_ARGS__)
#define SYSCALL_DEFINE5(name, ...) SYSCALL_DEFINEx(5, _##name, __VA_ARGS__)
#define SYSCALL_DEFINE6(name, ...) SYSCALL_DEFINEx(6, _##name, __VA_ARGS__)


#define SYSCALL_DEFINEx(x, sname, ...)                          \\
        SYSCALL_METADATA(sname, x, __VA_ARGS__)                 \\
        __SYSCALL_DEFINEx(x, sname, __VA_ARGS__)


#define __PROTECT(...) asmlinkage_protect(__VA_ARGS__)
#define __SYSCALL_DEFINEx(x, name, ...)                                 \\
        asmlinkage long sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))       \\
                __attribute__((alias(__stringify(SyS##name))));         \\
        static inline long SYSC##name(__MAP(x,__SC_DECL,__VA_ARGS__));  \\
        asmlinkage long SyS##name(__MAP(x,__SC_LONG,__VA_ARGS__));      \\
        asmlinkage long SyS##name(__MAP(x,__SC_LONG,__VA_ARGS__))       \\
        {                                                               \\
                long ret = SYSC##name(__MAP(x,__SC_CAST,__VA_ARGS__));  \\
                __MAP(x,__SC_TEST,__VA_ARGS__);                         \\
                __PROTECT(x, ret,__MAP(x,__SC_ARGS,__VA_ARGS__));       \\
                return ret;                                             \\
        }                                                               \\
        static inline long SYSC##name(__MAP(x,__SC_DECL,__VA_ARGS__)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们把宏展开之后，实现如下，和声明的是一样的。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>asmlinkage <span class="token keyword">long</span> <span class="token function">sys_open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span> filename<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">int</span> mode<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
 <span class="token keyword">long</span> ret<span class="token punctuation">;</span>


 <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">force_o_largefile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  flags <span class="token operator">|=</span> O_LARGEFILE<span class="token punctuation">;</span>


 ret <span class="token operator">=</span> <span class="token function">do_sys_open</span><span class="token punctuation">(</span>AT_FDCWD<span class="token punctuation">,</span> filename<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token function">asmlinkage_protect</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> ret<span class="token punctuation">,</span> filename<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>声明和实现都好了。接下来，在编译的过程中，需要根据 <code>syscall_32.tbl 和 syscall_64.tbl</code> 生成自己的 <code>unistd_32.h 和 unistd_64.h</code>。生成方式在 <code>arch/x86/entry/syscalls/Makefile</code> 中。</p><p>这里面会使用两个脚本，</p><ol><li>其中第一个脚本 arch/x86/entry/syscalls/syscallhdr.sh，会在文件中生成 <code>#define __NR_open</code>；</li><li>第二个脚本 arch/x86/entry/syscalls/syscalltbl.sh，会在文件中生成 <code>__SYSCALL(__NR_open, sys_open)</code>。这样，unistd_32.h 和 unistd_64.h 是对应的系统调用号和系统调用实现函数之间的对应关系。</li></ol><p>在文件 arch/x86/entry/syscall_32.c，定义了这样一个表，里面 include 了这个头文件，从而所有的 sys_ 系统调用都在这个表里面了。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>__visible <span class="token keyword">const</span> <span class="token class-name">sys_call_ptr_t</span> ia32_sys_call_table<span class="token punctuation">[</span>__NR_syscall_compat_max<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token comment">/*
         * Smells like a compiler bug -- it doesn&#39;t work
         * when the &amp; below is removed.
         */</span>
        <span class="token punctuation">[</span><span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> __NR_syscall_compat_max<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>sys_ni_syscall<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;asm/syscalls_32.h&gt;</span></span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同理，在文件 arch/x86/entry/syscall_64.c，定义了这样一个表，里面 include 了这个头文件，这样所有的 sys_ 系统调用就都在这个表里面了。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/* System call table for x86-64. */</span>
asmlinkage <span class="token keyword">const</span> <span class="token class-name">sys_call_ptr_t</span> sys_call_table<span class="token punctuation">[</span>__NR_syscall_max<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">/*
   * Smells like a compiler bug -- it doesn&#39;t work
   * when the &amp; below is removed.
   */</span>
  <span class="token punctuation">[</span><span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> __NR_syscall_max<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>sys_ni_syscall<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;asm/syscalls_64.h&gt;</span></span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="总结时刻" tabindex="-1"><a class="header-anchor" href="#总结时刻" aria-hidden="true">#</a> <strong>总结时刻</strong></h2><p>系统调用的过程还是挺复杂的吧？如果加上上一节的内核态和用户态的模式切换，就更复杂了。这里我们重点分析 64 位的系统调用，我将整个完整的过程画了一张图，帮你总结、梳理一下。</p><img src="`+d+'" alt="img" style="zoom:25%;"><h2 id="课堂练习" tabindex="-1"><a class="header-anchor" href="#课堂练习" aria-hidden="true">#</a> <strong>课堂练习</strong></h2><p>请你根据这一节的分析，看一下与 open 这个系统调用相关的文件都有哪些，在每个文件里面都做了什么？如果你要自己实现一个系统调用，能不能照着 open 来一个呢？</p><p>欢迎留言和我分享你的疑惑和见解，也欢迎你收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习、进步。</p><h2 id="课后讨论" tabindex="-1"><a class="header-anchor" href="#课后讨论" aria-hidden="true">#</a> 课后讨论</h2><p>对于做业务的同学真的不需要学习的这么细，<strong>分层学习才是适合自己的</strong>。通过操作系统课程了解大部分核心流程，比如进程的创建流程、内存分页这些基础概念。细节的东西日常用不到，<strong>即使现在弄懂了很快也会忘记</strong>，真有用到再来学习也会事倍功半。</p><p><mark>宏是什么？给像我一样不懂C的人:</mark></p><p>1，使用命令 #define 定义宏。该命令允许把一个名称指定成任何所需的文本，例如一个常量值或者一条语句。在定义了宏之后，无论宏名称出现在源代码的何处，预处理器都会把它用定义时指定的文本替换掉。</p><p>2，宏的名称一般使用全大写的形式。</p><p>3，宏可以定义参数，参数列表需要使用圆括号包裹，且必须紧跟名称，中间不能有空格。</p><p>4，使用#undef NAME取消宏的定义，从而可以重新定义或使用与宏重名的函数或变量。</p><p>5，出现在字符串中的宏名称不会被预编译器展开。</p>',85),m={href:"https://www.gnu.org/software/libc/started.html%E3%80%82",target:"_blank",rel:"noopener noreferrer"},b=n("mark",null,"主要过程是CPU上下文切换的过程。",-1),g={href:"https://elixir.bootlin.com/linux/v4.13.16",target:"_blank",rel:"noopener noreferrer"},y={href:"https://garlicspace.com/2019/06/02/linux%E4%B8%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/",target:"_blank",rel:"noopener noreferrer"},h=p('<p>1 用户在应用空间想要用内核环境的资源，怎么办捏？linux死规定了，就只能通过系统调用层</p><p>2 用户想要用什么资源就得通过调用对应的系统调用函数并加上参数</p><p>3 什么时候才真正实现了得到你想要的资源呢？</p><ul><li>那就是进入到内核空间（在中断处理函数里就可以），并调用了对应的系统调用函数（通过你在应用空间使用的函数（这些是名字固定了的）</li><li>--&gt; 里面有函数计算出对应的（映射的）真正系统调用号（就是真正系统调用函数地址在系统调用数组里的位置）</li><li>--&gt; 通过现在得到的系统调用号从系统调用数组中拿出这个真正的系统调用函数并执行，肯定加上一起传下来的参数了</li><li>--&gt; 返回</li></ul><p><mark>有个问题：首先没有说在这个文章中自己使用的glibc的版本是哪个版本的。其次：make-syscall.sh是错的，应该是make-syscalls.sh</mark></p><p>作者回复: 谢谢，是./sysdeps/unix/make-syscalls.sh。glibc的版本是glibc-2.26</p><h2 id="本节内容概括" tabindex="-1"><a class="header-anchor" href="#本节内容概括" aria-hidden="true">#</a> 本节内容概括</h2><h3 id="版本一-细节" tabindex="-1"><a class="header-anchor" href="#版本一-细节" aria-hidden="true">#</a> 版本一: 细节</h3><p>glibc 将系统调用封装成更友好的接口</p><p>本节解析 glibc 函数如何调用到内核的 open</p><ol><li>用户进程调用 open 函数 <ol><li>glibc 的 syscal.list 列出 glibc 函数对应的系统调用</li><li>glibc 的脚本 make_syscall.sh 根据 syscal.list 生成对应的宏定义(函数映射到系统调用)</li><li>glibc 的 syscal-template.S 使用这些宏, 定义了系统调用的调用方式(也是通过宏)</li><li>其中会调用 DO_CALL (也是一个宏), 32位与 64位实现不同</li></ol></li><li>32位 DO_CALL (位于 i386 目录下 sysdep.h) <ol><li>将调用参数放入寄存器中, 由系统调用名得到系统调用号, 放入 eax</li><li>执行 ENTER_KERNEL(一个宏), 对应 int $0x80 触发软中断, 进入内核</li><li>调用软中断处理函数 entry_INT80_32(内核启动时, 由 trap_init() 配置)</li><li>entry_INT80_32 将用户态寄存器存入 pt_regs 中(保存现场以及系统调用参数), 调用 do_syscall_32_iraq_on</li><li>do_syscall_32_iraq_on 从 pt_regs 中取系统调用号(eax), 从系统调用表得到对应实现函数,<br> 取 pt_regs 中存储的参数, 调用系统调用</li><li>entry_INT80_32 调用 INTERRUPT_RUTURN(一个宏)对应 iret 指令,<br> 系统调用结果存在 pt_regs 的 eax 位置, 根据 pt_regs 恢复用户态进程</li></ol></li><li>64位 DO_CALL (位于 x86_64 目录下 sysdep.h) <ol><li>通过系统调用名得到系统调用号, 存入 rax; 不同中断, 执行 syscall 指令</li><li>MSR(特殊模块寄存器), 辅助完成某些功能(包括系统调用)</li><li>trap_init() 会调用 cpu_init-&gt;syscall_init 设置该寄存器</li><li>syscall 从 MSR 寄存器中, 拿出函数地址进行调用, 即调用 entry_SYSCALL_64</li><li>entry_SYSCALL_64 先保存用户态寄存器到 pt_regs 中</li><li>调用 entry_SYSCALL64_slow_pat-&gt;do_syscall_64</li><li>do_syscall_64 从 rax 取系统调用号, 从系统调用表得到对应实现函数, 取 pt_regs 中存储的参数, 调用系统调用</li><li>返回执行 USERGS_SYSRET64(一个宏), 对应执行 swapgs 和 sysretq 指令;<br> 系统调用结果存在 pt_regs 的 ax 位置, 根据 pt_regs 恢复用户态进程</li></ol></li><li>系统调用表 sys_call_table <ol><li>32位 定义在 arch/x86/entry/syscalls/syscall_32.tbl</li><li>64位 定义在 arch/x86/entry/syscalls/syscall_64.tbl</li><li><code>syscall_*.tbl</code> 内容包括: 系统调用号, 系统调用名, 内核实现函数名(以 sys 开头)</li><li>内核实现函数的声明: include/linux/syscall.h</li><li>内核实现函数的实现: 某个 .c 文件, 例如 sys_open 的实现在 fs/open.c <ul><li>.c 文件中, 以宏的方式替代函数名, 用多层宏构建函数头</li></ul></li><li>编译过程中, 通过 <code>syscall_*.tbl</code> 生成 <code>unistd_*.h</code> 文件 <ul><li><code>unistd_*.h</code> 包含系统调用与实现函数的对应关系</li></ul></li><li><code>syscall_*.h</code> include 了 <code>unistd_*.h</code> 头文件, 并定义了系统调用表(数组)</li></ol></li></ol><h3 id="版本二-32-64-对比" tabindex="-1"><a class="header-anchor" href="#版本二-32-64-对比" aria-hidden="true">#</a> 版本二: 32/64 对比</h3><p>什么是系统调用? 系统调用是操作系统提供给程序设计人员使用系统服务的接口. 系统调用流程 Linux 提供了 glibc 库, 它封装了系统调用接口, 对上层更友好的提供服务, 系统调用最终都会通过 DO_CALL 发起, 这是一个宏定义, 其 32 位和 64 位的定义是不同的.</p><table><thead><tr><th>32位 系统调用</th><th>64位 系统调用</th></tr></thead><tbody><tr><td>用户态</td><td>用户态</td></tr><tr><td>- 1 将请求参数保存到寄存器<br>- 2 将系统调用名称转为系统调用号保存到寄存器 <code>eax</code> 中<br>- 3 通过<code>软中断 ENTER_KERNEL</code> 进入内核态</td><td>- 1 将请求参数保存到寄存器<br>- 2 将系统调用名称转为系统调用号保存到寄存器 <code>rax</code> 中<br>- 3 通过 <code>syscall</code> 进入内核态</td></tr><tr><td>内核态</td><td>内核态</td></tr><tr><td>1将用户态的寄存器保存到 pt_regs 中<br>2在系统调用函数表 sys_call_table 中根据调用号找到对应的函数<br>3执行函数实现, 将返回值写入 pt_regs 的 ax 位置<br>4通过 <code>INTERRUPT_RETURN</code> 根据 pt_regs 恢复用户态进程</td><td>1将用户态的寄存器保存到 pt_regs 中<br>2在系统调用函数表 sys_call_table 中根据调用号找到对应的函数<br>3执行函数实现, 将返回值写入 pt_regs 的 ax 位置<br>4通过 <code>sysretq</code> 返回用户态</td></tr></tbody></table><p>将 <code>软中断</code> 改成 <code>特殊指令</code>，性能更好</p>',15);function S(x,E){const a=l("ExternalLinkIcon");return i(),c("div",null,[_,n("p",null,[s("另外，glibc 还有一个脚本 "),n("a",k,[s("make-syscall.sh"),e(a)]),s("，可以根据上面的配置文件，对于每一个封装好的系统调用，生成一个文件。这个文件里面定义了一些宏，例如 #define SYSCALL_NAME open。")]),v,n("p",null,[s("大家可以参考glibc的源码理解，"),n("a",m,[s("https://www.gnu.org/software/libc/started.html。"),e(a)]),s(),b]),n("p",null,[s("==这个专栏，源码是linux哪个版本的？==作者回复: "),n("a",g,[s("https://elixir.bootlin.com/linux/v4.13.16"),e(a)])]),n("p",null,[s("本节内容紧跟"),n("a",y,[s('"Linux中实现一个系统调用"(点击跳转)'),e(a)]),s("相关, 做过内核添加系统调用实验, 知识就好理解很多.")]),h])}const f=t(u,[["render",S],["__file","G09-系统调用.html.vue"]]);export{f as default};
