import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as s,d as e}from"./app-cdabc73c.js";const p={},i=e(`<h1 id="温故知新-思考题参考答案-一" tabindex="-1"><a class="header-anchor" href="#温故知新-思考题参考答案-一" aria-hidden="true">#</a> 温故知新｜思考题参考答案（一）</h1><p>你好，我是编辑小新。首先，祝你元旦快乐。</p><p>计算机基础的学习并非一蹴而就，希望课程里讲到的内容，像火种一样点燃你的学习探索兴趣。为了辅助你检验每节课的学习效果，我们留下了很多思考题。</p><p>今天这节答疑课，就是为了把思考题环节做个“闭环”，我们会公布每节课的参考答案。在对答案之前，还是建议你先自己尝试回答问题，哪怕只是大致整理一下思路，然后再对比看看老师给的思路，查漏补缺。</p><p>后面就是前四章，第一节课到第二十二节课的思考题参考答案，希望对你有帮助。</p><p>我在结束语里，看到有同学留言说：“学习计算机基础真的很开心，打通的感觉最为舒畅！”看到这样的留言，我和老师都非常开心。也非常欢迎学完一遍课程的同学常回来二刷、三刷，温故知新，有什么新的体会，也欢迎继续在留言区记录分享。</p><h2 id="第一节课" tabindex="-1"><a class="header-anchor" href="#第一节课" aria-hidden="true">#</a> 第一节课</h2><p>Q：为什么 RISC 的 CPU 能同时执行多条指令？</p><p>A：因为 CPU 内核中有多条指令流水线，<em>取指、译码、执行、访存、回写</em>，这些逻辑部件能同时和独立工作。</p><h2 id="第二节课" tabindex="-1"><a class="header-anchor" href="#第二节课" aria-hidden="true">#</a> 第二节课</h2><p>Q：为什么 RISC-V 要定义特权级？</p><p>A：因为 RISC-V <em>要支持操作系统和虚拟化</em>，它们需要管理资源，需要用相应的特权来保护资源不被其它软件恶意使用。</p><h2 id="第三节课" tabindex="-1"><a class="header-anchor" href="#第三节课" aria-hidden="true">#</a> 第三节课</h2><p>Q：为什么很多特定算法，用 Verilog 设计并且硬件化之后，要比用软件实现的运算速度快很多？</p><p>A：因为 Verilog <em>设计的电路是并行执行的</em>，没有受到 CPU 流水线的限制，所以速度会快很多。</p><h2 id="第四节课" tabindex="-1"><a class="header-anchor" href="#第四节课" aria-hidden="true">#</a> 第四节课</h2><p>Q：既然用 Verilog 很容易就可以设计出芯片的数字电路，为什么我们国家还没有完全自主可控的高端 CPU 呢？</p><p>A：这是一个开放性的话题，这里根据我的理解列举几点：</p><ol><li>芯片是一个需要技术积累的行业，从设计到生产，每一个环节都有技术壁垒，发展起来至少需要十到二十年。</li><li>我国很多芯片行业起步晚，在 CPU 方面，国外早就有像 Intel、AMD 这样的公司形成垄断，中国很难赶超 Intel。</li><li>芯片行业，品牌效应很重要，初创公司做出的芯片可能面临没人敢买的尴尬局面。</li><li>芯片是一个很烧钱的且需要长期投入的行业，整个中国在集成电路方面的投入可能还不如国外一个大公司的投入多。</li><li>高端芯片是需要一个成熟生态支撑的，需要软件和硬件配套使用，两个需要同步更新、互相促进，才能一直保持领先。</li></ol><h2 id="第五节课" tabindex="-1"><a class="header-anchor" href="#第五节课" aria-hidden="true">#</a> 第五节课</h2><p>Q：今天我们讲到了 RISC-V 中的分支跳转指令 JAL。想想看，为什么要通过调整立即数的某些位，从 U-TYPE 指令得到 J-TYPE 指令格式呢？这样调整以后有什么好处？</p><p>A：JAL 在立即数处编码了一个有符号偏移量，这个偏移量加到 pc 上后，形成跳转目标地址，并将跳转指令后面的指令地址（pc+4）加载到 rd，跳转范围为±1MB，这样就可以得到更大的跳转范围了。</p><h2 id="第六节课" tabindex="-1"><a class="header-anchor" href="#第六节课" aria-hidden="true">#</a> 第六节课</h2><p>Q：为什么要对指令进行预读取？直接取指然后译码、执行不可以吗？</p><p>A：预读取是<em>为了让流水线执行指令更高效</em>，特别是在执行分支跳转指令的时候，预读取提供了<em>简单的分支预测功能</em>，可以在发生跳转之前预测跳转方向，并提前读取后续的指令。</p><h2 id="第七节课" tabindex="-1"><a class="header-anchor" href="#第七节课" aria-hidden="true">#</a> 第七节课</h2><p>Q：在 6 种指令格式中，S 型、J 型和 B 型指令里的立即数是不连续的，这是为什么？</p><p>A：为了让不同指令格式中尽可能多的字段信息保持位置重合，降低译码难度，同时减少硬件通路上 mux 数量，从而减少硬件逻辑延迟。</p><h2 id="第八节课" tabindex="-1"><a class="header-anchor" href="#第八节课" aria-hidden="true">#</a> 第八节课</h2><p>Q：在 ALU 模块代码中，为什么要把左移操作转换为右移进行处理？</p><p>A：把左移操作转换为右移操作，可以复用右移操作的电路，节省硬件电路的资源。</p><h2 id="第九节课" tabindex="-1"><a class="header-anchor" href="#第九节课" aria-hidden="true">#</a> 第九节课</h2><p>Q：除了数据冒险，我们的 CPU 流水线是否还存在其它的冲突问题，你想到解决方法了么？</p><p>A：流水线中除了<mark>数据冒险</mark>，还可能存在<mark>结构冒险</mark>和<mark>控制冒险</mark>，下节课我们将会讲解控制冒险。</p><h2 id="第十节课" tabindex="-1"><a class="header-anchor" href="#第十节课" aria-hidden="true">#</a> 第十节课</h2><p>Q：除了流水线停顿和分支预测方法，是否还有其他解决控制冒险问题的办法？</p><p>A：控制冒险的第三种解决方法称为延迟转移，也就是延迟转移顺序执行下一条指令，并在该指令后执行分支。这需要用到<em>汇编器对指令进行自动排序</em>，它会在延迟转移指令的后面放一条不受该分支影响的指令，<em>并且指令重新编排了</em>，后面的指令地址会发生变化。</p><h2 id="第十一节课" tabindex="-1"><a class="header-anchor" href="#第十一节课" aria-hidden="true">#</a> 第十一节课</h2><p>Q：计算机两大体系结构分别是冯诺依曼体系结构和哈弗体系结构，请问我们的 MiniCPU 属于哪一种体系结构呢？</p><p>A：哈弗结构是一种将程序指令存储和数据存储分开的存储器结构，而冯·诺依曼结构的数据空间和地址空间不分开。显然，我们的 MiniCPU 是把数据空间和地址空间分开的，所以是哈弗结构。</p><h2 id="第十二节课" tabindex="-1"><a class="header-anchor" href="#第十二节课" aria-hidden="true">#</a> 第十二节课</h2><p>Q：请你说一说交叉编译的过程？</p><p>A：首先在主环境上用<em>相应的编辑器</em>写好源代码，然后运行主环境上的<mark>交叉编译器</mark>对源代码进行编译，最后生成<mark>目标平台的可执行程序</mark>。</p><h2 id="第十三节课" tabindex="-1"><a class="header-anchor" href="#第十三节课" aria-hidden="true">#</a> 第十三节课</h2><p>Q：处理环境变量后为什么要执行 source ./.bashrc，才会生效？</p><p>A：source 命令和“.”是一样的，所以也可以是. ./.bashrc，source 命令与终端.bashrc 脚本命令的区别是，<mark>source</mark> 是在当前 bash 环境下执行命令，而<mark>运行脚本</mark>是启动一个子终端进程来执行其中的命令。</p><p>这样，如果把设置环境变量的命令写进.bashrc 脚本文件中，<em>就只会影响子进程，无法改变当前的 bash 环境</em>。</p><p>所以，通过.bashrc 脚本文件设置环境变量时，需要 source 命令。</p><h2 id="第十四节课" tabindex="-1"><a class="header-anchor" href="#第十四节课" aria-hidden="true">#</a> 第十四节课</h2><p>Q：为什么 C 语言中为什么要有流程控制？</p><p>A：因为程序不能一直顺序执行，如果没有分支和循环，这是程序的三大流程结构。也正因如此，我们才能实现各种算法，你可以再想想图灵机，就能明白了。</p><h2 id="第十五节课" tabindex="-1"><a class="header-anchor" href="#第十五节课" aria-hidden="true">#</a> 第十五节课</h2><p>Q：请问 C 语言函数如何传递结构体类型的参数呢？</p><p>A：如果结构体有多于 8 个成员的情况下，前 8 个成员会被放在寄存器中，剩下部分被存放在栈上，sp 指向第一个没有被存放在寄存器上的结构体成员。结构体中如果第 i 个成员是整型类型，那么就存放在整型寄存器 a(i) 上，如果第 i 个成员是浮点数类型，那么就存放在浮点寄存器 fa(i) 上（0&lt;=i&lt;=7）。</p><h2 id="第十六节课" tabindex="-1"><a class="header-anchor" href="#第十六节课" aria-hidden="true">#</a> 第十六节课</h2><p>Q：请写出机器码 0x00000033 对应的指令。</p><p>A：0x00000033 对应的指令是 add x0，x0，x0</p><h2 id="第十七节课" tabindex="-1"><a class="header-anchor" href="#第十七节课" aria-hidden="true">#</a> 第十七节课</h2><p>Q：为什么指令编码中，目标寄存器，源寄存器 1，源寄存器 2，占用的位宽都是 5 位呢？</p><p>A：因为 5 位二进制数据，就是 2 的 5 次方，所能表示的编码范围是 0~31，正好索引 RISC-V 的 32 个通用寄存器。</p><h2 id="第十八节课" tabindex="-1"><a class="header-anchor" href="#第十八节课" aria-hidden="true">#</a> 第十八节课</h2><p>Q：既然已经有 jal 指令了，为什么还需要 jalr 指令呢？</p><p>A：因为 jal 只能通过立即数传递跳转地址，只能跳转±2k 的地址空间，如果想要跳转到更远的地址，就得通过寄存器来传递跳转地址。</p><h2 id="第十九节课" tabindex="-1"><a class="header-anchor" href="#第十九节课" aria-hidden="true">#</a> 第十九节课</h2><p>Q：我们发现 RISC-V 指令集中没有大于指令和小于等于指令，为什么呢？</p><p>A：因为实现大于指令和小于等于指令的功能，只需要把小于指令和大于等于指令的两个操作数互换一下位置就行了。</p><h2 id="第二十节课" tabindex="-1"><a class="header-anchor" href="#第二十节课" aria-hidden="true">#</a> 第二十节课</h2><p>Q：请你尝试用 LR、SC 指令实现自旋锁。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/***************************************************************/</span>
<span class="token comment">//lrsc.S</span>
<span class="token punctuation">.</span>text
<span class="token punctuation">.</span>globl cas
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">a</span><span class="token expression"><span class="token number">0</span>内存地址</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">a</span><span class="token expression"><span class="token number">1</span>预期值</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">a</span><span class="token expression"><span class="token number">2</span>所需值</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">a</span><span class="token expression"><span class="token number">0</span>返回值，如果成功，则为<span class="token number">0</span>！否则为<span class="token number">1</span></span></span>
cas<span class="token operator">:</span>
    lr<span class="token punctuation">.</span>w t0<span class="token punctuation">,</span> <span class="token punctuation">(</span>a0<span class="token punctuation">)</span>       #加载以前的值
    bne t0<span class="token punctuation">,</span> a1<span class="token punctuation">,</span> fail    #不相等则跳转到fail
    sc<span class="token punctuation">.</span>w a0<span class="token punctuation">,</span> a2<span class="token punctuation">,</span> <span class="token punctuation">(</span>a0<span class="token punctuation">)</span>   #尝试更新
    jr ra               #返回
fail<span class="token operator">:</span>
    li a0<span class="token punctuation">,</span> <span class="token number">1</span>            #a0 <span class="token operator">=</span> <span class="token number">1</span>
    jr ra               #返回
<span class="token comment">/***************************************************************/</span>
<span class="token comment">//lock.c</span>
<span class="token comment">//定义锁类型</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Lock</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> LockVal<span class="token punctuation">;</span>    <span class="token comment">//锁值</span>
<span class="token punctuation">}</span>Lock<span class="token punctuation">;</span>
<span class="token comment">//自旋锁初始化</span>
<span class="token keyword">void</span> <span class="token function">SpinLockInit</span><span class="token punctuation">(</span>Lock<span class="token operator">*</span> lock<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">//锁值初始化为0</span>
    lock<span class="token operator">-&gt;</span>LockVal <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//自旋锁加锁</span>
<span class="token keyword">void</span> <span class="token function">SpinLock</span><span class="token punctuation">(</span>Lock<span class="token operator">*</span> lock<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> status<span class="token punctuation">;</span>
    <span class="token keyword">do</span>
    <span class="token punctuation">{</span>
        status <span class="token operator">=</span> <span class="token function">cas</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token operator">-&gt;</span>LockVal<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//加锁</span>
    <span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//循环加锁，直到成功</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//自旋锁解锁</span>
<span class="token keyword">void</span> <span class="token function">SpinUnLock</span><span class="token punctuation">(</span>Lock<span class="token operator">*</span> lock<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">SpinLockInit</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//直接初始化 解锁</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="第二十一节课" tabindex="-1"><a class="header-anchor" href="#第二十一节课" aria-hidden="true">#</a> 第二十一节课</h2><p>Q：为什么加载字节与加载半字指令，需要处理数据符号问题呢，而加载字指令却不需要？</p><p>A：首先，加载指令是从内存到寄存器。</p><p>其次加载到寄存器中的数据会参与运算，数据的运算就需要考虑数据的符号问题。</p><p>最后加载字指令是加载 32 位数据占用整个寄存器，不需要处理符号位问题，只需要原样加载内存中的数据就行了，内存中的数据有符号就有符号，没有符号那就是没有符号。</p><h2 id="第二十二节课" tabindex="-1"><a class="header-anchor" href="#第二十二节课" aria-hidden="true">#</a> 第二十二节课</h2><p>Q：为什么三条储存指令，不需要处理数据符号问题呢？</p><p>A：首先储存指令是把寄存器中的数据储存到内存，其次储存到内存中的数据不参与运算时，不需要考虑符号问题。只需要原样保存在内存中就行了。</p>`,77),c=[i];function t(o,r){return a(),s("div",null,c)}const u=n(p,[["render",t],["__file","P43-参考答案（一）.html.vue"]]);export{u as default};
