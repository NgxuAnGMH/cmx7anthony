import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o,c as r,d as s}from"./app-cdabc73c.js";const t="/assets/4c87a1851aeb6857a323064859da6396-407e9039.png",i="/assets/27cab77c0eec95ec29792e6c3d093d27-bb570736.png",a="/assets/a50a6cb9d3df027aeda5ee8e53b75422-855974a9.png",n="/assets/0b340db019d7e389a2bde4c237ee4700-6896f1f4.jpg",c={},p=s('<h1 id="_03-通过你的cpu主频-我们来谈谈-性能-究竟是什么" tabindex="-1"><a class="header-anchor" href="#_03-通过你的cpu主频-我们来谈谈-性能-究竟是什么" aria-hidden="true">#</a> 03 | 通过你的CPU主频，我们来谈谈“性能”究竟是什么？</h1><p>“性能”这个词，不管是在日常生活还是写程序的时候，都经常被提到。比方说，买新电脑的时候，我们会说“原来的电脑性能跟不上了”；写程序的时候，我们会说，“这个程序性能需要优化一下”。那么，你有没有想过，我们常常挂在嘴边的“性能”到底指的是什么呢？我们能不能给性能下一个明确的定义，然后来进行准确的比较呢？</p><p>在计算机组成原理乃至体系结构中，“<code>性能</code>”都是最重要的一个主题。我在前面说过，学习和研究计算机组成原理，就是在理解计算机是怎么运作的，以及为什么要这么运作。“为什么”所要解决的事情，很多时候就是提升“性能”。</p><h2 id="什么是性能-时间的倒数" tabindex="-1"><a class="header-anchor" href="#什么是性能-时间的倒数" aria-hidden="true">#</a> <strong>什么是性能？时间的倒数</strong></h2><p>计算机的性能，其实和我们干体力劳动很像，好比是我们要搬东西。对于计算机的性能，我们需要有个标准来衡量。这个标准中主要有两个指标。</p><p>第一个是==<strong>响应时间</strong>（Response time）<mark>或者叫</mark>执行时间（Execution time）==。想要提升响应时间这个性能指标，你可以理解为让计算机“<em>跑得更快</em>”。图中是我们实际系统里<em>性能监测工具NewRelic</em>中的响应时间，代表了每个外部的Web请求的执行时间</p><img src="'+t+'" alt="img" style="zoom:50%;"><p>第二个是==<strong>吞吐率</strong>（Throughput）<mark>或者</mark>带宽（Bandwidth）==，想要提升这个指标，你可以理解为让计算机“<em>搬得更多</em>”。服务器使用的网络带宽，通常就是一个吞吐率性能指标</p><img src="'+i+'" alt="img" style="zoom:50%;"><p>所以说，<em>响应时间</em>指的就是，我们执行一个程序，到底需要花多少时间。花的时间越少，自然性能就越好。而<em>吞吐率</em>是指我们在一定的时间范围内，到底能处理多少事情。这里的“事情”，在计算机里就是处理的数据或者执行的程序指令。</p><p>和搬东西来做对比，如果我们的响应时间短，跑得快，我们可以来回多跑几趟多搬几趟。所以说，<strong>缩短程序的响应时间，一般来说都会提升吞吐率</strong>。</p><p>除了缩短响应时间，我们还有别的方法吗？当然有，比如说，我们还可以多找几个人一起来搬，这就类似现代的服务器都是 <strong>8 核、16 核的。人多力量大，同时处理数据，在单位时间内就可以处理更多数据，吞吐率自然也就上去了</strong>。</p><p>提升吞吐率的办法有很多。大部分时候，我们只要多加一些机器，多堆一些硬件就好了。但是响应时间的提升却没有那么容易，因为 CPU 的性能提升其实在 10 年前就处于“挤牙膏”的状态了，所以我们得慎重地来分析对待。下面我们具体来看。</p><p>我们一般把性能，定义成响应时间的倒数，也就是：</p><p>性能 = 1/ 响应时间</p><p>这样一来，响应时间越短，性能的数值就越大。同样一个程序，在 Intel 最新的 CPU Coffee Lake 上，只需要 30s 就能运行完成，而在 5 年前 CPU Sandy Bridge 上，需要 1min 才能完成。那么我们自然可以算出来，Coffee Lake 的性能是 1/30，Sandy Bridge 的性能是 1/60，两个的性能比为 2。于是，我们就可以说，Coffee Lake 的性能是 Sandy Bridge 的 2 倍。</p><p>过去几年流行的手机跑分软件，就是把多个预设好的程序在手机上运行，然后根据运行需要的时间，算出一个分数来给出手机的性能评估。而在业界，各大 CPU 和服务器厂商组织了一个叫作 <strong>SPEC</strong>（Standard Performance Evaluation Corporation）的第三方机构，<em>专门用来指定各种“跑分”的规则</em>。</p><img src="'+a+`" alt="img" style="zoom:50%;"><p>一份SPEC报告通常包含了大量不同测试的评分</p><p>SPEC 提供的 CPU 基准测试程序，<em>就好像 CPU 届的“高考”</em>，通过数十个不同的计算程序，对于 CPU 的性能给出一个最终评分。这些程序丰富多彩，有编译器、解释器、视频压缩、人工智能国际象棋等等，涵盖了方方面面的应用场景。感兴趣的话，你可以点击这个链接看看。</p><h2 id="计算机的计时单位-cpu-时钟" tabindex="-1"><a class="header-anchor" href="#计算机的计时单位-cpu-时钟" aria-hidden="true">#</a> <strong>计算机的计时单位：CPU 时钟</strong></h2><p>虽然时间是一个很自然的用来衡量性能的指标，但是用时间来衡量时，有两个问题。</p><p><strong>第一个就是时间不“准”</strong>。如果用你自己随便写的一个程序，来统计程序运行的时间，每一次统计结果不会完全一样。有可能这一次花了 45ms，下一次变成了 53ms。</p><p>为什么会不准呢？这里面有好几个原因。首先，我们统计时间是用类似于“掐秒表”一样，记录程序运行结束的时间减去程序开始运行的时间。这个时间也叫 Wall Clock Time 或者 Elapsed Time，就是在运行程序期间，挂在墙上的钟走掉的时间。</p><p>但是，计算机可能同时运行着好多个程序，CPU 实际上不停地在各个程序之间进行切换。在这些走掉的时间里面，很可能 CPU 切换去运行别的程序了。而且，有些程序在运行的时候，可能要从网络、硬盘去读取数据，要等网络和硬盘把数据读出来，给到内存和 CPU。所以说，<strong>要想准确统计某个程序运行时间，进而去比较两个程序的实际性能，我们得把这些时间给刨除掉</strong>。</p><p>那这件事怎么实现呢？Linux 下有一个叫 <code>time</code> 的命令，可以帮我们统计出来，同样的 Wall Clock Time 下，程序实际在 CPU 上到底花了多少时间。</p><p>我们简单运行一下 time 命令。它会返回三个值，</p><ul><li>第一个是 <strong>real time</strong>，也就是我们说的 Wall Clock Time，也就是运行程序整个过程中流逝掉的时间；</li><li>第二个是 <strong>user time</strong>，也就是 CPU 在运行你的程序，在<code>用户态</code>运行指令的时间；</li><li>第三个是 <strong>sys time</strong>，是 CPU 在运行你的程序，在<code>操作系统内核</code>里运行指令的时间。</li></ul><p><strong>而程序实际花费的 CPU 执行时间（CPU Time），就是 <code>user time</code> 加上 <code>sys time</code></strong>。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ time seq 1000000 | wc -l
1000000


real  0m0.101s
user  0m0.031s
sys   0m0.016s
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在我给的这个例子里，你可以看到，实际上程序用了 0.101s，但是 CPU time 只有 0.031+0.016 = 0.047s。运行程序的时间里，只有不到一半是实际花在这个程序上的。</p><p>备注：你最好在云平台上，找一台 1 CPU 的机器来跑这个命令，<em>在多 CPU 的机器上</em>，seq 和 wc 两个命令可能分配到不同的 CPU 上，我们拿到的 user time 和 sys time 是两个 CPU 上花费的时间之和，可能会导致 real time 可能会小于 user time+sys time。</p><img src="`+n+'" alt="img" style="zoom:25%;"><p>程序实际占用的CPU时间一般比Elapsed Time要少不少</p><p><strong>其次，即使我们已经拿到了 CPU 时间，我们<code>也不一定可以直接“比较”出</code>两个程序的性能差异</strong>。即使在同一台计算机上，CPU 可能满载运行也可能降频运行，降频运行的时候自然花的时间会多一些。</p><p>除了 CPU 之外，时间这个性能指标还会受到<em>主板、内存这些其他相关硬件</em>的影响。所以，我们需要对“时间”这个我们可以感知的指标进行拆解，把程序的 CPU 执行时间变成 <mark>CPU 时钟周期数（CPU Cycles）</mark> 和 ==时钟周期时间（Clock Cycle）==的乘积。</p><blockquote><p>程序的 CPU 执行时间 = <em>CPU时钟周期数</em> × <strong>时钟周期时间</strong></p></blockquote><h2 id="_1-晶体振荡器-cpu-主频" tabindex="-1"><a class="header-anchor" href="#_1-晶体振荡器-cpu-主频" aria-hidden="true">#</a> 1 晶体振荡器：CPU 主频</h2><p>我们先来理解一下什么是时钟周期时间。你在买电脑的时候，一定关注过 <em>CPU 的主频</em>。比如我手头的这台电脑就是 Intel Core-i7-7700HQ 2.8GHz，这里的 <em>2.8GHz</em> 就是电脑的<code>主频（Frequency/Clock Rate）</code>。这个 2.8GHz，我们可以先粗浅地认为，<em>CPU 在 1 秒时间内，可以执行的简单指令的数量是 2.8G 条</em>。</p><ol><li>如果想要更准确一点描述，这个 2.8GHz 就代表，我们 CPU 的一个“钟表”能够识别出来的最小的时间间隔。就像我们挂在墙上的挂钟，都是“滴答滴答”一秒一秒地走，所以通过墙上的挂钟能够识别出来的最小时间单位就是秒。</li><li>而在 CPU 内部，和我们平时戴的电子石英表类似，有一个叫==晶体振荡器（Oscillator Crystal）==的东西，简称为晶振。我们把晶振当成 CPU 内部的电子表来使用。<em>晶振带来的每一次“滴答”</em>，就是<strong>时钟周期时间</strong>。</li></ol><p>在我这个 2.8GHz 的 CPU 上，这个时钟周期时间，就是 1/2.8G。我们的 CPU，是按照这个“时钟”提示的时间来进行自己的操作。<em>主频越高，意味着这个表走得越快</em>，我们的 CPU 也就“被逼”着走得越快。</p><p>如果你自己组装过台式机的话，可能听说过“<code>超频</code>”这个概念，这说的其实就相当于把买回来的 CPU 内部的钟给调快了，于是 CPU 的计算跟着这个时钟的节奏，也就自然变快了。<code>当然这个快不是没有代价的</code>，CPU 跑得越快，散热的压力也就越大。就和人一样，<code>超过生理极限</code>，CPU 就会崩溃了。</p><h2 id="_2-执行指令所用-cpu时钟周期数" tabindex="-1"><a class="header-anchor" href="#_2-执行指令所用-cpu时钟周期数" aria-hidden="true">#</a> 2 执行指令所用：CPU时钟周期数</h2><p>我们现在回到上面程序 CPU 执行时间的公式。</p><blockquote><p>程序的 CPU 执行时间 = <em>CPU时钟周期数</em> × <strong>时钟周期时间</strong></p></blockquote><p>最简单的提升性能方案，自然缩短时钟周期时间，也就是提升主频。换句话说，就是换一块好一点的 CPU。不过，这个是我们这些软件工程师控制不了的事情，所以我们就把目光挪到了乘法的另一个因子 —— <em>CPU时钟周期数</em> 上。如果能够<em>减少程序需要的 CPU 时钟周期数量</em>，一样能够提升程序性能。</p><h2 id="_3-拆分过程-指令数-×-cpi" tabindex="-1"><a class="header-anchor" href="#_3-拆分过程-指令数-×-cpi" aria-hidden="true">#</a> 3 拆分过程：指令数 × CPI</h2><p>对于 CPU 时钟周期数，我们可以再做一个分解，把它变成“ <em>指令数</em> × <strong>每条指令的平均时钟周期数</strong>（Cycles Per Instruction，简称 <strong>CPI</strong>）”。<em>不同的指令需要的 Cycles 是不同的</em>，</p><ul><li>加法和乘法都对应着一条 CPU 指令，</li><li>但是乘法需要的 Cycles 就比加法要多，自然也就慢。</li></ul><p>在这样拆分了之后，我们的程序的 CPU 执行时间就可以变成这样三个部分的乘积。</p><blockquote><p>程序的 CPU 执行时间 = <em>CPU时钟周期数</em> × <strong>时钟周期时间</strong>。</p><p>程序的 CPU 执行时间 = <em>指令数 × CPI</em> × <strong>Clock Cycle Time</strong>。</p></blockquote><h2 id="优化方案" tabindex="-1"><a class="header-anchor" href="#优化方案" aria-hidden="true">#</a> 优化方案</h2><p>因此，如果我们想要解决性能问题，其实就是要优化这三者。</p><p>1.<strong>时钟周期时间，就是计算机主频，这个取决于计算机硬件</strong>。我们所熟知的<code>摩尔定律</code>就一直在不停地提高我们计算机的主频。比如说，我最早使用的 80386 主频只有 33MHz，现在手头的笔记本电脑就有 2.8GHz，在主频层面，就提升了将近 100 倍。</p><p>2.<strong>每条指令的平均时钟周期数 CPI，就是一条指令到底需要多少 CPU Cycle</strong>。在后面讲解 CPU 结构的时候，我们会看到，现代的 CPU 通过<code>流水线技术（Pipeline）</code>，让一条指令需要的 CPU Cycle 尽可能地少。因此，对于 CPI 的优化，也是计算机组成和体系结构中的重要一环。</p><p>3.<strong>指令数，代表执行我们的程序到底需要多少条指令、用哪些指令</strong>。这个很多时候就把挑战交给了<code>编译器</code>。同样的代码，编译成计算机指令时候，就有各种不同的表示方式。</p><blockquote><p>我们可以把自己想象成一个 CPU，坐在那里写程序。</p><ul><li>计算机主频就好像是你的打字速度，<em>打字越快，你自然可以多写一点程序</em>。<br> 【<code>摩尔定律</code>】提升计算机主频，</li><li>CPI 相当于你在写程序的时候，<em>熟悉各种快捷键，越是打同样的内容，需要敲击键盘的次数就越少</em>。<br> 【<code>流水线技术</code>】优化 CPU 设计使得在单个时钟周期内能够执行更多指令，</li><li>指令数相当于你的程序<em>设计得够合理，同样的程序要写的代码行数就少</em>。<br> 以及通过<code>编译器</code>来减少需要的指令数。</li></ul><p>如果三者皆能实现，你自然可以很快地写出一个优秀的程序，你的“性能”从外面来看就是好的。</p></blockquote><h2 id="总结延伸" tabindex="-1"><a class="header-anchor" href="#总结延伸" aria-hidden="true">#</a> <strong>总结延伸</strong></h2><p>好了，学完这一讲，对“性能”这个名词，你应该有了更清晰的认识。我主要对于“响应时间”这个性能指标进行抽丝剥茧，拆解成了计算机时钟周期、CPI 以及指令数这三个独立的指标的乘积，并且为你指明了优化计算机性能的三条康庄大道。也就是，</p><ul><li>提升计算机主频，</li><li>优化 CPU 设计使得在单个时钟周期内能够执行更多指令，</li><li>以及通过编译器来减少需要的指令数。</li></ul><p>在后面的几讲里面，我会为你讲解，具体怎么在电路硬件、CPU 设计，乃至指令设计层面，提升计算机的性能。</p><h2 id="课后思考" tabindex="-1"><a class="header-anchor" href="#课后思考" aria-hidden="true">#</a> <strong>课后思考</strong></h2><p>每次有新手机发布的时候，总会有一些对于手机的跑分结果的议论。乃至于有“作弊”跑分或者“针对跑分优化”的说法。我们能针对“跑分”作弊么？怎么做到呢？“作弊”出来的分数对于手机性能还有参考意义么？</p><p>欢迎留言和我分享你的思考和疑惑，你也可以把今天的内容分享给你的朋友，和他一起学习和进步。</p><blockquote><p>老师，针对“主频越高，意味着这个表走得越快，我们的 CPU 也就“被逼”着走得越快。”这句话我有一点儿疑惑：<br> 时钟周期时间为1/2.8G 秒，代表CPU最细粒度时间，即一次晶振的时间<br> 这个周期时间和指令执行的耗时有直接关系吗？我说的直接关系指的是比如“一次晶振时间可以固定完成n个CPU（最简单的）指令”这种，如果有关系的话，那可以很明确的得出这个表走的快，CPU执行就快，毕竟单位时间内执行的指令数固定，通过降低单位时间就可以提升效率。<br> 但是文中好像并没有提到这个直接关系，所有我可不可以这么去理解，晶振时间变短后，CPU调度指令的周期变短频次变高，使得上一个指令执行完毕到下一个指令被调动期间的等待时间变短，从而提升了CPU的利用率。好比一个监工增加了抬头看监控视频的频率，一旦有员工手停下来能立马给安排任务，主频低的话，可能员工休息半天才会被发现。另外，这种情况下，似乎主频提升的倍率并不能与性能提升带来1:1的效益。<br> 1.晶振时间与CPU执行固定指令耗时成正比<br> 2.晶振时间降低使CPU调度指令的周期变短频次变高<br> 这两种哪一种对呢？还是都错？请指点~</p><p>又看了一遍，感觉刚刚对CPI的概念误读了，其实晶振时间是固定处理一个cpu简单指令的，CPI的平均时间是用来描述复杂指令的，指令数同样也是，其实整个公式如果用用简单指令来描述可能更容易理解一些</p><p>作者回复: 易儿易同学你好，这个问题提的得非常好，你学得和思考得都很仔细深入。1的理解更准确一点，我们为了理解简单可以暂且认为就是晶振在触发一条一条电路变化指令，就好像你拨算牌盘的节奏一样。算盘拨得快，珠算就算得快。结果就是一条简单的指令需要的事件就和一个时钟周期一样，实际这个问题要比这样一句话复杂很多。一方面，其实时钟周期应该是放下最复杂的一条指令的时间长度。我们是通过流水线来提升cpi的。我会在讲解cpu的部分更深入讲解始终信号和计数器，让大家能够理解cpu到底是怎么回事儿。</p><hr><p>老师，单个CPU的主频是有上限的，所以出现了多核CPU进行计算，为了提高更多的计算，是不是就要运用分布式计算这个技术。作者回复: 是的</p></blockquote>',65),d=[p];function l(m,C){return o(),r("div",null,d)}const g=e(c,[["render",l],["__file","A03-CPU性能.html.vue"]]);export{g as default};
