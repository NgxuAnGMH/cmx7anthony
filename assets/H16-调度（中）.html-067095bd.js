import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{r as c,o,c as i,a as s,b as n,e as p,d as a}from"./app-cdabc73c.js";const l="/assets/dfa9762cfec16822ec74d53350db4664-550d74e4.png",u="/assets/9f4433e82c78ed5cd4399b4b116a9064-80a0e7de.png",r={},k=a('<h1 id="_16-调度-中-主动调度是如何发生的" tabindex="-1"><a class="header-anchor" href="#_16-调度-中-主动调度是如何发生的" aria-hidden="true">#</a> 16 | 调度（中）：主动调度是如何发生的？</h1><p>上一节，我们为调度准备了这么多的数据结构，这一节我们来看调度是如何发生的。</p><p>所谓进程调度，其实就是一个人在做 A 项目，在某个时刻，换成做 B 项目去了。发生这种情况，主要有两种方式。</p><p><strong>方式一</strong>：A 项目做着做着，发现里面有一条指令 sleep，也就是要休息一下，或者在等待某个 I/O 事件。那没办法了，就要主动让出 CPU，然后可以开始做 B 项目。</p><p><strong>方式二</strong>：A 项目做着做着，旷日持久，实在受不了了。项目经理介入了，说这个项目 A 先停停，B 项目也要做一下，要不然 B 项目该投诉了。</p><h2 id="主动调度" tabindex="-1"><a class="header-anchor" href="#主动调度" aria-hidden="true">#</a> 主动调度</h2><p>我们这一节先来看方式一，主动调度。</p>',7),d=s("strong",null,"第一个片段是 Btrfs，等待一个写入",-1),v={href:"https://zh.wikipedia.org/wiki/Btrfs",target:"_blank",rel:"noopener noreferrer"},_=a(`<p>这个片段可以看作写入块设备的一个典型场景。写入需要一段时间，这段时间用不上 CPU，还不如主动让给其他进程。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">btrfs_wait_for_no_snapshoting_writes</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">btrfs_root</span> <span class="token operator">*</span>root<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">do</span> <span class="token punctuation">{</span>
    <span class="token function">prepare_to_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>root<span class="token operator">-&gt;</span>subv_writers<span class="token operator">-&gt;</span>wait<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wait<span class="token punctuation">,</span>
        TASK_UNINTERRUPTIBLE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    writers <span class="token operator">=</span> <span class="token function">percpu_counter_sum</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>root<span class="token operator">-&gt;</span>subv_writers<span class="token operator">-&gt;</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>writers<span class="token punctuation">)</span>
      <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">finish_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>root<span class="token operator">-&gt;</span>subv_writers<span class="token operator">-&gt;</span>wait<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>writers<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另外一个例子是，<strong>从 Tap 网络设备等待一个读取</strong>。Tap 网络设备是虚拟机使用的网络设备。当没有数据到来的时候，它也需要等待，所以也会选择把 CPU 让给其他进程。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">tap_do_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">tap_queue</span> <span class="token operator">*</span>q<span class="token punctuation">,</span>
         <span class="token keyword">struct</span> <span class="token class-name">iov_iter</span> <span class="token operator">*</span>to<span class="token punctuation">,</span>
         <span class="token keyword">int</span> noblock<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>noblock<span class="token punctuation">)</span>
      <span class="token function">prepare_to_wait</span><span class="token punctuation">(</span><span class="token function">sk_sleep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token operator">-&gt;</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>wait<span class="token punctuation">,</span>
          TASK_INTERRUPTIBLE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/* Nothing to read, let&#39;s sleep */</span>
    <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你应该知道，计算机主要处理计算、网络、存储三个方面。计算主要是 CPU 和内存的合作；网络和存储则多是和外部设备的合作；在操作外部设备的时候，往往需要让出 CPU，就像上面两段代码一样，选择调用 schedule() 函数。</p><p>接下来，我们就来看 <strong>schedule 函数的调用过程</strong>。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>asmlinkage __visible <span class="token keyword">void</span> __sched <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk <span class="token operator">=</span> current<span class="token punctuation">;</span>


  <span class="token function">sched_submit_work</span><span class="token punctuation">(</span>tsk<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">do</span> <span class="token punctuation">{</span>
    <span class="token function">preempt_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">__schedule</span><span class="token punctuation">(</span>false<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sched_preempt_enable_no_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">need_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的主要逻辑是在 __schedule 函数中实现的。这个函数比较复杂，我们分几个部分来讲解。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">void</span> __sched notrace <span class="token function">__schedule</span><span class="token punctuation">(</span>bool preempt<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev<span class="token punctuation">,</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span>switch_count<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> rf<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">;</span>
  <span class="token keyword">int</span> cpu<span class="token punctuation">;</span>


  cpu <span class="token operator">=</span> <span class="token function">smp_processor_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  rq <span class="token operator">=</span> <span class="token function">cpu_rq</span><span class="token punctuation">(</span>cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
  prev <span class="token operator">=</span> rq<span class="token operator">-&gt;</span>curr<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先，在当前的 CPU 上，我们取出任务队列 rq。</p><p>task_struct *prev 指向这个 CPU 的任务队列上面正在运行的那个进程 curr。为啥是 prev？因为一旦将来它被切换下来，那它就成了前任了。</p><p>接下来代码如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>next <span class="token operator">=</span> <span class="token function">pick_next_task</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rf<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">clear_tsk_need_resched</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">clear_preempt_need_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第二步，获取下一个任务，task_struct *next 指向下一个任务，这就是<strong>继任</strong>。</p><p>pick_next_task 的实现如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>
<span class="token function">pick_next_task</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> <span class="token operator">*</span>rf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> <span class="token operator">*</span>class<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
  <span class="token comment">/*
   * Optimization: we know that if all tasks are in the fair class we can call that function directly, 
   but only if the @prev task wasn&#39;t of a higher scheduling class, 
   because otherwise those loose the opportunity to pull in more work from other CPUs.
   */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span><span class="token punctuation">(</span>prev<span class="token operator">-&gt;</span>sched_class <span class="token operator">==</span> <span class="token operator">&amp;</span>idle_sched_class <span class="token operator">||</span>
        prev<span class="token operator">-&gt;</span>sched_class <span class="token operator">==</span> <span class="token operator">&amp;</span>fair_sched_class<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
       rq<span class="token operator">-&gt;</span>nr_running <span class="token operator">==</span> rq<span class="token operator">-&gt;</span>cfs<span class="token punctuation">.</span>h_nr_running<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    p <span class="token operator">=</span> fair_sched_class<span class="token punctuation">.</span><span class="token function">pick_next_task</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> rf<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>p <span class="token operator">==</span> RETRY_TASK<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token keyword">goto</span> again<span class="token punctuation">;</span>
    <span class="token comment">/* Assumes fair_sched_class-&gt;next == idle_sched_class */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span>
      p <span class="token operator">=</span> idle_sched_class<span class="token punctuation">.</span><span class="token function">pick_next_task</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> rf<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
again<span class="token operator">:</span>
  <span class="token function">for_each_class</span><span class="token punctuation">(</span>class<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    p <span class="token operator">=</span> class<span class="token operator">-&gt;</span><span class="token function">pick_next_task</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> rf<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>p <span class="token operator">==</span> RETRY_TASK<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">goto</span> again<span class="token punctuation">;</span>
      <span class="token keyword">return</span> p<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们来看 again 这里，就是咱们上一节讲的依次调用调度类。但是这里有了一个优化，因为大部分进程是普通进程，所以大部分情况下会调用上面的逻辑，调用的就是 fair_sched_class.pick_next_task。</p><p>根据上一节对于 fair_sched_class 的定义，它调用的是 pick_next_task_fair，代码如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>
<span class="token function">pick_next_task_fair</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> <span class="token operator">*</span>rf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq <span class="token operator">=</span> <span class="token operator">&amp;</span>rq<span class="token operator">-&gt;</span>cfs<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>se<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
  <span class="token keyword">int</span> new_tasks<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于 CFS 调度类，取出相应的队列 cfs_rq，这就是我们上一节讲的那棵红黑树。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>curr <span class="token operator">=</span> cfs_rq<span class="token operator">-&gt;</span>curr<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>curr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>curr<span class="token operator">-&gt;</span>on_rq<span class="token punctuation">)</span>
        <span class="token function">update_curr</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">else</span>
        curr <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
    se <span class="token operator">=</span> <span class="token function">pick_next_entity</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> curr<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>取出当前正在运行的任务 curr，如果依然是可运行的状态，也即处于进程就绪状态，则调用 update_curr 更新 vruntime。update_curr 咱们上一节就见过了，它会根据实际运行时间算出 vruntime 来。</p><p>接着，pick_next_entity 从红黑树里面，取最左边的一个节点。这个函数的实现我们上一节也讲过了。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>  p <span class="token operator">=</span> <span class="token function">task_of</span><span class="token punctuation">(</span>se<span class="token punctuation">)</span><span class="token punctuation">;</span>


  <span class="token keyword">if</span> <span class="token punctuation">(</span>prev <span class="token operator">!=</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>pse <span class="token operator">=</span> <span class="token operator">&amp;</span>prev<span class="token operator">-&gt;</span>se<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">put_prev_entity</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> pse<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">set_next_entity</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> se<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>


  <span class="token keyword">return</span> p
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>task_of 得到下一个调度实体对应的 task_struct，如果发现继任和前任不一样，这就说明有一个更需要运行的进程了，就需要更新红黑树了。前面前任的 vruntime 更新过了，put_prev_entity 放回红黑树，会找到相应的位置，然后 set_next_entity 将继任者设为当前任务。</p><p>第三步，当选出的继任者和前任不同，就要进行上下文切换，继任者进程正式进入运行。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>prev <span class="token operator">!=</span> next<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    rq<span class="token operator">-&gt;</span>nr_switches<span class="token operator">++</span><span class="token punctuation">;</span>
    rq<span class="token operator">-&gt;</span>curr <span class="token operator">=</span> next<span class="token punctuation">;</span>
    <span class="token operator">++</span><span class="token operator">*</span>switch_count<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    rq <span class="token operator">=</span> <span class="token function">context_switch</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> next<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rf<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="进程上下文切换" tabindex="-1"><a class="header-anchor" href="#进程上下文切换" aria-hidden="true">#</a> 进程上下文切换</h2><p>上下文切换主要干两件事情，一是切换进程空间，也即虚拟内存；二是切换寄存器和 CPU 上下文。</p><p>我们先来看 context_switch 的实现。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/*
 * context_switch - switch to the new MM and the new thread&#39;s register state.
 */</span>
<span class="token keyword">static</span> __always_inline <span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>
<span class="token function">context_switch</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev<span class="token punctuation">,</span>
         <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>next<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> <span class="token operator">*</span>rf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>mm<span class="token punctuation">,</span> <span class="token operator">*</span>oldmm<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  mm <span class="token operator">=</span> next<span class="token operator">-&gt;</span>mm<span class="token punctuation">;</span>
  oldmm <span class="token operator">=</span> prev<span class="token operator">-&gt;</span>active_mm<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token function">switch_mm_irqs_off</span><span class="token punctuation">(</span>oldmm<span class="token punctuation">,</span> mm<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token comment">/* Here we just switch the register state and the stack. */</span>
  <span class="token function">switch_to</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> next<span class="token punctuation">,</span> prev<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">barrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">finish_task_switch</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里首先是内存空间的切换，里面涉及内存管理的内容比较多。内存管理后面我们会有专门的章节来讲，这里你先知道有这么一回事就行了。</p><p>接下来，我们看 switch_to。它就是寄存器和栈的切换，它调用到了 __switch_to_asm。这是一段汇编代码，主要用于栈的切换。</p><p>对于 32 位操作系统来讲，切换的是栈顶指针 esp。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/*
 * %eax: prev task
 * %edx: next task
 */</span>
<span class="token function">ENTRY</span><span class="token punctuation">(</span>__switch_to_asm<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token comment">/* switch stack */</span>
  movl  <span class="token operator">%</span>esp<span class="token punctuation">,</span> <span class="token function">TASK_threadsp</span><span class="token punctuation">(</span><span class="token operator">%</span>eax<span class="token punctuation">)</span>
  movl  <span class="token function">TASK_threadsp</span><span class="token punctuation">(</span><span class="token operator">%</span>edx<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>esp
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  jmp  __switch_to
<span class="token function">END</span><span class="token punctuation">(</span>__switch_to_asm<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于 64 位操作系统来讲，切换的是栈顶指针 rsp。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/*
 * %rdi: prev task
 * %rsi: next task
 */</span>
<span class="token function">ENTRY</span><span class="token punctuation">(</span>__switch_to_asm<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token comment">/* switch stack */</span>
  movq  <span class="token operator">%</span>rsp<span class="token punctuation">,</span> <span class="token function">TASK_threadsp</span><span class="token punctuation">(</span><span class="token operator">%</span>rdi<span class="token punctuation">)</span>
  movq  <span class="token function">TASK_threadsp</span><span class="token punctuation">(</span><span class="token operator">%</span>rsi<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span>rsp
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  jmp  __switch_to
<span class="token function">END</span><span class="token punctuation">(</span>__switch_to_asm<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最终，都返回了 __switch_to 这个函数。这个函数对于 32 位和 64 位操作系统虽然有不同的实现，但里面做的事情是差不多的。所以我这里仅仅列出 64 位操作系统做的事情。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>__visible __notrace_funcgraph <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>
<span class="token function">__switch_to</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev_p<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>next_p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">thread_struct</span> <span class="token operator">*</span>prev <span class="token operator">=</span> <span class="token operator">&amp;</span>prev_p<span class="token operator">-&gt;</span>thread<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">thread_struct</span> <span class="token operator">*</span>next <span class="token operator">=</span> <span class="token operator">&amp;</span>next_p<span class="token operator">-&gt;</span>thread<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">int</span> cpu <span class="token operator">=</span> <span class="token function">smp_processor_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">tss_struct</span> <span class="token operator">*</span>tss <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">per_cpu</span><span class="token punctuation">(</span>cpu_tss<span class="token punctuation">,</span> cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token function">load_TLS</span><span class="token punctuation">(</span>next<span class="token punctuation">,</span> cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token function">this_cpu_write</span><span class="token punctuation">(</span>current_task<span class="token punctuation">,</span> next_p<span class="token punctuation">)</span><span class="token punctuation">;</span>


  <span class="token comment">/* Reload esp0 and ss1.  This changes current_thread_info(). */</span>
  <span class="token function">load_sp0</span><span class="token punctuation">(</span>tss<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">return</span> prev_p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里面有一个 Per CPU 的结构体 tss。这是个什么呢？</p><p>在 x86 体系结构中，提供了一种以硬件的方式进行进程切换的模式，对于每个进程，x86 希望在内存里面维护一个 TSS（Task State Segment，任务状态段）结构。这里面有所有的寄存器。</p><p>另外，还有一个特殊的寄存器 TR（Task Register，任务寄存器），指向某个进程的 TSS。更改 TR 的值，将会触发硬件保存 CPU 所有寄存器的值到当前进程的 TSS 中，然后从新进程的 TSS 中读出所有寄存器值，加载到 CPU 对应的寄存器中。</p><p>下图就是 32 位的 TSS 结构。</p><img src="`+l+`" alt="img" style="zoom:50%;"><p>图片来自 Intel® 64 and IA-32 Architectures Software Developer’s Manual Combined Volumes</p><p>但是这样有个缺点。我们做进程切换的时候，没必要每个寄存器都切换，这样每个进程一个 TSS，就需要全量保存，全量切换，动作太大了。</p><p>于是，Linux 操作系统想了一个办法。还记得在系统初始化的时候，会调用 cpu_init 吗？这里面会给每一个 CPU 关联一个 TSS，然后将 TR 指向这个 TSS，然后在操作系统的运行过程中，TR 就不切换了，永远指向这个 TSS。TSS 用数据结构 tss_struct 表示，在 x86_hw_tss 中可以看到和上图相应的结构。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">cpu_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> cpu <span class="token operator">=</span> <span class="token function">smp_processor_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>curr <span class="token operator">=</span> current<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">tss_struct</span> <span class="token operator">*</span>t <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">per_cpu</span><span class="token punctuation">(</span>cpu_tss<span class="token punctuation">,</span> cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">load_sp0</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> thread<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">set_tss_desc</span><span class="token punctuation">(</span>cpu<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">load_TR_desc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>


<span class="token keyword">struct</span> <span class="token class-name">tss_struct</span> <span class="token punctuation">{</span>
  <span class="token comment">/*
   * The hardware state:
   */</span>
  <span class="token keyword">struct</span> <span class="token class-name">x86_hw_tss</span>  x86_tss<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span>    io_bitmap<span class="token punctuation">[</span>IO_BITMAP_LONGS <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 Linux 中，真的参与进程切换的寄存器很少，主要的就是栈顶寄存器。</p><p>于是，在 task_struct 里面，还有一个我们原来没有注意的成员变量 thread。这里面保留了要切换进程的时候需要修改的寄存器。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/* CPU-specific state of this task: */</span>
  <span class="token keyword">struct</span> <span class="token class-name">thread_struct</span>    thread<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>所谓的进程切换，就是将某个进程的 thread_struct 里面的寄存器的值，写入到 CPU 的 TR 指向的 tss_struct，对于 CPU 来讲，这就算是完成了切换。</p><p>例如 __switch_to 中的 load_sp0，就是将下一个进程的 thread_struct 的 sp0 的值加载到 tss_struct 里面去。</p><h2 id="指令指针的保存与恢复" tabindex="-1"><a class="header-anchor" href="#指令指针的保存与恢复" aria-hidden="true">#</a> 指令指针的保存与恢复</h2><p>你是不是觉得，这样真的就完成切换了吗？是的，不信我们来<strong>盘点</strong>一下。</p><p>从进程 A 切换到进程 B，用户栈要不要切换呢？当然要，其实早就已经切换了，就在切换内存空间的时候。每个进程的用户栈都是独立的，都在内存空间里面。</p><p>那内核栈呢？已经在 __switch_to 里面切换了，也就是将 current_task 指向当前的 task_struct。里面的 void *stack 指针，指向的就是当前的内核栈。</p><p>内核栈的栈顶指针呢？在 __switch_to_asm 里面已经切换了栈顶指针，并且将栈顶指针在 __switch_to 加载到了 TSS 里面。</p><p>用户栈的栈顶指针呢？如果当前在内核里面的话，它当然是在内核栈顶部的 pt_regs 结构里面呀。当从内核返回用户态运行的时候，pt_regs 里面有所有当时在用户态的时候运行的上下文信息，就可以开始运行了。</p><p>唯一让人不容易理解的是指令指针寄存器，它应该指向下一条指令的，那它是如何切换的呢？这里有点绕，请你仔细看。</p><p>这里我先明确一点，进程的调度都最终会调用到 __schedule 函数。为了方便你记住，我姑且给它起个名字，就叫“<strong>进程调度第一定律</strong>”。后面我们会多次用到这个定律，你一定要记住。</p><p>我们用最前面的例子仔细分析这个过程。本来一个进程 A 在用户态是要写一个文件的，写文件的操作用户态没办法完成，就要通过系统调用到达内核态。在这个切换的过程中，用户态的指令指针寄存器是保存在 pt_regs 里面的，到了内核态，就开始沿着写文件的逻辑一步一步执行，结果发现需要等待，于是就调用 __schedule 函数。</p><p>这个时候，进程 A 在内核态的指令指针是指向 __schedule 了。这里请记住，A 进程的内核栈会保存这个 __schedule 的调用，而且知道这是从 btrfs_wait_for_no_snapshoting_writes 这个函数里面进去的。</p><p>__schedule 里面经过上面的层层调用，到达了 context_switch 的最后三行指令（其中 barrier 语句是一个编译器指令，用于保证 switch_to 和 finish_task_switch 的执行顺序，不会因为编译阶段优化而改变，这里咱们可以忽略它）。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token function">switch_to</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> next<span class="token punctuation">,</span> prev<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">barrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> <span class="token function">finish_task_switch</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当进程 A 在内核里面执行 switch_to 的时候，内核态的指令指针也是指向这一行的。但是在 switch_to 里面，将寄存器和栈都切换到成了进程 B 的，唯一没有变的就是指令指针寄存器。当 switch_to 返回的时候，指令指针寄存器指向了下一条语句 finish_task_switch。</p><p>但这个时候的 finish_task_switch 已经不是进程 A 的 finish_task_switch 了，而是进程 B 的 finish_task_switch 了。</p><p>这样合理吗？你怎么知道进程 B 当时被切换下去的时候，执行到哪里了？恢复 B 进程执行的时候一定在这里呢？这时候就要用到咱的“进程调度第一定律”了。</p><p>当年 B 进程被别人切换走的时候，也是调用 __schedule，也是调用到 switch_to，被切换成为 C 进程的，所以，B 进程当年的下一个指令也是 finish_task_switch，这就说明指令指针指到这里是没有错的。</p><p>接下来，我们要从 finish_task_switch 完毕后，返回 __schedule 的调用了。返回到哪里呢？按照函数返回的原理，当然是从内核栈里面去找，是返回到 btrfs_wait_for_no_snapshoting_writes 吗？当然不是了，因为 btrfs_wait_for_no_snapshoting_writes 是在 A 进程的内核栈里面的，它早就被切换走了，应该从 B 进程的内核栈里面找。</p><p>假设，B 就是最前面例子里面调用 tap_do_read 读网卡的进程。它当年调用 __schedule 的时候，是从 tap_do_read 这个函数调用进去的。</p><p>当然，B 进程的内核栈里面放的是 tap_do_read。于是，从 __schedule 返回之后，当然是接着 tap_do_read 运行，然后在内核运行完毕后，返回用户态。这个时候，B 进程内核栈的 pt_regs 也保存了用户态的指令指针寄存器，就接着在用户态的下一条指令开始运行就可以了。</p><p>假设，我们只有一个 CPU，从 B 切换到 C，从 C 又切换到 A。在 C 切换到 A 的时候，还是按照“进程调度第一定律”，C 进程还是会调用 __schedule 到达 switch_to，在里面切换成为 A 的内核栈，然后运行 finish_task_switch。</p><p>这个时候运行的 finish_task_switch，才是 A 进程的 finish_task_switch。运行完毕从 __schedule 返回的时候，从内核栈上才知道，当年是从 btrfs_wait_for_no_snapshoting_writes 调用进去的，因而应该返回 btrfs_wait_for_no_snapshoting_writes 继续执行，最后内核执行完毕返回用户态，同样恢复 pt_regs，恢复用户态的指令指针寄存器，从用户态接着运行。</p><p>到这里你是不是有点理解为什么 switch_to 有三个参数呢？为啥有两个 prev 呢？其实我们从定义就可以看到。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">switch_to</span><span class="token expression"><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> next<span class="token punctuation">,</span> last<span class="token punctuation">)</span>          </span><span class="token punctuation">\\</span>
<span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span>                  </span><span class="token punctuation">\\</span>
  <span class="token expression"><span class="token function">prepare_switch_to</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>          </span><span class="token punctuation">\\</span>
                  <span class="token punctuation">\\</span>
  <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span>last<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">__switch_to_asm</span><span class="token punctuation">(</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      </span><span class="token punctuation">\\</span>
<span class="token expression"><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的例子中，A 切换到 B 的时候，运行到 __switch_to_asm 这一行的时候，是在 A 的内核栈上运行的，prev 是 A，next 是 B。但是，A 执行完 __switch_to_asm 之后就被切换走了，当 C 再次切换到 A 的时候，运行到 __switch_to_asm，是从 C 的内核栈运行的。这个时候，prev 是 C，next 是 A，但是 __switch_to_asm 里面切换成为了 A 当时的内核栈。</p><p>还记得当年的场景“prev 是 A，next 是 B”，__switch_to_asm 里面 return prev 的时候，还没 return 的时候，prev 这个变量里面放的还是 C，因而它会把 C 放到返回结果中。但是，一旦 return，就会弹出 A 当时的内核栈。这个时候，prev 变量就变成了 A，next 变量就变成了 B。这就还原了当年的场景，好在返回值里面的 last 还是 C。</p><p>通过三个变量 switch_to(prev = A, next=B, last=C)，A 进程就明白了，我当时被切换走的时候，是切换成 B，这次切换回来，是从 C 回来的。</p><h2 id="总结时刻" tabindex="-1"><a class="header-anchor" href="#总结时刻" aria-hidden="true">#</a> 总结时刻</h2><p>这一节我们讲主动调度的过程，也即一个运行中的进程主动调用 __schedule 让出 CPU。在 __schedule 里面会做两件事情，第一是选取下一个进程，第二是进行上下文切换。而上下文切换又分用户态进程空间的切换和内核态的切换。</p><figure><img src="`+u+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><blockquote><ul><li><p>调度, 切换运行进程, 有两种方式</p></li><li><p>进程<code>调用 sleep</code> 或<code>等待 I/O</code>, <mark>主动</mark>让出 CPU</p><ul><li>进程运行一段时间, <mark>被动</mark>让出 CPU</li></ul></li><li><p>主动让出 CPU 的方式, 调用 schedule(), schedule() 调用 __schedule()</p></li><li><p>__schedule() 取出 rq; 取出当前运行进程的 task_struct</p><ul><li><p>调用 pick_next_task 取下一个进程</p></li><li><p>依次调用调度类(优化: 大部分都是普通进程), 因此大多数情况调用 fair_sched_class.pick_next_task[_fair]</p><ul><li>pick_next_task_fair 先取出 cfs_rq 队列, 取出当前运行进程调度实体, 更新 vruntime</li><li>pick_next_entity 取最左节点, 并得到 task_struct, 若与当前进程不一样, 则更新红黑树 cfs_rq</li></ul></li><li><p>进程上下文切换: 切换进程内存空间, 切换寄存器和 CPU 上下文(运行 context_switch)</p></li><li><p>context_switch() -&gt; switch_to() -&gt; <code>__switch_to_asm(切换[内核]栈顶指针)</code> -&gt; <code>__switch_to()</code></p><ul><li><p>__switch_to() 取出 Per CPU 的 tss(任务状态段) 结构体</p></li><li><blockquote><p>x86 提供以硬件方式切换进程的模式, 为每个进程在内存中维护一个 tss, tss 有所有寄存器, 同时 TR(任务寄存器)指向某个 tss, 更改 TR 会触发换出 tss(旧进程)和换入 tss(新进程), 但切换进程没必要换所有寄存器</p></blockquote></li><li><p>因此 Linux 中每个 CPU 关联一个 tss, 同时 TR 不变, Linux 中参与进程切换主要是栈顶寄存器</p></li><li><p>task_struct 的 thread 结构体保留切换时需要修改的寄存器, 切换时将新进程 thread 写入 CPU tss 中</p></li><li><p>具体各类指针保存位置和时刻</p></li><li><p>用户栈, 切换进程内存空间时切换</p><ul><li>用户栈顶指针, 内核栈 pt_regs 中弹出</li><li>用户指令指针, 从内核栈 pt_regs 中弹出</li><li>内核栈, 由切换的 task_struct 中的 stack 指针指向</li><li>内核栈顶指针, __switch_to_asm 函数切换(保存在 thread 中)</li><li>内核指令指针寄存器: 进程调度最终都会调用 __schedule, 因此在让出(从当前进程)和取得(从其他进程) CPU 时, 该指针都指向同一个代码位置.</li></ul></li></ul></li></ul></li></ul></blockquote><h2 id="课堂练习" tabindex="-1"><a class="header-anchor" href="#课堂练习" aria-hidden="true">#</a> 课堂练习</h2><p>你知道应该用什么命令查看进程的运行时间和上下文切换次数吗？</p><p>欢迎留言和我分享你的疑惑和见解，也欢迎你收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习、进步。</p><h2 id="课后讨论" tabindex="-1"><a class="header-anchor" href="#课后讨论" aria-hidden="true">#</a> 课后讨论</h2><p>proc文件系统里面可以看运行时间和切换次数，还可以看自愿切换和非自愿切换次数。老师请教一个问题，A切到B, B切到C，C切到A，当最后切换回A的时候，A要知道自己是从C切换过来的，也就是last，这样做的目的是什么呢？A要对C做什么善后操作吗？<br> 作者回复: 是的 finish_task_switch完成清理工作</p><p>进程切换需要搞明白：我从哪里来，我要到哪里去<br> 作者回复: 这句话赞</p><p><code>vmstat 、 pidstat 和 /proc/interrupts</code>可以查看进程的上下文切换。</p>',90),m={href:"https://garlicspace.com/2019/07/20/%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E5%8F%8A%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E6%AC%A1%E6%95%B0/",target:"_blank",rel:"noopener noreferrer"},b=a("<p>看了三遍，因为有一些基础，大概明白了。我觉得有个地方很巧妙。当函数返回的时候，由于切换了上下文，包括栈指针，所以一个进程函数执行return返回到了另一个进程，也就是完成了进程的切换。由此也可以看出，cpu也是比较&quot;笨的&quot;，它只提供了基本的机制，至于如何利用这种机制，玩出花样，那就是各个操作系统自由发挥了。<br> 作者回复: 是的，这一点比较绕</p><p>刘老师，每个用户的进程都会被分配一个内核栈吗？<br> 作者回复: 是的</p><p>看起来 ps 里面的 TIME 就是进程的 cpu runtime 吧; <code>查看上下文切换</code>, 可以用 <code>cat /proc/x/status</code><br> 作者回复: 赞</p><p>补充一下,看了最后的那张图,感觉切换,就是切内核态的 stack/rsp/pc, 这样下一个任务就能找到在哪执行了,以及继续怎么执行, 而内核态共享一片内存空间,所以不需要mm_switch,切换完了,返回用户态,用户态的stack/rsp/pc都被切换了, 而用户态的内存空间需要单独切换<br> 作者回复: 是的</p><p>“cpu_init会给每一个 CPU 关联一个 TSS，然后将 TR 指向这个 TSS，然后在操作系统的运行过程中，TR 就不切换了，永远指向这个 TSS” 看到这里，想到了一个设计模式：享元模式（Flyweight Design Pattern）<br> 作者回复: 牛，这是从设计模式专栏过来的吧</p><p>关于指令指针的讲解, 厉害了...专栏有时候可以反者看, 先看最后总结, 然后往上顺藤模块看你的分析. 同时在读的书: lkd/ulk, 推荐给大家<br> 作者回复: 先看总结也挺好的</p><p>看了三遍 终于看懂了 A -&gt; B -&gt; C -&gt; A 这整个过程才能让A最后知道我是被谁切走的, 又从哪里切回来, 其实last就是前一个内核栈的prev, 只是需要将prev携带到next内核栈保留到last中.</p><p>&quot;通过三个变量 switch_to(prev = A, next=B，last = C);A 进程就明白了，我当时被切换走的时候，是切换成 B，这次切换回来，是从 C 回来的&quot;；这段话中，进程A从进程C切换回来时，进程A内核栈中变量的定义:prev=last=C，netxt=B，由于当前就是在进程A的地址空间里，所以，可以进程A可以说，当年我被切换到进程B，现在，由进程C又切换回来了。</p><p>在进程A-&gt;B-C时，其实文章开头的两个例子都用上了。就是文件系统那个例子在等待而让CPU的时候，被Tab网络那个进程抢到CPU了。然后B又因为网络等待，把CPU“让给”C。等C执行完成或者再让出CPU时，又调度给A了</p>",9);function h(w,f){const t=c("ExternalLinkIcon");return o(),i("div",null,[k,s("p",null,[n("这里我找了几个代码片段。"),d,n("。"),s("a",v,[n("Btrfs"),p(t)]),n("（B-Tree）是一种文件系统，感兴趣你可以自己去了解一下。")]),_,s("p",null,[n('通过ps -o etime= -p "$$" 可以 查看，进程的运行时间， 通过/proc/{pid}/status 中的 voluntary_ctxt_switches: nonvoluntary_ctxt_switches: 可以看到主动调度和抢占调度的次数， 也可以单独安装sysstat 使用pidstat -w 查看相关进程的调度信息 '),s("a",m,[n("https://garlicspace.com/2019/07/20/查看进程运行时间及上下文切换次数/"),p(t)])]),b])}const x=e(r,[["render",h],["__file","H16-调度（中）.html.vue"]]);export{x as default};
