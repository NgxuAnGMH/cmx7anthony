import{_ as p}from"./plugin-vue_export-helper-c27b6911.js";import{r as e,o as t,c as o,a as n,b as s,e as c,d as l}from"./app-cdabc73c.js";const i="/assets/4e68e7b1f59cedb8723b32141ac12fe0-8e06c571.jpg",u="/assets/c39053403fc1c3bf6e33392952d2c33a-ca815ecb.jpg",r="/assets/31b586c344cd7d0127775e7ff63711dd-5a27463e.jpg",k="/assets/70c2682fbbd1f9f3f4d14d7f5d5cd337-9ed18ea8.jpg",d="/assets/a08a9d2a3e693e95bd035af3673bb009-f6340900.jpg",m="/assets/1027ff24d1dc411c05670099e27fa8c4-ae5509ff.jpg",b="/assets/82b3fyy2fd5b465256fyy76da8a58eeb-546ba003.jpg",v={},g=n("h1",{id:"_06-手写cpu-一-迷你cpu架构设计与取指令实现",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_06-手写cpu-一-迷你cpu架构设计与取指令实现","aria-hidden":"true"},"#"),s(" 06｜手写CPU（一）：迷你CPU架构设计与取指令实现")],-1),y=n("p",null,"你好，我是 LMOS。",-1),w=n("p",null,"经过上一节课的学习，我们已经知道了一个基于 RISC-V 指令集设计的 CPU，必须要实现哪些指令。从这节课开始，我们就可以着手设计和实现 MiniCPU 了。",-1),_=n("em",null,"什么是流水线，在 CPU 中使用流水线的好处是什么",-1),f=n("em",null,"五个阶段",-1),h={href:"https://gitee.com/lmos/Geek-time-computer-foundation",target:"_blank",rel:"noopener noreferrer"},C=l('<p>话不多说，让我们正式开始今天的学习吧。</p><h2 id="什么是-cpu-流水线" tabindex="-1"><a class="header-anchor" href="#什么是-cpu-流水线" aria-hidden="true">#</a> 什么是 CPU 流水线？</h2><p>说到流水线，你是否会马上想到我们打工人的工厂流水线？没错，高大上的 CPU 流水线其实和我们打工人的流水线是一样的。</p><p>假如我们在冰墩墩工厂上班，生产流水线分为五个步骤，如下图所示：</p><figure><img src="'+i+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>在冰墩墩生产线上需要至少五个工人，各自负责模具制作、模具清洗、模具抛光、硅胶塑形和融入图案这五个环节中的一个。最简单的方法自然是：同一时刻只有一个冰墩墩在制作。但是冬奥会的热度让市场上的冰墩墩供应不足，为了早日实现“人手一墩”的目标，有什么提升生产效率的办法呢？</p><p>稍微想想就知道，<em>生产线上一个人在制作冰墩墩的时候，另外四个工人都处于空闲状态</em>，显然这是对人力资源的极大浪费。想要提高效率，我们不妨在第一个冰墩墩模具制作出来进入清洗阶段的时候，马上开始进行第二个冰墩墩模具的制作，而不是等到第一个冰墩墩全部步骤做完后，才开始制作下一个。</p><p>这样，后续生产中就能够保证<em>五个工人一直处于工作状态，不会造成人员的闲置</em>而产线的冰墩墩就好像流水一样源源不断地产出，因此我们称这种生产方式为流水线。</p><p>在 CPU 中也是使用类似的流水线作业。以经典的五级流水线为例，流水线中一条指令的生命周期分为五个阶段：</p><p><strong>取指阶段（Instruction Fetch）</strong>：取指阶段是指将指令从存储器中读取出来的过程。程序指针寄存器用来指定当前指令在存储器中的位置。读取一条指令后，程序指针寄存器会根据指令的长度自动递增，或者改写成指定的地址。</p><p><strong>译码阶段（Instruction Decode）</strong>：指令译码是指将存储器中取出的指令进行翻译的过程。指令译码器对指令进行拆分和解释，识别出指令类别以及所需的各种操作数。</p><p><strong>执行阶段（Instruction Execute）</strong>：指令执行是指对指令进行真正运算的过程。例如指令是一条加法运算指令，则对操作数进行相加操作；如果是一条乘法运算指令，则进行乘法运算。在“执行”阶段最关键的模块为<mark>算术逻辑单元</mark>（Arithmetic Logical Unit，ALU），它是实施具体运算的硬件功能单元。</p><p><strong>访存阶段（Memory Access）</strong>：访存是指存储器访问指令将数据从存储器中读出，或写入存储器的过程。</p><p><strong>写回阶段（Write-Back）</strong>：写回是指将指令执行的结果写回通用寄存器的过程。</p><ul><li>如果是<code>普通运算指令</code>，该结果值来自于“执行”阶段计算的结果；</li><li>如果是<code>存储器读指令</code>，该结果来自于“访存”阶段从存储器中读取出来的数据。</li></ul><p>和上述的冰墩墩生产线的流水作业一样，为了提高效率，CPU 使用流水线也是为了提高处理器的性能。</p><figure><img src="'+u+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>对照上图，CPU 在第一个时钟周期 T 内完成取指操作。然后在第二个时钟周期 2T 内对上一条指令进行译码的同时，取下一条指令。接着在第三个时钟周期 3T 内就有取指、译码和执行 3 个操作同时进行……以此类推，<em>五级流水线的 CPU 内就可以同时进行 5 个操作</em>。这样平均下来，<em>就相当于每条指令只需要五分之一的时钟周期时间来完成</em>。</p><p>总体上看，流水线提高了指令的处理速度，缩短了程序执行的时间。</p><p>那我们能不能把流水线的思想，引入到我们的 MiniCPU 中呢？答案是肯定的。具体如何实现呢？我们接着往下看。</p><h2 id="minicpu-的架构" tabindex="-1"><a class="header-anchor" href="#minicpu-的架构" aria-hidden="true">#</a> MiniCPU 的架构</h2><p>先明确一下我们想实现的目标：使用 Verilog 硬件描述语言，基于 RV32I 指令集，设计一个 32 位的经典五级流水线的处理器核。它将会支持运行大多数 RV32I 的基础指令。</p><p>那什么样的架构设计才能实现这个目标呢？参照 CPU 流水线的五个步骤，我们可以对处理器核的各个功能模块进行划分，主要模块包括<mark>指令提取单元</mark>、<mark>指令译码单元</mark>、<mark>整型执行单元</mark>、<mark>访问存储器</mark>和<mark>写回结果</mark>等单元模块。</p><p>根据上面的模块划分，我们可以设计出 MiniCPU 的整体框架，如下图所示：</p><figure><img src="'+r+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>这张图片中一个方框就表示一个模块，方框里面的文字就是模块的名字，箭头则表示模块与模块之间的信号传输关系。</p><p>从图中可以看到，我们要设计的不仅仅是一个 CPU 内核了，它更像是一个 <code>SOC</code>（System on Chip 的缩写）。</p><p>因为我们要对它进行一些仿真验证，就必须要包含存放指令、数据的 ROM 和 RAM，还有一些简单的外设。比如用于串口通信的 UART 以及一些通用输入、输出端口 GPIO 都属于外设。CPU 通过系统总线（System Bus）和这些外设进行通信。</p><p>下面我们先快速了解一下，在我们这个 CPU 架构中，体现五级流水线的主要模块有哪些。</p><ol><li>首先我们来看 <strong>pre_if 模块</strong>，这里我把它叫作<code>分支预测或者预读取模块</code>，因为它主要是先对上一个指令进行预处理，判断是不是分支跳转指令。如果是跳转指令，则产生跳转后的 PC 值，并对下一条指令进行预读取。</li><li>然后是取指通路模块，即 <strong>if_id 模块</strong>。它是<code>取指到译码之间的模块</code>，上面的指令预读取之后就会首先送入 if_id 模块，如果当前流水线没有发出指令清除信号，if_id 模块就会把指令送到译码模块。</li><li>接下来是 <strong>id_ex 模块</strong>，它是<code>译码到执行之间的模块</code>，用于将完成指令译码之后的寄存器索引值，以及指令执行的功能信息，根据流水线控制模块的控制信号，选择性地发送给执行模块去执行。</li><li>指令译码之后便可以进行指令执行，<strong>ex_mem 模块</strong>负责指令执行之后<code>将数据写入存储器中</code>或者<code>从存储器中读出数据</code>的过程。</li><li>最后由 <strong>mem_wb 模块</strong>将指令执行的运算结果或者从存储器读出的数据，<code>写回到通用寄存器</code>。到这里，处理器流水线的总体结构就设计好啦。</li></ol><p>接下来我们先完成流水线第一步，即取指模块的设计与实现。</p><h2 id="流水线的第一步-指令预读取" tabindex="-1"><a class="header-anchor" href="#流水线的第一步-指令预读取" aria-hidden="true">#</a> 流水线的第一步：指令预读取</h2><p>我们的 MiniCPU 流水线的第一步是指令预读取，也就是先把指令从存储器中读出。</p><p>由于我们的指令长度是 32 位的，也就是一条指令在存储器中占有 4 个字节的空间，所以一般情况下，CPU 中的程序计数器（PC）是以 4 递增的。</p><p>但是，如果你熟悉计算机程序就应该知道，我们的程序通常不是从头到尾执行一次就完事了，往往还需要调用函数或者循环执行某一段程序的操作。</p><p>而这样的操作，在硬件底层的 CPU 里面就涉及分支跳转指令了。为了实现程序分支跳转功能，就需要我们的预读取模块来处理。</p><p>我先把这个模块的 Verilog 代码给你展示一下，再具体给你讲解：</p><div class="language-verilog line-numbers-mode" data-ext="verilog"><pre class="language-verilog"><code><span class="token keyword">module</span> pre_if <span class="token punctuation">(</span>
    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> instr<span class="token punctuation">,</span>
    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> pc<span class="token punctuation">,</span>
    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> pre_pc
<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">wire</span> is_bxx <span class="token operator">=</span> <span class="token punctuation">(</span>instr<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">\`OPCODE_BRANCH</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//条件跳转指令的操作码</span>
    <span class="token keyword">wire</span> is_jal <span class="token operator">=</span> <span class="token punctuation">(</span>instr<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">\`OPCODE_JAL</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>     <span class="token comment">//无条件跳转指令的操作码</span>
    
    <span class="token comment">//B型指令的立即数拼接</span>
    <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> bimm  <span class="token operator">=</span> <span class="token operator">{{</span><span class="token number">20</span><span class="token operator">{</span>instr<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token operator">}}</span><span class="token punctuation">,</span> instr<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> instr<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">:</span><span class="token number">25</span><span class="token punctuation">]</span><span class="token punctuation">,</span> instr<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1&#39;b0</span><span class="token operator">}</span><span class="token punctuation">;</span>
    <span class="token comment">//J型指令的立即数拼接</span>
    <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> jimm  <span class="token operator">=</span> <span class="token operator">{{</span><span class="token number">12</span><span class="token operator">{</span>instr<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token operator">}}</span><span class="token punctuation">,</span> instr<span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">:</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">,</span> instr<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">,</span> instr<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">:</span><span class="token number">21</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1&#39;b0</span><span class="token operator">}</span><span class="token punctuation">;</span>
    <span class="token comment">//指令地址的偏移量</span>
    <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> adder <span class="token operator">=</span> is_jal <span class="token operator">?</span> jimm <span class="token punctuation">:</span> <span class="token punctuation">(</span>is_bxx <span class="token operator">&amp;</span> bimm<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> bimm <span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token keyword">assign</span> pre_pc <span class="token operator">=</span> pc <span class="token operator">+</span> adder<span class="token punctuation">;</span>
<span class="token keyword">endmodule</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们来看看第八行和第九行代码，分别是根据指令的低 7 位操作码，判断是否是条件跳转指令或是无条件跳转指令。</p><p>其实上一节课的 RISC-V 指令架构中，我们讲过 RISC-V 指令集中有两类分支跳转指令，分别是<strong>条件跳转指令</strong>和<strong>无条件跳转指令</strong>。</p><p>条件跳转指令格式如下表所示：</p><figure><img src="`+k+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>从这张表格我们可以发现，条件跳转指令的操作码，也就是指令中的低 7 位数都是 7’b1100011。根据这一特点，我们就可以在指令解码之前，判断出接下来可能会发生跳转。</p><p>我们结合代码来看看。下面的 Verilog 语句就是跳转指令的判断，其中的`OPCODE_BRANCH 已经通过宏定义为 7’b1100011。</p><div class="language-verilog line-numbers-mode" data-ext="verilog"><pre class="language-verilog"><code><span class="token keyword">wire</span> is_bxx <span class="token operator">=</span> <span class="token punctuation">(</span>instr<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">`OPCODE_BRANCH</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//条件跳转指令的操作码</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>条件跳转指令执行时是否发生跳转，要根据相关的数据来判断，这就需要指令执行之后才能知道是否需要跳转（具体如何判断，我们后面第十节课再展开）。</p><figure><img src="'+d+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>但是，我们的 CPU 是多级流水线架构，一条指令执行需要多个时钟周期。如果要等到跳转指令执行完成之后再去取下一条指令，就会降低我们的指令执行效率。</p><p>而指令预读取模块刚好可以解决这个问题。不管指令是否跳转，都提前把跳转之后的下一条指令从存储器中读取出来，以备流水线的下一阶段使用，这就提高了 CPU 的执行效率。</p><p>以下代码就是根据条件跳转指令的格式，对指令中的立即数进行拼接，为指令跳转时的 PC 提供偏移量。</p><div class="language-verilog line-numbers-mode" data-ext="verilog"><pre class="language-verilog"><code> <span class="token comment">//B型指令的立即数拼接</span>
<span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> bimm  <span class="token operator">=</span> <span class="token operator">{{</span><span class="token number">20</span><span class="token operator">{</span>instr<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token operator">}}</span><span class="token punctuation">,</span> instr<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> instr<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">:</span><span class="token number">25</span><span class="token punctuation">]</span><span class="token punctuation">,</span> instr<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1&#39;b0</span><span class="token operator">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>同样地，无条件跳转指令也用这种方式进行预处理。如下图的 jal 跳转指令的格式，它的操作码为 7’b1101111。</p><figure><img src="`+m+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>根据指令的操作码，预译码电路就可以判断出是否为无条件跳转指令。下面就是无条件跳转指令的判断的 Verilog 语句，其中的\`OPCODE_BRANCH 已经通过宏定义为 7’b1101111。</p><div class="language-verilog line-numbers-mode" data-ext="verilog"><pre class="language-verilog"><code><span class="token keyword">wire</span> is_jal <span class="token operator">=</span> <span class="token punctuation">(</span>instr<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">\`OPCODE_JAL</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>     <span class="token comment">//无条件跳转指令的操作码</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>顾名思义，无条件跳转指令就是不需要判断其他的任何条件，直接跳转。我们继续结合代码理解，这行代码的意思是，根据 jal 指令的格式对指令中的立即数进行拼接，为指令跳转时的 PC 提供偏移量。</p><div class="language-verilog line-numbers-mode" data-ext="verilog"><pre class="language-verilog"><code><span class="token comment">//J型指令的立即数拼接</span>
<span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> jimm  <span class="token operator">=</span> <span class="token operator">{{</span><span class="token number">12</span><span class="token operator">{</span>instr<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token operator">}}</span><span class="token punctuation">,</span> instr<span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">:</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">,</span> instr<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">,</span> instr<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">:</span><span class="token number">21</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1&#39;b0</span><span class="token operator">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>最后，预读取电路会根据当前的 PC 值和指令的偏移量相加，得到预测的 PC 值，并用预测的 PC 值提前读出下一条指令。其 Verilog 代码如下：</p><div class="language-verilog line-numbers-mode" data-ext="verilog"><pre class="language-verilog"><code><span class="token comment">//指令地址的偏移量</span>
  <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> adder <span class="token operator">=</span> is_jal <span class="token operator">?</span> jimm <span class="token punctuation">:</span> <span class="token punctuation">(</span>is_bxx <span class="token operator">&amp;</span> bimm<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> bimm <span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">;</span>
  <span class="token keyword">assign</span> pre_pc <span class="token operator">=</span> pc <span class="token operator">+</span> adder<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="取指数据通路模块" tabindex="-1"><a class="header-anchor" href="#取指数据通路模块" aria-hidden="true">#</a> 取指数据通路模块</h2><p>由上述的指令预读取模块把指令从存储器中读取之后，需要把它发送给译码模块进行翻译。但是，预读取模块读出的指令，并不是全部都能发送后续模块去执行。</p><p>例如上面的条件分支指令，在指令完成之前就把后续的指令预读取出来了。如果指令执行之后发现跳转的条件不成立，这时预读取的指令就是无效的，需要对流水线进行冲刷（flush），把无效的指令都清除掉。</p><p>取指通路模块 <strong>if_id</strong> 主要产生 3 个信号。首先是给后面解码模块提供的指令信号 **reg_instr。**如果流水线没有发生冲突，也就是没有发出清除信号 flush，则把预读取的指令保存，否则把指令清“0”。</p><div class="language-verilog line-numbers-mode" data-ext="verilog"><pre class="language-verilog"><code><span class="token comment">//指令通路</span>
  <span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clock<span class="token punctuation">)</span> <span class="token keyword">begin</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span> 
      reg_instr <span class="token operator">&lt;=</span> <span class="token number">32&#39;h0</span><span class="token punctuation">;</span> 
    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>flush<span class="token punctuation">)</span> <span class="token keyword">begin</span> 
      reg_instr <span class="token operator">&lt;=</span> <span class="token number">32&#39;h0</span><span class="token punctuation">;</span> 
    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>valid<span class="token punctuation">)</span> <span class="token keyword">begin</span> 
      reg_instr <span class="token operator">&lt;=</span> in_instr<span class="token punctuation">;</span> 
    <span class="token keyword">end</span>
  <span class="token keyword">end</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第二个是更新 PC 值，如果指令清除信号 flush=“0”，则把当前指令对应的 PC 值保存为 <strong>reg_pc</strong>，否则就把 reg_pc 清“0”。</p><div class="language-verilog line-numbers-mode" data-ext="verilog"><pre class="language-verilog"><code><span class="token comment">//PC值通路</span>
  <span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clock<span class="token punctuation">)</span> <span class="token keyword">begin</span><span class="token string">&quot;&quot;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span> 
      reg_pc <span class="token operator">&lt;=</span> <span class="token number">32&#39;h0</span><span class="token punctuation">;</span> 
    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>flush<span class="token punctuation">)</span> <span class="token keyword">begin</span> 
      reg_pc <span class="token operator">&lt;=</span> <span class="token number">32&#39;h0</span><span class="token punctuation">;</span> 
    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>valid<span class="token punctuation">)</span> <span class="token keyword">begin</span> 
      reg_pc <span class="token operator">&lt;=</span> in_pc<span class="token punctuation">;</span> 
    <span class="token keyword">end</span>
  <span class="token keyword">end</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后一个是流水线冲刷的标志信号 <strong>reg_noflush</strong>。当需要进行流水线冲刷时，reg_noflush=“0”，否则 reg_noflush=“1”。</p><div class="language-verilog line-numbers-mode" data-ext="verilog"><pre class="language-verilog"><code><span class="token comment">//流水线冲刷标志位</span>
  <span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clock<span class="token punctuation">)</span> <span class="token keyword">begin</span>  
    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span> 
      reg_noflush <span class="token operator">&lt;=</span> <span class="token number">1&#39;h0</span><span class="token punctuation">;</span> 
    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>flush<span class="token punctuation">)</span> <span class="token keyword">begin</span> 
      reg_noflush <span class="token operator">&lt;=</span> <span class="token number">1&#39;h0</span><span class="token punctuation">;</span> 
    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>valid<span class="token punctuation">)</span> <span class="token keyword">begin</span> 
      reg_noflush <span class="token operator">&lt;=</span> in_noflush<span class="token punctuation">;</span> 
    <span class="token keyword">end</span>
  <span class="token keyword">end</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以下就是 if_id 模块的完整代码：</p><div class="language-verilog line-numbers-mode" data-ext="verilog"><pre class="language-verilog"><code> <span class="token comment">//  IF_ID</span>
<span class="token keyword">module</span> <span class="token function">if_id</span><span class="token punctuation">(</span>           
  <span class="token keyword">input</span>         clk<span class="token punctuation">,</span>
  <span class="token keyword">input</span>         reset<span class="token punctuation">,</span>
  <span class="token keyword">input</span>  <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> in_instr<span class="token punctuation">,</span>
  <span class="token keyword">input</span>  <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> in_pc<span class="token punctuation">,</span>
  <span class="token keyword">input</span>         flush<span class="token punctuation">,</span>
  <span class="token keyword">input</span>         valid<span class="token punctuation">,</span>
  <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> out_instr<span class="token punctuation">,</span>
  <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> out_pc<span class="token punctuation">,</span>
  <span class="token keyword">output</span>        out_noflush
<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> reg_instr<span class="token punctuation">;</span> 
  <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> reg_pc<span class="token punctuation">;</span> 
  <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> reg_pc_next<span class="token punctuation">;</span> 
  <span class="token keyword">reg</span>        reg_noflush<span class="token punctuation">;</span> 
  <span class="token keyword">assign</span> out_instr <span class="token operator">=</span> reg_instr<span class="token punctuation">;</span> 
  <span class="token keyword">assign</span> out_pc <span class="token operator">=</span> reg_pc<span class="token punctuation">;</span> 
  <span class="token keyword">assign</span> out_noflush <span class="token operator">=</span> reg_noflush<span class="token punctuation">;</span> 
  <span class="token comment">//指令传递</span>
  <span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">posedge</span> reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span> 
      reg_instr <span class="token operator">&lt;=</span> <span class="token number">32&#39;h0</span><span class="token punctuation">;</span> 
    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>flush<span class="token punctuation">)</span> <span class="token keyword">begin</span> 
      reg_instr <span class="token operator">&lt;=</span> <span class="token number">32&#39;h0</span><span class="token punctuation">;</span> 
    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>valid<span class="token punctuation">)</span> <span class="token keyword">begin</span> 
      reg_instr <span class="token operator">&lt;=</span> in_instr<span class="token punctuation">;</span> 
    <span class="token keyword">end</span>
  <span class="token keyword">end</span>
  <span class="token comment">//PC值转递</span>
  <span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">posedge</span> reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span> 
      reg_pc <span class="token operator">&lt;=</span> <span class="token number">32&#39;h0</span><span class="token punctuation">;</span> 
    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>flush<span class="token punctuation">)</span> <span class="token keyword">begin</span> 
      reg_pc <span class="token operator">&lt;=</span> <span class="token number">32&#39;h0</span><span class="token punctuation">;</span> 
    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>valid<span class="token punctuation">)</span> <span class="token keyword">begin</span> 
      reg_pc <span class="token operator">&lt;=</span> in_pc<span class="token punctuation">;</span> 
    <span class="token keyword">end</span>
  <span class="token keyword">end</span>
  <span class="token comment">//流水线冲刷标志位</span>
  <span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">posedge</span> reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>  
    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span> 
      reg_noflush <span class="token operator">&lt;=</span> <span class="token number">1&#39;h0</span><span class="token punctuation">;</span> 
    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>flush<span class="token punctuation">)</span> <span class="token keyword">begin</span> 
      reg_noflush <span class="token operator">&lt;=</span> <span class="token number">1&#39;h0</span><span class="token punctuation">;</span> 
    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>valid<span class="token punctuation">)</span> <span class="token keyword">begin</span> 
      reg_noflush <span class="token operator">&lt;=</span> <span class="token number">1&#39;h1</span><span class="token punctuation">;</span> 
    <span class="token keyword">end</span>
  <span class="token keyword">end</span>
<span class="token keyword">endmodule</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>好了，到这里 CPU 流水线的第一步——取指，我们就讲完了。<em>在取指阶段就是把存储器里的指令读出，并传递给后续的译码模块进行处理</em>。</p><h2 id="重点回顾" tabindex="-1"><a class="header-anchor" href="#重点回顾" aria-hidden="true">#</a> 重点回顾</h2><p>今天我们终于开启了 MiniCPU 的设计与实现之旅，为此我们做了很多准备，恭喜你坚持到这里。</p><p>在开始设计之前，我先带你了解了流水线的设计思想。工厂里的流水线设计在 CPU 里也可以借鉴，通过这种方法就能提高 CPU 的性能。</p><p>真正的 CPU 流水线要根据应用需求来设计，应用场景不一样，设计的流水线也不一样。为了让你在弄懂原理的基础上能快速上手，我们的 MiniCPU 采用了经典的五级流水线设计。这个流水线里一条指令的五个阶段分别是<em>取指、译码、执行、访存和写回</em>。</p><p>从 MiniCPU 的架构设计上也能看到，我们的重心放在了最能体现五级流水线的模块。不过麻雀虽小，五脏俱全，这个架构里已经包含了 CPU 内核，用于存放指令、数据的 ROM 和 RAM 以及一些简单的外设。CPU 会通过<code>系统总线（System Bus）</code>和这些外设进行通信。</p><p>CPU 架构里的五个主要模块，你可以参考后面的导图，其中前两个模块我们这节课已经拿下了，其它模块之后的课程里我们再展开学习。</p><figure><img src="`+b+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>明确了设计思想和架构以后，我带你迈出了流水线的第一步，也就是取指令。</p><p>我们现实通过指令预读取模块，在程序发生分支跳转的之前，对指令进行分析，预测指令跳转的方向，并提前读取跳转后的指令。这么做能提高指令在流水线中执行效率。</p><p>最后，在 if_id 模块中，会根据是否需要进行流水线冲刷，来判断预读取的指令能否传递给后面的译码模块。如果指令在流水线中发生冲突，需要进行流水线冲刷，就把预读取的指令清除，否则就把预读取的指令传递给后续的译码模块。</p><p>那之后指令是如何译码的呢？译码是流水线很关键的一步，让我们下节课一起解锁这部分内容吧。</p><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题" aria-hidden="true">#</a> 思考题</h2><p>为什么要对指令进行预读取？直接取指然后译码、执行不可以吗？</p><p>欢迎你在留言区提问或者记录今天的收获，如果感觉这节课还不错，也推荐你分享给身边的朋友，和他一起手写 CPU。</p><blockquote><p>预读取指令的好处是加强分支预测能力，减少无用功，但不仅仅于此，比如某些软件代码转汇编，为了对齐会增加一些无用的指令，比如x86的nop（它有时会夹在几个其它指令中），还有 复杂的指令可以通过微码进行转换为几个简单的指令，总之，cpu不是也不应该所有的指令全部都执行<br> 预读取指令，有利于提高cpu效率，在一开始不执行浪费的时间好过cpu做到一半，才发现是无用的指令强的啊，还有部分条件指令，可以跳过不执行（比如c语言提高if的权重，降低else if的权重就是代码优化的方法），所以提高cpu效率在软硬件结合一起努力的啊<br> 可以直接取指然后译码再执行，但那样效率会低很多！分支预测是配合cpu流水线工作的，主要是看应用场景，电脑手机等肯定用到分支预测等，但那些老旧或简单的计算器压根分支预测用不到呀<br> 一句话：看应用场景再决定造什么样的cpu？<br> 作者回复: 正确</p><p>对指令预读取，方便形成流水线，加快执行速度，因为从存储器中直接取指令会比较慢。<br> 作者回复: 是的</p></blockquote>',86);function P(x,U){const a=e("ExternalLinkIcon");return t(),o("div",null,[g,y,w,n("p",null,[s("我会先跟你讲讲"),_,s("？然后，我们再以经典的五级流水线为例，讲解 CPU 流水线的"),f,s("。接着设计出我们 MiniCPU 的总体结构，并根据规划的五级流水线，完成流水线的第一步——取指模块的设计。课程的配套代码可以从"),n("a",h,[s("这里下载"),c(a)]),s("。")]),C])}const M=p(v,[["render",P],["__file","F06-手写CPU（一）.html.vue"]]);export{M as default};
