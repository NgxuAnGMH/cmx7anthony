import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o as p,c as r,a,b as s,e,d as c}from"./app-cdabc73c.js";const i="/assets/ef754d9b2c816acff1dad63875ffea27-a4dc8328.jpeg",l="/assets/432050446f68569a37c7699cccda75d9-0bd1a152.jpeg",d="/assets/dbda1bd1d43d6fa9d7b552ca57d223b9-85761d9e.jpeg",m={},u=c('<h1 id="_41-理解内存-下-解析tlb和内存保护" tabindex="-1"><a class="header-anchor" href="#_41-理解内存-下-解析tlb和内存保护" aria-hidden="true">#</a> 41 | 理解内存（下）：解析TLB和内存保护</h1><p>机器指令里面的内存地址都是虚拟内存地址。程序里面的每一个进程，都有一个属于自己的虚拟内存地址空间。我们可以通过地址转换来获得最终的实际物理地址。我们每一个指令都存放在内存里面，每一条数据都存放在内存里面。因此，<em>“地址转换”是一个非常高频的动作，“地址转换”的性能就变得至关重要了</em>。这就是我们今天要讲的<strong>第一个问题</strong>，也就是**<code>性能问题</code>**。</p><p>因为我们的指令、数据都存放在内存里面，这里就会遇到我们今天要谈的<strong>第二个问题</strong>，也就是**<code>内存安全问题</code>**。如果被人修改了内存里面的内容，我们的 CPU 就可能会去执行我们计划之外的指令。这个指令可能是破坏我们服务器里面的数据，也可能是被人获取到服务器里面的敏感信息。</p><p>现代的 CPU 和操作系统，会通过什么样的方式来解决这两个问题呢？别着急，等讲完今天的内容，你就知道答案了。</p><h2 id="加速地址转换-tlb" tabindex="-1"><a class="header-anchor" href="#加速地址转换-tlb" aria-hidden="true">#</a> 加速地址转换：TLB</h2><p>上一节我们说了，从虚拟内存地址到物理内存地址的转换，我们通过页表这个数据结构来处理。为了节约页表的内存存储空间，我们会使用多级页表数据结构。</p><p>不过，多级页表虽然节约了我们的存储空间，但是却带来了时间上的开销，变成了一个“以时间换空间”的策略。原本我们进行一次地址转换，只需要访问一次内存就能找到物理页号，算出物理内存地址。但是用了 4 级页表，我们就需要访问 4 次内存，才能找到物理页号。</p><p>我们知道，<em>内存访问其实（已经）比 Cache 要慢很多</em>。我们本来只是要做一个简单的地址转换，<em>现在反而（还）要一下子多访问好多次内存</em>。这种情况该怎么处理呢？你是否还记得之前讲过的“<code>加个缓存</code>”的办法呢？我们来试一试。</p><p>程序所需要使用的指令，都顺序存放在虚拟内存里面。我们执行的指令，也是一条条顺序执行下去的。也就是说，我们对于指令地址的访问，存在前面几讲所说的“空间局部性”和“时间局部性”，而需要访问的数据也是一样的。我们连续执行了 5 条指令。因为内存地址都是连续的，所以这 5 条指令通常都在同一个“虚拟页”里。</p><p>因此，这连续 5 次的内存地址转换，<strong>其实都来自于同一个虚拟页号，转换的结果自然也就是同一个物理页号</strong>。那我们就可以用前面几讲说过的，用一个“<code>加个缓存</code>”的办法。把之前的内存转换地址缓存下来，<em>使得我们不需要反复去访问内存来进行内存地址转换</em>。</p><img src="'+i+'" alt="img" style="zoom:25%;"><p>于是，计算机工程师们专门在 CPU 里放了一块缓存芯片。这块<mark>缓存芯片</mark>我们称之为 <strong>TLB</strong>，全称是<strong>地址变换高速缓冲</strong>（Translation-Lookaside Buffer）。这块缓存存放了<em>之前已经进行过地址转换的查询结果</em>。这样，当同样的虚拟地址需要进行地址转换的时候，<em>我们可以直接在 TLB 里面查询结果，而不需要多次访问内存来完成一次转换</em>。</p><p>TLB 和我们前面讲的 CPU 的高速缓存类似，可以分成指令的 TLB 和数据的 TLB，也就是 <strong>ITLB</strong> 和 <strong>DTLB</strong>。同样的，我们也可以根据大小对它进行分级，变成 L1、L2 这样多层的 TLB。</p><p>除此之外，还有一点和 CPU 里的高速缓存也是一样的，我们需要用<mark>脏标记</mark>这样的标记位，来实现“写回”这样缓存管理策略。</p><p>为了性能，我们整个内存转换过程也要由硬件来执行。在 CPU 芯片里面，我们封装了<mark>内存管理单元</mark>（MMU，Memory Management Unit）<strong>芯片</strong>，用来完成地址转换。<em>和 TLB 的访问和交互，都是由这个 MMU 控制的</em>。</p><img src="'+l+`" alt="img" style="zoom:25%;"><h2 id="安全性与内存保护" tabindex="-1"><a class="header-anchor" href="#安全性与内存保护" aria-hidden="true">#</a> 安全性与内存保护</h2><p>讲完了虚拟内存和物理内存的转换，我们来看看内存保护和安全性的问题。</p><p>进程的程序也好，数据也好，都要存放在内存里面。实际程序指令的执行，也是通过<mark>程序计数器</mark>里面的地址，去读取内存内的内容，然后运行对应的指令，使用相应的数据。</p><p>虽然我们现代的操作系统和 CPU，已经做了各种权限的管控。正常情况下，我们已经通过虚拟内存地址和物理内存地址的区分，隔离了各个进程。但是，无论是 CPU 这样的硬件，还是操作系统这样的软件，都太复杂了，难免还是会被黑客们找到各种各样的漏洞。</p><p>就像我们在软件开发过程中，常常会有一个“<em>兜底</em>”的错误处理方案一样，在对于内存的管理里面，计算机也有一些最底层的安全保护机制。这些机制统称为<strong>内存保护</strong>（Memory Protection）。我这里就为你简单介绍两个。</p><h2 id="_1、可执行空间保护" tabindex="-1"><a class="header-anchor" href="#_1、可执行空间保护" aria-hidden="true">#</a> 1、可执行空间保护</h2><p>第一个常见的安全机制，叫<strong>可执行空间保护</strong>（Executable Space Protection）。</p><p>这个机制是说，我们对于一个进程使用的内存，只把其中的指令部分设置成“<code>可执行</code>”的，对于其他部分，比如数据部分，<code>不给予“可执行”的权限</code>。</p><hr><p>因为无论是指令，还是数据，在我们的 CPU 看来，都是二进制的数据。我们直接把数据部分拿给 CPU，如果这些数据解码后，也能变成一条合理的指令，其实就是可执行的。</p><p>（如果）这个时候，黑客们想到了一些搞破坏的办法。我们在程序的数据区里，放入一些要执行的指令编码后的数据，然后找到一个办法，让 CPU 去把它们当成指令去加载，那 CPU 就能执行我们想要执行的指令了。</p><hr><p>（因此）对于进程里内存空间的执行权限进行控制，可以使得 CPU 只能执行指令区域的代码。对于数据区域的内容，即使找到了其他漏洞想要加载成指令来执行，也会因为没有权限而被阻挡掉。</p><h3 id="防止注入攻击" tabindex="-1"><a class="header-anchor" href="#防止注入攻击" aria-hidden="true">#</a> 防止注入攻击</h3><p>其实，在实际的应用开发中，类似的策略也很常见。我下面给你举两个例子。</p><p>比如说，在用 PHP 进行 Web 开发的时候，我们通常会禁止 PHP 有 eval 函数的执行权限。这个其实就是害怕外部的用户，所以没有把数据提交到服务器，而是把一段想要执行的脚本提交到服务器。服务器里在拼装字符串执行命令的时候，可能就会执行到预计之外被“注入”的破坏性脚本。这里我放了一个例子，用这个办法可以去删除服务器上的数据。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>script<span class="token punctuation">.</span>php<span class="token operator">?</span>param1<span class="token operator">=</span>xxx
<span class="token comment">//我们的PHP接受一个传入的参数，这个参数我们希望提供计算功能</span>
$code <span class="token operator">=</span> <span class="token function">eval</span><span class="token punctuation">(</span>$_GET<span class="token punctuation">[</span><span class="token string">&quot;param1&quot;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 我们直接通过 eval 计算出来对应的参数公式的计算结果</span>
script<span class="token punctuation">.</span>php<span class="token operator">?</span>param1<span class="token operator">=</span>&quot;<span class="token punctuation">;</span><span class="token operator">%</span><span class="token number">20</span>echo<span class="token operator">%</span><span class="token function">20exec</span><span class="token punctuation">(</span>&#39;rm <span class="token operator">-</span>rf <span class="token operator">~</span><span class="token operator">/</span>&#39;<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">%</span><span class="token number">20</span><span class="token comment">//</span>
<span class="token comment">// 用户传入的参数里面藏了一个命令</span>
$code <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span> echo <span class="token function">exec</span><span class="token punctuation">(</span>&#39;rm <span class="token operator">-</span>rf <span class="token operator">~</span><span class="token operator">/</span>&#39;<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;;</span>
<span class="token comment">// 执行的结果就变成了删除服务器上的数据</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>还有一个例子就是 SQL 注入攻击。如果服务端执行的 SQL 脚本是通过字符串拼装出来的，那么在 Web 请求里面传输的参数就可以藏下一些我们想要执行的 SQL，让服务器执行一些我们没有想到过的 SQL 语句。这样的结果就是，或者破坏了数据库里的数据，或者被人拖库泄露了数据。</p><h2 id="_2、地址空间布局随机化" tabindex="-1"><a class="header-anchor" href="#_2、地址空间布局随机化" aria-hidden="true">#</a> 2、地址空间布局随机化</h2><p>第二个常见的安全机制，叫<strong>地址空间布局随机化</strong>（Address Space Layout Randomization）。</p><p>内存层面的安全保护核心策略，<em>是在可能有漏洞的情况下进行安全预防</em>。上面的可执行空间保护就是一个很好的例子。但是，内存层面的漏洞还有其他的可能性。</p><p>这里的核心问题是，其他的人、进程、程序，会去修改掉特定进程的指令、数据，然后，让当前进程去执行这些指令和数据，造成破坏。<em><code>要想修改这些指令和数据</code>，我们需要知道这些指令和数据<code>所在的位置</code>才行</em>。</p><ol><li><strong><code>原先</code>我们一个进程的内存布局空间是固定的，所以任何第三方很容易就能知道</strong>指令在哪里，程序栈在哪里，数据在哪里，堆又在哪里。这个其实为想要搞破坏的人创造了很大的便利。</li><li><strong>而<mark>地址空间布局随机化</mark>这个机制，就是让这些区域的位置不再固定</strong>，在内存空间随机去分配这些进程里不同部分所在的内存空间地址，让破坏者猜不出来。猜不出来呢，自然就没法找到想要修改的内容的位置。如果只是随便做点修改，<em>程序只会 crash 掉，而不会去执行计划之外的代码</em>。</li></ol><img src="`+d+`" alt="img" style="zoom:25%;"><h3 id="密码加盐" tabindex="-1"><a class="header-anchor" href="#密码加盐" aria-hidden="true">#</a> 密码加盐</h3><p>这样的“随机化”策略，其实也是我们日常应用开发中一个常见的策略。一个大家都应该接触过的例子就是密码登陆功能。网站和 App 都会需要你设置用户名和密码，之后用来登陆自己的账号。然后，在服务器端，我们会把用户名和密码保存下来，在下一次用户登陆的时候，使用这个用户名和密码验证。</p><p>我们的密码当然不能明文存储在数据库里，不然就会有安全问题。如果明文存储在数据库里，意味着能拿到数据库访问权限的人，都能看到用户的明文密码。这个可能是因为安全漏洞导致被人拖库，而且网站的管理员也能直接看到所有的用户名和密码信息。</p><p>比如，前几年 CSDN 就发生过被人拖库的事件。虽然用户名和密码都是明文保存的，别人如果只是拿到了 CSDN 网站的用户名密码，用户的损失也不会太大。但是很多用户可能会在不同的网站使用相同的密码，如果拿到这些用户名和密码的人，能够成功登录用户的银行、支付、社交等等其他网站的话，用户损失就大了去了。</p><p>于是，大家会在数据库里存储密码的哈希值，比如用现在常用的 SHA256，生成一一个验证的密码哈希值。但是这个往往还是不够的。因为同样的密码，对应的哈希值都是相同的，大部分用户的密码又常常比较简单。于是，拖库成功的黑客可以通过彩虹表的方式，来推测出用户的密码。</p><p>这个时候，我们的“随机化策略”就可以用上了。我们可以在数据库里，给每一个用户名生成一个随机的、使用了各种特殊字符的<strong>盐值</strong>（Salt）。这样，我们的哈希值就不再是仅仅使用密码来生成的了，而是密码和盐值放在一起生成的对应的哈希值。哈希值的生成中，包括了一些类似于“乱码”的随机字符串，所以通过彩虹表碰撞来猜出密码的办法就用不了了。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>$password <span class="token operator">=</span> <span class="token string">&quot;goodmorning12345&quot;</span><span class="token punctuation">;</span>
<span class="token comment">// 我们的密码是明文存储的</span>
$hashed_password <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token char">&#39;sha256&#39;</span><span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 对应的hash值是 054df97ac847f831f81b439415b2bad05694d16822635999880d7561ee1b77ac</span>
<span class="token comment">// 但是这个hash值里可以用彩虹表直接“猜出来”原始的密码就是goodmorning12345</span>
$salt <span class="token operator">=</span> <span class="token string">&quot;#21Pb$Hs&amp;Xi923^)?&quot;</span><span class="token punctuation">;</span>
$salt_password <span class="token operator">=</span> $salt<span class="token punctuation">.</span>$password<span class="token punctuation">;</span>
$hashed_salt_password <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token char">&#39;sha256&#39;</span><span class="token punctuation">,</span> salt_password<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 这个hash后的slat因为有部分随机的字符串，不会在彩虹表里面出现。</span>
<span class="token comment">// 261e42d94063b884701149e46eeb42c489c6a6b3d95312e25eee0d008706035f</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，通过加入“随机”因素，我们有了一道最后防线。即使在出现安全漏洞的时候，我们也有了更多的时间和机会去补救这些问题。</p><p>虽然安全机制似乎在平时用不太到，但是在开发程序的时候，还是要有安全意识。毕竟谁也不想看到，被拖库的新闻里出现的是自己公司的名字，也不希望用户因为我们的错误遭受到损失。</p><h2 id="总结延伸" tabindex="-1"><a class="header-anchor" href="#总结延伸" aria-hidden="true">#</a> 总结延伸</h2><p>为了节约页表所需要的内存空间，我们采用了多级页表这样一个数据结构。但是，多级页表虽然节省空间了，却要花费更多的时间去多次访问内存。于是，<em>我们在<mark>实际进行地址转换的 <strong>MMU</strong></mark> 旁边放上了 <mark><strong>TLB</strong> 这个用于地址转换的缓存</mark></em>。TLB 也像 <code>CPU Cache</code> 一样，分成<em>指令</em>和<em>数据</em>部分，也可以进行 L1、L2 这样的分层。</p><p>然后，我为你介绍了<mark>内存保护</mark>。无论是数据还是代码，我们都要存放在内存里面。为了防止因为各种漏洞，导致一个进程可以访问别的进程的数据或者代码，甚至是执行对应的代码，造成严重的安全问题，我们介绍了最常用的两个内存保护措施，<mark>可执行空间保护</mark>和<mark>地址空间布局随机化</mark>。</p><ol><li>通过让数据空间里面的内容不能执行，可以避免了类似于“注入攻击”的攻击方式。</li><li>通过随机化内存空间的分配，可以避免让一个进程的内存里面的代码，被推测出来，从而不容易被攻击。</li></ol><h2 id="推荐阅读" tabindex="-1"><a class="header-anchor" href="#推荐阅读" aria-hidden="true">#</a> 推荐阅读</h2>`,54),h={href:"https://en.wikipedia.org/wiki/Memory_protection#Capability-based_addressing",target:"_blank",rel:"noopener noreferrer"},k={href:"https://zh.wikipedia.org/wiki/%E5%B9%BD%E7%81%B5%E6%BC%8F%E6%B4%9E",target:"_blank",rel:"noopener noreferrer"},_=a("p",null,"Spectre 和 Meltdown 漏洞，出现在 CPU 的高速缓存和虚拟机结合的层面。理解这个漏洞，可以让你看到，安全问题是如何出现各种让人难以想到的结果。这也是为什么我们需要可执行空间保护和地址空间布局，随机化这样的“防卫性”的安全策略。即使我们不知道漏洞可以从哪里来，即使漏洞可能已经发生了，这些策略也能够使得我们的系统更不容易被攻破。",-1),b=a("h2",{id:"课后思考",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#课后思考","aria-hidden":"true"},"#"),s(" 课后思考")],-1),g=a("p",null,"除了我们今天说的可执行空间保护和地址空间布局随机化之外，你还知道其他内存保护策略吗？你想到的这些内存保护策略，和你日常的开发工作中，是否也有类似思路的应用呢？",-1),v=a("p",null,"欢迎留言和我分享你日常开发中用到的内存保护策略，如果这篇文章对你有帮助，你也可以把它分享给你的朋友，和他一起讨论和学习。",-1),f=a("p",null,[s("想通了一个问题: 你知道sql里面不用sql拼接，而使用占位符可以防止sql注入攻击吧？那么为什么使用占位符可以防止攻击呢，我之前没想明白。简单来说就是将占位符当成数据解析，而不当作指令解析，不管这个占位符给得什么，我都把它当成是数据，而不会是指令。"),a("br"),s(" 其他网友：预编译了，这里的占位符不会当指令执行。另外，用占位符在数据库内核里走的不一样的处理流程")],-1),x=a("p",null,[s("linux下 内存空间随机化是否开启 是有配置的吗 还是跟内核版本有关？"),a("br"),s(" 其他网友：cat /proc/sys/kernel/randomize_va_space。0 为禁用，2 为启用")],-1),L={href:"https://www.sohu.com/a/318447401_132567",target:"_blank",rel:"noopener noreferrer"};function P(C,B){const n=t("ExternalLinkIcon");return p(),r("div",null,[u,a("p",null,[s("对于内存保护的相关知识，你可以通过"),a("a",h,[s("Wikipedia 里面的相关条目"),e(n)]),s("来进一步了解相关的信息。")]),a("p",null,[s("另外，2017 年暴露出来的"),a("a",k,[s("Spectre 和 Meltdown 漏洞"),e(n)]),s("的相关原理，你也可以在 Wikipedia 里面找到相关的信息，来了解一下。")]),_,b,g,v,a("blockquote",null,[f,x,a("p",null,[s("spectre漏洞：CPU流水线优化- 分支预测-边信号-"),a("a",L,[s("https://www.sohu.com/a/318447401_132567"),e(n)])])])])}const T=o(m,[["render",P],["__file","F41-理解内存（下）.html.vue"]]);export{T as default};
