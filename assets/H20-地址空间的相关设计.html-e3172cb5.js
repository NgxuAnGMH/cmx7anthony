import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as e,d as t}from"./app-cdabc73c.js";const p="/assets/99f9249ac492456573c4c96194a23380-da1ff282.jpg",c="/assets/image-20220707115420528-e6f69710.png",o="/assets/cb066df57938ce9277ba99102f95075e-fa3f04ff.jpg",s="/assets/c6c40d74f0be52ee65527c5d361619e1-81fed987.jpg",l="/assets/yybbca3006b16d8ae342295ebe566faf-ab962af0.jpg",i={},m=t('<h1 id="_20-土地需求扩大与保障-如何表示虚拟内存" tabindex="-1"><a class="header-anchor" href="#_20-土地需求扩大与保障-如何表示虚拟内存" aria-hidden="true">#</a> 20 | 土地需求扩大与保障：如何表示虚拟内存？</h1><p>你好，我是 LMOS。</p><p>在现实中，有的人需要向政府申请一大块区域，在这块区域中建楼办厂，但是土地有限且已经被占用。所以可能的方案是，只给你分配一个总的面积区域，今年湖北有空地就在湖北建立一部分厂房，明年广东有空地就在广东再建另一部分厂房，但是总面积不变。</p><p>其实在计算机系统中也有类似的情况，一个应用往往拥有很大的连续地址空间，并且每个应用都是一样的，只有在运行时才能分配到真正的物理内存，在操作系统中这称为虚拟内存。</p><p>那问题来了，操作系统要怎样实现虚拟内存呢？由于内容比较多，我会用两节课的时间带你解决这个问题。今天这节课，我们先进行<mark>虚拟地址空间的划分</mark>，搞定<mark>虚拟内存数据结构的设计</mark>。下节课再动手实现虚拟内存的核心功能。</p><p>好，让我们进入正题，先从虚拟地址空间的划分入手，配套代码你可以从这里获得。</p><h2 id="虚拟地址空间的划分" tabindex="-1"><a class="header-anchor" href="#虚拟地址空间的划分" aria-hidden="true">#</a> 虚拟地址空间的划分</h2><p>虚拟地址就是逻辑上的一个数值，而虚拟地址空间就是一堆数值的集合。通常情况下，32 位的处理器有 0～0xFFFFFFFF 的虚拟地址空间，而 64 位的虚拟地址空间则更大，有 0～0xFFFFFFFFFFFFFFFF 的虚拟地址空间。</p><p>对于如此巨大的地址空间，我们自然需要一定的安排和设计，<strong>比如什么虚拟地址段放应用，什么虚拟地址段放内核等</strong>。下面我们首先看看处理器硬件层面的划分，再来看看在此基础上我们系统软件层面是如何划分的。</p><h2 id="x86-cpu-如何划分虚拟地址空间" tabindex="-1"><a class="header-anchor" href="#x86-cpu-如何划分虚拟地址空间" aria-hidden="true">#</a> x86 CPU 如何划分虚拟地址空间</h2><p>我们 Cosmos 工作在 x86 CPU 上，所以我们先来看看 x86 CPU 是如何划分虚拟地址空间的。</p><p>由于 x86 CPU 支持虚拟地址空间时，要么开启保护模式，要么开启长模式，保护模式下是 32 位的，有 0～0xFFFFFFFF 个地址，可以使用完整的 4GB 虚拟地址空间。</p><p>在保护模式下，对这 4GB 的虚拟地址空间没有进行任何划分，而长模式下是 64 位的虚拟地址空间有 0～0xFFFFFFFFFFFFFFFF 个地址，这个地址空间非常巨大，硬件工程师根据需求设计，把它分成了 3 段，如下图所示。</p><img src="'+p+'" alt="img" style="zoom:15%;"><img src="'+c+'" alt="image-20220707115420528" style="zoom:25%;"><p>x86虚拟地址划分</p><p>长模式下，CPU 目前只实现了 48 位地址空间，但寄存器却是 64 位的，CPU 自己用地址数据的第 47 位的值扩展到最高 16 位，所以 64 位地址数据的<strong>最高 16 位，要么是全 0，要么全 1</strong>，这就是我们在上图看到的情形。</p><h2 id="cosmos-如何划分虚拟地址空间" tabindex="-1"><a class="header-anchor" href="#cosmos-如何划分虚拟地址空间" aria-hidden="true">#</a> Cosmos 如何划分虚拟地址空间</h2><p>现在我们来规划一下，Cosmos 对 x86 CPU 长模式下虚拟地址空间的使用。由前面的图形可以看出，在长模式下，整个虚拟地址空间只有两段是可以用的，很自然一段给内核，另一段就给应用。</p><p>我们把 0xFFFF800000000000～0xFFFFFFFFFFFFFFFF 虚拟地址空间分给内核，把 0～0x00007FFFFFFFFFFF 虚拟地址空间分给应用，内核占用的称为<strong>内核空间</strong>，应用占用的就叫<strong>应用空间</strong>。</p><p>在内核空间和应用空间中，我们又继续做了细分。后面的图并不是严格按比例画的，应用程序在链接时，会将各个模块的指令和数据分别放在一起，应用程序的栈是在最顶端，向下增长，应用程序的堆是在应用程序数据区的后面，向上增长。</p><p><strong>内核空间</strong>中有个<strong>线性映射区(直接映射区/连续且简单的映射关系)</strong> 0xFFFF800000000000～0xFFFF800400000000，这是我们在二级引导器中建立的 <strong>MMU 页表映射</strong>。</p><img src="'+o+`" alt="img" style="zoom:15%;"><p>内核空间与应用空间</p><h2 id="如何设计数据结构" tabindex="-1"><a class="header-anchor" href="#如何设计数据结构" aria-hidden="true">#</a> 如何设计数据结构</h2><p>根据前面经验，我们要实现一个功能模块，首先要设计出相应的数据结构，虚拟内存模块也一样。</p><p>这里涉及到虚拟地址区间，管理虚拟地址区间以及它所对应的物理页面，最后让进程和虚拟地址空间相结合。这些数据结构小而多，下面我们一个个来设计。</p><h2 id="虚拟地址区间" tabindex="-1"><a class="header-anchor" href="#虚拟地址区间" aria-hidden="true">#</a> 虚拟地址区间</h2><p>我们先来设计虚拟地址区间数据结构，由于虚拟地址空间非常巨大，我们绝不能像管理物理内存页面那样，一个页面对应一个结构体。那样的话，我们整个物理内存空间或许都放不下所有的虚拟地址区间数据结构的实例变量。</p><p>由于虚拟地址空间往往是以区为单位的，比如栈区、堆区，指令区、数据区，这些区内部往往是连续的，区与区之间却间隔了很大空间，而且每个区的空间扩大时我们不会建立新的虚拟地址区间数据结构，而是改变<strong>其中的指针</strong>，这就节约了内存空间。</p><p>下面我们来设计这个数据结构，代码如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">KMVARSDSC</span>
<span class="token punctuation">{</span>
    <span class="token class-name">spinlock_t</span> kva_lock<span class="token punctuation">;</span>        <span class="token comment">//保护自身自旋锁</span>
    <span class="token class-name">u32_t</span>  kva_maptype<span class="token punctuation">;</span>         <span class="token comment">//映射类型</span>
    <span class="token class-name">list_h_t</span> kva_list<span class="token punctuation">;</span>          <span class="token comment">//链表</span>
    <span class="token class-name">u64_t</span>  kva_flgs<span class="token punctuation">;</span>            <span class="token comment">//相关标志</span>
    <span class="token class-name">u64_t</span>  kva_limits<span class="token punctuation">;</span>
    <span class="token keyword">void</span><span class="token operator">*</span>  kva_mcstruct<span class="token punctuation">;</span>        <span class="token comment">//指向它的上层结构</span>
    <span class="token class-name">adr_t</span>  kva_start<span class="token punctuation">;</span>           <span class="token comment">//虚拟地址的开始</span>
    <span class="token class-name">adr_t</span>  kva_end<span class="token punctuation">;</span>             <span class="token comment">//虚拟地址的结束</span>
    <span class="token class-name">kvmemcbox_t</span><span class="token operator">*</span> kva_kvmbox<span class="token punctuation">;</span>    <span class="token comment">//管理这个结构映射的物理页面</span>
    <span class="token keyword">void</span><span class="token operator">*</span>  kva_kvmcobj<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token class-name">kmvarsdsc_t</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如你所见，除了自旋锁、链表、类型等字段外，最重要的就是<strong>虚拟地址的开始与结束字段</strong>，它精确描述了一段虚拟地址空间。</p><h2 id="整个虚拟地址空间如何描述" tabindex="-1"><a class="header-anchor" href="#整个虚拟地址空间如何描述" aria-hidden="true">#</a> 整个虚拟地址空间如何描述</h2><p>有了虚拟地址区间的数据结构，怎么描述整个虚拟地址空间呢？我们整个的虚拟地址空间，正是由多个虚拟地址区间连接起来组成，也就是说，只要把许多个虚拟地址区间数据结构按顺序连接起来，就可以表示整个虚拟地址空间了。</p><p>这个数据结构我们这样来设计。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">s_VIRMEMADRS</span>
<span class="token punctuation">{</span>
    <span class="token class-name">spinlock_t</span> vs_lock<span class="token punctuation">;</span>            <span class="token comment">//保护自身的自旋锁</span>
    <span class="token class-name">u32_t</span>  vs_resalin<span class="token punctuation">;</span>
    <span class="token class-name">list_h_t</span> vs_list<span class="token punctuation">;</span>              <span class="token comment">//链表，链接虚拟地址区间</span>
    <span class="token class-name">uint_t</span> vs_flgs<span class="token punctuation">;</span>                <span class="token comment">//标志</span>
    <span class="token class-name">uint_t</span> vs_kmvdscnr<span class="token punctuation">;</span>            <span class="token comment">//多少个虚拟地址区间</span>
    <span class="token class-name">mmadrsdsc_t</span><span class="token operator">*</span> vs_mm<span class="token punctuation">;</span>            <span class="token comment">//指向它的上层的数据结构</span>
    <span class="token class-name">kmvarsdsc_t</span><span class="token operator">*</span> vs_startkmvdsc<span class="token punctuation">;</span>   <span class="token comment">//开始的虚拟地址区间</span>
    <span class="token class-name">kmvarsdsc_t</span><span class="token operator">*</span> vs_endkmvdsc<span class="token punctuation">;</span>     <span class="token comment">//结束的虚拟地址区间</span>
    <span class="token class-name">kmvarsdsc_t</span><span class="token operator">*</span> vs_currkmvdsc<span class="token punctuation">;</span>    <span class="token comment">//当前的虚拟地址区间</span>
    <span class="token class-name">adr_t</span> vs_isalcstart<span class="token punctuation">;</span>           <span class="token comment">//能分配的开始虚拟地址</span>
    <span class="token class-name">adr_t</span> vs_isalcend<span class="token punctuation">;</span>             <span class="token comment">//能分配的结束虚拟地址</span>
    <span class="token keyword">void</span><span class="token operator">*</span> vs_privte<span class="token punctuation">;</span>               <span class="token comment">//私有数据指针</span>
    <span class="token keyword">void</span><span class="token operator">*</span> vs_ext<span class="token punctuation">;</span>                  <span class="token comment">//扩展数据指针</span>
<span class="token punctuation">}</span><span class="token class-name">virmemadrs_t</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上述代码可以看出，virmemadrs_t 结构管理了整个虚拟地址空间的 kmvarsdsc_t 结构，kmvarsdsc_t 结构表示一个虚拟地址区间。这样我们就能知道，虚拟地址空间中哪些地址区间没有分配，哪些地址区间已经分配了。</p><h2 id="进程的内存地址空间" tabindex="-1"><a class="header-anchor" href="#进程的内存地址空间" aria-hidden="true">#</a> 进程的内存地址空间</h2><p>虚拟地址空间作用于应用程序，而应用程序在操作系统中用进程表示。</p><p>当然，一个进程有了虚拟地址空间信息还不够，还要知道进程和虚拟地址到物理地址的映射信息，应用程序文件中的指令区、数据区的开始、结束地址信息。</p><p>所以，我们要把这些信息综合起来，才能表示一个进程的完整地址空间。这个数据结构我们可以这样设计，代码如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">s_MMADRSDSC</span>
<span class="token punctuation">{</span>
    <span class="token class-name">spinlock_t</span> msd_lock<span class="token punctuation">;</span>               <span class="token comment">//保护自身的自旋锁</span>
    <span class="token class-name">list_h_t</span> msd_list<span class="token punctuation">;</span>                 <span class="token comment">//链表</span>
    <span class="token class-name">uint_t</span> msd_flag<span class="token punctuation">;</span>                   <span class="token comment">//状态和标志</span>
    <span class="token class-name">uint_t</span> msd_stus<span class="token punctuation">;</span>
    <span class="token class-name">uint_t</span> msd_scount<span class="token punctuation">;</span>                 <span class="token comment">//计数，该结构可能被共享</span>
    <span class="token class-name">sem_t</span>  msd_sem<span class="token punctuation">;</span>                    <span class="token comment">//信号量</span>
    <span class="token class-name">mmudsc_t</span> msd_mmu<span class="token punctuation">;</span>                  <span class="token comment">//MMU相关的信息</span>
    <span class="token class-name">virmemadrs_t</span> msd_virmemadrs<span class="token punctuation">;</span>       <span class="token comment">//虚拟地址空间</span>
    <span class="token class-name">adr_t</span> msd_stext<span class="token punctuation">;</span>                   <span class="token comment">//应用的指令区的开始、结束地址</span>
    <span class="token class-name">adr_t</span> msd_etext<span class="token punctuation">;</span>
    <span class="token class-name">adr_t</span> msd_sdata<span class="token punctuation">;</span>                   <span class="token comment">//应用的数据区的开始、结束地址</span>
    <span class="token class-name">adr_t</span> msd_edata<span class="token punctuation">;</span>
    <span class="token class-name">adr_t</span> msd_sbss<span class="token punctuation">;</span>
    <span class="token class-name">adr_t</span> msd_ebss<span class="token punctuation">;</span>
    <span class="token class-name">adr_t</span> msd_sbrk<span class="token punctuation">;</span>                    <span class="token comment">//应用的堆区的开始、结束地址</span>
    <span class="token class-name">adr_t</span> msd_ebrk<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token class-name">mmadrsdsc_t</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>进程的物理地址空间，其实可以用一组 MMU 的页表数据表示，它保存在 mmudsc_t 数据结构中，但是这个数据结构我们不在这里研究，放在后面再研究。</p><h2 id="页面盒子" tabindex="-1"><a class="header-anchor" href="#页面盒子" aria-hidden="true">#</a> 页面盒子</h2><p>我们知道每段虚拟地址区间，在用到的时候都会映射对应的物理页面。根据前面我们物理内存管理器的设计，每分配一个或者一组内存页面，都会返回一个 msadsc_t 结构，所以我们还需要一个数据结构来挂载 msadsc_t 结构。</p><p>但为什么不直接挂载到 kmvarsdsc_t 结构中去，而是要设计一个新的数据结构呢？</p><p>我们当然有自己的考虑，一般虚拟地址区间是和文件对应的数据相关联的。比如进程的应用程序文件，又比如把一个文件映射到进程的虚拟地址空间中，只需要在内存页面中保留一份共享文件，多个程序就都可以共享它。</p><p>常规操作就是把同一个物理内存页面映射到不同的虚拟地址区间，所以我们实现一个专用的数据结构，共享操作时就可以让多个 kmvarsdsc_t 结构指向它，代码如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">KVMEMCBOX</span> 
<span class="token punctuation">{</span>
    <span class="token class-name">list_h_t</span> kmb_list<span class="token punctuation">;</span>        <span class="token comment">//链表</span>
    <span class="token class-name">spinlock_t</span> kmb_lock<span class="token punctuation">;</span>      <span class="token comment">//保护自身的自旋锁</span>
    <span class="token class-name">refcount_t</span> kmb_cont<span class="token punctuation">;</span>      <span class="token comment">//共享的计数器</span>
    <span class="token class-name">u64_t</span> kmb_flgs<span class="token punctuation">;</span>           <span class="token comment">//状态和标志</span>
    <span class="token class-name">u64_t</span> kmb_stus<span class="token punctuation">;</span>
    <span class="token class-name">u64_t</span> kmb_type<span class="token punctuation">;</span>           <span class="token comment">//类型</span>
    <span class="token class-name">uint_t</span> kmb_msanr<span class="token punctuation">;</span>         <span class="token comment">//多少个msadsc_t</span>
    <span class="token class-name">list_h_t</span> kmb_msalist<span class="token punctuation">;</span>     <span class="token comment">//挂载msadsc_t结构的链表</span>
    <span class="token class-name">kvmemcboxmgr_t</span><span class="token operator">*</span> kmb_mgr<span class="token punctuation">;</span>  <span class="token comment">//指向上层结构</span>
    <span class="token keyword">void</span><span class="token operator">*</span> kmb_filenode<span class="token punctuation">;</span>       <span class="token comment">//指向文件节点描述符</span>
    <span class="token keyword">void</span><span class="token operator">*</span> kmb_pager<span class="token punctuation">;</span>          <span class="token comment">//指向分页器 暂时不使用</span>
    <span class="token keyword">void</span><span class="token operator">*</span> kmb_ext<span class="token punctuation">;</span>            <span class="token comment">//自身扩展数据指针</span>
<span class="token punctuation">}</span><span class="token class-name">kvmemcbox_t</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到这里为止，一个内存页面容器盒子就设计好了，它可以独立存在，又和虚拟内存区间有紧密的联系，甚至可以用来管理文件数据占用的物理内存页面。</p><h2 id="页面盒子的头" tabindex="-1"><a class="header-anchor" href="#页面盒子的头" aria-hidden="true">#</a> 页面盒子的头</h2><p>kvmemcbox_t 结构是一个独立的存在，我们必须能找到它，所以还需要设计一个全局的数据结构，用于管理所有的 kvmemcbox_t 结构。这个结构用于挂载 kvmemcbox_t 结构，对其进行计数，还要支持缓存多个空闲的 kvmemcbox_t 结构，代码如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">KVMEMCBOXMGR</span> 
<span class="token punctuation">{</span>
    <span class="token class-name">list_h_t</span> kbm_list<span class="token punctuation">;</span>        <span class="token comment">//链表</span>
    <span class="token class-name">spinlock_t</span> kbm_lock<span class="token punctuation">;</span>      <span class="token comment">//保护自身的自旋锁</span>
    <span class="token class-name">u64_t</span> kbm_flgs<span class="token punctuation">;</span>           <span class="token comment">//标志与状态</span>
    <span class="token class-name">u64_t</span> kbm_stus<span class="token punctuation">;</span> 
    <span class="token class-name">uint_t</span> kbm_kmbnr<span class="token punctuation">;</span>         <span class="token comment">//kvmemcbox_t结构个数</span>
    <span class="token class-name">list_h_t</span> kbm_kmbhead<span class="token punctuation">;</span>     <span class="token comment">//挂载kvmemcbox_t结构的链表</span>
    <span class="token class-name">uint_t</span> kbm_cachenr<span class="token punctuation">;</span>       <span class="token comment">//缓存空闲kvmemcbox_t结构的个数</span>
    <span class="token class-name">uint_t</span> kbm_cachemax<span class="token punctuation">;</span>      <span class="token comment">//最大缓存个数，超过了就要释放</span>
    <span class="token class-name">uint_t</span> kbm_cachemin<span class="token punctuation">;</span>      <span class="token comment">//最小缓存个数</span>
    <span class="token class-name">list_h_t</span> kbm_cachehead<span class="token punctuation">;</span>   <span class="token comment">//缓存kvmemcbox_t结构的链表</span>
    <span class="token keyword">void</span><span class="token operator">*</span> kbm_ext<span class="token punctuation">;</span>            <span class="token comment">//扩展数据指针</span>
<span class="token punctuation">}</span><span class="token class-name">kvmemcboxmgr_t</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中的缓存相关的字段，是为了防止频繁分配、释放 kvmemcbox_t 结构带来的系统性能抖动。同时，缓存几十个 kvmemcbox_t 结构下次可以取出即用，不必再找内核申请，这样可以大大提高性能。</p><h2 id="理清数据结构之间的关系" tabindex="-1"><a class="header-anchor" href="#理清数据结构之间的关系" aria-hidden="true">#</a> 理清数据结构之间的关系</h2><p>现在，所有的数据结构已经设计完成，比较多。其中每个数据结构的功能我们已经清楚了，唯一欠缺的是，我们还没有明白它们之间的关系是什么。</p><p>只有理清了它们之间的关系，你才能真正明白，它们组合在一起是怎么完成整个功能的。</p><p>我们在写代码时，脑中有图，心中才有底。这里我给你画了一张图，为了降低复杂性，我并没有画出数据结构的每个字段，图里只是表达一下它们之间的关系。</p><img src="`+s+`" alt="img" style="zoom:25%;"><p>虚拟内存数据结构</p><p>这张图你需要按照从上往下、从左到右来看。首先从进程的虚拟地址空间开始，而进程的虚拟地址是由 kmvarsdsc_t 结构表示的，一个 kmvarsdsc_t 结构就表示一个已经分配出去的虚拟地址空间。一个进程所有的 kmvarsdsc_t 结构，要交给进程的 mmadrsdsc_t 结构中的 virmemadrs_t 结构管理。</p><p>我们继续往下看，为了管理虚拟地址空间对应的物理内存页面，我们建立了 kvmembox_t 结构，它由 kvmemcboxmgr_t 结构统一管理。在 kvmembox_t 结构中，挂载了物理内存页面对应的 msadsc_t 结构。</p><p>整张图片完整地展示了从虚拟内存到物理内存的关系，理清了这些数据结构关系之后，我们就可以写代码实现了。</p><h2 id="初始化-krlglobal-c-krlvadrsmem-c-krlinit-c" tabindex="-1"><a class="header-anchor" href="#初始化-krlglobal-c-krlvadrsmem-c-krlinit-c" aria-hidden="true">#</a> 初始化: krlglobal.c\\krlvadrsmem.c\\krlinit.c</h2><p>由于我们还没有讲到进程相关的章节，而虚拟地址空间的分配与释放，依赖于进程数据结构下的 mmadrsdsc_t 数据结构，所以我们得想办法产生一个 mmadrsdsc_t 数据结构的实例变量，最后初始化它。</p><p>下面我们先在 cosmos/kernel/<code>krlglobal.c</code> 文件中，申明一个 mmadrsdsc_t 数据结构的实例变量，代码如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token function">KRL_DEFGLOB_VARIABLE</span><span class="token punctuation">(</span><span class="token class-name">mmadrsdsc_t</span><span class="token punctuation">,</span> initmmadrsdsc<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>接下来，我们要初始化这个申明的变量，操作也不难。因为这是属于内核层的功能了，所以要在 cosmos/kernel/ 目录下建立一个模块文件 <code>krlvadrsmem.c</code>，在其中写代码，如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token class-name">bool_t</span> <span class="token function">kvma_inituserspace_virmemadrs</span><span class="token punctuation">(</span><span class="token class-name">virmemadrs_t</span> <span class="token operator">*</span>vma<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">kmvarsdsc_t</span> <span class="token operator">*</span>kmvdc <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">*</span>stackkmvdc <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token comment">//分配一个kmvarsdsc_t</span>
    kmvdc <span class="token operator">=</span> <span class="token function">new_kmvarsdsc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> kmvdc<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> FALSE<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//分配一个栈区的kmvarsdsc_t</span>
    stackkmvdc <span class="token operator">=</span> <span class="token function">new_kmvarsdsc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> stackkmvdc<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">del_kmvarsdsc</span><span class="token punctuation">(</span>kmvdc<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> FALSE<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//虚拟区间开始地址0x1000</span>
    kmvdc<span class="token operator">-&gt;</span>kva_start <span class="token operator">=</span> USER_VIRTUAL_ADDRESS_START <span class="token operator">+</span> <span class="token number">0x1000</span><span class="token punctuation">;</span>
    <span class="token comment">//虚拟区间结束地址0x5000</span>
    kmvdc<span class="token operator">-&gt;</span>kva_end <span class="token operator">=</span> kmvdc<span class="token operator">-&gt;</span>kva_start <span class="token operator">+</span> <span class="token number">0x4000</span><span class="token punctuation">;</span>
    kmvdc<span class="token operator">-&gt;</span>kva_mcstruct <span class="token operator">=</span> vma<span class="token punctuation">;</span>
    <span class="token comment">//栈虚拟区间开始地址0x1000USER_VIRTUAL_ADDRESS_END - 0x40000000</span>
    stackkmvdc<span class="token operator">-&gt;</span>kva_start <span class="token operator">=</span> <span class="token function">PAGE_ALIGN</span><span class="token punctuation">(</span>USER_VIRTUAL_ADDRESS_END <span class="token operator">-</span> <span class="token number">0x40000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//栈虚拟区间结束地址0x1000USER_VIRTUAL_ADDRESS_END</span>
    stackkmvdc<span class="token operator">-&gt;</span>kva_end <span class="token operator">=</span> USER_VIRTUAL_ADDRESS_END<span class="token punctuation">;</span>
    stackkmvdc<span class="token operator">-&gt;</span>kva_mcstruct <span class="token operator">=</span> vma<span class="token punctuation">;</span>

    <span class="token function">knl_spinlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vma<span class="token operator">-&gt;</span>vs_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vma<span class="token operator">-&gt;</span>vs_isalcstart <span class="token operator">=</span> USER_VIRTUAL_ADDRESS_START<span class="token punctuation">;</span>
    vma<span class="token operator">-&gt;</span>vs_isalcend <span class="token operator">=</span> USER_VIRTUAL_ADDRESS_END<span class="token punctuation">;</span>
    <span class="token comment">//设置虚拟地址空间的开始区间为kmvdc</span>
    vma<span class="token operator">-&gt;</span>vs_startkmvdsc <span class="token operator">=</span> kmvdc<span class="token punctuation">;</span>
    <span class="token comment">//设置虚拟地址空间的开始区间为栈区</span>
    vma<span class="token operator">-&gt;</span>vs_endkmvdsc <span class="token operator">=</span> stackkmvdc<span class="token punctuation">;</span>
    <span class="token comment">//加入链表</span>
    <span class="token function">list_add_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmvdc<span class="token operator">-&gt;</span>kva_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>vma<span class="token operator">-&gt;</span>vs_list<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">list_add_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stackkmvdc<span class="token operator">-&gt;</span>kva_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>vma<span class="token operator">-&gt;</span>vs_list<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//计数加2</span>
    vma<span class="token operator">-&gt;</span>vs_kmvdscnr <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token function">knl_spinunlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vma<span class="token operator">-&gt;</span>vs_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> TRUE<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">init_kvirmemadrs</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">//初始化mmadrsdsc_t结构非常简单</span>
    <span class="token function">mmadrsdsc_t_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>initmmadrsdsc<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//初始化进程的用户空间 </span>
    <span class="token function">kvma_inituserspace_virmemadrs</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>initmmadrsdsc<span class="token punctuation">.</span>msd_virmemadrs<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中，init_kvirmemadrs 函数首先调用了 mmadrsdsc_t_init，对我们申明的变量进行了初始化。因为这个变量中有链表、自旋锁、信号量这些数据结构，必须要初始化才能使用。</p><p>最后调用了 kvma_inituserspace_virmemadrs 函数，这个函数中建立了一个虚拟地址区间和一个栈区，栈区位于虚拟地址空间的顶端。下面我们在 <code>krlinit.c</code> 中的 init_krl 函数中来调用它。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">init_krl</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">//初始化内核功能层的内存管理</span>
    <span class="token function">init_krlmm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token function">die</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">init_krlmm</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">init_kvirmemadrs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>至此，我们的内核功能层的初始流程就建立起来了，是不是很简单呢？</p><h2 id="重点回顾" tabindex="-1"><a class="header-anchor" href="#重点回顾" aria-hidden="true">#</a> 重点回顾</h2><p>至此我们关于虚拟内存的虚拟地址空间的划分和虚拟内存数据结构的设计就结束了，我把这节课的重点为你梳理一下。</p><p>首先是虚拟地址空间的划分。由于硬件平台的物理特性，虚拟地址空间被分成了两段，Cosmos 也延续了这种划分的形式，顶端的虚拟地址空间为内核占用，底端为应用占用。内核还建立了 16GB 的线性映射区，而应用的虚拟地址空间分成了指令区，数据区，堆区，栈区。</p><p>然后为了实现虚拟地址内存，我们设计了大量的数据结构，它们分别是</p><ol><li><strong>虚拟地址区间</strong> kmvarsdsc_t 结构、</li><li><strong>管理虚拟地址区间的虚拟地址空间</strong> virmemadrs_t 结构、</li><li><strong>包含 virmemadrs_t 结构和 mmudsc_t 结构的</strong> mmadrsdsc_t 结构、</li><li><strong>用于挂载 msadsc_t 结构的页面盒子</strong>的 kvmemcbox_t 结构、</li><li>还有<strong>用于管理所有的 kvmemcbox_t 结构的</strong> kvmemcboxmgr_t 结构。</li></ol><img src="`+l+'" alt="img" style="zoom:33%;"><p>数据结构功能表</p><p>最后是初始化工作。由于我们还没有进入到进程相关的章节，所以这里必须要申明一个进程相关的 mmadrsdsc_t 结构的实例变量，并进行初始化，这样我们才能测试虚拟内存的功能。</p><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题" aria-hidden="true">#</a> 思考题</h2><p>请问内核虚拟地址空间为什么有一个 0xFFFF800000000000～0xFFFF800400000000 的线性映射区呢？</p><p>欢迎你在留言区跟我交流讨论。如果这节课对你有帮助，也欢迎你分享给你的朋友。</p><p>我是 LMOS，我们下节课见！</p><h2 id="关键-数据结构总结图" tabindex="-1"><a class="header-anchor" href="#关键-数据结构总结图" aria-hidden="true">#</a> 关键: 数据结构总结图</h2><img src="'+s+'" alt="img" style="zoom:25%;">',88),d=[m];function r(k,u){return a(),e("div",null,d)}const b=n(i,[["render",r],["__file","H20-地址空间的相关设计.html.vue"]]);export{b as default};
