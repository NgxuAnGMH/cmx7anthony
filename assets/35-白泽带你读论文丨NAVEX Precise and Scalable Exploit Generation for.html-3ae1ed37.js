import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{r,o,c as s,a as i,b as e,e as t,d as p}from"./app-cdabc73c.js";const l="/assets/640-1691475114025-285-057ff548.png",c="/assets/640-1691475114026-286-a7c68e8b.png",g="/assets/640-1691475114026-287-8ec25f93.png",d="/assets/640-1691475114026-288-b62e7fb5.png",f="/assets/640-1691475114026-289-9ca971fd.png",_="/assets/640-1691475114026-290-e01e72af.png",h="/assets/640-1691475114027-291-90349955.png",u="/assets/640-1691475114027-292-8b4a12a3.png",x="/assets/640-1691475114027-293-07afe26d.png",m={},b=i("h1",{id:"_35-白泽带你读论文丨navex-precise-and-scalable-exploit-generation-for",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#_35-白泽带你读论文丨navex-precise-and-scalable-exploit-generation-for","aria-hidden":"true"},"#"),e(" 35-白泽带你读论文丨NAVEX: Precise and Scalable Exploit Generation for")],-1),E=i("p",null,[i("strong",null,"NAVEX: Precise and Scalable Exploit Generation")],-1),N=i("p",null,[i("strong",null,"for Dynamic Web Application")],-1),A={href:"https://www.usenix.org/system/files/conference/usenixsecurity18/sec18-alhuzali.pdf",target:"_blank",rel:"noopener noreferrer"},S={href:"https://github.com/aalhuz/navex",target:"_blank",rel:"noopener noreferrer"},V=p('<p>本文发表在USENIX Security‘18，第一作者是来自伊利诺伊大学芝加哥分校的助理教授Abeer Alhuzali。</p><h2 id="_1-主要内容" tabindex="-1"><a class="header-anchor" href="#_1-主要内容" aria-hidden="true">#</a> <strong>1 主要内容</strong></h2><p>现代Web应用程序通常包含客户端、服务端和数据库三层架构，而且包含许多的动态特性，会根据用户的交互和输入动态地生成内容。这些动态特性增加了Web应用的复杂性，同时也增加了分析其安全性的难度。</p><p>此前也有不少关于Web应用自动化审计的工作，但是主要存在两个问题：（i）误报率较高，需要人工检查每个报告的漏洞点是否正确；（ii）以往基于静态程序分析的审计方法无法分析程序中的一些特性，存在覆盖率问题。为了解决这个问题，作者采用动静结合的方式，以静态分析为指导，辅助动态分析构造可用的exploit来自动验证漏洞的正确性。</p><p>作者实现一个名为NAVEX的工具来自动识别漏洞，并生成相应的exploit。最后作者对26个PHP CMS进行了测试，发现NAVEX一共构建了204个具体的exploit，其中195个与SQLI和XSS漏洞相关，9个与EAR（Execution After Redirect，重定向后执行）漏洞相关。</p><h2 id="_2-设计与实现" tabindex="-1"><a class="header-anchor" href="#_2-设计与实现" aria-hidden="true">#</a> <strong>2 设计与实现</strong></h2><figure><img src="'+l+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>NAVEX的工作机制如上图所示，主要分为两个阶段，</p><ol><li>第一阶段是Vulnerable Sinks Identification（<em>静态分析阶段</em>），<br> 目的是找到候选的漏洞点及其触发漏洞的漏洞利用字符串；</li><li>第二个阶段是Concrete Exploits Generation（<em>动态分析阶段</em>），<br> 目标是生成具体的exploit，由从公共页面到sink点所在页面会产生的一系列HTTP请求组成。</li></ol><h3 id="_1-vulnerable-sinks-identification" tabindex="-1"><a class="header-anchor" href="#_1-vulnerable-sinks-identification" aria-hidden="true">#</a> （1）Vulnerable Sinks Identification</h3><figure><img src="'+c+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>在静态分析阶段，作者在NAVEX中定义了一个Attack Dictionary，由四个部分组成：</p><ul><li>（i）Sinks，敏感函数；</li><li>（ii）Sanitization，常见的过滤函数或是过滤方式；</li><li>（iii）Traversal type，遍历方向，分为前向回溯和后向回溯；</li><li>（iv）Attack Strings，触发漏洞的攻击字符串，是一个fuzz字典。</li></ul><p>首先，对每个潜在漏洞的模块建立图模型：作者对图模型生成工具phpjoern进行了扩展，加入了节点的过滤信息。</p><p>然后，对代码属性图进行遍历来寻找从source点到sink点的路径，对于注入类漏洞统一采取后向回溯的方式，根据PDG关系寻找攻击路径；对于EAR漏洞采取前向遍历的漏洞方式。</p><p>最后，用符号执行生成公式后利用约束求解器求解哪些路径可以被利用，输出是触发漏洞的exploit string，在第二阶段会被使用。</p><h3 id="_2-concrete-exploits-generation" tabindex="-1"><a class="header-anchor" href="#_2-concrete-exploits-generation" aria-hidden="true">#</a> （2）Concrete Exploits Generation</h3><figure><img src="'+g+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>从上图可以看到，动态分析阶段分为3个步骤：</p><p><strong>a. Dynamic Execution</strong></p><p>这一步的目的是生成从公共页面到sink点所在页面会产生的HTTP请求，涉及到前端约束提取求解以及后端约束提取求解。</p><p>前端约束提取是利用爬虫完成的，Crawler爬取HTML页面中的表单属性信息并生成约束F(html)，同时爬取验证表单信息时会用到JavaScript代码并生成约束F(js)。最后生成最终的前端约束F(form)=F(html)∧F(js)，用约束求解器Z3求解生成相应的表单input。</p><p>除了客户端的约束之外，服务端也会对用户的输入做一些限制，所以还需要满足服务端的约束。NAVEX会动态跟踪判断用户输入是否满足服务端约束，该判断主要基于两种方式：(i) 是否更改程序状态（有无新的session生成，是否有新变量生成等）; (ii) 是否有敏感操作被执行，如sql查询操作等。如果检测到请求没有成功，NAVEX会将后端的约束也加入到前端约束中，用约束求解器重新生成的新input进行提交，这个过程会重复多次，直到请求成功为止。</p><p><strong>b. Navigation Graph</strong></p><p>NAVEX会将上一步动态执行生成的相关HTTP请求信息都存储到Navigation Graph，G = (N, E)中，该图结构如下图所示：</p><figure><img src="'+d+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>上图中，每一个节点表示一个完整的HTTP请求，边表示跳转的方式（通过链接link或是表单form进行跳转）。单个节点中，ID是节点的唯一标识符，URL是HTTP请求中的URL，Form_Params存储表单的输入，Role存储爬虫时用到的登录凭证。</p><p><strong>c. Final Exploit Generation</strong></p><p>最后NAVEX会结合静态分析阶段得到的漏洞模块及其对应的exploit string对Navigation Graph进行遍历，最后会得到类似下图的完整的攻击请求链接。</p><figure><img src="'+f+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h2 id="_3-实验评估" tabindex="-1"><a class="header-anchor" href="#_3-实验评估" aria-hidden="true">#</a> <strong>3 实验评估</strong></h2><p>作者对26个PHP CMS进行了测试，数据集包含22.7K PHP文件，代码行数超过了3.2M行。针对这些CMS，NAVEX共构造了204个具体的exploit，以SQL注入漏洞为例：</p><figure><img src="'+_+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>对于SQL注入漏洞，NAVEX仅关心4种敏感函数：</p><p>mssql_query, mysql_query, mysqli_query,sqlite_query</p><p>最后NAVEX在37m 45s内找到了155个SQLI漏洞点，并在7m左右生成了与之对应的exploit。</p><p>作者同时对NAVEX的性能进行了评估。如下图所示，作者发现在CPG中加入sanitization tag和database constraint tag之后，找到的漏洞点的误报被大幅度减少。</p><figure><img src="'+h+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>除此之外，在动态分析阶段对客户端代码进行分析也在一定程度上提高了程序覆盖率，生成的exploit的数量也随之增加了。</p><figure><img src="'+u+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>最后，因为Chainsaw支持SQL注入漏洞和XSS漏洞的exploit生成，作者将NAVEX与Chainsaw进行了对比，结果如下图所示。除了SchoolMate之外，对于其余参与测评的8个cms，无论是在生成exploit的数量上还是效率上，NAVEX都有更好的表现。</p><figure><img src="'+x+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h2 id="_4-评价" tabindex="-1"><a class="header-anchor" href="#_4-评价" aria-hidden="true">#</a> <strong>4 评价</strong></h2><p>本文的创新点在于采用了动静结合的分析方法，扩大了程序的覆盖范围，因此相比于先前的静态审计工具能找到更多的漏洞。相较于作者先前的发表在CCS 2016的工作Chainsaw，在静态分析阶段，作者采用扩展后的代码属性图挖掘攻击路径，利用sanitization tag和database constraint tag过滤掉很多不可利用的路径来防止路径爆炸，所以在效率方面也有较大幅度的提升。同时，phpjoern生成的CPG图不支持动态函数调用的问题也导致了NAVEX会遗失一些潜在的漏洞点。</p>',44);function y(X,z){const a=r("ExternalLinkIcon");return o(),s("div",null,[b,E,N,i("p",null,[e("原文链接："),i("a",A,[e("https://www.usenix.org/system/files/conference/usenixsecurity18/sec18-alhuzali.pdf"),t(a)])]),i("p",null,[e("项目地址："),i("a",S,[e("https://github.com/aalhuz/navex"),t(a)])]),V])}const v=n(m,[["render",y],["__file","35-白泽带你读论文丨NAVEX Precise and Scalable Exploit Generation for.html.vue"]]);export{v as default};
