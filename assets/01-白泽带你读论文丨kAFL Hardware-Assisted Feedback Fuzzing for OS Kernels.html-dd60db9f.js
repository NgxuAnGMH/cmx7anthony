import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as r,c as a,d as n}from"./app-cdabc73c.js";const t="/assets/640-1691488142447-390-f4bdb845.jpeg",s="/assets/640-1691488142447-391-3f799df7.jpeg",d={},i=n('<h1 id="_01-白泽带你读论文丨kafl-hardware-assisted-feedback-fuzzing-for-os-kernels" tabindex="-1"><a class="header-anchor" href="#_01-白泽带你读论文丨kafl-hardware-assisted-feedback-fuzzing-for-os-kernels" aria-hidden="true">#</a> 01-白泽带你读论文丨kAFL: Hardware-Assisted Feedback Fuzzing for OS Kernels</h1><h2 id="论文名称" tabindex="-1"><a class="header-anchor" href="#论文名称" aria-hidden="true">#</a> 论文名称</h2><p><strong>kAFL: Hardware-Assisted Feedback Fuzzing for OS Kernels</strong></p><h2 id="主要内容" tabindex="-1"><a class="header-anchor" href="#主要内容" aria-hidden="true">#</a> 主要内容</h2><p>本文发表在USENIX Security 2017上，本文工作主要由来自德国波鸿鲁尔大学(RuhrUniversität Bochum)的研究者完成。第一作者Sergej Schumilo在Fuzz相关领域曾发表过2篇论文，对于软件硬件结合的fuzz在之前也有相关研究。</p><p><strong>Fuzz</strong>在漏洞挖掘中是一个重要的过程，也是研究的重点。用户态的Fuzz被讨论的比较多，相关工具也比较多。但是内核的Fuzz难度较大，工具相较来说比较少。之前大部分的工具模拟效率低，对闭源操作系统支持较差。这篇论文就是实现了一个内核的Fuzz工具，利用了两个硬件特性来提高Fuzz的效率，最终完成了一个高效的内核Fuzz工具。这两个硬件特性都是Intel CPU提供的，一个是VT-x虚拟化技术，另一个是PT-Trace追踪功能。第一种是用于提高虚拟化效率的技术，相较于传统的模拟化，这种虚拟化使得VMM操作和控制VM时，将更加快速、可靠和安全。第二种PT追踪技术，让CPU可以搜集指令运行的部分上下文信息，这些信息对于推测Fuzz输入来说十分重要。作者结合了两种技术，并借鉴了著名Fuzz工具AFL的设计思路，完成了kAFL。经过测试，这款工具再发现能力和效率上都比较理想，带来的系统开销也几乎可以忽略不计，解决了目前内核Fuzz中存在的一些问题。</p><h2 id="设计与实现" tabindex="-1"><a class="header-anchor" href="#设计与实现" aria-hidden="true">#</a> 设计与实现</h2><p>在功能设计上，KAFL采用了模块化的设计，扩展性好，修改更加灵活。整体设计分为<strong>VMM</strong>部分和<strong>VM</strong>部分。</p><p>VMM中可以分为3个模块KVM，QEMU-PT和kAFL。VM又能分为Target Kernel和Agent。</p><p>-<strong>KVM</strong>中实现了PT追踪功能，负责收集目标内核的运行信息。</p><p>-<strong>QEMU-PT</strong>除了作为KVM和kAFL交互的中间件之外，还有一个很重要的功能就是作为PT data的decoder。</p><p>-<strong>kAFL</strong>就是Fuzz工具的逻辑部分了，整体设计实现上都借鉴了AFL的思路。会根据反馈结果更高效的生成下一次输入。</p><p>-<strong>Target Kernel</strong>就是目标Kernel了，该工具对主流的操作系统都做了支持。</p><p>-<strong>Agent</strong>同样也作为一个交互的中间件，主要和目标Kernel做一些交互操作，如挂载镜像。</p><figure><img src="'+t+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>kAFL的模块化设计</p><p>论文另外一个重要部分就是PT data的<strong>decoder</strong>了，intel官方提供的decoder效率太低，作者借鉴了JIT compiler的思想，实现了一个效率更高的decoder，在结合对于PT功能的配置，过滤掉一些不关心的数据，使得对PT data的处理变得更加高效。</p><p>为了测试工具的效果，作者也设计了比较完善的evaluation，对Windows，MacOS，Linux系统都进行了挂载镜像功能的fuzz。在每个平台上或多或少都发现了一些问题。对于已知漏洞的发现能力也做了实验，工具也能较好的发现已知漏洞。</p><figure><img src="'+s+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>测试结果</p><p>另外，工具对于自身带来的开销也做了评测，量化出来大约只有4%左右的损失，JIT机制的decoder也比intel官方提供的高效的了很多，整体来说实验结果表现都很优秀。</p><h2 id="评价" tabindex="-1"><a class="header-anchor" href="#评价" aria-hidden="true">#</a> 评价</h2><p>这个工具从Kernel Fuzz目前存在的问题出发，以新颖的角度提出了解决方案，并以实验证明效果不错，解决了部分Challenge，对于接下来Kernel fuzzer的发展有较大的指导意义。不过测试都是在一些简单的程序上进行的，没有针对现实生活中常见的软件和操作，可能实用性还没有那么好。</p>',23),o=[i];function c(g,p){return r(),a("div",null,o)}const h=e(d,[["render",c],["__file","01-白泽带你读论文丨kAFL Hardware-Assisted Feedback Fuzzing for OS Kernels.html.vue"]]);export{h as default};
