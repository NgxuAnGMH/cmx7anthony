import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o,c,a as s,b as n,e as p,d as a}from"./app-cdabc73c.js";const l="/assets/31b586c344cd7d0127775e7ff63711dd-5a27463e.jpg",u="/assets/ac1d4cf173d140225fff21f2c9fedb0e-5ef9ac3d.jpg",d="/assets/e7308850a0d185b3ccdde6b7ef4806c2-e5284667.jpg",r="/assets/93a1c6c0c1e71cb4cc6f5bffbc86f577-ce134a68.jpg",m="/assets/31b586c344cd7d0127775e7ff63711dd-5a27463e.jpg",k="/assets/54b5250d3992644cf27ebe953fb44283-d97b2d98.jpg",v={},b=a('<h1 id="_11-手写cpu-六-如何让我们的cpu跑起来" tabindex="-1"><a class="header-anchor" href="#_11-手写cpu-六-如何让我们的cpu跑起来" aria-hidden="true">#</a> 11｜手写CPU（六）：如何让我们的CPU跑起来？</h1><p>你好，我是 LMOS。</p><p>通过前面几节课的学习，我们已经完成了 MiniCPU 五级流水线的模块设计，现在距离实现一个完整的 MiniCPU 也就一步之遥。</p><p>还差哪些工作没完成呢？还记得我们在第六节课设计的 MiniCPU 架构图吗？回想一下，我们已经设计完成的五级流水线，都包含下图的哪些模块？</p><figure><img src="'+l+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>上图的 CPU 核心模块，也就是 CPU Core 包含的模块的设计，这些我们已经在前面几节课里完成了。除了五级流水线的模块，我们还设计了用于保存操作数和运算结果的通用寄存器组，设计了解决数据冒险问题的 <mark>forwarding 模块</mark>，以及解决控制冒险问题的 <mark>hazard 模块</mark>。</p><p>接下来，我们还需要搞定一些外围组件，也就是图里虚线框外的系统总线、<mark>ROM</mark>、<mark>RAM</mark>、<mark>输入输出端口 GPIO</mark>（GPIO 比较简单，课程里没专门讲）和 <mark>UART 模块</mark>。</p>',7),_={href:"https://gitee.com/lmos/Geek-time-computer-foundation",target:"_blank",rel:"noopener noreferrer"},g=a(`<h2 id="系统总线设计" tabindex="-1"><a class="header-anchor" href="#系统总线设计" aria-hidden="true">#</a> 系统总线设计</h2><p>首先，让我们看看 CPU 的系统总线。</p><p>总线是连接多个部件的信息传输线，它是各部件共享的传输介质。在某一时刻，只允许有一个部件向总线发送信息，而多个部件可以同时从总线上接收相同的信息。MiniCPU 的系统总线用来连接 CPU 内核与外设，完成信息传输的功能。</p><p>系统总线在整个 MiniCPU 中是一个很关键的模块。你可以这样理解，总线就是 CPU 内核跟其他外设部件的“<code>联络员</code>”。举几个例子，总线可以从 ROM 中读取指令，再交给 CPU 去执行；CPU 运行程序时的变量，也会交由总线保存到 RAM 中；用来实现芯片与外部通信的 UART 模块，也需要通过总线跟 CPU 进行信息交换……</p><p>那总线的代码具体要怎么设计呢？我先展示一下写好的整体代码，再带你具体分析。</p><div class="language-verilog line-numbers-mode" data-ext="verilog"><pre class="language-verilog"><code><span class="token keyword">module</span> sys_bus <span class="token punctuation">(</span>
    <span class="token comment">// cpu -&gt; imem</span>
    <span class="token keyword">input</span>  <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> cpu_imem_addr<span class="token punctuation">,</span>
    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> cpu_imem_data<span class="token punctuation">,</span>
    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> imem_addr<span class="token punctuation">,</span>              
    <span class="token keyword">input</span>  <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> imem_data<span class="token punctuation">,</span> 
  
    <span class="token comment">// cpu -&gt; bus</span>
    <span class="token keyword">input</span>  <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> cpu_dmem_addr<span class="token punctuation">,</span>        
    <span class="token keyword">input</span>  <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> cpu_dmem_data_in<span class="token punctuation">,</span>     
    <span class="token keyword">input</span>         cpu_dmem_wen<span class="token punctuation">,</span>        
    <span class="token keyword">output</span> <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> cpu_dmem_data_out<span class="token punctuation">,</span>
  
    <span class="token comment">// bus -&gt; ram </span>
    <span class="token keyword">input</span>  <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> dmem_read_data<span class="token punctuation">,</span>     
    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> dmem_write_data<span class="token punctuation">,</span>    
    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> dmem_addr<span class="token punctuation">,</span>           
    <span class="token keyword">output</span> <span class="token keyword">reg</span>    dmem_wen<span class="token punctuation">,</span>
  
    <span class="token comment">// bus -&gt; rom </span>
    <span class="token keyword">input</span>  <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> dmem_rom_read_data<span class="token punctuation">,</span>
    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> dmem_rom_addr<span class="token punctuation">,</span> 
  
    <span class="token comment">// bus -&gt; uart</span>
    <span class="token keyword">input</span>  <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> uart_read_data<span class="token punctuation">,</span>   
    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> uart_write_data<span class="token punctuation">,</span>   
    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> uart_addr<span class="token punctuation">,</span>         
    <span class="token keyword">output</span> <span class="token keyword">reg</span>    uart_wen
<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">assign</span> imem_addr <span class="token operator">=</span> cpu_imem_addr<span class="token punctuation">;</span>
    <span class="token keyword">assign</span> cpu_imem_data <span class="token operator">=</span> imem_data<span class="token punctuation">;</span>
    <span class="token keyword">assign</span> dmem_addr <span class="token operator">=</span> cpu_dmem_addr<span class="token punctuation">;</span>
    <span class="token keyword">assign</span> dmem_write_data <span class="token operator">=</span> cpu_dmem_data_in<span class="token punctuation">;</span>
    <span class="token keyword">assign</span> dmem_rom_addr <span class="token operator">=</span> cpu_dmem_addr<span class="token punctuation">;</span>
    <span class="token keyword">assign</span> uart_addr <span class="token operator">=</span> cpu_dmem_addr<span class="token punctuation">;</span>
    <span class="token keyword">assign</span> uart_write_data <span class="token operator">=</span> cpu_dmem_data_in<span class="token punctuation">;</span>
    <span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>
        <span class="token keyword">case</span> <span class="token punctuation">(</span>cpu_dmem_addr<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">28</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token number">4&#39;h0</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>                <span class="token comment">//ROM</span>
                cpu_dmem_data_out <span class="token operator">&lt;=</span> dmem_rom_read_data<span class="token punctuation">;</span>
                dmem_wen <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                uart_wen <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">end</span>
            <span class="token number">4&#39;h1</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>               <span class="token comment">// RAM</span>
                dmem_wen <span class="token operator">&lt;=</span> cpu_dmem_wen<span class="token punctuation">;</span>
                cpu_dmem_data_out <span class="token operator">&lt;=</span> dmem_read_data<span class="token punctuation">;</span>
                uart_wen <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">end</span>
            <span class="token number">4&#39;h2</span><span class="token punctuation">:</span> <span class="token keyword">begin</span>               <span class="token comment">// uart io</span>
                uart_wen <span class="token operator">&lt;=</span> cpu_dmem_wen<span class="token punctuation">;</span>
                cpu_dmem_data_out <span class="token operator">&lt;=</span> uart_read_data<span class="token punctuation">;</span>
                dmem_wen <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">end</span>
            <span class="token keyword">default</span><span class="token punctuation">:</span>   <span class="token keyword">begin</span>
                dmem_wen <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                uart_wen <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                cpu_dmem_data_out <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">end</span>
        <span class="token keyword">endcase</span>
    <span class="token keyword">end</span>
<span class="token keyword">endmodule</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们设计的系统总线其实是一个**“一对多”**的结构，也可以说是“一主多从”结构，就是一个 CPU 内核作为主设备（Master），多个外设作为从设备（Slave）。</p><figure><img src="`+u+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>CPU 内核具有系统总线的控制权，它可以通过系统总线，发起对外设的访问，而外设只能响应从 CPU 内核发来的各种总线命令。因此，<em>每个外设都需要有一个固定的地址，作为 CPU 访问特定外设的标识</em>。</p><p>以下就是给从设备分配的地址空间：</p><blockquote><p>// 设备地址空间</p><p>// 0x0000_0000 -ROM (word to byte )</p><p>// 0x1000_0000 -RAM (word to byte )</p><p>// 0x2000_0000 -uart (word to byte )</p><p>// 0x3000_0000 -other(word to byte )</p></blockquote><p>从代码的第 39～60 行也可以看到，总线根据地址的<strong>高 4 bit 的值</strong>，就可以判断出 CPU 访问的是哪个从设备。</p><ul><li>当（cpu_dmem_addr[31:28] = 4’h0 ）时，CPU 访问的是 <code>ROM</code>，<br> 把从 ROM 返回的数据赋给总线；</li><li>当（cpu_dmem_addr[31:28] = 4’h1 ）时，CPU 访问的是 <code>RAM</code>，<br> 把 CPU 的写使能 cpu_dmem_wen 赋给 RAM 的写使能信号 dmem_wen，<br> 同时把从 RAM 返回的数据赋给总线；</li><li>当（cpu_dmem_addr[31:28] = 4’h2 ）时，CPU 访问的是串行通信模块 <code>UART</code>，<br> 把 CPU 的写使能 cpu_dmem_wen 赋给 uart 的写使能信号 uart_wen，<br> 同时把从 UART 返回的数据赋给总线。</li></ul><p>这就是 MiniCPU 总线的工作过程。</p><h2 id="只读存储器-rom-的实现" tabindex="-1"><a class="header-anchor" href="#只读存储器-rom-的实现" aria-hidden="true">#</a> 只读存储器 ROM 的实现</h2><p>接下来，我们看看连接在总线上的存储器要如何实现。</p><p>ROM 是个缩写，它表示只读存储器（Read Only Memory）。ROM 具有非易失性的特点。什么是非易失性呢？说白了就是在系统断电的情况下，仍然可以保存数据。</p><p>正是因为这一特点，ROM 很适合用来存放计算机的程序。由于历史原因，虽然现在使用的 ROM 中，有些类型不仅是可以读，还可以写，但我们还是习惯性地把它们称作只读存储器。比如，现在电子系统中常用的 EEPROM、NOR flash 、Nand flash 等，都可以归类为 ROM。</p><p>在我们的 MiniCPU 中，目前没有真正使用上述的 ROM 作为指令存储器。让我们看看 MiniCPU 中实现 ROM 功能的代码，再相应分析我们的设计思路。</p><div class="language-verilog line-numbers-mode" data-ext="verilog"><pre class="language-verilog"><code><span class="token keyword">module</span> imem <span class="token punctuation">(</span>
    <span class="token keyword">input</span>  <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> addr1<span class="token punctuation">,</span>
    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> imem_o1<span class="token punctuation">,</span>
    <span class="token keyword">input</span>  <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> addr2<span class="token punctuation">,</span>
    <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> imem_o2
<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> imem_reg<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">4096</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">assign</span> imem_o1 <span class="token operator">=</span> imem_reg<span class="token punctuation">[</span>addr1<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">assign</span> imem_o2 <span class="token operator">=</span> imem_reg<span class="token punctuation">[</span>addr2<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">endmodule</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了方便学习和仿真，我们使用了寄存器（reg）临时定义了一个指令存储器 imem，并在仿真的顶层（tb_top.v）使用了 $readmemh（）函数，把编译好的二进制指令读入到 imem 中，以便 CPU 内部读取并执行这些指令。这里我们设置的存储器在功能上是只读的。</p><p>以下就是仿真的顶层（tb_top.v）调用 $readmemh（）函数的语句。</p><div class="language-verilog line-numbers-mode" data-ext="verilog"><pre class="language-verilog"><code><span class="token kernel-function property">$readmemh</span><span class="token punctuation">(</span><span class="token constant">\`HEXFILE</span><span class="token punctuation">,</span> MiniCPU<span class="token punctuation">.</span>u_imem<span class="token punctuation">.</span>imem_reg<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>函数里面有两个参数，一个是存放二进制指令的文件（HEXFILE），另一个就是实现 ROM 功能的寄存器（imem_reg）。这条语句可以在我们启动 CPU 仿真时，把二进制的指令一次性读入到 imem 中，这样 CPU 运行的过程中就可以取 imem 中的指令去执行了。</p><h2 id="随机访问存储器-ram" tabindex="-1"><a class="header-anchor" href="#随机访问存储器-ram" aria-hidden="true">#</a> 随机访问存储器 RAM</h2><p>除了存放指令的 ROM，我们还需要一个存放变量和数据的 RAM（Random Access Memory）。</p><p>RAM 和特点跟 ROM 正好相反，它是易失性存储器，通常都是在掉电之后就会丢失数据。但是它具有读写速度快的优势，所以通常用作 CPU 的高速缓存。</p><p>RAM 之所以叫做随机访问存储器，是因为不同的地址可以在相同的时间内随机读写。这是由 RAM 的结构决定的，RAM 使用存储阵列来存储数据，只要给出行地址和列地址，就能确定目标数据，而且这一过程和目标数据所处的物理位置无关。</p><p>和 ROM 一样，为了方便对设计的 MiniCPU 进行仿真验证，我们还是用寄存器（reg）临时构建了一个数据存储器 dmem，作为 MiniCPU 中的 RAM 使用。虽然临时构建的存储器和实际的 ROM 有点差别，但我们还在初期学习阶段，这已经足够了。</p><p>下面就是实现 RAM 功能的数据存储器 dmem 的代码：</p><div class="language-verilog line-numbers-mode" data-ext="verilog"><pre class="language-verilog"><code><span class="token keyword">module</span> <span class="token function">dmem</span><span class="token punctuation">(</span>
    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> addr<span class="token punctuation">,</span>
    <span class="token keyword">input</span> we<span class="token punctuation">,</span>
    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> din<span class="token punctuation">,</span>
    <span class="token keyword">input</span> clk<span class="token punctuation">,</span>
    <span class="token keyword">output</span> <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> dout
<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> dmem_reg<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">4095</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    
    <span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span> <span class="token keyword">begin</span>
        <span class="token function">if</span><span class="token punctuation">(</span>we<span class="token punctuation">)</span> <span class="token keyword">begin</span>
            dmem_reg<span class="token punctuation">[</span>addr<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> din<span class="token punctuation">;</span>
        <span class="token keyword">end</span>
            dout <span class="token operator">&lt;=</span> dmem_reg<span class="token punctuation">[</span>addr<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">end</span>
<span class="token keyword">endmodule</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码的第 11~16 行可以看到，我们使用了时钟信号 clk，说明这里的 dmem 实现的是一个时钟同步 RAM。而且当写使能信号（we）为“1”时，才能往 RAM 里写数据，否则只能读取数据。</p><h2 id="外设-uart-设计" tabindex="-1"><a class="header-anchor" href="#外设-uart-设计" aria-hidden="true">#</a> 外设 UART 设计</h2><p>为了让 MiniCPU 能和其他电子设备进行通信，我们还要设计 UART 模块。</p><p>同样地，设计代码之前我先带你快速了解一下 UART 是什么，它的工作原理是怎样的。</p><p>UART 的全称叫通用异步收发传输器（Universal Asynchronous Receiver/Transmitter），它是一种串行、异步、全双工的通信协议，是电子设备间进行异步通信的常用模块。</p><p>UART 负责对系统总线的并行数据和串行口上的串行数据进行转换，通信双方采用相同的波特率。在不使用时钟信号线的情况下，仅用一根数据发送信号线和一根数据接收信号线（Rx 和 Tx）就可以完成两个设备间的通信，因此我们也把 UART 称为异步串行通信。</p><p>串行通信是指，利用一条传输线将数据按顺序一位位传送的过程。UART 的发送模块会把来自 CPU 总线的并行数据转换为串行数据，再以串行方式将其发送到另一个设备的 UART 接收端。然后由 UART 的接收模块把串行数据转换为并行数据，以便接收设备存储和使用这些数据。</p><p>UART 的数据传输格式如下图所示：</p><figure><img src="`+d+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>从图里我们可以看到，UART 传输数据包括起始位、数据位、奇偶校验位、停止位和空闲位。UART 数据传输线通常在不传输数据时保持在高电平。</p><p>这么多名词是不是有点应接不暇？我挨个解释一下，你就清楚了。</p><ol><li><strong>起始位</strong>是在数据线上先发出一个逻辑低电平“0”信号，表示数据传输的开始。</li><li><strong>数据位</strong>是由 5~8 位逻辑高低电平表示的“1”或“0”信号。</li><li><strong>校验位</strong>在传输的数据位的后面加 1bit，表示“1”的位数应为偶数（偶校验）或奇数（奇校验）。</li><li><strong>停止位</strong>是一个数据位宽的 1 倍、1.5 倍、或者 2 倍的高电平信号，它是一次数据传输的结束标志。</li><li><strong>空闲位</strong>是数据传输线处于逻辑高电平状态，表示当前线路上处于空闲状态，没有数据传送。</li></ol>',43),x=s("mark",null,"发送模块",-1),w=s("mark",null,"接收模块",-1),y={href:"https://gitee.com/lmos/Geek-time-computer-foundation/tree/master/lesson06~11/mini_cpu",target:"_blank",rel:"noopener noreferrer"},h=a(`<p>这里只放出来发送模块的端口信号，如下所示：</p><div class="language-verilog line-numbers-mode" data-ext="verilog"><pre class="language-verilog"><code><span class="token keyword">module</span> <span class="token function">uart_tx</span><span class="token punctuation">(</span>
<span class="token keyword">input</span>           clk         <span class="token punctuation">,</span> <span class="token comment">// Top level system clock input.</span>
<span class="token keyword">input</span>           resetn      <span class="token punctuation">,</span> <span class="token comment">// Asynchronous active low reset.</span>
<span class="token keyword">output</span>          uart_txd    <span class="token punctuation">,</span> <span class="token comment">// UART transmit pin.</span>
<span class="token keyword">output</span>          uart_tx_busy<span class="token punctuation">,</span> <span class="token comment">// Module busy sending previous item.</span>
<span class="token keyword">input</span>           uart_tx_en  <span class="token punctuation">,</span> <span class="token comment">// Send the data on uart_tx_data</span>
<span class="token keyword">input</span>   <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>   uart_tx_data  <span class="token comment">// The data to be sent</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>UART 接收模块的端口信号如下：</p><div class="language-verilog line-numbers-mode" data-ext="verilog"><pre class="language-verilog"><code><span class="token keyword">module</span> <span class="token function">uart_rx</span><span class="token punctuation">(</span>
<span class="token keyword">input</span>         clk          <span class="token punctuation">,</span> <span class="token comment">// Top level system clock input.</span>
<span class="token keyword">input</span>         resetn       <span class="token punctuation">,</span> <span class="token comment">// Asynchronous active low reset.</span>
<span class="token keyword">input</span>         uart_rxd     <span class="token punctuation">,</span> <span class="token comment">// UART Recieve pin.</span>
<span class="token keyword">input</span>         uart_rx_en   <span class="token punctuation">,</span> <span class="token comment">// Recieve enable</span>
<span class="token keyword">output</span>        uart_rx_break<span class="token punctuation">,</span> <span class="token comment">// Did we get a BREAK message?</span>
<span class="token keyword">output</span>        uart_rx_valid<span class="token punctuation">,</span> <span class="token comment">// Valid data recieved and available.</span>
<span class="token keyword">output</span> <span class="token keyword">reg</span>  <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> uart_rx_data   <span class="token comment">// The recieved data.</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>端口信号的代码你结合上面的注释很容易就能理解，后面 CPU 跑程序的时候就会用到这部分的功能。</p><h2 id="在-cpu-上跑个-hello-world" tabindex="-1"><a class="header-anchor" href="#在-cpu-上跑个-hello-world" aria-hidden="true">#</a> 在 CPU 上跑个 Hello World</h2><p>好，现在来到我们的最后一个环节，编写程序，并把它放到我们的 MiniCPU 上跑起来。</p><p>为了能更直观看到 CPU 的运行效果，这里我们使用 RISC-V 汇编指令，设计了一段用 UART 发送“Hello MiniCPU!”字符串的代码，然后让串口接收端把发送的字符串在电脑上打印出来。</p><p>具体的代码如下：</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>#    Assembly                Description
main:   
        li      x2, 0x20000000          # uart address
        li      x6,  0x1500             #x6 &lt;== 0x1500, delay 1ms
        addi    x7, x0, 0               #x7 &lt;== 0
        addi    x5, x0, 0x48            #x5 &lt;== &quot;H&quot;
        sw      x5, 0(x2)  
delay1: addi    x7, x7, 1               #x7 &lt;== x7 + 1
        bne     x7, x6, delay1          #x6 != x7 
        addi    x7, x0, 0               #x7 &lt;== 0
        addi    x5, x0, 0x65            #x5 &lt;== &quot;e&quot;
        sw      x5, 0(x2)  
delay2: addi    x7, x7, 1               #x7 &lt;== x7 + 1
        bne     x7, x6, delay2           #x6 != x7
        addi    x7, x0, 0               #x7 &lt;== 0
        addi    x5, x0, 0x6c            #x5 &lt;== &quot;l&quot;
        sw      x5, 0(x2) 
delay3: addi    x7, x7, 1               #x7 &lt;== x7 + 1
        bne     x7, x6, delay3           #x6 != x7
        addi    x7, x0, 0               #x7 &lt;== 0
        addi    x5, x0, 0x6c            #x5 &lt;== &quot;l&quot;
        sw      x5, 0(x2)  
  …………  //由于代码较长，结构相似，这里省略了一部分，完整代码你可以从Gitee上获取
delay13: addi    x7, x7, 1               #x7 &lt;== x7 + 1
        bne     x7, x6, delay13           #x6 != x7
        addi    x7, x0, 0               #x7 &lt;== 0
        addi    x5, x0, 0x21            #x5 &lt;== &quot;!&quot;
        sw      x5, 0(x2) 
end:    j       end
        ret
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有了代码，我们还需要把它编译成能在 CPU 上运行的机器码，才能把它放在 CPU 上跑。</p><p>下面的代码就是放在课程代码中的 Makefile，作用是编译汇编代码，还有定义好 CPU 仿真需要用到的一些命名规则。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>SOURCE_TB :<span class="token operator">=</span> ./tb/tb_top.v
TMP_DIR :<span class="token operator">=</span> ./tmp
SOURCE :<span class="token operator">=</span> ./rtl.f
TARGET :<span class="token operator">=</span> <span class="token variable">\${TMP_DIR}</span>/tb_top.o
TEST_HEX :<span class="token operator">=</span> ./sim/asm/build/test.dat
<span class="token comment"># 编译汇编程序，输出二进制指令</span>
asm:
  <span class="token function">make</span> <span class="token parameter variable">-C</span> ./sim/asm 
  python ./sim/asm/word2byte.py
<span class="token comment"># 对CPU进行仿真</span>
cpu:
  <span class="token function">rm</span> <span class="token parameter variable">-f</span> <span class="token variable">\${TMP_DIR}</span>/*
  <span class="token function">cp</span> <span class="token variable">\${SOURCE_TB}</span> <span class="token variable">\${TMP_DIR}</span>
  <span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">&#39;s#.hex#\${TEST_HEX}#&#39;</span> <span class="token variable">\${TMP_DIR}</span>/tb_top.v
  iverilog <span class="token parameter variable">-f</span> <span class="token variable">\${SOURCE}</span> <span class="token parameter variable">-o</span> <span class="token variable">\${TARGET}</span>
  vvp <span class="token variable">\${TARGET}</span>
<span class="token comment"># 查看波形</span>
wave:
  gtkwave <span class="token variable">\${TMP_DIR}</span>/tb_top.vcd <span class="token operator">&amp;</span>
<span class="token comment"># 清除临时文件</span>
clean:
  <span class="token function">make</span> <span class="token parameter variable">-C</span> ./sim/asm clean
  <span class="token function">rm</span> ./tmp/* <span class="token parameter variable">-rf</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从 Makefile 的代码中可以看到，我们一共定义了 4 个目标命令，它们的作用分别是完成汇编程序编译的（asm）命令、执行 MiniCPU 仿真的（cpu）命令、用软件 GTKwave 打开仿真后的波形（wave）命令，以及清除仿真过程中产生的临时文件的（clean）命令。</p><p>通过在终端上执行“make asm”命令，便可以把上面设计的汇编程序编译成二进制指令 test.dat。然后我们再输入“make cpu”命令就启动 MiniCPU 的仿真了，运行结果如下图所示：</p><figure><img src="`+r+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>到此，我们的 MiniCPU 就设计完成啦！祝贺你一路进行到这里。看到页面上输出 Hello MiniCPU 的时候，是不是感觉还挺好玩的？</p><p>如果你觉得意犹未尽，还可以在项目文件夹里的“./mini_cpu/sim/asm/src/miniCPU_sim.asm”这个文件中编写你自己的 RISC-V 汇编程序，然后就可以在我们的 MiniCPU 上玩出更多花样了。</p><h2 id="重点回顾" tabindex="-1"><a class="header-anchor" href="#重点回顾" aria-hidden="true">#</a> 重点回顾</h2><p>这节课，我们把 MiniCPU 的几个外部模块设计完成，这几个模块是让 CPU“跑起来”的必要组件。</p><figure><img src="'+m+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>我们首先设计了 MiniCPU 的系统总线。有了它，就能连接 CPU 内核与外设，完成信息传输的功能，相当于 CPU 内核与外部设备的一座桥梁。</p><p>接下来的模块就是 ROM 和 RAM。ROM 是存放 CPU 指令的只读存储器。为了方便学习和仿真，我们通过寄存器临时定义了一个指令存储器，然后在仿真的顶层使用了 $readmemh 函数，把编译好的二进制指令读入到指令存储器中，这样 CPU 运行时就可以读取和执行这些指令了。</p><p>RAM 用来存放数据，它在掉电之后会丢失数据，但是读写速度快，通常用来作为 CPU 的高速缓存。跟 ROM 的实现思路一样，我们还是用寄存器临时构建了一个数据存储器 dmem，作为 MiniCPU 中的 RAM 使用。</p><p>为了让 MiniCPU 能和其他设备通信，我们还设计了异步串行通信模块 UART，它用一根数据发送信号线和一根数据接收信号线就可以完成两个设备间的通信。</p><p>MiniCPU 设计好了之后，我们进入运行调试环节，用 RISC-V 指令编写了一段用 UART 发送“Hello MiniCPU!”字符串的汇编程序，然后让串口接收端把发送的字符串在电脑上打印出来。如果字符串显示正常，说明我们的 miniCPU 已经可以正常运行了。</p><p>到这里，我们 RISC-V 处理器的实现就全部完成了。这节课要点，你可以参考下面的导图。</p><figure><img src="'+k+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>你有兴趣的话，还可以课后做更多的探索，比如给它添加更多的 RISCV 指令功能，在 CPU 总线上挂载更多的外设……后面的课程里，我会带你学习更多的 RISC-V 指令，敬请期待！</p><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题" aria-hidden="true">#</a> 思考题</h2><p>计算机两大体系结构分别是冯诺依曼体系结构和哈弗体系结构，请问我们的 MiniCPU 属于哪一种体系结构呢？</p><p>期待你在留言区跟我交流互动，说说这个模块学习下来的感受，如果觉得手写 CPU 很酷，别忘了分享给身边更多的朋友。</p>',32),U=s("br",null,null,-1),C=s("br",null,null,-1),R=s("br",null,null,-1),P={href:"https://github.com/CosmosPsi/CosmosDocs",target:"_blank",rel:"noopener noreferrer"},f=s("br",null,null,-1),M=s("br",null,null,-1),A=s("br",null,null,-1),T=a("<p>需要指出一下，如果同学用13讲里的方法安装toolchain的话，需要作以下修改才能跑出hello world来：<br> 1\\在<code>sim/asm/Makefile</code>中，需要把所有的<code>riscv32</code>都替换成<code>riscv64</code>。详情见12讲里面的multilib部分。<br> 2\\如果你和我一样用的是ubuntu 20.04，那么需要<code>mini_cpu/Makefile</code>里面，把<code>python</code>换成<code>python3</code>。因为默认ubuntu20.04开始已经没有<code>python</code>了。<br> 作者回复: 对</p>",1);function O(E,I){const e=i("ExternalLinkIcon");return o(),c("div",null,[b,s("p",null,[n("学完这节课，我们就可以把这个 CPU 运行起来了，最终我还会带你在这个 CPU 上跑一个 RISC-V 版本的 Hello World 程序（"),s("a",_,[n("课程代码从这里下载"),p(e)]),n("），是不是很期待？话不多说，我们这就开始！")]),g,s("p",null,[n("跟数据发送信号线 TX、数据接收信号线 RX 相对应，我们的 UART 也分别设计了"),x,n("（uart_tx）和"),w,n("（uart_rx）。如果你想了解具体的功能实现，"),s("a",y,[n("可以课后查看我们的 MiniCPU 的项目代码"),p(e)]),n("。")]),h,s("blockquote",null,[s("p",null,[n("询问小编一个小问题：学到此处 mini_cpu 小结了，还有后续的扩展吗？后续 “RISC-V 指令精讲（X）” 系列是在 GCC + QEMU 环境实现吗？会和 min_cpu 有关联吗？谢谢！"),U,n(" 编辑回复:"),C,n(" 1.mini CPU的讲解告一段落了，目前专栏里没计划后续扩展，有什么想法建议可以说说，这样LMOS也能看到。"),R,n(" 后面可以看看大伙儿实际学习情况，也欢迎自荐和LMOS团队的在开源Cosmos Psi里折腾更多东西。项目链接（初始阶段，未来可期） "),s("a",P,[n("https://github.com/CosmosPsi/CosmosDocs"),p(e)]),n(" ，感觉不错记得star支持下！"),f,n(" 2.环境搭建下周一、三发布，一共两节课讲解交叉编译环境配置，除了你说GCC，应该还用到了Deepin。"),M,n(" 3.课程设计的时候，考虑到同学们水平参差不齐，为了尽量让大家跟上老师步伐，有所收获。后面的课程跟min_cpu 没有直接的“依赖”性。意思就是，前面手写CPU你觉得比较难，暂时还达不到手写出CPU的程度，也并不影响学习后续内容。"),A,n(" 题外话：当然啦，你硬件和语言都掌握了，那更好。前期做用户调研的时候，有个同学提到一个思路：如果把执可执行程序反汇编，然后通过CPU方针或其他手段执行者可执行程序，我们看看CPU的指令流是啥样，就能帮你把CPU和汇编串联起来了。")]),T])])}const q=t(v,[["render",O],["__file","F11-手写CPU（六）.html.vue"]]);export{q as default};
