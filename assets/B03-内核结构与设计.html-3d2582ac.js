import{_ as p}from"./plugin-vue_export-helper-c27b6911.js";import{o as r,c as a,d as e}from"./app-cdabc73c.js";const o="/assets/28cc064d767d792071a789a5b4e7d714-a74e388e.jpg",d="/assets/eb8e9487475f960dccda0fd939999b6b-97229afb.jpg",i="/assets/4b190d617206379ee6cd77fcea231c64-402adf15.jpg",n="/assets/6cf68bebe4f114f00f848d1d5679d33c-71c62963.jpg",t={},s=e('<h1 id="_03-黑盒之中有什么-内核结构与设计" tabindex="-1"><a class="header-anchor" href="#_03-黑盒之中有什么-内核结构与设计" aria-hidden="true">#</a> 03 | 黑盒之中有什么：内核结构与设计</h1><p>你好，我是 LMOS。</p><p>在上节课中，我们写了一个极简的操作系统——Hello OS，并成功运行，直观地感受了一下自己控制计算机的乐趣，或许你正沉浸在这种乐趣之中，但我不得不提醒你赶快从这种快乐中走出来。</p><p>因为我们的 Hello OS 虽然能使计算机运行起来，但其实没有任何实际的功能。</p><p>什么？没有实际功能，我们往里增加功能不就好了吗？</p><p>你可能会这样想，但是这样想就草率了，开发操作系统内核（以下简称内核）就像建房子一样，房子要建得好，就先要设计。比如用什么结构，什么材料，房间怎么布局，电路、水路等，最后画出设计图纸，依据图纸按部就班地进行建造。</p><p>而一个内核的复杂程度要比房子的复杂程度高出几个数量级，所以在开发内核之前先要对其进行设计。</p><p>下面我们就先搞清楚内核之中有些什么东西，然后探讨一下怎么组织它们、用什么架构来组织、并对比成熟的架构，最后设计出我们想要的内核架构。</p><h2 id="黑盒之中有什么" tabindex="-1"><a class="header-anchor" href="#黑盒之中有什么" aria-hidden="true">#</a> 黑盒之中有什么</h2><p>从用户和应用程序的角度来看，内核之中有什么并不重要，能提供什么服务才是重要的，所以内核在用户和上层应用眼里，就像一个大黑盒，至于黑盒里面有什么，怎么实现的，就不用管了。</p><p>不过，作为内核这个黑盒的开发者，我们要实现它，就必先设计它，而要设计它，就必先搞清楚内核中有什么。</p><p>从抽象角度来看，内核就是计算机资源的管理者，当然管理资源是为了让应用使用资源。既然内核是资源的管理者，我们先来看看计算机中有哪些资源，然后通过资源的归纳，就能推导出内核这个大黑盒中应该有什么。</p><p>计算机中资源大致可以分为两类资源，一种是<strong>硬件资源</strong>，一种是<strong>软件资源</strong>。先来看看硬件资源有哪些，如下：</p><h3 id="硬件资源" tabindex="-1"><a class="header-anchor" href="#硬件资源" aria-hidden="true">#</a> 硬件资源</h3><ol><li><p><strong>总线</strong>，负责连接各种其它设备，是其它设备工作的基础。</p></li><li><p><strong>CPU</strong>，即中央处理器，负责执行程序和处理数据运算。</p></li><li><p><strong>内存</strong>，负责储存运行时的代码和数据。</p></li><li><p><strong>硬盘</strong>，负责长久储存用户文件数据。</p></li><li><p><strong>网卡</strong>，负责计算机与计算机之间的通信。</p></li><li><p><strong>显卡</strong>，负责显示工作。</p></li><li><p><strong>各种 I/O 设备</strong>，如显示器，打印机，键盘，鼠标等。</p></li></ol><p>下面给出一幅经典的计算机内部结构图，如下：</p><img src="'+o+'" alt="img" style="zoom:15%;"><p>经典计算机结构图</p><p>而计算机中的软件资源，则可表示为计算机中的各种形式的数据。如各种文件、软件程序等。</p><p>内核作为硬件资源和软件资源的管理者，其内部组成在逻辑上大致如下：</p><p>1.**管理 CPU，**由于 CPU 是执行程序的，而内核把运行时的程序抽象成进程，所以又称为<mark>进程管理</mark>。</p><p>2.<strong>管理内存</strong>，由于程序和数据都要占用内存，内存是非常宝贵的资源，所以内核要非常小心地分配、释放内存。<mark>内存管理</mark></p><p>3.<strong>管理硬盘</strong>，而硬盘主要存放用户数据，而内核把用户数据<code>抽象成</code>文件，即管理文件，<code>文件需要合理地组织，方便用户查找和读写</code>，所以形成了<mark>文件系统</mark>。</p><p>4.<strong>管理显卡</strong>，负责显示信息，而现在操作系统都是支持 <code>GUI（图形用户接口）</code>的，<code>管理显卡</code>自然而然地就成了内核中的<mark>图形系统</mark>。</p><p>5.<strong>管理网卡</strong>，网卡主要完成网络通信，网络通信需要各种通信协议，最后在内核中就形成了<mark>网络协议栈</mark>，又称<mark>网络组件</mark>。</p><p>6.<strong>管理各种 I/O 设备</strong>，我们经常把键盘、鼠标、打印机、显示器等统称为 I/O（输入输出）设备，在内核中抽象成 <mark>I/O 管理器</mark>。</p><ul><li><p>内核除了这些必要组件之外，根据功能不同还有安全组件等，</p></li><li><p>最值得一提的是，各种计算机硬件的性能不同，硬件型号不同，硬件种类不同，硬件厂商不同，</p><p>内核要想管理和控制这些硬件就要编写对应的代码，通常这样的代码我们称之为<strong>驱动程序</strong>。</p></li><li><p>硬件厂商就可以根据自己不同的硬件<code>编写不同的驱动</code>，加入到内核之中。</p></li></ul><p>以上我们已经大致知道了内核之中有哪些组件，但是另一个问题又出现了，即如何组织这些组件，让系统更加稳定和高效，这就需要我们从现有的一些<strong>经典内核结构</strong>里找灵感了。</p><h2 id="宏内核结构" tabindex="-1"><a class="header-anchor" href="#宏内核结构" aria-hidden="true">#</a> 宏内核结构</h2><p>其实看这名字，就已经能猜到了，宏即大也，这种最简单适用，也是最早的一种内核结构。</p><p>宏内核就是把以上诸如管理进程的代码、管理内存的代码、管理各种 I/O 设备的代码、文件系统的代码、图形系统代码以及其它功能模块的代码，把这些所有的代码经过编译，最后链接在一起，形成一个大的可执行程序。</p><p>这个大程序里有实现支持这些功能的所有代码，向用户应用软件提供一些接口，这些接口就是常说的<code>系统 API 函数</code>。而这个大程序会在处理器的<mark>特权模式</mark>下运行，这个模式通常被称为<mark>宏内核模式</mark>。结构如下图所示。</p><img src="'+d+'" alt="img" style="zoom:15%;"><p>宏内核结构图</p><p>尽管图中一层一层的，这并不是它们有层次关系，仅仅表示它们链接在一起。</p><h3 id="用户态-内核态" tabindex="-1"><a class="header-anchor" href="#用户态-内核态" aria-hidden="true">#</a> 用户态/内核态</h3><p>为了理解宏内核的工作原理，我们来看一个例子，宏内核提供内存分配功能的服务过程，具体如下：</p><p>\\1. 应用程序调用内存分配的 API（应用程序接口）函数。</p><p>\\2. 处理器切换到特权模式，开始运行内核代码。</p><p>\\3. 内核里的内存管理代码按照特定的算法，分配一块内存。</p><p>\\4. 把分配的内存块的首地址，返回给内存分配的 API 函数。</p><p>\\5. 内存分配的 API 函数返回，处理器开始运行用户模式下的应用程序，应用程序就得到了一块内存的首地址，并且可以使用这块内存了。</p><p>上面这个过程和一个实际的操作系统中的运行过程，可能有差异，但大同小异。当然，系统 API 和应用程序之间可能还有<code>库函数</code>，也可能只是分配了一个虚拟地址空间，但是我们关注的只是这个过程。</p><h3 id="优缺点利弊" tabindex="-1"><a class="header-anchor" href="#优缺点利弊" aria-hidden="true">#</a> 优缺点利弊</h3><p>上图的宏内核结构有明显的缺点，<strong>因为它没有模块化，没有扩展性、没有移植性，高度耦合在一起，一旦其中一个组件有漏洞，内核中所有的组件可能都会出问题</strong>。</p><p>开发一个新的功能也得重新编译、链接、安装内核。其实现在这种原始的宏内核结构已经没有人用了。这种宏内核唯一的优点是<strong>性能很好，因为在内核中，这些组件可以互相调用，性能极高</strong>。</p><p>为了方便我们了解不同内核架构间的优缺点，下面我们看一个和宏内核结构对应的反例。</p><h2 id="微内核结构" tabindex="-1"><a class="header-anchor" href="#微内核结构" aria-hidden="true">#</a> 微内核结构</h2><blockquote><p>宏内核强调组织间的相互关联性，感觉像是一种命令由上到下的一个传递过程。微内核强调的是独立，相互调用性，感觉就像部门与部门之间的合作关系。</p></blockquote><p>微内核架构正好与宏内核架构相反，它提倡<mark>内核功能</mark>尽可能少：仅仅只有<code>进程调度、处理中断、内存空间映射、进程间通信等</code>功能（目前不懂没事，这是属于管理进程和管理内存的功能模块，后面课程里还会专门探讨的）。</p><h3 id="用户态服务进程承担内核职能" tabindex="-1"><a class="header-anchor" href="#用户态服务进程承担内核职能" aria-hidden="true">#</a> 用户态服务进程承担内核职能</h3><p>这样的内核是不能完成什么实际功能的，开发者们把实际的<code>进程管理、内存管理、设备管理、文件管理等</code>服务功能，做成一个个<mark>服务进程</mark>。和<mark>用户应用进程</mark>一样，只是它们很特殊，宏内核提供的功能，在微内核架构里由这些服务进程专门负责完成。</p><h3 id="提供消息机制作为进程间通信" tabindex="-1"><a class="header-anchor" href="#提供消息机制作为进程间通信" aria-hidden="true">#</a> 提供消息机制作为进程间通信</h3><p>微内核定义了一种良好的进程间通信的机制——<strong><mark>消息</mark></strong>。应用程序要请求相关服务，就向微内核发送一条<strong>与此服务对应的消息</strong>，微内核再把这条消息<strong>转发给相关的服务进程</strong>，接着服务进程会<strong>完成相关的服务</strong>。服务进程的编程模型就是<strong>循环处理来自其它进程的消息</strong>，完成相关的服务功能。其结构如下所示：</p><img src="'+i+'" alt="img" style="zoom:15%;"><h3 id="工作模式" tabindex="-1"><a class="header-anchor" href="#工作模式" aria-hidden="true">#</a> 工作模式</h3><p>为了理解微内核的工程原理，我们来看看微内核提供内存分配功能的服务过程，具体如下：</p><p>\\1. 应用程序发送内存分配的消息，这个发送消息的函数是微内核提供的，相当于<mark>系统 API</mark>，微内核的 API（应用程序接口）相当少，极端情况下仅需要两个，一个接收消息的 API 和一个发送消息的 API。</p><p>\\2. 处理器切换到<mark>特权模式</mark>，开始运行<mark>内核代码</mark>。</p><p>\\3. 微内核代码让当前进程停止运行，并根据消息包中的数据，确定消息发送给谁，分配内存的消息当然是发送给<mark>内存管理服务进程</mark>。</p><p>\\4. 内存管理服务进程收到消息，分配一块内存。</p><p>\\5. 内存管理服务进程，<strong>也会通过消息的形式</strong>返回分配内存块的地址给内核，然后继续等待下一条消息。</p><p>\\6. 微内核把包含内存块地址的消息返回给<strong>发送内存分配消息的应用程序</strong>。</p><p>\\7. 处理器开始运行<mark>用户模式</mark>下的<mark>应用程序</mark>，应用程序就得到了一块内存的首地址，并且可以使用这块内存了。</p><h3 id="优缺点利弊-1" tabindex="-1"><a class="header-anchor" href="#优缺点利弊-1" aria-hidden="true">#</a> 优缺点利弊</h3><p>微内核的架构实现虽然不同，但是大致过程和上面一样。同样是分配内存，在微内核下拐了几个弯，一来一去的消息带来了非常大的开销，当然各个服务进程的切换开销也不小。<code>这样系统性能就大打折扣</code>。</p><blockquote><p>服务进程工作在用户态吗？如果是，那么就会有多次切换了？<br> 作者回复: 是的，你说的非常正确。来回都要涉及内核。</p></blockquote><p>但是微内核有很多优点，首先，<code>系统结构相当清晰利于协作开发</code>。其次，<code>系统有良好的移植性</code>，微内核代码量非常少，就算重写整个内核也不是难事。最后，<code>微内核有相当好的伸缩性、扩展性</code>，因为那些系统功能只是一个进程，可以随时拿掉一个服务进程以减少系统功能，或者增加几个服务进程以增强系统功能。</p><p>微内核的代表作有 MACH、MINIX、L4 系统，这些系统都是微内核，但是它们不是商业级的系统，<strong>商业级的系统不采用微内核主要还是因为性能差</strong>。</p><p>好了，粗略了解了宏内核和微内核两大系统内核架构的优、缺点，以后设计我们自己的系统内核时，心里也就有了底了，到时就可以扬长避短了，下面我们先学习一点其它的东西，即分离硬件相关性，为设计出我们自己的内核架构打下基础。</p><h2 id="分离硬件的相关性" tabindex="-1"><a class="header-anchor" href="#分离硬件的相关性" aria-hidden="true">#</a> 分离硬件的相关性</h2><p>我们会经常听说，Windows 内核有什么 HAL 层、Linux 内核有什么 arch 层。这些 xx 层就是 Windows 和 Linux 内核设计者，给他们的系统内核分的第一个层。</p><p>今天如此庞杂的计算机，其实也是一层一层地构建起来的，从硬件层到操作系统层再到应用软件层这样构建。分层的主要目的和好处在于<strong>屏蔽底层细节，使上层开发更加简单。</strong></p><p>计算机领域的一个基本方法是增加一个抽象层，从而使得抽象层的上下两层独立地发展，所以在内核内部再分若干层也不足为怪。</p><p>分离硬件的相关性，就是要把操作硬件和处理硬件功能差异的代码抽离出来，形成一个独立的**<mark>软件抽象层</mark>**，对外提供相应的接口，方便上层开发。</p><h3 id="例如进程调度" tabindex="-1"><a class="header-anchor" href="#例如进程调度" aria-hidden="true">#</a> 例如进程调度</h3><p>为了让你更好理解，我们举进程管理中的一个模块实现细节的例子：<mark>进程调度模块</mark>。通过这个例子，来看看分层对系统内核的设计与开发有什么影响。</p><p>一般操作系统理论课程都会花大量篇幅去讲进程相关的概念，其实说到底，进程是操作系统开发者为了实现多任务而提出的，并让每个进程在 CPU 上运行一小段时间，这样就能实现多任务同时运行的假象。</p><p>当然，这种假象十分奏效。要实现这种假象，就要实现下面这两种机制：</p><ol><li><p><strong>进程调度</strong>，它的目的是要从众多进程中<code>选择一个将要运行的进程</code>，当然有各种选择的算法，例如，轮转算法、优先级算法等。</p></li><li><p><strong>进程切换</strong>，它的目的是停止当前进程，运行新的进程，主要动作是<code>保存当前进程的机器上下文，装载新进程的机器上下文</code>。</p></li></ol><p>我们不难发现，</p><ul><li>不管是在 <code>ARM 硬件平台</code>上还是在 <code>x86 硬件平台</code>上，选择一个进程的算法和代码是不容易发生改变的，</li><li>需要改变的代码是进程切换的相关代码，因为<code>不同的硬件平台的机器上下文是不同的</code>。</li></ul><p>所以，这时最好是将进程切换的代码放在一个独立的层中实现，比如<mark>硬件平台相关层</mark>，当操作系统要运行在不同的硬件平台上时，<code>就只是需要修改</code>硬件平台相关层中的相关代码，这样操作系统的<strong>移植性</strong>就大大增强了。</p><h3 id="硬件平台相关层" tabindex="-1"><a class="header-anchor" href="#硬件平台相关层" aria-hidden="true">#</a> 硬件平台相关层</h3><p>如果把所有硬件平台相关的代码，都抽离出来，放在一个独立硬件相关层中实现并且定义好相关的调用接口，再在这个层之上开发内核的其它功能代码，就会方便得多，结构也会清晰很多。操作系统的移植性也会大大增强，移植到不同的硬件平台时，就构造开发一个与之对应的硬件相关层。这就是分离硬件相关性的好处。</p><h2 id="我们的选择-接口-功能-硬件-混合架构" tabindex="-1"><a class="header-anchor" href="#我们的选择-接口-功能-硬件-混合架构" aria-hidden="true">#</a> 我们的选择: 接口/功能/硬件 混合架构</h2><p>从前面内容中，我们知道了内核必须要完成的功能，宏内核架构和微内核架构各自的优、缺点，最后还分析了分离硬件相关层的重要性，其实说了这么多，就是为了设计我们自己的操作系统内核。</p><p>虽然前面的内容，对操作系统设计这个领域还远远不够，但是对于我们自己从零开始的操作系统内核这已经够了。</p><p>首先大致将我们的操作系统内核分为三个大层，分别是：</p><p>\\1. 内核接口层。</p><p>\\2. 内核功能层。</p><p>\\3. 内核硬件层。</p><h2 id="内核接口层-unix" tabindex="-1"><a class="header-anchor" href="#内核接口层-unix" aria-hidden="true">#</a> 内核接口层: Unix</h2><p>内核接口层，定义了一系列接口，主要有两点内容，如下：</p><p>\\1. 定义了一套 <code>UNIX 接口</code>的子集，我们出于学习和研究的目的，使用 UNIX 接口的子集，优点之一是接口少，只有几个，并且这几个接口又能大致定义出操作系统的功能。</p><p>\\2. 这套接口的代码，<code>就是检查其参数是否合法</code>，如果参数有问题就返回相关的错误，接着调用下层完成功能的核心代码。</p><h2 id="内核功能层-进程-内存-中断-设备" tabindex="-1"><a class="header-anchor" href="#内核功能层-进程-内存-中断-设备" aria-hidden="true">#</a> 内核功能层: 进程/内存/中断/设备</h2><p>内核功能层，主要完成各种实际功能，这些功能按照其类别可以分成各种模块，当然这些功能模块最终会用具体的算法、数据结构、代码去实现它，内核功能层的模块如下：</p><p>\\1. <strong>进程管理</strong>，主要是实现进程的创建、销毁、调度进程，当然这要设计几套数据结构用于表示进程和组织进程，还要实现一个简单的进程调度算法。</p><p>\\2. <strong>内存管理</strong>，在内核功能层中只有内存池管理，分两种内存池：<code>页面内存池</code>和<code>任意大小的内存池</code>，你现在可能不明白什么是内存池，这里先有个印象就行，后面课程研究它的时候再详细介绍。</p><p>\\3. <strong>中断管理</strong>，这个在内核功能层中非常简单：就是把一个中断回调函数安插到相关的数据结构中，一旦发生相关的中断就会调用这个函数。</p><p>\\4. <strong>设备管理</strong>，这个是最难的，需要用一系列的数据结构表示驱动程序模块、驱动程序本身、驱动程序创建的设备，最后把它们组织在一起，还要实现创建设备、销毁设备、访问设备的代码，这些代码最终会调用设备驱动程序，达到操作设备的目的。</p><h2 id="内核硬件层-初始化-cpu-中断-物理内存-其他" tabindex="-1"><a class="header-anchor" href="#内核硬件层-初始化-cpu-中断-物理内存-其他" aria-hidden="true">#</a> 内核硬件层: 初始化/CPU/中断/物理内存/其他</h2><p>内核硬件层，主要包括一个具体硬件平台相关的代码，如下：</p><p>\\1. <strong>初始化</strong>，初始化代码是内核被加载到内存中最先需要运行的代码，例如初始化少量的设备、CPU、内存、中断的控制、内核用于管理的数据结构等。</p><p>\\2. <strong>CPU 控制</strong>，提供 CPU 模式设定、开、关中断、读写 CPU 特定寄存器等功能的代码。</p><p>\\3. <strong>中断处理</strong>，保存中断时机器的上下文，调用中断回调函数，操作中断控制器等。</p><p>\\4. <strong>物理内存管理</strong>，提供分配、释放大块内存，内存空间映射，操作 MMU、Cache 等。</p><p>\\5. <strong>平台其它相关的功能</strong>，有些硬件平台上有些特殊的功能，需要额外处理一下。</p><h2 id="总结图" tabindex="-1"><a class="header-anchor" href="#总结图" aria-hidden="true">#</a> 总结图</h2><p>如果上述文字让你看得头晕，我们来画幅图，可能就会好很多，如下所示，<code>当然这里没有画出用户空间的应用进程</code>，<strong>API 接口以下的为内核空间，这才是设计、开发内核的重点。</strong></p><img src="'+n+'" alt="img" style="zoom:15%;"><p>我们的内核结构</p><p>从上述文字和图示，可以发现，我们的操作系统内核没有任何设备驱动程序，甚至没有文件系统和网络组件，内核所实现的功能很少。这吸取了微内核的优势，内核小出问题的可能性就少，扩展性就越强。</p><p>同时，我们把<code>文件系统、网络组件、其它功能组件</code>作为<mark>虚拟设备</mark>交由设备管理，</p><ul><li>比如需要文件系统时就写<code>一个文件系统虚拟设备的驱动</code>，完成文件系统的功能，</li><li>需要网络时就开发<code>一个网络虚拟设备的驱动</code>，完成网络功能。</li></ul><p><strong>这些驱动一旦被装载，就是内核的一部分了</strong>，并不是像微内核一样作为服务进程运行。这又吸取了宏内核的优势，代码高度耦合，性能强劲。</p><p>这样的内核架构既不是宏内核架构也不是微内核架构，而是这两种架构综合的结果，可以说是<code>混合内核架构</code>，也可以说这是我们自己的内核架构……</p><p>好了，到这里为止，我们已经设计了内核，确定了内核的功能并且设计了一种内核架构用来组织这些功能，这离完成我们自己的操作系统内核又进了一步。</p><h2 id="重点回顾" tabindex="-1"><a class="header-anchor" href="#重点回顾" aria-hidden="true">#</a> 重点回顾</h2><p>内核设计真是件让人兴奋的事情，今天的内容讲完了，我们先停下赶路的脚步，回过头来看一看这一节课我们学到了什么。</p><p>我们一开始感觉内核是个大黑盒，但通过分析通用计算机有哪些资源，就能推导出内核作为资源管理者应该有这些组件：</p><blockquote><p>I/O 管理组件、内存管理组件、文件系统组件、进程管理组件、图形系统组件、网络组件、安全组件等。</p></blockquote><p>接着，我们探讨了用两种结构来组织这些组件，这两种结构分别是宏内核结构和微内核结构，知道了他们各自的优缺点，**宏内核有极致的性能，微内核有极致的可移植性、可扩展性。**还弄清楚了它们各自完成应用程序服务的机制与流程。</p><p>然后，我们研究了分层的重要性，为什么分离硬件相关性。用实例说明了分离硬件相关性的好处，这是为了更容易扩展和移植。</p><p>最后，在前面的基础上，我们为自己的内核设计作出了选择。</p><p>我们的内核结构分为三层：内核硬件层，内核功能层，内核接口层，</p><ul><li>内核接口层主要是定义了一套 UNIX 接口的子集，</li><li>内核功能层主要完成 I/O 管理组件、内存管理组件、文件系统组件、进程管理组件、图形系统组件、网络组件、安全组件的通用功能型代码；</li><li>内核硬件层则完成其内核组件对应的具体硬件平台相关的代码。</li></ul><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题" aria-hidden="true">#</a> 思考题</h2><p>其实我们的内核架构不是我们首创的，它是属于微内核、宏内核之外的第三种架构，请问这是什么架构？</p><p>欢迎你在留言区跟我交流互动。如果这节课对你有启发，也欢迎分享给你的朋友或同事。</p><h2 id="课后探讨" tabindex="-1"><a class="header-anchor" href="#课后探讨" aria-hidden="true">#</a> 课后探讨</h2><p>之前感觉内核很神秘，真的就是个黑盒子，但是通过老师的讲解，觉得也可以透过现象看本质。内核设计的演进貌似和软件系统架构演进惊人的相似。宏内核和单体架构一致，微内核和SOA架构一致，而课程里面讲的第三种架构更像是微服务架构。从整体的架构演进来看，核心就是拆分，从all in one到垂直拆分，再到水平拆分，更面向用户操作和技术专注。</p><p>首先认识到内核是一个软件：管理硬件平台资源的底层软件，应用程序等都是借由它完成程序执行和硬件功能。内核设计的模式宏内核、微内核、外内核以及组合式内核，本文提到的内核结构类似于Linux内核， 首先它是一个宏内核，但是同时具备有微内核的特点，模块化设计，支持动态可加载和卸载。</p><p>混合内核。 特点是通过LKM充分利用了宏内核和微内核的优势。</p><p>本文中的内核接口层想必也没什么神秘的，应该就是所谓的system call了。这个系统api函数就是咱们说的系统调用</p><p>看到一半就想到《UNIX编译艺术》一书中的一句话：UNIX提供的是机制，而不是策略，策略命短，机制永存。</p><p>首先它是可扩展的，有微内核的特点 但是他提供的功能选比微内核提供的功能多，并且是加载到内核区，从这一点上吸取了宏内核的设计思想 那么为什么可加载呢？主要还是分层解耦合带来的，加代码直接加到内核功能区。 所以性能强，并且可扩展，吸收微内核和宏内核各自的优点。windows 是 混合内核</p><p>总体来讲，我们要取得微内核的优点：结构简单，调用清晰，扩展方便。但是不想为此付出太多的性能成本，这样不得不对微内核做一些功能上限制，采取宏内核的组织方式。设计上是微内核的，实现上是宏内核的，权衡了结构清晰和模块间的调用性能。</p><h3 id="综合" tabindex="-1"><a class="header-anchor" href="#综合" aria-hidden="true">#</a> 综合</h3><ul><li><p>首先一点 操作系统 也是软件，用来管理计算机资源。</p></li><li><p>开发一定要学会抽象和分层的思想。</p><p>不要把所有的功能都放在一起，不利于维护和扩展。<br> 利用分层的特性，将服务和功能拆分化，最外层只负责封装的封装，功能的实现依次的向内核靠近。增加系统的可维护性和可扩展性。</p></li><li><p>计算机资源分为软件资源和硬件资源。</p><p>硬件资源分为总线、cpu、内存、硬盘、网卡、显卡、IO。<br> 软件资源为计算机中各种形式的数据。文件、软件程序等。</p></li><li><p>管理资源就是管理硬件和软件</p></li><li><p>内核结构分为宏内核结构和微内核结构已经混合内核结构。</p></li><li><p>宏内核是把各种管理硬件设备的代码、文件系统的代码、图像系统代码以及各种模块代码都给链接到一起，形成一个超级大的可执行程序。宏内核结构不分层。优缺点明显，优点：性能好。缺点：结构不分层，因此没有扩展性，没有移植性，高度耦合，一点一个地方有问题，可能会殃及到所有地方。</p></li><li><p>微内核。提倡内核功能尽可能的少，仅有基本的功能。其他功能诸如进程控制、内存管理、设备管理等功能都做成一个个服务进程。和用户的进程程序一样，微内核定义了一种良好的进程间通信机制-消息。优点：结构清晰，利于协作开发。有良好的移植性，微内核代码非常少。有良好的伸缩性、扩展性，可以随时拿掉一个服务，反正也只是一个进程。缺点：性能差。</p></li><li><p>分离硬件也只是运用了分层和抽象的思想。</p></li><li><p>混合内核架构。运用分层和抽象，将内核分为内核接口层、内核功能层和内核硬件层。</p></li></ul>',141),c=[s];function h(l,g){return r(),a("div",null,c)}const u=p(t,[["render",h],["__file","B03-内核结构与设计.html.vue"]]);export{u as default};
