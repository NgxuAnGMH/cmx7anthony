import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o as c,c as i,a as e,b as t,e as o,d as p}from"./app-cdabc73c.js";const s="/assets/640-1691465360425-210-33d6bebd.png",d="/assets/640-1691465360425-211-e586d7ba.png",l={},_=e("h1",{id:"_42-白泽带你读论文丨nojitsu-locking-down-javascript-engines",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_42-白泽带你读论文丨nojitsu-locking-down-javascript-engines","aria-hidden":"true"},"#"),t(" 42-白泽带你读论文丨NoJITsu: Locking Down JavaScript Engines")],-1),h=e("p",null,[e("strong",null,"NoJITsu: Locking Down JavaScript Engines")],-1),u={href:"https://www.ndss-symposium.org/wp-content/uploads/2020/02/24262-paper.pdf",target:"_blank",rel:"noopener noreferrer"},J={href:"https://www.michaelfranz.com",target:"_blank",rel:"noopener noreferrer"},g=p('<h2 id="_1-主要内容" tabindex="-1"><a class="header-anchor" href="#_1-主要内容" aria-hidden="true">#</a> <strong>1 主要内容</strong></h2><p>Data-only attack在当下针对浏览器JavaScript引擎的攻击中较为常见，与传统的会控制程序流的攻击方式不同，其借助<mark>内存漏洞</mark>（Memory-corruption vulnerability）获取对任意内存的读写权限，能够对即时编译引擎（JIT compiler）函数执行中所需的重要数据进行修改，达到远程任意代码执行的目的。</p><p>为了防止对即时编译引擎发起的攻击，前人提出了将其放入独立工作的进程或是可信执行环境中运行，将部分内存访问权限设定为仅可执行或可读，并通过内存空间地址随机化和控制流完整性校验等措施实现进一步的保护。但是，在这样的保护措施下，JavaScript引擎仍然会受到Data-only attack的攻击。</p><p>本文针对现有的JS引擎中的解释器（Interpreter），提出了新的攻击手段（Bytecode Interpreter Attack），攻击者可以在进入JIT编译之前修改一些关键数据，从而绕过现有防御机制并执行任意系统shell命令。</p><p>除此之外本文从Data-only attack产生的必要条件出发，提出了更加完善的防御机制—NoJITsu，即通过施加精确和细粒度的内存权限访问控制，来杜绝恶意的内存篡改行为。并通过实验证明该防御机制在对抗代码注入，代码重用，以及Bytecode Interpreter Attack上的有效性。并且这套防御机制仅在之前的JS引擎之上增加了平均5%的性能开销。</p><h2 id="_2-bytecode-interpreter-attack攻击原理" tabindex="-1"><a class="header-anchor" href="#_2-bytecode-interpreter-attack攻击原理" aria-hidden="true">#</a> <strong>2 Bytecode Interpreter Attack攻击原理</strong></h2><figure><img src="'+s+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>如图所示，本文提出了针对解释器的Data-only attack手段。虽然文章主要针对Mozilla的SpiderMonkey即时编译引擎，但理论上该攻击也可对具有相似解释器核心的V8和JavaScriptCore发起攻击。攻击者首先需要通过CVE-2019-11707来获取任意内存的读写权限。接着，具体攻击过程主要包含以下三个步骤：</p><p>（1）在解释器对攻击者输入的恶意JavaScript脚本进行解释后，会生成Bytecode，Object table，以及JavaScript object三个部分的数据。攻击者尝试读取JavaScript Object数据中的一个待执行的函数信息（即Context object和Function object的位置）。</p><p>（2）攻击者将Context object和Function object中的数据修改为指向攻击者想要执行的系统函数的位置。</p><p>（3）最终，当解释器在执行原本函数的时候，实际上是执行了攻击者指定的系统函数，从而使得攻击者可以执行任意系统命令。</p><h2 id="_3-nojitsu的防御设计与实现" tabindex="-1"><a class="header-anchor" href="#_3-nojitsu的防御设计与实现" aria-hidden="true">#</a> <strong>3 NoJITsu的防御设计与实现</strong></h2><p>对于上述攻击的描述我们可以发现，此类针对浏览器JavaScript引擎的Data-only attack攻击需要利用已有内存漏洞来获取对任意内存读写的能力，并且利用该能力修改编译后的一些关键数据。于是本文提出了针对JIT中关键数据结构的细粒度内存权限访问控制机制来防止恶意的数据写入行为。</p><p>工具实现上，作者采用了最新的Intel Memory Protection Key（MPK）硬件机制来提供技术支持。MPK技术能够将内存分为15个内存域（Memory Domain），每个内存域可以被赋予独立的权限（甚至支持Execute-only）。并且不同的工作线程都拥有各自独立的寄存器用来管理内存访问权限，杜绝了攻击者从其他线程线程发起同时写操作的可能。</p><p>防御机制主要由两部分组成：</p><p>（1）识别并定位到JavaScript引擎中的五大核心数据结构：Bytecode，Object table，JavaScript object，JIT code和JIT IR。NoJITsu会在原来的JS引擎基础上进行修改，将这些数据结构放置在独立的内存域中。</p><p>（2）针对不同的数据结构，作者通过分析它们的生命周期，在合适的时间，动态地赋予JS引擎对其进行写操作的权限，杜绝非法的写操作产生。</p><figure><img src="'+d+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>如上图所示，具体来说NoJITsu对五个核心数据结构的保护可分为三部分：</p><p>（1） 针对Bytecode和Object table的保护：这两部分的数据仅由Bytecode compiler组件产生，在编译过程时，才会写入内存中，且其余情况仅进行读操作。于是本文将它们的内存域默认设置为仅读权限，并对compiler相关函数进行插桩，在具体的写操作之前赋予可写权限，操作结束之后立即恢复为原来的权限保护状态。</p><p>（2） 针对JIT IR和JIT code的保护：与上面两个数据结构相似，这部分的数据也仅在JIT compiler工作过程中写入内存。由于JIT code中会包含机器码部分以及数据部分，本文更细粒度的拆分了这两部分的数据，对于机器码部分放入仅可执行的内存域中，而数据部分则是默认可读权限。</p><p>（3） 针对JavaScript Object的保护：首先本文将该部分数据细粒度的分为了Primitive（记录data types等）和Sensitive（记录scrip, shape, function object等）object两种类型，分别存储于不同的内存域中。且由于该部分的数据会经常在程序执行过程中进行更新，于是想要通过静态方式去找到对这个数据结构进行写操作的函数是很难的事。所以本文采取了基于LLVM动态插桩的方式，来定位执行了写操作的函数，即在默认情况下当程序试图对仅读内存区域进行写操作时，会触发Segmentation Fault错误，通过定制的Handler来捕捉这个错误，并重新将此区域权限修改为可写，则在原函数插桩代码部分即可感知到内存权限的修改，同时也说明了被插桩的函数在JavaScript引擎运作过程中会对内存进行写操作，于是记录下对应函数信息。在动态分析结束后，会在该函数中插入动态赋予和恢复权限的代码，让引擎在稳定版本中没有Hanlder的情况下能允许被认可的函数执行内存写操作。为了降低复杂度，本文仅对JS引擎的底层接口accessor函数进行归纳总结。通过运行官方的JavaScript测试集，能够尽可能全面的收集到所有的accessor函数。</p><p>除此之外，NoJITsu也针对动态插入权限修改代码的位置进行了优化设计，通过对函数调用图中的函数是否会进行写操作进行打分，用阈值来决定权限修改发生的位置，可以减少例如循环中持续写函数调用带来的不少开销。</p><h2 id="_4-实验与分析" tabindex="-1"><a class="header-anchor" href="#_4-实验与分析" aria-hidden="true">#</a> <strong>4 实验与分析</strong></h2><p>作者对NoJITsu防御机制的安全性以及性能开销进行了评估实验。</p><p>（1） 动态方法获取accessor函数的完备性：本文在6,246个脚本运行中获得到的300个accessor函数进行了权限授予，并运行了所有的30,605个测试脚本，运行过程中并没有产生内存访问冲突的情况，即说明了这300个函数足以覆盖所有合理的写操作。</p><p>（2） 针对现有攻击的防御性：本文从根本条件上杜绝了代码注入、代码重用攻击的可能，并且也在自己提出的攻击上进行了测试，NoJITsu可以很好的抵御这些类型的攻击。</p><p>（3） 性能开销：作者选取LongSpider作为测试集，其大部分的脚本代码运行时长都能超过100ms，相比广泛使用的SunSpider更能体现出这套防御机制对开销的影响。而实验也表明，平均对每个脚本的运行耗时开销大约只在5%左右，在开启了优化选项时，这部分影响还能降低到2%。</p><h2 id="_5-评价" tabindex="-1"><a class="header-anchor" href="#_5-评价" aria-hidden="true">#</a> <strong>5 评价</strong></h2><p>本文借助JS引擎的Interpreter组件，巧妙地绕过了前人仅针对JIT compiler部分做的防御措施，发起了Data-only attack。并且与传统的攻防研究不同，本文提出的NoJITsu防御机制，是在一系列的攻击前提上开展的防护措施，抓住了这些攻击手段的共同点，限制在不合时宜的地方对重要的数据进行修改写入的行为。在Intel MPK的硬件支持下，能施加细粒度的内存权限访问控制，所需的性能开销也是可以被接受的。</p><p>面对如今越来越复杂的系统设计，系统中关键数据的生命周期也会变得越来越长。从攻击角度来说，可以是牵一发而动全身的，但是从防御角度的来说，更重要的是去分析攻击产生的根本原因，从更高层的角度上去进行防御，才能起到对系统中整个生命周期的保护作用，抵御一系列的恶意攻击行为。</p>',31);function m(b,I){const a=n("ExternalLinkIcon");return c(),i("div",null,[_,h,e("p",null,[t("论文链接："),e("a",u,[t("https://www.ndss-symposium.org/wp-content/uploads/2020/02/24262-paper.pdf"),o(a)])]),e("p",null,[t("本文发表在NDSS 2020，出自加利福尼亚大学欧文分校的Michael Franz教授带领的研究组。Franz教授的个人主页见："),e("a",J,[t("https://www.michaelfranz.com"),o(a)]),t("。")]),g])}const y=r(l,[["render",m],["__file","42-白泽带你读论文丨NoJITsu Locking Down JavaScript Engines.html.vue"]]);export{y as default};
