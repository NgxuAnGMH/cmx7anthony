import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o as c,c as o,a as n,b as a,e,d as p}from"./app-cdabc73c.js";const l="/assets/1c036c9c63d1f9375297967183215501-381983c4.jpg",r="/assets/b3c8155114a94966cfyy30086fdf6438-0911255f.jpg",d="/assets/65d91c8c35430a97949de0a9fc2f59ca-bd497531.jpg",u="/assets/6297287620499304320cedc4cbef7e9b-8e1ba5f7.jpg",m="/assets/c6b423821b0d991bd47a7c8ee09c8ecc-81cf4ce9.jpg",k="/assets/e57605892f5465d2bbc48960c3c700a1-1374fd56.jpg",b="/assets/87043296f491a61933346ebeaaae5b83-0aa8e8a2.jpg",g="/assets/481f8bdcb349242b76d82a49508f032f-b894f4a8.jpg",v={},C=n("h1",{id:"√14-走进c语言-高级语言怎样抽象执行逻辑",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#√14-走进c语言-高级语言怎样抽象执行逻辑","aria-hidden":"true"},"#"),a(" √14｜走进C语言：高级语言怎样抽象执行逻辑？")],-1),f=n("p",null,"你好，我是 LMOS。",-1),h=n("p",null,"前面我们设计了迷你 CPU，相信你已经对 CPU 如何执行指令有了一定的了解。",-1),_=n("p",null,"而 CPU 执行的指令，正是由工程师敲出来的高级编程语言产生的，比如我们熟知的 C、C++、Java 等。",-1),x=n("p",null,"平时我们做编程的时候，底层 CPU 如何执行指令已经被封装好了，因此你很少会想到把底层和语言编译联系在一起。但从我自己学习各种编程语言的经历看，从这样一个全新视角重新剖析 C 语言，有助于加深你对它的理解。",-1),y={href:"https://gitee.com/lmos/Geek-time-computer-foundation/tree/master/lesson14",target:"_blank",rel:"noopener noreferrer"},w=p(`<h3 id="cpu-执行指令的过程" tabindex="-1"><a class="header-anchor" href="#cpu-执行指令的过程" aria-hidden="true">#</a> CPU 执行指令的过程</h3><p>通过之前的学习，我们已经知道了 CPU 执行一条特定指令的详细过程，它们是取指、译码，执行、访存、回写。这是一个非常详细的硬件底层细节，我们现在再迈一个台阶，站高一点，<strong>从软件逻辑的角度看看 CPU 执行多条指令的过程</strong>。</p><p>这个过程描述起来很简单，就是一个循环。为了让你分清每个步骤，我分点列一下：</p><ol><li><p>以 PC 寄存器中值为内存地址 A，读取内存地址 A 中的数据 ;</p></li><li><p>CPU 把内存地址 A 中的数据作为指令执行，具体执行过程为取指、译码，执行、访存、写回 ;</p></li><li><p>将 PC 寄存器中的值更新为内存地址 A+（一条指令占用的字节数）;</p></li><li><p>回到第一步。</p></li></ol><p>上述过程就是 CPU 执行指令的逻辑过程。下面我们动手来写几行代码，调试一下，观察一下内存的内容和 CPU 寄存器的变化，这样你就更加清楚了。代码如下：</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>.text    

.global  main
main:          # main函数
  add t1,zero,1    # x6 = 1
  add t2,zero,2    # x7 = 2
  add t0,t1,t2    # x5 = x6 + x7
  add a0,zero,zero   # x10 = 0 相当于main函数中的return 0
  ret
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这是一段 RV32I 指令集编写的汇编代码，现在你无法完全理解这段代码也没关系，能看懂注释就行了。</p>`,7),P={href:"https://gitee.com/lmos/Geek-time-computer-foundation/tree/master/lesson14",target:"_blank",rel:"noopener noreferrer"},U=p('<p>这里我们用 VSCode 打开本课的目录，设置好断点，按下“F5”键，就行了，如下所示。</p><figure><img src="'+l+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>我们看到 t0、t1、t2 寄存器中的数据和我们预期的一样。PC 寄存器从 0x10120，一直变化到 0x1012c，每执行一条指令 PC 寄存器的值都要加 4，这是因为每条 RV32I 指令都占用 4 字节的内存空间。</p><p>我们在调试控制台中执行“-exec x/16xb 0x10120”命令，即可显示从 0x10120 开始的 16 字节内存数据，刚好 4 条指令的数据。我还在文稿里画了一幅图，它展示了内存中的情况，如下所示：</p><figure><img src="'+r+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>对照示意图，我来为你解释一下，大致逻辑是这样的：最开始，由 CPU 控制单元通过控制总线发出要读取数据的控制信号。；接着通过地址总线发送地址信号（当前情况下地址数据来源 PC 寄存器（0x10120））；然后通过数据总线传送指令数据 (0x00100313)；最后执行单元拿到指令数据开始执行，并增加 PC 寄存器使之指向下一条指令。重复这个过程，内存中的指令就能一条一条地执行了。</p><h3 id="c-语言编译过程" tabindex="-1"><a class="header-anchor" href="#c-语言编译过程" aria-hidden="true">#</a> C 语言编译过程</h3><p>了解了 CPU 执行逻辑过程之后，我们再来看看内存中的指令数据是如何产生的。</p><p>其实数据产生的方式有很多，我们可以用手写，也可以用电子编程器。只不过这样的方式，太古老了，也太低效了，更加容易出错。所以人们之后设计汇编语言时，实现了指令符号化，这看似高级了不少，但是依然是低效且难以理解的。</p><p>直到后来人们开发出了高级语言，进一步抽象，形成更容易让人们理解的形式。但是<strong>因为 CPU 始终只认识那些二进制数据，就需要把高级语言转化成为二进制数据，这个转化的过程叫编译过程，完成这个转化的工具软件就叫编译器。</strong></p><p>比如下面要讲的 C 语言编译器编译 C 语言的过程。我们先通过示意图来理解这一过程，建立一个整体印象，如下所示：</p><figure><img src="'+d+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>现代的 C 预处理器、C 编译器、汇编器、链接器是独立的程序，可以分开独立工作，并不是一个程序完成上图中所有的工作。</p><p>因为我们不开发编译器，这里你不需要理解词法、语法是如何分析的，中间代码是怎样优化的。我们要关注的焦点是，从 C 源代码到二进制机器指令数据的转化过程。</p><h3 id="c-语言的重要组成" tabindex="-1"><a class="header-anchor" href="#c-语言的重要组成" aria-hidden="true">#</a> C 语言的重要组成</h3><p>想要弄清楚 C 如何跟二进制指令数据转化，首先要清楚 C 语言的重要组成部分。你可能会说，C 语言的重要组成当然是 C 语言代码。这个说法当然没错，但代码只是一个统称。从不同层次抽象，里面的内容是不一样的：从高层次看代码中只有声明和定义，下一层看代码只有函数和变量，变量进一步分解还有不同的类型。</p><p>硬背这些分类只会让你晕头转向。接下来我们不妨分析一下，想要让一段 C 语言代码编译通过，需要哪些重要成分和逻辑结构。</p><p>我们在 C 语言中经常容易混淆声明和定义这两个概念，我们先来看看声明。</p><p>声明是给变量、函数、结构体等命名，表明在程序代码中有该变量、函数、结构体，我们来看看下图中的代码：</p><figure><img src="'+u+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>我们在 declaration.c 程序文件中，声明了一个整型变量，一个结构体变量，一个函数。然后我们编译它，确实能编译成功，这说明在 C 语言文法中仅仅需要有声明就可以，当然空文件也是可以的。声明不会分配内存空间。</p><p>这里需要注意的是，只有声明的代码确实能编译成功，但链接的时候就不一定了，我们这里之所以能链接成功。是因为在其它代码中没有对这些声明进行了引用。</p><p>下面我们来看看定义，定义是具体给变量分配内存空间。这个内存空间可以是初始化的，也可以是没有初始化的、给出具体函数的实现。</p><p>具体函数可以是空函数，函数中没有语句什么都不做也可以，唯一必需的就是指明结构体成员。结构体也是变量，只不过结构体是多个变量的组合，同样要分配内存空间，可以初始化也可以不做初始化。</p><p>我们写代码验证一下对不对，如下图所示：</p><figure><img src="'+m+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>我们还是在 definition.c 程序文件中，定义了一个整型变量，一个结构体变量，一个函数。我们同样能成功编译它。这说明 C 语言文法中没有声明，只有定义也可以成功编译的，其实 C 语言文法的原则是，<strong>声明可以出现很多次，定义有且只能出现一次</strong>。声明和定义也可以同时出现。</p><p>现在我来总结一下，其实编译的其中一个过程，就是用某种编程语言的文法来检查所写语言（代码）是否正确。你可以这么理解，语言的文法就是对这种语言的最高抽象，所以我们可以说 <strong>C 语言最重要的组成部分就是声明或者定义。</strong></p><p>声明或者定义中又包含变量和函数，变量又有指针、数组、结构体，它们又包含各种类型，而函数中包含了各种表达式，各种表达式对变量进行操作。</p><p>编译器的语法分析过程，就是这样层层递归推导下去，最终构建出语法树，从而检查语言是否正确无误、是否符合该语言文法的规则定义，都符合编译才能通过。就像你学英文一样，你怎么判断一条英语句子是否正确呢？你会拿主谓宾等等约定俗成的语法去套，如果能套上去，就是正确的。</p><h3 id="c-语言对程序的抽象" tabindex="-1"><a class="header-anchor" href="#c-语言对程序的抽象" aria-hidden="true">#</a> C 语言对程序的抽象</h3><p>前面我们已经从整体上了解了 C 语言的重要组成，可以看出，一段程序从语法角度来说就是声明加上定义。</p><p>现在我们继续深入了解 C 语言对程序的抽象，平时我们最多是使用设计好的 C 语言。而现在我们要站在 C 语言设计者的角度想一想，一门既能写程序，又更容易让人类理解的语言要怎么设计？其实这门语言的“设计过程”，就是 C 语言对机器语言的抽象，也就是 C 语言对程序的抽象。</p><p>我特意为你绘制了一幅图，我们从 C 语言的核心语言元素开始了解。这些元素就像英文里的各种固定词型，知道了这些元素在 C 语言中发挥的作用，你就找到了理解 C 语言的钥匙。</p><figure><img src="'+k+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>一图读懂C语言</p><p>我们看到 C 语言中，包含声明和定义，可以声明变量和函数，由图中绿色箭头指向。也可以定义变量和函数，由图中蓝色箭头指向，注意定义只能出现一次，声明可以出现多次。</p><p>我故意安排指针在最前端，是因为从 C 语言特性讲，指针能指向任一变量和函数，由图中红色箭头指向；从另一个角度看，<em>指针就是内存，能自由寻址读写内存空间，但能否读写内存则要看操作系统给的权限</em>，指针就是 C 语言中的“<u>上帝之手</u>”。同时，图中黑色线条还表示指针可以有相应的类型，并且能参与运算，这是我把指针放在比函数更高位置的原因。</p><p>需要注意的是，<strong>各种类型的变量是可以定义在函数以外的，这些定义在函数以外的变量是全局变量，而定义在函数内部的变量叫局部变量</strong>。</p><p>如果我们要用 C 语言完成一个实际功能，一定要写一个函数。函数就是 C 语言中对一段功能代码的抽象。一个函数就是一个执行过程，有输入参数也有返回结果（根据需要可有可无），代码如下所示：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中的函数是空函数，C 语言是允许的，当然这样的函数不会完成任何功能。</p><p>如果我们要完成点什么功能，就要在函数中写代码语句。代码语句又被抽象成表达式和流程控制。这也是为什么上图中函数下面包含了表达式和流程控制。</p><p>接下来，我们写个完成求两数之差、求两数之和的函数，代码如下所示：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> op<span class="token punctuation">,</span> <span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>op <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">//表达式：op &lt; 1 </span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span><span class="token comment">//表达式：a - b </span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token comment">//表达式：a + b </span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中有三个表达式，注释中已经写明了，含有三种流程控制：if 判断分支控制，return 返回控制，还有默认的从上至下的代码顺序。你可以把上述代码拿到上图中去套，以证明 C 语言对代码语句的抽象，你会发现一套一个准。</p><p>下面我们继续研究一下表达式。从前面的图里，可以看到 C 语言表达式包含了变量和运算符。</p><p>变量又有各种类型，单个变量也是表达式，但是运算符不能单独存在变成表达式，所以 C 语言表达式要么是单个变量，要么是变量加运算符一起。根据运算符的类型不同，可以分成运算表达式、逻辑表达式、赋值表达式等。</p><p>下面我们使用代码实例来找找感觉，如下所示：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> sumdata <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//全局整型变量sumdata</span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//局部整型变量i</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span> <span class="token comment">//局部整型指针变量p</span>
    p <span class="token operator">=</span> <span class="token operator">&amp;</span>sumdata<span class="token punctuation">;</span><span class="token comment">//把sumdata变量的地址赋值给p变量，从而指向sumdata变量</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//循环流程控制</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&gt;</span> <span class="token number">100</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment">//跳出循环，流程控制</span>
        <span class="token punctuation">}</span>
        <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token operator">+=</span> i<span class="token punctuation">;</span><span class="token comment">//相当于sumdata = sumdata + i</span>
        i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码所有的表达式中，涉及了一个全局变量，两个局部变量。其中局部变量中有一个是指针变量，指向全局的变量。包含了更多的流程控制语句，可以明显地看到表达式就是：变量和运算符组合在一起，完成了对变量的操作。而变量代表了数据，最终就能实现对数据的运算。但是变量有各种类型，这些类型只是规范了变量的位宽和大小，下一节我们会有更详细的介绍。</p><p>现在我们就可以总结一下，C 语言是如何抽象程序的，如下表所示。</p><figure><img src="`+b+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>这就是 C 语言对程序的抽象。到这里，今天的课程也到了尾声，你是否像我一样，想起了那个著名的公式：程序 = 算法 + 数据结构？</p><p>没错，C 语言就是函数 + 变量。函数表示算法操作，变量存放数据，即数据结构，合起来就是程序 = 算法 + 数据结构。</p><p>C 语法的运算符和流程控制可以实现各种算法，而各种类型的变量组合起来，就能实现各种复杂的数据结构。理解了这些，你就抓住了 C 语言的本质，也为后续学习打下了良好的基础。</p><h3 id="重点回顾" tabindex="-1"><a class="header-anchor" href="#重点回顾" aria-hidden="true">#</a> 重点回顾</h3><p>到这里今天的课程就告一段落了，我来总结一下这节课的重点。</p><p>首先我们研究了 CPU 执行指令过程和 C 语言编译过程。理解了这两个过程，后续的学习就有了良好基础。</p><p>接着我们进入到 C 语言内部，从宏观上理解了定义和声明这两个 C 语言的重要组成部分。声明只是一种说明性质的东西，不产生机器指令，而定义则是实现，会产生对应的机器指令。</p><p>最后我们从 C 语言的核心语言元素入手，抽丝剥茧，层层解构。C 语言由函数构成，函数中又包含多条语句，语句由流程控制和表达式构成，表达式由各种类型的变量和各种运算符构成。这些东西组合在一起，就把机器执行的程序抽象成了人类易于掌握和理解的概念——C 语言。文稿里我总结的那张图，你不妨保存下来，作为你学习理解 C 语言的导航图。</p><figure><img src="'+g+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>下节课我们继续研究 C 语言和汇编语言的对应关系，敬请期待。</p><h3 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题" aria-hidden="true">#</a> 思考题</h3><p>为什么 C 语言中为什么要有流程控制？</p><p>期待你在留言区踊跃发言，积极思考有助于你更好地领会课程内容。也推荐你把这节课分享给身边的朋友，说不定就能让他进一步掌握 C 语言了。</p><blockquote><p>RISC-V Support，RISCV汇编高亮显示<br> RISC-V Venus Simulator，RISCV汇编仿真调试<br> 要调试RISCV汇编的话，VSCode要安装这两个插件才行<br> 作者回复: 看的出来 你成功了<br> 其他网友：不装这两个插件的话无法调试main.S，无法加断点也没有高亮显示</p><hr><p>老师您好。想问一下，vscode里面我调试C语言代码可以加断点，但是跑汇编代码加不了断点，怎么解决呢？用riscv64-unknown-elf-gcc编译了直接在命令行里用qemu-risc32 main.elf跑是没有问题的。但是用vscode调试没法加断点。<br> 谢谢老师<br> 作者回复: 加不了 断点 是vscode中加不上吗<br> 其他网友：在设置里面找到debug，勾选上allow breakpoints everywhere<br> 其他网友：右键选择运行到光标处可以设置单个断点</p><hr><p>除了需要安装那两个插件，代码还需要再重新放在一个目录下运行，我把十四课代码直接放在十三课目录下（新建了一个lesson14的目录）就无法运行了，应该重新创建一个独立的环境lesson14然后把.vscode和Makefile都扔进去<br> 作者回复: 是的</p><hr><p>流程控制？c语言代码不一定需要所有的都在cpu上跑一遍，还有main函数是入口，如果按照程序等于算法加数据结构来说，就是赋予不同函数不同的权重（如main为入口，如float与int的存储方式不同），来模拟更直观更抽象的人的思维（毕竟，汇编语言是快，但是数据结构越复杂，那么人对它的理解难度上升）<br> 简而言之，c语言是通过增加抽象层，来实现更接近人的思维，流程控制的好处是降低cpu工作量（不是所有代码都要执行），提升c语言到汇编语言的转化效率！也可以理解为通过优化下的算法加数据结构，来对接汇编语言 操纵cpu的啊！<br> 作者回复: 这么理解 也好</p></blockquote>',67);function V(S,z){const s=i("ExternalLinkIcon");return c(),o("div",null,[C,f,h,_,x,n("p",null,[a("这节课我们首先要了解 CPU 执行指令的过程，然后再来分析 C 语言的编译过程，掌握 C 语言的重要组成，最后我们再重点学习 C 语言如何对程序以及程序中的指令和数据进行抽象，变成更易于人类理解的语言（代码从**"),n("a",y,[a("这里"),e(s)]),a("**下载）。")]),w,n("p",null,[a("下面我们一起打开我为你们准备"),n("a",P,[a("工程代码"),e(s)]),a("，调试一下。如何用 VSCode 调试代码，我在环境那节课讲过了，记不清了可以回顾一下。")]),U])}const R=t(v,[["render",V],["__file","√H14-走进C语言.html.vue"]]);export{R as default};
