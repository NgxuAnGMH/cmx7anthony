import{_ as p}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as i,c,a as s,b as n,e,d as t}from"./app-cdabc73c.js";const l="/assets/2ea68b40d928e6469233fcb4948c7cd2-00b06ad9.jpg",u="/assets/73349c0fab1a92d4e1ae0c684cfe06e2-1417e51b.jpeg",d="/assets/b8f184696be8d37ad6f2e2a4f12d002a-f528c8d0.jpeg",r="/assets/d790fb19b76d7504985639aceac43c25-a540d524.jpeg",k="/assets/e3718f0af6a2523a43606a0c4003631b-fd3e0b8a.jpeg",_="/assets/b0bf4690882253a70705acc7368983b9-78210c48.jpeg",m="/assets/3ea2ad5704f20538d9c911b02f42086d-66691447.jpeg",v="/assets/45a6cfdd9d45e30dc2f38f0d2572be7b-d9084dbe.jpeg",b="/assets/f81bf3e5a6cd060c3225a8ae1803a138-a70ea8af.png",g={},h=t('<h1 id="_28-硬盘文件系统-如何最合理地组织档案库的文档" tabindex="-1"><a class="header-anchor" href="#_28-硬盘文件系统-如何最合理地组织档案库的文档" aria-hidden="true">#</a> 28 | 硬盘文件系统：如何最合理地组织档案库的文档？</h1><p>上一节，我们按照图书馆的模式，规划了档案库，也即文件系统应该有的样子。这一节，我们将这个模式搬到硬盘上来看一看。</p><img src="'+l+`" alt="img" style="zoom:25%;"><p>我们常见的硬盘是上面这幅图左边的样子，中间圆的部分是磁盘的盘片，右边的图是抽象出来的图。每一层里分多个磁道，每个磁道分多个扇区，每个扇区是 512 个字节。</p><p>文件系统就是安装在这样的硬盘之上。这一节我们重点目前 Linux 下最主流的文件系统格式——<strong>ext 系列</strong>的文件系统的格式。</p><h2 id="inode-与块的存储" tabindex="-1"><a class="header-anchor" href="#inode-与块的存储" aria-hidden="true">#</a> inode 与块的存储</h2><p>就像图书馆的书架都要分成大小相同的格子，硬盘也是一样的。硬盘分成相同大小的单元，我们称为<strong>块</strong>（Block）。<mark>一块的大小</mark>是<strong>扇区大小(512字节)的整数倍，默认是 4K</strong>。在格式化的时候，这个值是可以设定的。</p><p>一大块硬盘被分成了一个个小的块，用来存放文件的数据部分。这样一来，如果我们像存放一个文件，就不用给他分配一块连续的空间了。我们可以分散成一个个小块进行存放。这样就灵活得多，也比较容易添加、删除和插入数据。</p><p>但是这也带来一个新的问题，那就是文件的数据存放得太散，找起来就比较困难。有什么办法解决呢？我们是不是可以像图书馆那样，也设立<mark>一个索引区域</mark>，用来维护“某个文件分成几块、每一块在哪里”等等这些<strong>基本信息</strong>?</p><p>另外，文件还有**<mark>元数据</mark>**部分，例如名字、权限等，这就需要一个结构 <strong>inode</strong> 来存放。</p><p>什么是 inode 呢？inode 的“i”是 index 的意思，其实就是“索引”，类似图书馆的索引区域。既然如此，我们每个文件都会对应一个 inode；一个文件夹就是一个文件，也对应一个 inode。</p><p>至于 inode 里面有哪些信息，其实我们在内核中就有定义。你可以看下面这个数据结构。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">ext4_inode</span> <span class="token punctuation">{</span>
  __le16  i_mode<span class="token punctuation">;</span>    <span class="token comment">/* File mode */</span>
  __le16  i_uid<span class="token punctuation">;</span>    <span class="token comment">/* Low 16 bits of Owner Uid */</span>
  __le32  i_size_lo<span class="token punctuation">;</span>  <span class="token comment">/* Size in bytes */</span>
  __le32  i_atime<span class="token punctuation">;</span>  <span class="token comment">/* Access time */</span>
  __le32  i_ctime<span class="token punctuation">;</span>  <span class="token comment">/* Inode Change time */</span>
  __le32  i_mtime<span class="token punctuation">;</span>  <span class="token comment">/* Modification time */</span>
  __le32  i_dtime<span class="token punctuation">;</span>  <span class="token comment">/* Deletion Time */</span>
  __le16  i_gid<span class="token punctuation">;</span>    <span class="token comment">/* Low 16 bits of Group Id */</span>
  __le16  i_links_count<span class="token punctuation">;</span>  <span class="token comment">/* Links count */</span>
  __le32  i_blocks_lo<span class="token punctuation">;</span>  <span class="token comment">/* Blocks count */</span>
  __le32  i_flags<span class="token punctuation">;</span>  <span class="token comment">/* File flags */</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  __le32  i_block<span class="token punctuation">[</span>EXT4_N_BLOCKS<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">/* Pointers to blocks */</span>
  __le32  i_generation<span class="token punctuation">;</span>  <span class="token comment">/* File version (for NFS) */</span>
  __le32  i_file_acl_lo<span class="token punctuation">;</span>  <span class="token comment">/* File ACL */</span>
  __le32  i_size_high<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从这个数据结构中，我们可以看出，inode 里面有文件的读写权限 i_mode，属于哪个用户 i_uid，哪个组 i_gid，大小是多少 i_size_io，占用多少个块 i_blocks_io。咱们讲 <code>ls</code> 命令行的时候，列出来的<strong>权限、用户、大小</strong>这些信息，就是从(inode)这里面取出来的。</p><p>另外，这里面还有几个与文件相关的时间。</p><ol><li><code>i_atime</code> 是 access time，是最近一次访问文件的时间；</li><li><code>i_ctime</code> 是 change time，是最近一次更改 inode 的时间；</li><li><code>i_mtime</code> 是 modify time，是最近一次更改文件的时间。</li></ol><p>这里你需要注意区分几个地方。首先，访问了，不代表修改了，也可能只是打开看看，就会改变 access time。其次，修改 inode，有可能修改的是用户和权限，没有修改数据部分，就会改变 change time。只有数据也修改了，才改变 modify time。</p><p>我们刚才说的**“某个文件分成几块、每一块在哪里”**，这些在 <code>inode</code> 里面，应该保存在 <code>i_block</code> 里面。</p><p>具体如何保存的呢？EXT4_N_BLOCKS 有如下的定义，计算下来一共有 15 项。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span>  <span class="token macro-name">EXT4_NDIR_BLOCKS</span>    <span class="token expression"><span class="token number">12</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span>  <span class="token macro-name">EXT4_IND_BLOCK</span>      <span class="token expression">EXT4_NDIR_BLOCKS</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span>  <span class="token macro-name">EXT4_DIND_BLOCK</span>      <span class="token expression"><span class="token punctuation">(</span>EXT4_IND_BLOCK <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span>  <span class="token macro-name">EXT4_TIND_BLOCK</span>      <span class="token expression"><span class="token punctuation">(</span>EXT4_DIND_BLOCK <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span>  <span class="token macro-name">EXT4_N_BLOCKS</span>      <span class="token expression"><span class="token punctuation">(</span>EXT4_TIND_BLOCK <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span></span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 ext2 和 ext3 中，其中<strong>前 12 项</strong>直接保存了块的位置，也就是说，我们可以<strong>通过 i_block[0-11]，直接得到保存文件内容的块</strong>。</p><img src="`+u+'" alt="img" style="zoom:25%;"><p>但是，如果一个文件比较大，12 块放不下。当我们用到 i_block[12]的时候，就不能直接放数据块的位置了，要不然 i_block 很快就会用完了。这该怎么办呢？我们需要想个办法。我们可以让 i_block[12]指向一个块，这个块里面不放数据块，而是放数据块的位置，这个块我们称为**<mark>间接块</mark><strong>。也就是说，我们在 i_block[12]里面放间接块的位置，通过 i_block[12]找到间接块后，间接块里面放数据块的位置，即通过间接块可以找到数据块。如果文件再大一些，i_block[13]会指向一个块，我们可以用</strong><mark>二次间接块</mark><strong>。二次间接块里面存放了间接块的位置，间接块里面存放了数据块的位置，数据块里面存放的是真正的数据。如果文件再大一些，i_block[14]会指向</strong><mark>三次间接块</mark>**。原理和上面都是一样的，就像一层套一层的俄罗斯套娃，一层一层打开，才能拿到最中心的数据块。</p><h3 id="extents-大文件存放成连续的块" tabindex="-1"><a class="header-anchor" href="#extents-大文件存放成连续的块" aria-hidden="true">#</a> Extents: 大文件存放成连续的块</h3><p>如果你稍微有点经验，现在你应该能够意识到，这里面有一个非常显著的问题，对于大文件来讲，我们要多次读取硬盘才能找到相应的块，这样访问速度就会比较慢。</p><p>为了解决这个问题，ext4 做了一定的改变。它引入了一个新的概念，叫做 <strong>Extents</strong>。</p><p>我们来解释一下 Extents。比方说，一个文件大小为 128M，如果使用 4k 大小的块进行存储，需要 32k 个块。如果按照 ext2 或者 ext3 那样散着放，数量太大了。<strong>但是 Extents 可以用于存放连续的块</strong>，也就是说，我们可以把 128M 放在一个 Extents 里面。这样的话，对大文件的读写性能提高了，文件碎片也减少了。</p><p>Exents 如何来存储呢？它其实会保存成<strong>一棵树</strong>。</p><img src="'+d+`" alt="img" style="zoom:25%;"><p>树有一个个的节点，有叶子节点，也有分支节点。每个节点都有一个头，ext4_extent_header 可以用来描述某个节点。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">ext4_extent_header</span> <span class="token punctuation">{</span>
  __le16  eh_magic<span class="token punctuation">;</span>  <span class="token comment">/* probably will support different formats */</span>
  __le16  eh_entries<span class="token punctuation">;</span>  <span class="token comment">/* number of valid entries */</span>
  __le16  eh_max<span class="token punctuation">;</span>    <span class="token comment">/* capacity of store in entries */</span>
  __le16  eh_depth<span class="token punctuation">;</span>  <span class="token comment">/* has tree real underlying blocks? */</span>
  __le32  eh_generation<span class="token punctuation">;</span>  <span class="token comment">/* generation of the tree */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们仔细来看里面的内容。<code>eh_entries</code> 表示这个节点里面有多少项。这里的项分两种，</p><ol><li>如果是<strong>叶子节点</strong>，这一项会直接指向硬盘上的连续块的地址，我们称为数据节点 <code>ext4_extent</code>；</li><li>如果是<strong>分支节点</strong>，这一项会指向下一层的分支节点或者叶子节点，我们称为索引节点 <code>ext4_extent_idx</code>。</li></ol><p>这两种类型的项的大小都是 12 个 byte。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/*
 * This is the extent on-disk structure.
 * It&#39;s used at the bottom of the tree.
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">ext4_extent</span> <span class="token punctuation">{</span>
  __le32  ee_block<span class="token punctuation">;</span>  <span class="token comment">/* first logical block extent covers */</span>
  __le16  ee_len<span class="token punctuation">;</span>    <span class="token comment">/* number of blocks covered by extent */</span>
  __le16  ee_start_hi<span class="token punctuation">;</span>  <span class="token comment">/* high 16 bits of physical block */</span>
  __le32  ee_start_lo<span class="token punctuation">;</span>  <span class="token comment">/* low 32 bits of physical block */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">/*
 * This is index on-disk structure.
 * It&#39;s used at all the levels except the bottom.
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">ext4_extent_idx</span> <span class="token punctuation">{</span>
  __le32  ei_block<span class="token punctuation">;</span>  <span class="token comment">/* index covers logical blocks from &#39;block&#39; */</span>
  __le32  ei_leaf_lo<span class="token punctuation">;</span>  <span class="token comment">/* pointer to the physical block of the next *
         * level. leaf or next index could be there */</span>
  __le16  ei_leaf_hi<span class="token punctuation">;</span>  <span class="token comment">/* high 16 bits of physical block */</span>
  __u16  ei_unused<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果文件不大，inode 里面的 i_block 中，可以放得下一个 ext4_extent_header 和 4 项 ext4_extent。所以这个时候，eh_depth 为 0，也即 inode 里面的就是叶子节点，树高度为 0。</p><p><strong>如果文件比较大，4 个 extent 放不下，就要分裂成为一棵树</strong>，eh_depth&gt;0 的节点就是索引节点，其中根节点深度最大，在 inode 中。最底层 eh_depth=0 的是叶子节点。</p><p>除了根节点，其他的节点都保存在一个块 4k 里面，4k 扣除 ext4_extent_header 的 12 个 byte，剩下的能够放 340 项，<strong>每个 extent 最大能表示 128MB 的数据</strong>，340 个 extent 会使你表示的文件达到 42.5GB。这已经非常大了，如果再大，我们可以增加树的深度。</p><h2 id="inode-位图和块位图" tabindex="-1"><a class="header-anchor" href="#inode-位图和块位图" aria-hidden="true">#</a> inode 位图和块位图</h2><p>到这里，我们知道了，硬盘上肯定有一系列的 inode 和一系列的块排列起来。</p><p>接下来的问题是，如果我要保存一个数据块，或者要保存一个 inode，我应该放在硬盘上的哪个位置呢？难道需要将所有的 inode 列表和块列表扫描一遍，找个空的地方随便放吗？</p><p>当然，这样效率太低了。所以在文件系统里面，我们专门弄了一个块来保存 inode 的位图。在这 4k 里面，每一位对应一个 inode。如果是 1，表示这个 inode 已经被用了；如果是 0，则表示没被用。同样，我们也弄了一个块保存 block 的位图。</p><p>上海虹桥火车站的厕位智能引导系统，不知道你有没有见过？这个系统很厉害，我们要想知道哪个位置有没有被占用，不用挨个拉门，从这样一个电子版上就能看到了。</p><img src="`+r+`" alt="img" style="zoom:33%;"><p>接下来，我们来看位图究竟是如何在 Linux 操作系统里面起作用的。前一节我们讲过，如果创建一个新文件，会调用 open 函数，并且参数会有 O_CREAT。这表示当文件找不到的时候，我们就需要创建一个。open 是一个系统调用，在内核里面会调用 sys_open，定义如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>open<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> filename<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> flags<span class="token punctuation">,</span> <span class="token class-name">umode_t</span><span class="token punctuation">,</span> mode<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">force_o_largefile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    flags <span class="token operator">|=</span> O_LARGEFILE<span class="token punctuation">;</span>


  <span class="token keyword">return</span> <span class="token function">do_sys_open</span><span class="token punctuation">(</span>AT_FDCWD<span class="token punctuation">,</span> filename<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们还是重点看对于 inode 的操作。其实 open 一个文件很复杂，下一节我们会详细分析整个过程。</p><p>我们来看接下来的调用链：do_sys_open-&gt; do_filp_open-&gt;path_openat-&gt;do_last-&gt;lookup_open。这个调用链的逻辑是，要打开一个文件，先要根据路径找到文件夹。如果发现文件夹下面没有这个文件，同时又设置了 O_CREAT，就说明我们要在这个文件夹下面创建一个文件，那我们就需要一个新的 inode。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">lookup_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">nameidata</span> <span class="token operator">*</span>nd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">path</span> <span class="token operator">*</span>path<span class="token punctuation">,</span>
      <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span>
      <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">open_flags</span> <span class="token operator">*</span>op<span class="token punctuation">,</span>
      bool got_write<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>opened<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dentry<span class="token operator">-&gt;</span>d_inode <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>open_flag <span class="token operator">&amp;</span> O_CREAT<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    error <span class="token operator">=</span> dir_inode<span class="token operator">-&gt;</span>i_op<span class="token operator">-&gt;</span><span class="token function">create</span><span class="token punctuation">(</span>dir_inode<span class="token punctuation">,</span> dentry<span class="token punctuation">,</span> mode<span class="token punctuation">,</span>
            open_flag <span class="token operator">&amp;</span> O_EXCL<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>想要创建新的 inode，我们就要调用 dir_inode，也就是文件夹的 inode 的 create 函数。它的具体定义是这样的：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">inode_operations</span> ext4_dir_inode_operations <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span>create    <span class="token operator">=</span> ext4_create<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>lookup    <span class="token operator">=</span> ext4_lookup<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>link    <span class="token operator">=</span> ext4_link<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>unlink    <span class="token operator">=</span> ext4_unlink<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>symlink  <span class="token operator">=</span> ext4_symlink<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>mkdir    <span class="token operator">=</span> ext4_mkdir<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>rmdir    <span class="token operator">=</span> ext4_rmdir<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>mknod    <span class="token operator">=</span> ext4_mknod<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>tmpfile  <span class="token operator">=</span> ext4_tmpfile<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>rename    <span class="token operator">=</span> ext4_rename2<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>setattr  <span class="token operator">=</span> ext4_setattr<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>getattr  <span class="token operator">=</span> ext4_getattr<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>listxattr  <span class="token operator">=</span> ext4_listxattr<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>get_acl  <span class="token operator">=</span> ext4_get_acl<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>set_acl  <span class="token operator">=</span> ext4_set_acl<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>fiemap         <span class="token operator">=</span> ext4_fiemap<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里面定义了，如果文件夹 inode 要做一些操作，每个操作对应应该调用哪些函数。这里 create 操作调用的是 ext4_create。</p><p>接下来的调用链是这样的：ext4_create-&gt;ext4_new_inode_start_handle-&gt;<code>__ext4_new_inode</code>。在 __ext4_new_inode 函数中，我们会创建新的 inode。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token function">__ext4_new_inode</span><span class="token punctuation">(</span><span class="token class-name">handle_t</span> <span class="token operator">*</span>handle<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>dir<span class="token punctuation">,</span>
             <span class="token class-name">umode_t</span> mode<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">qstr</span> <span class="token operator">*</span>qstr<span class="token punctuation">,</span>
             __u32 goal<span class="token punctuation">,</span> <span class="token class-name">uid_t</span> <span class="token operator">*</span>owner<span class="token punctuation">,</span> __u32 i_flags<span class="token punctuation">,</span>
             <span class="token keyword">int</span> handle_type<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> line_no<span class="token punctuation">,</span>
             <span class="token keyword">int</span> nblocks<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
inode_bitmap_bh <span class="token operator">=</span> <span class="token function">ext4_read_inode_bitmap</span><span class="token punctuation">(</span>sb<span class="token punctuation">,</span> group<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
ino <span class="token operator">=</span> <span class="token function">ext4_find_next_zero_bit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span>
                inode_bitmap_bh<span class="token operator">-&gt;</span>b_data<span class="token punctuation">,</span>
                <span class="token function">EXT4_INODES_PER_GROUP</span><span class="token punctuation">(</span>sb<span class="token punctuation">)</span><span class="token punctuation">,</span> ino<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里面一个重要的逻辑就是，从文件系统里面读取 inode 位图，然后找到下一个为 0 的 inode，就是空闲的 inode。</p><p>对于 block 位图，在写入文件的时候，也会有这个过程，我就不展开说了。感兴趣的话，你可以自己去找代码看。</p><h2 id="文件系统的格式" tabindex="-1"><a class="header-anchor" href="#文件系统的格式" aria-hidden="true">#</a> 文件系统的格式</h2><p>看起来，我们现在应该能够很顺利地通过 inode 位图和 block 位图创建文件了。如果仔细计算一下，其实还是有问题的。</p><p>数据块的位图是放在一个块里面的，共 4k。每位表示一个数据块，共可以表示 4∗1024∗8=2<sup>15</sup> 个数据块。如果每个数据块也是按默认的 4K，最大可以表示空间为 2<sup>15</sup>∗4∗1024=2<sup>27</sup> 个 byte，也就是 128M。</p><p>也就是说按照上面的格式，如果采用“<strong>一个块的位图 + 一系列的块</strong>”，外加“<strong>一个块的 inode 的位图 + 一系列的 inode 的结构</strong>”，最多能够表示 128M。是不是太小了？现在很多文件都比这个大。我们先把这个结构称为一个**<mark>块组</mark>**。有 N 多的块组，就能够表示 N 大的文件。</p><p>对于块组，我们也需要一个数据结构来表示为 <code>ext4_group_desc</code>。这里面对于一个块组里的</p><ol><li><p><strong>inode 位图(块)</strong> bg_inode_bitmap_lo、</p></li><li><p><strong>块位图(块)</strong> bg_block_bitmap_lo、</p></li><li><p><strong>inode 列表(多块)</strong> bg_inode_table_lo，</p><ul><li>都有相应的成员变量。</li></ul></li></ol><p>这样一个个块组，就基本构成了我们整个文件系统的结构。因为块组有多个，块组描述符也同样组成一个列表，我们把这些称为**<mark>块组描述符表(多块)</mark>**。</p><p>当然，我们还需要有一个数据结构，<strong>对整个文件系统的情况进行描述</strong>，这个就是**<mark>超级块</mark>**ext4_super_block。</p><ol><li><p>这里面有整个文件系统一共有多少 inode，s_inodes_count；</p></li><li><p>一共有多少块，s_blocks_count_lo，</p></li><li><p>每个块组有多少 inode，s_inodes_per_group，</p></li><li><p>每个块组有多少块，s_blocks_per_group 等。</p><ul><li>这些都是这类的全局信息。</li></ul></li></ol><p>对于整个文件系统，别忘了咱们讲系统启动的时候说的。如果是<strong>一个启动盘</strong>，我们需要预留一块区域作为引导区，<strong>所以第一个块组的前面要留 1K，用于启动引导区</strong>。</p><p>最终，整个文件系统格式就是下面这个样子。</p><img src="`+k+'" alt="img" style="zoom:25%;"><h2 id="重要的备份机制" tabindex="-1"><a class="header-anchor" href="#重要的备份机制" aria-hidden="true">#</a> 重要的备份机制</h2><p>这里面我还需要重点说一下，超级块和块组描述符表都是全局信息，而且这些数据很重要。<strong>如果这些数据丢失了，整个文件系统都打不开了</strong>，这比一个文件的一个块损坏更严重。所以，这两部分我们都需要备份，但是采取不同的策略。</p><h3 id="超级块" tabindex="-1"><a class="header-anchor" href="#超级块" aria-hidden="true">#</a> 超级块</h3><p>默认情况下，超级块和块组描述符表都有副本保存在每一个块组里面。</p><p>如果开启了 sparse_super 特性，超级块和块组描述符表的副本只会保存在块组索引为 0、3、5、7 的整数幂里。除了块组 0 中存在一个超级块外，在块组 1（3<sup>0</sup>=1）的第一个块中存在一个副本；在块组 3（3<sup>1</sup>=3）、块组 5（5<sup>1</sup>=5）、块组 7（7<sup>1</sup>=7）、块组 9（3<sup>2</sup>=9）、块组 25（5<sup>2</sup>=25）、块组 27（3<sup>3</sup>=27）的第一个 block 处也存在一个副本。</p><p>对于超级块来讲，由于超级块不是很大，所以就算我们备份多了也没有太多问题。但是，对于块组描述符表来讲，如果每个块组里面都保存一份完整的块组描述符表，一方面很浪费空间；另一个方面，由于一个块组最大 128M，而块组描述符表里面有多少项，这就限制了有多少个块组，128M * 块组的总数目是整个文件系统的大小，就被限制住了。</p><h3 id="块组描述符表" tabindex="-1"><a class="header-anchor" href="#块组描述符表" aria-hidden="true">#</a> 块组描述符表</h3><p>我们的改进的思路就是引入 <strong>Meta Block Groups 特性</strong>。</p><p>首先，块组描述符表不会保存所有块组的描述符了，而是将块组分成多个组，我们称为<mark>元块组（Meta Block Group）</mark>。每个元块组里面的块组描述符表仅仅包括自己的，一个元块组包含 64 个块组，这样一个元块组中的块组描述符表最多 64 项。我们假设一共有 256 个块组，原来是一个整的块组描述符表，里面有 256 项，要备份就全备份，现在分成 4 个元块组，每个元块组里面的块组描述符表就只有 64 项了，这就小多了，而且四个元块组自己备份自己的。</p><img src="'+_+`" alt="img" style="zoom:25%;"><p>根据图中，每一个元块组包含 64 个块组，块组描述符表也是 64 项，备份三份，在元块组的第一个，第二个和最后一个块组的开始处。</p><p>这样化整为零，我们就可以发挥出 ext4 的 48 位块寻址的优势了，在超级块 ext4_super_block 的定义中，我们可以看到块寻址分为高位和低位，均为 32 位，其中有用的是 48 位，2^48 个块是 1EB，足够用了。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">ext4_super_block</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  __le32  s_blocks_count_lo<span class="token punctuation">;</span>  <span class="token comment">/* Blocks count */</span>
  __le32  s_r_blocks_count_lo<span class="token punctuation">;</span>  <span class="token comment">/* Reserved blocks count */</span>
  __le32  s_free_blocks_count_lo<span class="token punctuation">;</span>  <span class="token comment">/* Free blocks count */</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  __le32  s_blocks_count_hi<span class="token punctuation">;</span>  <span class="token comment">/* Blocks count */</span>
  __le32  s_r_blocks_count_hi<span class="token punctuation">;</span>  <span class="token comment">/* Reserved blocks count */</span>
  __le32  s_free_blocks_count_hi<span class="token punctuation">;</span>  <span class="token comment">/* Free blocks count */</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="目录的存储格式" tabindex="-1"><a class="header-anchor" href="#目录的存储格式" aria-hidden="true">#</a> 目录的存储格式</h2><p>通过前面的描述，我们现在知道了一个普通的文件是如何存储的。有一类特殊的文件，我们会经常用到，就是目录，它是如何保存的呢？</p><p>其实目录本身也是个文件，也有 inode。inode 里面也是指向一些块。和普通文件不同的是，普通文件的块里面保存的是文件数据，而目录文件的块里面保存的是目录里面一项一项的文件信息。这些信息我们称为 ext4_dir_entry。从代码来看，有两个版本，在成员来讲几乎没有差别，只不过第二个版本 ext4_dir_entry_2 是将一个 16 位的 name_len，变成了一个 8 位的 name_len 和 8 位的 file_type。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">ext4_dir_entry</span> <span class="token punctuation">{</span>
  __le32  inode<span class="token punctuation">;</span>      <span class="token comment">/* Inode number */</span>
  __le16  rec_len<span class="token punctuation">;</span>    <span class="token comment">/* Directory entry length */</span>
  __le16  name_len<span class="token punctuation">;</span>    <span class="token comment">/* Name length */</span>
  <span class="token keyword">char</span>  name<span class="token punctuation">[</span>EXT4_NAME_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">/* File name */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">ext4_dir_entry_2</span> <span class="token punctuation">{</span>
  __le32  inode<span class="token punctuation">;</span>      <span class="token comment">/* Inode number */</span>
  __le16  rec_len<span class="token punctuation">;</span>    <span class="token comment">/* Directory entry length */</span>
  __u8  name_len<span class="token punctuation">;</span>    <span class="token comment">/* Name length */</span>
  __u8  file_type<span class="token punctuation">;</span>
  <span class="token keyword">char</span>  name<span class="token punctuation">[</span>EXT4_NAME_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">/* File name */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在目录文件的块中，最简单的保存格式是列表，就是一项一项地将 ext4_dir_entry_2 列在哪里。</p><p>每一项都会保存这个目录的下一级的文件的文件名和对应的 inode，通过这个 inode，就能找到真正的文件。第一项是“.”，表示当前目录，第二项是“…”，表示上一级目录，接下来就是一项一项的文件名和 inode。</p><p>有时候，如果一个目录下面的文件太多的时候，我们想在这个目录下找一个文件，按照列表一个个去找，太慢了，于是我们就添加了索引的模式。</p><p>如果在 inode 中设置 EXT4_INDEX_FL 标志，则目录文件的块的组织形式将发生变化，变成了下面定义的这个样子：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">dx_root</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">fake_dirent</span> dot<span class="token punctuation">;</span>
  <span class="token keyword">char</span> dot_name<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">fake_dirent</span> dotdot<span class="token punctuation">;</span>
  <span class="token keyword">char</span> dotdot_name<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">dx_root_info</span>
  <span class="token punctuation">{</span>
    __le32 reserved_zero<span class="token punctuation">;</span>
    u8 hash_version<span class="token punctuation">;</span>
    u8 info_length<span class="token punctuation">;</span> <span class="token comment">/* 8 */</span>
    u8 indirect_levels<span class="token punctuation">;</span>
    u8 unused_flags<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  info<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">dx_entry</span>  entries<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然，首先出现的还是差不多的，第一项是“.”，表示当前目录；第二项是“…”，表示上一级目录，这两个不变。接下来就开始发生改变了。是一个 dx_root_info 的结构，其中最重要的成员变量是 indirect_levels，表示间接索引的层数。</p><p>接下来我们来看索引项 dx_entry。这个也很简单，其实就是文件名的哈希值和数据块的一个映射关系。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">dx_entry</span>
<span class="token punctuation">{</span>
  __le32 hash<span class="token punctuation">;</span>
  __le32 block<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们要查找一个目录下面的文件名，可以通过名称取哈希。如果哈希能够匹配上，就说明这个文件的信息在相应的块里面。然后打开这个块，如果里面不再是索引，而是索引树的叶子节点的话，那里面还是 ext4_dir_entry_2 的列表，我们只要一项一项找文件名就行。通过索引树，我们可以将一个目录下面的 N 多的文件分散到很多的块里面，可以很快地进行查找。</p><img src="`+m+`" alt="img" style="zoom:25%;"><h2 id="软链接和硬链接的存储格式-跨文件系统" tabindex="-1"><a class="header-anchor" href="#软链接和硬链接的存储格式-跨文件系统" aria-hidden="true">#</a> 软链接和硬链接的存储格式/跨文件系统</h2><p>还有一种特殊的文件格式，<strong>硬链接（Hard Link）<strong>和</strong>软链接（Symbolic Link）</strong>。在讲操作文件的命令的时候，我们讲过软链接的概念。所谓的链接（Link），我们可以认为是文件的别名，而链接又可分为两种，硬链接与软链接。通过下面的命令可以创建。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code> ln <span class="token punctuation">[</span>参数<span class="token punctuation">]</span><span class="token punctuation">[</span>源文件或目录<span class="token punctuation">]</span><span class="token punctuation">[</span>目标文件或目录<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>ln -s 创建的是软链接，不带 -s 创建的是硬链接。它们有什么区别呢？在文件系统里面是怎么保存的呢？</p><ul><li>如图所示，硬链接与原始文件共用一个 inode 的，但是 inode 是不跨文件系统的，<br> 每个文件系统都有自己的 inode 列表，因而<strong>硬链接是没有办法跨文件系统的</strong>。</li><li>而软链接不同，软链接相当于重新创建了一个文件。<br> 这个文件也有独立的 inode，只不过打开这个文件看里面内容的时候，内容指向另外的一个文件。<br> 这就很灵活了。我们<strong>软链接可以跨文件系统</strong>，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</li></ul><img src="`+v+'" alt="img" style="zoom:25%;"><h2 id="总结时刻" tabindex="-1"><a class="header-anchor" href="#总结时刻" aria-hidden="true">#</a> 总结时刻</h2><p>这一节，我们描述了复杂的硬盘上的文件系统，但是对于咱们平时的应用来讲，用的最多的是两个概念，一个是 inode，一个是数据块。</p><p>这里我画了一张图，来总结一下 inode 和数据块在文件系统上的关联关系。</p><p>为了表示图中上半部分的那个简单的树形结构，在文件系统上的布局就像图的下半部分一样。无论是文件夹还是文件，都有一个 inode。inode 里面会指向数据块，对于文件夹的数据块，里面是一个表，是下一层的文件名和 inode 的对应关系，文件的数据块里面存放的才是真正的数据。</p><img src="'+b+'" alt="img" style="zoom:25%;"><h2 id="课堂练习" tabindex="-1"><a class="header-anchor" href="#课堂练习" aria-hidden="true">#</a> 课堂练习</h2><p>你知道如何查看 inode 的内容和文件夹的内容吗？</p><p>欢迎留言和我分享你的疑惑和见解 ，也欢迎可以收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习和进步。</p><h2 id="课后讨论" tabindex="-1"><a class="header-anchor" href="#课后讨论" aria-hidden="true">#</a> 课后讨论</h2><ul><li>磁盘→盘片→磁道→扇区(每个 512 字节)</li><li>ext* 定义文件系统的格式</li><li>inode 与数据块</li><li>硬盘分为大小相同的单元→块 ( block ), 大小 4K, 扇区的整数倍, 大小在格式化时可配置 <ul><li>因此, 存放文件时不用分配连续的空间</li><li>也因此要为文件建立块索引 + 元数据(名字, 权限, 所属) 信息, 存放于 inode 中</li><li>inode 还维护三个时间: i_atime 访问时间; i_ctime 更改 inode 时间; i_mtime 更改文件时间</li><li>文件分为多个块, 每个块的位置存放在 inode 的 i_block 中, 共 15 项</li><li>ext2 和 ext3 中, 前 12 项保存块的位置, 若文件较大, 则第十三项指向间接块, 间接块存放剩余数据块的位置; 文件再大, 第 14 项指向两级间接块, 以此类推 <ul><li>但上述, 大文件需要访问多个块才能读取到数据</li><li>ext4 引入 Extents 概念, 可以用于存放连续的数据块</li><li>Extents 是树形结构, 每个节点由一个头 ext4_extend_header 来描述节点</li><li>节点有多个项, 对于叶子节点: 每项直接指向硬盘上的连续块的地址; 分支节点: 每项指向下一层节点 <ul><li>文件不大: inode 可放下一个头 + 4 个数据项, eh_depth = 0 表示数据节点</li><li>文件较大: 除了根节点(存于 inode.i_block 中) , 其他节点都存于一个块中, 4K 能存 340 项, 每项可放 128MB, 总 42.5GB</li></ul></li></ul></li></ul></li><li>inode 位图与块位图</li><li>要保存数据是, 应放在哪? 全扫一遍效率低 <ul><li>用一个块保存 inode 位图, 每一位对应一个 inode, 1→被占用; 同样用一个块保存块位图</li><li>open 再空文件夹下创建文件: do_sys_open→...→lookup_open 再调用 dir_node→i_op_create(ext4_create) 创建文件夹 inode</li><li>调用 ext4_create→...→__ext4_new_inode 读取 inode 位图, 找到下一个空闲 inode <ul><li>同样用块位图找空闲块</li></ul></li></ul></li><li>文件系统格式</li><li>一个位图只能表示 2^15 个数据块, 即 128MB <ul><li>一个 inode 位图 + 一个 block 位图, 称为块组, 用数据结构 ext4_group_desc 表示, 里面包含 inode 位图, block 位图和 inode 列表</li><li>这些块组描述符构成列表, 另外用超级块 ext4_super_block 描述整个文件系统; 第一个块组前 1k 用于启动引导</li><li>文件系统由引导块 + N 个块组组成; 每个块组由: 超级块 + 块组描述符表 + 块位图 + inode 位图 + inode 列表 + 数据块构成</li><li>超级块和块组描述符表都是全局信息; 默认超级块和块组描述符表再灭个租客都有备份; 若开启 sparse_super, 则只在固定块组中备份</li><li>采用 Meta Block Groups 特性, 避免块组表浪费空间, 或限制文件系统的大小</li><li>将块组分成多个组(元块组) 块组描述符表只保存当前元块组中块组的信息, 并在元块组内备份</li></ul></li><li>目录存储格式</li><li>目录也是文件, 也有 inode, inode 指向一个块, 块中保存各个文件信息, ext4_dir_entry 包括文件名和 inode, 默认按列表存 <ul><li>第一项 &quot;.&quot; 当前目录; 第二项 &quot;..&quot; 上一级目录</li><li>可添加索引, 加快文件查找</li><li>需要改变目录块格式, 加入索引树: 用索引项 dx_entry 保存文件名哈希和块的映射, 若该块不是索引, 则里面保存 ext4_dir_enry 列表, 逐项查找</li></ul></li><li>软连接/硬链接的存储</li><li>链接即文件的别名: ln -s 创建软链接; ln 创建硬链接 <ul><li>硬链接与原始文件共用一个 inode, 但不能跨文件系统</li><li>软链接是一个文件, 有自己的 inode, 该文件内容指向另一个文件, 可跨文件系统</li></ul></li></ul><p>每个 extent 最大能表示 128MB 的数据。<br> 疑问：ee_len大小为16bit，最大能表示2^16 - 1,如果块大小为4K，则一个extent能表示256MB<br> 解惑：ee_len为一个16bit的无符号整数，但是其最高位在预分配特性中用来标识这个extent是否被初始化过了，所有ee_len中可用的位为15bit，最大可表示2^15个连续的块，如果块大小为4K，则一个extent最大能表示128MB</p><p>[课后作业]<br> 查看文件inode:stat filename<br> 查看目录inode:stat dirname<br> 查看磁盘inode:df -i</p><p>每次ls的时候，文件夹大小都显示4096，原来是一个块的大小，4k<br> vim 文件夹 能看到文件夹下的文件列表<br> 作者回复: 对的</p>',114),x={href:"https://blog.csdn.net/liushengxi_root/article/details/80962979",target:"_blank",rel:"noopener noreferrer"},f=s("br",null,null,-1),y={href:"https://blog.csdn.net/dyw_666666/article/details/107251134",target:"_blank",rel:"noopener noreferrer"},w=s("br",null,null,-1),E=s("br",null,null,-1),L={href:"http://1.ls",target:"_blank",rel:"noopener noreferrer"},B=s("br",null,null,-1),N=s("br",null,null,-1),M=s("p",null,[n("老师，您好。相同的文件夹在不同Linux机器上用ls -U得到的顺序也不一样。这是什么原因呢？文件系统如何确定文件夹中不同文件iNode的存储顺序的？"),s("br"),n(" 作者回复: 创建的顺序也不一样呀。ls没有访问文件的Inode，仅仅访问了文件夹的内容")],-1),T={href:"https://www.cnblogs.com/f-ck-need-u/p/7016077.html#auto_id_26",target:"_blank",rel:"noopener noreferrer"},I=t("<p>偷偷地问一句，4K对齐是不是就跟一个block默认大小是4K有关？<br> 作者回复: 有的，缓存的时候好弄</p><p>刷第三遍：block跟扇区是存储层面的概念，是用来管理空间的。inode是文件管理的概念，用来索引文件的。因为一个文件可能需要多个block才能完全存储下来</p><p>ext2/ext3:<br> i_block[0-11]: 12 x 4k = 48k （&lt; 48k）<br> i_block[12]: 4k x 4k = 16M (&gt;48k &amp;&amp; &lt; （16M+48k） 需要用到)<br> i_block[13]:4k x 4k x 4k = 64G(&gt;（16M+48k） &amp;&amp; &lt; （64G+16M+48k） 一般也最多用到这一级)<br> ext4:<br> i_block:4 x 128M = 512M<br> depth = 1: 340 x 128 = 42.5G (一般也就用到这里，2个header + 344个extent)<br> 对于大文件：<br> ext2/ext3:每多读4K，需要一次或多次硬盘io？<br> ext4:每多读128M，需要一次或多次硬盘io？</p><p>老师，链接这种文件，如果是引用了一个inode，那么这个链接文件的名称信息是存储在哪儿呢？<br> 网友回复：这个是看软硬链接吧，如果共用一套inode的话，那是在真正的文件所在的文件系统里面，如果不是的话，那么各自都会有</p><p>为啥系统块大小是4096但是stat出来的blocks按照512b算呢，显示8个blocks？<br> 网友回复：512字节那个是扇区的大小，4096是文件系统的一个存储块的大小，一个块=8*扇区</p><p>超总，请教个硬链接的问题，一个inode对应一个文件，一个文件硬链接出另外一个文件。当删除一个文件的时候，inode 还有效？那inode什么时候无效？<br> 网友回复：有效，除非这个inode没有对应任何文件才会被系统清理掉</p><p>目录文件和后边讲的目录项（dentry）的关系是什么呢？<br> 我理解目录文件里边的内容就是 目录项列表（即目录文件下边的每一个普通文件和目录文件的目录项集合）<br> 作者回复: dentry不止表示目录项，后面讲内存中结构的时候会讲</p><p>git的底层文件设计，是不是也借鉴了ex4的inode和块</p><p>硬链接既然inode是相同的，那么创建硬链接文件系统做了啥工作呢？<br> 网友回复：仅仅是在对应的目录下面，加了一行记录，也就是文件名与inode的那一行，只不过inode是相同的，文件名不同的而已</p><p>老是，麻烦解惑一下，会出现一个文件的inode在一个块组中，而其数据块在另一个块组中吗？<br> 作者回复: 在同一个块组中</p><p>老师，系统启动时是先挂载到内存等磁盘驱动程序完成后，再把根目录挂载到磁盘嘛？初始挂载得目录是什么时候生成的？<br> 作者回复: 是的</p><p>老师，inode里面的i_block不是有15项吗，为什么说超过4项ext4_extent就要分裂成树呢？<br> 作者回复: 大小和原来的不一样了，看一下一个extent占用的字节数。一个i_block32位，4字节，一个ext4_extent占12字节，i_block[15]只能放15*4/12=5个ext4_extent，第一个是头结点，后面4项放数据节点，超过4就要分裂了啊</p><p><strong>文件在文件系统中使用 inode 来描述, 每个 inode 中都含有一些列的数据块</strong></p><ul><li>对于普通文件: 数据块中保存的是文件数据</li><li>对于文件夹: 数据块中保存的是子文件的文件项</li><li>为了加快文件夹中文件的搜索速度, Linux 通过索引模式, 可以使用文件名的散列快速定位到文件的位置</li></ul><p><strong>软链接与硬链接</strong></p><ul><li>软链接: 在链接目标文件之前, 会创建自己的 inode 和数据块, 然后其数据块中的内容指向目标文件</li><li>可跨系统链接</li><li>硬链接: 即为一个文件创建了一个别名, 这个别名会指向真实文件的 inode 结构体</li><li>因为直接指向源文件结构体, 因此他无法跨文件系统进行链接</li></ul><p><strong>文件的组织</strong></p><ul><li>Linux 中将磁盘的块分成一个个的块组, 每个块组由一个块组的位图和对应的数据块描述, 最大可描述 128M 的空间</li><li>每个块组有其对应的块组描述符, 描述符之间形成一个链表</li><li>为了更好地管理块组, Linux 通过元块组来描述块组</li><li>一个元块组中由 64 个块组组成, 其中的块组描述符一共 64 项, 分别在 0, 1, 63 的位置的块组上备份三份</li><li>整个文件系统通过超级块来描述</li></ul>",18);function K(C,O){const a=o("ExternalLinkIcon");return i(),c("div",null,[h,s("p",null,[n("老师可以贴一些操作系统磁盘管理的基础概念方便理解，比如这个讲索引存储"),s("a",x,[n("https://blog.csdn.net/liushengxi_root/article/details/80962979"),e(a)]),f,n(" 还有这个讲超级块比较清楚一些，超级块就是可用块集，可以分级，和内存管理多级页表类似，用来分配空闲块"),s("a",y,[n("https://blog.csdn.net/dyw_666666/article/details/107251134"),e(a)]),w,n(" 我没找到合适的完整文档")]),s("p",null,[n("针对ext2/ext3/ext4， 可以通过以下命令查看inode信息"),E,s("a",L,[n("1.ls"),e(a)]),n(" -i 文件名或目录名"),B,n(' 2.sudo debugfs -R "stat 文件名或目录名" /dev/sdb2'),N,n(" 3.stat 文件名或目录名")]),M,s("p",null,[n("看两遍以上还蒙的朋友，看看这篇文章吧。非常清晰："),s("a",T,[n("https://www.cnblogs.com/f-ck-need-u/p/7016077.html#auto_id_26"),e(a)])]),I])}const z=p(g,[["render",K],["__file","J28-硬盘文件系统.html.vue"]]);export{z as default};
