import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o,c as p,a as i,b as a,e as s,d as l}from"./app-cdabc73c.js";const c="/assets/640-1689745710873-113-576b1fb4.png",g="/assets/640-1689745710873-114-27b732ec.png",e="/assets/640-1689745710874-115-57bb9cca.png",d="/assets/640-1689745710874-116-b980f3e2.png",m="/assets/640-1689745710874-117-39a46819.png",f="/assets/640-1689745710874-118-276eb1d5.png",h="/assets/640-1689745710874-119-cdf9e298.png",S="/assets/640-1689745710874-120-d1dc5abb.png",u="/assets/640-1689745710874-121-f2bee7d6.png",_="/assets/640-1689745710874-122-f20a214c.png",F="/assets/640-1689745710874-123-2e10fa96.png",k={},A=i("h1",{id:"_78-白泽带你读论文-fast",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#_78-白泽带你读论文-fast","aria-hidden":"true"},"#"),a(" 78-白泽带你读论文｜FAST")],-1),T={href:"https://yinzhicao.org/FAST/ODGen-FAST.pdf",target:"_blank",rel:"noopener noreferrer"},b=l('<p><strong>如需转载请注明出处，侵权必究。</strong></p><p>论文题目：<strong>Scaling JavaScript Abstract Interpretation to Detect and Exploit Node.js Taint-style Vulnerability</strong></p><p><strong>发表会议：S&amp;P 23</strong></p><p>本文第一作者是来自Johns Hopkins University的Mingqing Kang，师从Yinzhi Cao教授。课题组主要研究如何使用程序分析技术解决Web、智能手机以及机器学习领域的安全和隐私问题。</p><h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><p><mark>污点类型（Taint-style）漏洞</mark>（例如命令注入和路径穿越漏洞）是一类常见且危害较大的漏洞。现有的方法在检测此类漏洞时在规模化和准确性方面难以平衡。一方面，现有的语法导向方法（Syntax-directed）在分析具有动态特性（如括号语法）的语言（如JavaScript）时会牺牲准确性。另一方面，现有的抽象解释方法（Abstract Interpretation）面临抽象领域中的状态爆炸问题，导致无法规模化检测。</p><p>本文提出FAST工具，利用新颖的抽象解释方法来提升针对<em>JavaScript包</em>的漏洞大规模检测能力。该方法依赖于两种新技术，</p><ol><li>即自下而上抽象解释，基于作用域（而不是传统的基于调用序列）来抽象地解释函数，并在此基础上构建控制流调用边；</li><li>以及自上而下抽象解释，遍历特定的控制流路径并修剪程序，以跳过与污点无关的语句。</li></ol><p>如果找到了端到端的数据流路径，则FAST将尝试求解路径约束，自动生成攻击代码来验证漏洞的可利用性，以减少人力投入。</p><p>作者实现了FAST的原型，并对NPM上的Node.js软件包进行评估。实验表明FAST能够在NPM中找到242个0-day漏洞，共计获得21个CVE。实验证明FAST可以扩展到现实世界的应用程序（例如NodeBB），以及流行的框架（例如total.js和strapi），以发现之前工作未检出的漏洞。</p><h2 id="贡献" tabindex="-1"><a class="header-anchor" href="#贡献" aria-hidden="true">#</a> 贡献</h2><ol><li>提出一种自底向上和自顶向下两阶段的抽象解释方法，以解决漏洞检测精度和规模化难以平衡的问题。</li><li>实现开源静态分析工具原型 FAST，以检测污点类型漏洞。</li><li>实验表明FAST在减少漏报方面显著优于现有工具。</li></ol><h2 id="背景" tabindex="-1"><a class="header-anchor" href="#背景" aria-hidden="true">#</a> 背景</h2><p><strong>污点类型漏洞</strong></p><p>污点类型漏洞是一类比较常见的漏洞，此类漏洞一般是由于外部控制的输入数据在未经过滤的情况下到达敏感函数导致的。这类漏洞最终会造成服务劫持、信息泄露等安全问题。常见的污点类型漏洞包括：</p><ul><li><ul><li><ul><li>外部输入注入<em>OS命令</em>造成的命令注入漏洞。</li><li>外部输入注入的<em>未授权资源路径</em>造成的路径穿越漏洞。</li><li>外部输入注入<em>能够执行的代码</em>造成的任意代码执行漏洞。</li></ul></li></ul></li></ul><hr><p><strong>JavaScript 等语言的动态特性</strong></p><p>对于污点类型漏洞的自动化检测，一个直接的想法是使用传统的静态分析方法，去构建<mark>控制流图</mark>与<mark>数据流图</mark>，但是由于JavaScript是一种基于原型（prototype）的脚本语言，具有大量的动态特性。这些动态特性使得如果<em>不提供运行时上下文信息，那么大量的调用边是无法解析的</em>。也就是说，仅使用语法导向的静态分析会使得构建出来的调用图不准确，因此需要针对JavaScript等语言的动态特性定制解决方案。</p><p><strong>现有工作的局限性</strong></p><p>为了解决语法导向的静态分析精度不高的问题，相关工作提出了抽象解释的思路，即以图或者矩阵的形式存储分析所需的上下文信息，用于调用边的解析。理论上这是能够解决调用边的解析问题，但是由于目前工作在分析时会尝试探索所有可能的程序状态，这也带来了路径爆炸的问题。</p><h2 id="挑战" tabindex="-1"><a class="header-anchor" href="#挑战" aria-hidden="true">#</a> 挑战</h2><p>对于JavaScript等具有动态特性的复杂语言，传统静态分析无法在精确性和规模化之间达到较好的平衡。一方面，JavaScript语言的动态特性、复杂且灵活的语法，以及Promise特性使得传统静态分析在建模时难以实现较高的精确度。另一方面，现有的抽象解释方法会尝试对所有程序执行的状态进行探索，进而导致状态爆炸问题，使得方法无法应对规模较大的软件项目。</p><p>除此之外，对于静态分析检测出的漏洞进行自动化验证同样存在挑战。针对特定漏洞，前人的工作仅仅提取出了source与sink之间的数据流，然后依赖人工审计来过滤误报，会消耗安全研究者大量的时间和精力，因此作者希望<em>工具能够自动化生成漏洞利用代码</em>，来验证检测出的漏洞。</p><h2 id="insight" tabindex="-1"><a class="header-anchor" href="#insight" aria-hidden="true">#</a> Insight</h2><p>为了解决精确性和规模化之间的矛盾，作者的想法是尽可能地在抽象解释过程中仅分析source点到sink点相关的表达式与函数，从而裁剪掉无关的程序语句，<em>以减少程序分析的规模</em>。对于整个方法带来的规模化能力和精确度提升，作者给出了如下形象的图示：</p><figure><img src="'+c+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>此外，为了解决自动化利用代码生成（AEG）问题，FAST在抽象域中注解所有对象（object）之间的依赖关系，然后提取之前生成的控制流和数据流约束条件，最后进行约束求解，以生成漏洞利用代码。</p><h2 id="工作流程" tabindex="-1"><a class="header-anchor" href="#工作流程" aria-hidden="true">#</a> 工作流程</h2><p>FAST整体分为三个阶段，分别是<mark>控制流路径生成</mark>（Control Flow Path Generation）、<mark>数据流路径生成</mark>（Data Flow Path Generation）和<mark>利用代码生成</mark>（Exploit Generation）。</p><ol><li>控制流路径生成阶段使用自底向上的抽象解释构建函数间与函数内部的控制流图，获取从source到sink的控制流路径。</li><li>数据流路径生成阶段基于上述生成的函数间与函数内部的控制流图，使用自顶向下的抽象解释来生成准确和包含足够信息的数据流路径。</li><li>利用代码生成阶段利用控制流和数据流路径生成的约束条件，使用<mark>约束求解器</mark>求解约束，然后生成漏洞利用代码。</li></ol><figure><img src="'+g+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p><strong>阶段一：控制流路径生成</strong></p><p>此阶段的目的是找到sink点和source点之间的路径。具体来说，方法会忽略函数的调用序列，而仅关注<mark>函数的作用域（scope）</mark>，也就是只构建函数内的控制流图。例如对于如下函数compress，其控制流示意图如下所示：</p><figure><img src="'+e+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>然后，方法构建Function Dependency Graph（FDG）以标注所有函数的依赖关系，此步骤是为了解决JS的<em>函数指针</em>和<em>动态特性</em>导致的调用链缺失问题。例如对于下图中promisify函数的参数fn，在静态分析时只能确定其函数名，而无法确定具体调用的是什么函数（需要等待execProcess函数里childProcess[method]部分解析完成后才能够确定）。因此为了不丢失函数之间的调用关系，需要先在函数依赖图中标记promisify和fn之间存在的依赖关系，以便于后续fn函数的具体指向解析完成后构建完整的控制流图。</p><figure><img src="'+d+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>作者定义函数依赖图包含的四种依赖关系：</p><ol><li>Lookup Dependency（由闭包或外部作用域中的函数指针查找引起的依赖关系）、</li><li>Callback Dependency（由回调函数引起的依赖关系）、</li><li>Return Dependency（由另一个函数返回的函数调用引起的依赖关系）、</li><li>Promise Dependency（由Promise引起的依赖关系）。</li></ol><p>下图是上图代码片段中针对Promise函数生成的函数依赖图：</p><figure><img src="'+m+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>接下来，在函数依赖图的基础上构建函数间的控制流图。控制流图的构建主要考虑三种类型的表达式：</p><ol><li>函数调用：直接可解析函数调用；无法直接解析的函数调用（需要借助FDG）；Return相关的函数调用和回调相关的函数调用。</li><li>函数定义：回调、返回函数和函数表达式类型的函数定义。</li><li>Promise相关语句。最终根据控制流图生成source到sink的控制流路径。整体流程图如下：</li></ol><figure><img src="'+f+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p><strong>阶段二：数据流路径生成</strong></p><p>此阶段的目的是构建出数据流图，并验证漏洞存在。</p><p>此处首先采用过程内后向切片技术，来为每个函数生成函数内的数据流图。具体来说，根据上一阶段得到的函数间控制流关系，就可以从到sink点的中间函数出发，反向找出仅与sink点相关的语句，<em>对其他无关语句剪枝</em>，然后在数据流图上构建数据边，如下所示：</p><figure><img src="'+e+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>然后，FAST基于控制流路径和程序后向切片的结果，对裁剪后的程序语句子集进行抽象解释，即自顶向下的抽象解释。此过程包括两个步骤，首先是object级别的数据流生成，FAST在object之间创建数据流，为数据流图构造数据边。第二步是路径敏感信息的收集，当FAST对某个分支的代码进行抽象解释时，会传入当前的路径敏感信息到当前的分支栈中，当抽象解释完成时，再从分支栈里pop出相应的路径敏感对象。</p><p>最后进行数据流搜索与漏洞检测。首先FAST会通过模式匹配和搜索所有预定义的函数来找到source点。其次，FAST采用深度优先搜索来找到source到sink的数据流路径，并限制每个语句的访问次数以避免循环。</p><p>程序内数据流图的例子如下所示：</p><figure><img src="'+h+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p><strong>阶段三：利用代码生成</strong></p><p>此阶段为一个漏洞生成利用代码，具体包括三部分：<mark>类型推断</mark>、<mark>约束提取</mark>以及<mark>Exploit代码生成</mark>。</p><p>由于JavaScript是弱类型语言，但约束求解器需要提供类型信息才能进行求解，因此需要确定输入约束的变量类型。作者提出两种确定变量类型的方法，</p><ol><li>前向推导：遵循数据流从一个对象到它在内置函数中的使用，并根据特定的内置函数推导出类型。</li><li>后向推导：指FAST从一个对象开始向后追踪数据流，并且遍历所有与该对象相关的数据流，根据相关对象来反向推导变量类型。</li></ol><p>然后基于数据流和控制流路径生成约束。此处主要有三种约束：1. Sink对象约束2. 路径约束。3. 常量约束。</p><p>最后约束求解生成利用代码。从sink点出发，获取sink相关的对象与操作符。随后将相关对象与操作符构成的约束添加到约束池中，不断循环直到提取到sink点与source点一个路径上的所有约束。然后进行约束求解，生成漏洞利用代码。最后通过运行利用代码来验证生成的利用是否有效，无效则再次进行之前的步骤，直到验证成功或是所有路径都已经遍历过。</p><h2 id="实验评估" tabindex="-1"><a class="header-anchor" href="#实验评估" aria-hidden="true">#</a> 实验评估</h2><p><strong>RQ1：对比现有工作挖掘的Zero-Day漏洞</strong></p><p>FAST对比ODGen和CodeQL两个SOTA工具，在100k个真实世界的Node.js软件包中检测到242个Zero-Day漏洞，并成功地自动生成182个漏洞的exploit，其中21个漏洞被分配了CVE。</p><p>作者认为FAST效果更好的原因是其降低了程序分析的开销，使得工具能够跑出更多的结果，并且能够处理JavaScript异步编程、括号语法等之前工作没能处理的复杂特性。</p><figure><img src="'+S+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p><strong>RQ2：误报率与漏报率</strong></p><p>针对给定100k Node.js软件包的数据集，FAST-det以最低的FP和FN优于所有SOTA方法。其中，FAST-det在规模化方面的提升使得它优于现有的抽象解释方法（即ODGen）。此外，由于抽象解释能够解决JavaScript动态特性难以处理的问题，因此FAST-det优于现有的语法导向方法（例如CodeQL）。</p><p>FAST漏报的主要原因是存在一些未建模的source与sink，导致数据流丢失。相比之下，ODGen的漏报主要是由于代码覆盖率较低，即在分析期间可能无法到达某些漏洞点。CodeQL的漏报原因则是无法处理动态JavaScript功能，例如与括号语法相关的函数调用。而FAST-det误报主要原因是许多应用程序有控制流和数据流的sanitizations，这使得部分检测的漏洞实际上是无法利用的。</p><p>而另一方面，FAST-exp的误报率为零，但漏报率相对较高。这是因为Z3求解器在有限时间内无法求解约束条件。但是作者提出这部分复杂的漏洞利用代码可以由人工构造。误报与漏报的实验结果如下所示：</p><figure><img src="'+u+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p><strong>RQ3：Scalability</strong></p><p>对于大规模项目（&gt;10K LoC）的实验测试数据集，FAST能够检测14个漏洞中的10个，甚至在拥有近200K行代码的strapi中也能够执行分析检测。相比之下，ODGen在分析漏洞一天后依然无法检测到漏洞（甚至会崩溃）。但是作者发现FAST漏报了其中三个漏洞，而漏报的原因是某些source和sink建模失败。</p><figure><img src="'+_+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p><strong>RQ4：Call Edges构建的FN与FP</strong></p><p>在这个实验中，作者比较FAST和现有方法（即抽象解释方法ODGen和语法导向方法JS Call Graph的开源实现）生成调用边的情况。</p><p>在漏洞数据集中，作者运行以上三种工具，来生成调用边，然后比较三种方法生成的结果，并手动检查三种方法生成调用边的正确性。检查所有调用边大约需要一个研究生230个小时。下面列出FAST调用边误报和漏报的原因：</p><p>FN：无法为未知对象（例如函数参数没有标准定义）构造调用边，以及建模嵌入式三元运算符的时候存在某些工程错误。</p><p>FP：无法识别回调函数是同步还是异步的，FAST会默认认为是同步的，导致调用图构建不精确。</p><p>调用图构建误报和漏报的实验结果如下所示：</p><figure><img src="'+F+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>本文提出了一种新颖的两阶段抽象解释方法FAST，用于检测和利用Node.js污点类型漏洞。FAST第一阶段（自下而上的抽象解释）生成source和sink之间的控制流路径。然后，第二阶段（自上而下的抽象解释）沿着控制流路径分析只与sink具有控制或者数据依赖关系的语句。与现有的抽象解释方法相比，<em>此种剪枝分析显著缓解状态爆炸问题</em>，并且提升了抽象分析方法的规模化能力。在两个阶段之后，FAST遍历sink相关的控制流路径，收集和求解数据和控制流约束，自动生成漏洞利用exploit。实验评估结果显示，FAST在减少误报和检测漏洞方面优于所有现有的方法。</p>',80);function x(y,D){const t=n("ExternalLinkIcon");return o(),p("div",null,[A,i("p",null,[i("a",T,[a("yinzhicao.org/FAST/ODGen-FAST.pdf"),s(t)]),a("。")]),b])}const G=r(k,[["render",x],["__file","78-白泽带你读论文｜FAST.html.vue"]]);export{G as default};
