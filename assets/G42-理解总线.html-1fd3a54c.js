import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as m,c as i,a as r,b as e,e as t,d as s}from"./app-cdabc73c.js";const p="/assets/afdf06aeb84a92a9dfe5e9d2299e6958-6ac949aa.jpeg",k="/assets/1c6002fabbb80407a34afec76cdb5f53-06699cda.jpeg",d="/assets/4ddbb489ceaac5e7a2c8491178db1cf9-bf8e5802.jpeg",c="/assets/f58610f211422d71ff50eeeeb729d166-91d4ad10.jpeg",l={},h=s('<h1 id="_42-总线-计算机内部的高速公路" tabindex="-1"><a class="header-anchor" href="#_42-总线-计算机内部的高速公路" aria-hidden="true">#</a> 42 | 总线：计算机内部的高速公路</h1><p>专栏讲到现在，如果我再问你，计算机五大组成部分是什么，应该没有人不知道了吧？我们这一节要讲的内容，依然要围绕这五大部分，控制器、运算器、存储器、输入设备和输出设备。</p><p>CPU 所代表的控制器和运算器，要和存储器，也就是我们的主内存，以及输入和输出设备进行通信。那问题来了，CPU 从我们的键盘、鼠标接收输入信号，向显示器输出信号，这之间究竟是怎么通信的呢？换句话说，计算机是用什么样的方式来完成，CPU 和内存、以及外部输入输出设备的通信呢？</p><p>这个问题就是我们今天要讲的主题，也就是<strong>总线</strong>。之前很多同学留言问，我什么时候会讲一讲总线。那这一讲，你就要听仔细了。</p><h2 id="降低复杂性-总线的设计思路来源" tabindex="-1"><a class="header-anchor" href="#降低复杂性-总线的设计思路来源" aria-hidden="true">#</a> 降低复杂性：总线的设计思路来源</h2><p>计算机里其实有很多不同的硬件设备，除了 CPU 和内存之外，我们还有大量的输入输出设备。可以说，你计算机上的每一个接口，键盘、鼠标、显示器、硬盘，乃至通过 USB 接口连接的各种外部设备，都对应了一个设备或者模块。</p><p>如果各个设备间的通信，都是互相之间单独进行的。如果我们有 <em>N</em> 个不同的设备，他们之间需要各自单独连接，那么系统复杂度就会变成 <em>N</em>2。每一个设备或者功能电路模块，都要和其他 <em>N</em>−1 个设备去通信。为了简化系统的复杂度，我们就引入了总线，把这个 <em>N</em>2 的复杂度，变成一个 <em>N</em> 的复杂度。</p><p>那怎么降低复杂度呢？与其让各个设备之间互相单独通信，<strong>不如我们去设计一个公用的线路</strong>。CPU 想要和什么设备通信，通信的指令是什么，对应的数据是什么，都发送到这个线路上；设备要向 CPU 发送什么信息呢，也发送到这个线路上。<strong>这个线路就好像一个高速公路，各个设备和其他设备之间，不需要单独建公路，只建一条小路通向这条高速公路就好了</strong>。</p><img src="'+p+'" alt="img" style="zoom:25%;"><h2 id="事件总线-eventbus设计模式" tabindex="-1"><a class="header-anchor" href="#事件总线-eventbus设计模式" aria-hidden="true">#</a> 事件总线：EventBus设计模式</h2><p>这个设计思路，就是我们今天要说的<strong>总线</strong>（Bus）。</p><p>总线，其实就是一组线路。我们的 CPU、内存以及输入和输出设备，都是通过这组线路，进行相互间通信的。总线的英文叫作 Bus，就是一辆公交车。这个名字很好地描述了总线的含义。我们的“公交车”的各个站点，就是各个接入设备。要想向一个设备传输数据，我们只要把数据放上公交车，在对应的车站下车就可以了。</p>',12),_=r("em",null,"我们在做大型系统开发的过程中",-1),u={href:"https://dzone.com/articles/design-patterns-event-bus",target:"_blank",rel:"noopener noreferrer"},g=s('<p>进行大规模应用系统开发的时候，系统中的各个组件之间也需要相互通信。模块之间如果是两两之间单独去定义协议，这个软件系统一样会遇到一个复杂度变成了 <em>N</em>2 的问题。所以常见的一个解决方案，<strong>就是事件总线这个设计模式</strong>。</p><p>在事件总线这个设计模式里，各个模块触发对应的事件，并把事件对象发送到总线上。也就是说，<mark>每个模块</mark>都是<mark>一个发布者</mark>（Publisher）。<strong>而各个模块也会把自己注册到总线上</strong>，去监听总线上的事件，并根据事件的<mark>对象类型</mark>或者是<mark>对象内容</mark>，<strong>来决定自己是否要进行特定的处理或者响应</strong>。</p><p>这样的设计下，注册在总线上的各个模块就是松耦合的。模块互相之间并没有依赖关系。无论代码的维护，还是未来的扩展，都会很方便。</p><img src="'+k+'" alt="img" style="zoom:33%;"><h2 id="理解总线-三种线路和多总线架构" tabindex="-1"><a class="header-anchor" href="#理解总线-三种线路和多总线架构" aria-hidden="true">#</a> 理解总线：三种线路和多总线架构</h2><p>理解了总线的设计概念，我们来看看，总线在实际的计算机硬件里面，到底是什么样。</p><p>现代的 Intel CPU 的体系结构里面，通常有好几条总线。</p><p>首先，CPU 和内存以及高速缓存通信的总线，这里面通常有两种总线。这种方式，我们称之为**<code>双独立总线</code>**（Dual Independent Bus，缩写为 DIB）。CPU 里，</p><ol><li>有一个<em>快速</em>的**<mark>本地总线</mark>**（Local Bus），（不在图里）<br> 也叫：后端总线、缓存总线</li><li>以及一个<em>速度相对较慢</em>的**<mark>前端总线</mark>**（Front-side Bus）。<br> 也叫：处理器总线、系统总线</li></ol><p>我们在前面几讲刚刚讲过，现代的 CPU 里，通常有专门的高速缓存芯片。这里的高速<mark>本地总线</mark>，就是用来和<em>高速缓存</em>通信的。而<mark>前端总线</mark>，则是用来和 <em>主内存 以及 输入输出设备</em> 通信的。有时候，我们会把本地总线也叫作<mark>后端总线</mark>（Back-side Bus），和前面的<mark>前端总线</mark>对应起来。而前端总线也有很多其他名字，比如<mark>处理器总线</mark>（Processor Bus）、<mark>内存总线</mark>（Memory Bus）。</p><img src="'+d+'" alt="img" style="zoom:25%;"><p>除了前端总线呢，我们常常还会听到 <mark>PCI 总线</mark>、<mark>I/O 总线</mark>或者<mark>系统总线</mark>（System Bus）。看到这么多总线的名字，你是不是已经有点晕了。这些名词确实容易混为一谈。其实各种总线的命名一直都很混乱，我们不如直接来看一看 <strong>CPU 的硬件架构图</strong>。对照图来看，一切问题就都清楚了。</p><p>CPU 里面的北桥芯片，把我们上面说的前端总线，一分为二，变成了三个总线。</p><h2 id="_1-系统总线、内存总线、io总线" tabindex="-1"><a class="header-anchor" href="#_1-系统总线、内存总线、io总线" aria-hidden="true">#</a> 1 系统总线、内存总线、IO总线</h2><p>我们的前端总线，其实就是<strong>系统总线</strong>。CPU 里面的<mark>内存接口</mark>，直接和<mark>系统总线</mark>通信，然后系统总线再接入一个 <mark>I/O 桥接器</mark>（I/O Bridge）。这个 I/O 桥接器，一边接入了我们的<mark>内存总线</mark>，使得我们的 CPU 和内存通信；另一边呢，又接入了<mark>一个 I/O 总线</mark>，用来连接 I/O 设备。</p><p>事实上，真实的计算机里，这个总线层面拆分得更细。<em>根据不同的设备</em>，还会分成独立的 <mark>PCI 总线</mark>、<mark>ISA 总线</mark>等等。</p><img src="'+c+'" alt="img" style="zoom:25%;"><h2 id="_2-数据线、地址线、控制线" tabindex="-1"><a class="header-anchor" href="#_2-数据线、地址线、控制线" aria-hidden="true">#</a> 2 数据线、地址线、控制线</h2><p>在物理层面，其实我们完全可以把总线看作一组“电线”。不过呢，这些电线之间也是有分工的，我们通常有三类线路。</p><ol><li><mark>数据线</mark>（Data Bus），<strong>用来传输实际的数据信息</strong>，也就是实际上了公交车的“人”。</li><li><mark>地址线</mark>（Address Bus），<strong>用来确定到底把数据传输到哪里去</strong>，<br> 是<em>内存的某个位置</em>，还是<em>某一个 I/O 设备</em>。<br> 这个其实就相当于拿了个纸条，写下了上面的人要下车的站点。</li><li><mark>控制线</mark>（Control Bus），<strong>用来控制对于总线的访问</strong>。虽然我们把总线比喻成了一辆公交车。<br> 那么有人想要做公交车的时候，需要告诉公交车司机，这个就是我们的控制信号。</li></ol><p>尽管总线减少了设备之间的耦合，也降低了系统设计的复杂度，但同时也带来了一个新问题，那就是总线不能<strong>同时</strong>给多个设备提供通信功能。</p>',21),b=r("em",null,"我们的总线是很多个设备公用的，那多个设备都想要用总线，我们就需要有一个机制",-1),f=r("mark",null,"总线裁决",-1),I={href:"https://en.wikipedia.org/wiki/Arbiter_(electronics)",target:"_blank",rel:"noopener noreferrer"},B=s('<h2 id="总结延伸" tabindex="-1"><a class="header-anchor" href="#总结延伸" aria-hidden="true">#</a> 总结延伸</h2><p>好了，你现在明白计算机里的总线、各种不同的总线到底是什么意思了吧？希望这一讲能够帮你厘清计算机总线的知识点。现在我们一起来总结梳理一下这节的内容。</p><p>这一讲，我为你讲解了计算机里各个不同的组件之间用来通信的渠道，也就是总线。<em>总线的设计思路，核心是为了减少多个模块之间交互的复杂性和耦合度</em>。实际上，总线这个设计思路在我们的软件开发过程中也经常会被用到。<mark>事件总线</mark>就是我们常见的一个设计模式，通常事件总线也会和<mark>订阅者发布者模式</mark>结合起来，成为大型系统的各个松耦合的模块之间交互的一种主要模式。</p><p>在实际的硬件层面，总线其实就是一组连接电路的线路。因为不同设备之间的速度有差异，所以一台计算机里面往往会有多个总线。常见的就有<strong>在 CPU 内部</strong>和高速缓存通信的<mark>本地总线</mark>，以及**（在CPU外部的IO桥接器上）**和外部 I/O 设备以及内存通信的<mark>前端总线</mark>。</p><p>前端总线通常也被叫作<mark>系统总线</mark>。它可以通过<mark>一个 I/O 桥接器</mark>，拆分成两个总线，分别来和 I/O 设备以及内存通信。自然，这样拆开的两个总线，就叫作 <mark>I/O 总线</mark>和<mark>内存总线</mark>。总线本身的电路功能，又可以拆分成用来传输数据的<mark>数据线</mark>、用来传输地址的<mark>地址线</mark>，以及用来传输控制信号的<mark>控制线</mark>。</p><p>总线是一个各个接入的设备公用的线路，所以自然会在各个设备之间争夺总线所有权的情况。于是，我们需要一个机制来决定让谁来使用总线，这个决策机制就是<mark>总线裁决</mark>。</p><h2 id="推荐阅读" tabindex="-1"><a class="header-anchor" href="#推荐阅读" aria-hidden="true">#</a> 推荐阅读</h2>',7),P={href:"https://github.com/google/guava/wiki/EventBusExplained",target:"_blank",rel:"noopener noreferrer"},C={href:"https://en.wikipedia.org/wiki/Bus_(computing)",target:"_blank",rel:"noopener noreferrer"},U={href:"https://en.wikipedia.org/wiki/System_bus",target:"_blank",rel:"noopener noreferrer"},v=r("h2",{id:"课后思考",tabindex:"-1"},[r("a",{class:"header-anchor",href:"#课后思考","aria-hidden":"true"},"#"),e(" 课后思考")],-1),x={href:"https://en.wikipedia.org/wiki/Intel_QuickPath_Interconnect",target:"_blank",rel:"noopener noreferrer"},O=s("<p>欢迎在留言区分享你查阅到的资料，以及阅读之后的思考总结，和大家一起交流。如果有收获，你也可以把这篇文章分享给你的朋友。</p><blockquote><p>说到总线，我就想起了后端系统演进中，从最初的巨型单体，到具备总线的SOA，到最近完全去掉总线的微服务系统。总线这个东西在计算机体系诞生了很多年了，它虽然降低了各系统通信的复杂度，但是现在看缺点也不少，最典型的就是带宽问题，某些硬件的性能提升速度，超过了总线性能的提升速度，比如典型的使用PCIE的某些硬件，而且现代计算机系统对即时响应提出了更高的要求，总线很明显制约了这个东西。我在想如果微服务这种成百上千的，相互之间调用复杂的结构在现代技术的加持下也被证明是有效的话；那么如果把计算机的每个硬件抽象成1个服务，计算机硬件之间为何不能像微服务那样直接调用呢。当然硬件架构的发展比软件架构是保守和谨慎的多了。可能我这个想法也不太现实<br> 作者回复: 主要还是软件的修改比起硬件的修改的成本低太多了。而且其实现在大家的微服务，一般都是说一个公司内部的系统里。<br> 如果要多家不同公司之间协作（硬件的显卡、内存、硬盘都来自不桶厂商），传统的企业软件还是有专门的ESB（Enterprise Service Bus）这样的厂商。<br> 其他网友：微服务之间的连接都是逻辑连接 硬件的连接都是电路直接连接 硬件微服务就要在电路里搭类似网络和路由器节点的硬件了<br> 其他网友：想想维服务为什么能直接调用？软件网络直接调用相当于硬件中一个线路，本质还是N方，复杂度太高。要降复杂度，复用线路就是总线思路，完全复用总线，总线上就要加状态，否则硬件冲突问题无法解决，这样实现复杂度就会提升，造成响应时间上升。目前的总线方案，不复用和复用之间达到一个平衡，这样看来，平衡才是王道。</p><p>想不到主板上的总线bus，还真的和Guava的bus异曲同工。这篇课程让人既熟悉，又陌生，还充满惊喜。最近在重读《深入理解计算机系统》，要回头读读老师的文章了！</p><p>vue.js 里面有个 eventBus ， Vue.prototype.$EventBus<br> 作者回复: 没错，总线（Bus）本身就是来自现实生活中的抽象，无论在底层硬件还是抽象的软件中都有这个模式的应用。</p><p>文中的“系统总线与CPU的内存接口相连”这一句不是太懂，这个内存接口是指什么？ARM架构下的cpu芯片与外设相连，它会有一个存储器（里面会分成8个bank）来进行控制和管理IO设备。浩哥说的这个内存接口与arm的存储器类似么？<br> 作者回复: 说内存接口的确不太准确，这个我写得有点随意。更准确的说法是内存控制器 Memory Controller，通过这个来连接的总线。</p></blockquote>",2);function E(N,w){const a=o("ExternalLinkIcon");return m(),i("div",null,[h,r("p",null,[e("其实，对应的设计思路，在软件开发中也是非常常见的。"),_,e("，经常会用到一种叫作"),r("a",u,[e("事件总线（Event Bus）"),t(a)]),e("的设计模式。")]),g,r("p",null,[b,e("，去决定这种情况下，到底把总线给哪一个设备用。这个机制，就叫作**"),f,e("**（Bus Arbitraction）。总线裁决的机制有很多种不同的实现，如果你对这个实现的细节感兴趣，可以去看一看 Wiki 里面关于"),r("a",I,[e("裁决器"),t(a)]),e("的对应条目，这里我们就不多说了。")]),B,r("p",null,[e("总线是一个抽象的设计模式，它不仅在我们计算机的硬件设计里出现。在日常的软件开发中，也是一个常见的设计模式，你可以去读一读 Google 开源的 Java 的一个常用的工具库 Guava "),r("a",P,[e("的相关资料和代码"),t(a)]),e("，进一步理解事件总线的设计模式，看看在软件层面怎么实现它。")]),r("p",null,[e("对于计算机硬件层面的总线，很多教科书里讲得都比较少，你可以去读一读 Wiki 里面"),r("a",C,[e("总线"),t(a)]),e("和"),r("a",U,[e("系统总线"),t(a)]),e("的相关条目。")]),v,r("p",null,[e("2008 年之后，我们的 Intel CPU 其实已经没有前端总线了。Intel 发明了"),r("a",x,[e("快速通道互联"),t(a)]),e("（Intel Quick Path Interconnect，简称为 QPI）技术，替代了传统的前端总线。这个 QPI 技术，你可以搜索和翻阅一下相关资料，了解一下它引入了什么新的设计理念。")]),O])}const A=n(l,[["render",E],["__file","G42-理解总线.html.vue"]]);export{A as default};
