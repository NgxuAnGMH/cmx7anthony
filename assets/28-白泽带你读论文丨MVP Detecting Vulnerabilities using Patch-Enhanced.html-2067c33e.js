import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as n,d as i}from"./app-cdabc73c.js";const t="/assets/640-1691477360802-73-2b2cb49f.png",r="/assets/640-1691477360803-74-301e4c1e.png",s={},c=i('<h1 id="_28-白泽带你读论文丨mvp-detecting-vulnerabilities-using-patch-enhanced" tabindex="-1"><a class="header-anchor" href="#_28-白泽带你读论文丨mvp-detecting-vulnerabilities-using-patch-enhanced" aria-hidden="true">#</a> 28-白泽带你读论文丨MVP: Detecting Vulnerabilities using Patch-Enhanced</h1><p><strong>MVP: Detecting Vulnerabilities using Patch-Enhanced Vulnerability Signatures</strong></p><p>本文发表在USENIX Security 2020，第一作者是来自中科院信息工程研究所的Yang Xiao。</p><h2 id="_1-主要内容" tabindex="-1"><a class="header-anchor" href="#_1-主要内容" aria-hidden="true">#</a> <strong>1 主要内容</strong></h2><p>重复漏洞（Recurring Vulnerability）广泛存在于操作系统中，由于代码重用或是共享的代码逻辑，导致相同的安全漏洞也会在其他地方重复发生，而未被检测。为了定位该类重复漏洞，现有工作主要分为两类：</p><ul><li>(1)从漏洞所在函数中提取特征（token）如相关函数调用，并进行函数相似性计算（即Function matching-based approach）, 以此定位其他可能的漏洞函数。</li><li>(2)提取语法级别的签名（signature）并进行匹配分析（即Clone-based approach）。</li></ul><p>这些方法的缺陷在于缺乏对漏洞补丁（Patch）的存在性分析，以及对漏洞特性的精确描述，导致对应工具会漏报许多可能存在的漏洞，或是将打了补丁的版本误报为可能的安全漏洞。</p><p>于是，本文提出了一种新的检测工具：MVP，其能够对重复漏洞以及对应补丁的特征进行提取，并对代码切片技术（slicing technique）进行了优化改进，在目标系统中通过匹配漏洞特性以及检测补丁是否存在，有效减少了误报和漏报。作者使用MVP对10个C/C++开源项目进行了评估测试，<em>发现了97个尚未被发现的安全漏洞，并获得了23个CVE认证</em>。</p><h2 id="_2-设计与实现" tabindex="-1"><a class="header-anchor" href="#_2-设计与实现" aria-hidden="true">#</a> <strong>2 设计与实现</strong></h2><figure><img src="'+t+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h3 id="工作流程" tabindex="-1"><a class="header-anchor" href="#工作流程" aria-hidden="true">#</a> 工作流程</h3><p>如图是MVP的设计架构图，该工具是基于函数级别的重复漏洞静态检测框架，主要包含以下三个工作流程：</p><p>（1）MVP首先接收待检测系统函数的源代码，基于抽象语法树（AST）进行参数、局部变量和字符串的分析，然后对整个函数进行简化，用哈希对各个语句进行签名（signature），并且参考源代码生成的程序依赖图（PDG）来生成函数中各语句之间的依赖关系，组成对整个函数的描述，作为后续的待匹配集合。</p><p>（2）MVP接收已知漏洞及对应补丁的源代码，通过定位其中添加和删除的语句，利用改良的切片技术（slicing technique）找寻更多相关的语句，组成对漏洞和补丁的描述。有了这些描述，就可以在待匹配集合中计算漏洞和补丁出现的可能性。</p><p>（3）对于第二步中获取到的漏洞和补丁签名（signature），如果在待匹配集合中发现了相应漏洞特性，但是又不存在对应的补丁，则会认为待检测系统函数中存在这样的重复漏洞。反之则不存在。</p><h3 id="核心模块" tabindex="-1"><a class="header-anchor" href="#核心模块" aria-hidden="true">#</a> 核心模块</h3><p>以上流程主要包含五个核心功能模块：</p><p><strong>（1）Extracting Function Signature</strong>: 首先对要分析的系统函数代码进行一些预处理，包括将函数参数、局部变量、字符串分别用统一的符号进行表示，然后删除注释、花括号、制表符、空格这些无关元素，对每个语句进行哈希计算，最后标记各语句之间的控制流或数据流依赖关系。</p><p><strong>（2）Identifying Code Changes</strong>: 对已知漏洞和对应补丁的代码进行分析，针对仅在一个函数中有改变的语句进行定位。将漏洞版本中被删除的行，以及补丁版本中添加的行视为分析的起点。</p><p><strong>（3）Computing Slices to Changed Code</strong>: 在拿到添加/删除的语句后，为了获取整个函数中与之有关联的语句，作者结合后向和前向切片技术来找寻相关的上下文语句，并且针对前向切片技术，划分了Assignment，Condition，Return，Others四种语句进行不同的切片方式，降低引入无关语句的可能性。</p><p><strong>（4）Generating Vulnerability and Patch Signatures</strong>:  对上一步获得的添加/删除相关语句集合进行并交叉分析，得出漏洞/补丁相关语句集合。在此基础上结合信息理论，对漏洞相关语句集合进行信息熵的计算，保证总信息熵不超过一定的阈值，或语句之间都是直接相关关系，否则移除距离被删除（添加）部分最远的语句，大大降低了噪音的存在。同时，也对这些语句进行签名的计算，以便后续进行匹配。</p><p><strong>（5）Detecting Vulnerability through Matching</strong>:  利用签名，计算目标函数和已知漏洞函数在语法和语义层面的相似度，以及目标函数和已知补丁在语法和语义方面的相似度，综合评价输出最后的检测报告。</p><h2 id="_3-实验与分析" tabindex="-1"><a class="header-anchor" href="#_3-实验与分析" aria-hidden="true">#</a> <strong>3 实验与分析</strong></h2><p>作者对10个开源的C/C++项目代码进行测试，包含了25，377个版本代码，34,378个有变动的函数。通过对误报和漏报率进行计算，与业界标准<mark>ReDeBug</mark>和同方向最优工具<mark>VUDDY</mark>，以及<em>基于函数匹配检测方法的工具</em>—<mark>SourcererCC</mark>和<mark>CCAligner</mark>进行对比，对MVP的准确性和时间开销做了分析评估。同时也设计了实验来说明工具中阈值选取的合理性，并利用实验中测出的漏洞来说明通用漏洞检测方法在该方向上的检测效果。</p><figure><img src="'+r+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>（1）工具准确性与开销评估：结果表明，在十个开源项目上，MVP比现有工具取得了更高的准确率和召回率，共发现了97个未曾发现的漏洞。在误报和漏报方面，MVP也远远低于其他两个工具，但是仍有13个误报和6个漏报。误报方面，主要由于MVP未对相同功能的函数名进行抽象，在补丁特征匹配上造成了一定的误差。并且本工作为了降低程序分析的复杂性，选择仅对一个函数内部进行分析，没有考虑补丁打在函数外部的可能。而漏报方面，取决于工具对噪音的处理，且在平衡准确率和召回率之间，会存在一定的漏报。总体来说，MVP时间开销也不是很大，在更高准确度的情况下，反而能减少人工检查的时间。</p><p>（2）工具阈值选取：结果表明，在进行信息熵阈值的选取方面，当总信息熵不超过5时，能取得最高的准确率和召回率。当漏洞特征签名在待匹配函数中占比大于0.8，补丁特征签名在待匹配函数中占比小于0.2时，能达到最高的准确率。</p><p>（3）与<mark>通用漏洞检测工具</mark>比较结果：结果表明，基于学习的漏洞检测工具：VulDeePecker, Devign，以及商业化静态检测工具：Coverity, Checkmarx，对于本实验能发现的漏洞，检测结果都普遍偏低。</p><h2 id="_4-评价" tabindex="-1"><a class="header-anchor" href="#_4-评价" aria-hidden="true">#</a> <strong>4 评价</strong></h2><p>MVP是第一个借助了补丁存在检测，来进行重复漏洞检测的框架。它在目前的重复漏洞检测工具中，实现了高准确、低误报、低漏报的检测结果。</p><p>但是在实验中，工具仍然有出现误报和漏报的可能，从原因上来说，工具对特征提取时，函数一些关键变量、参数和字符串的抽象方法较为粗糙，而且没有对现有程序分析中跨函数分析的难点进行突破，选择了仅在函数内进行分析，这些因素同时也限制了工具的使用范围。</p><p>总的来说，作者提出应当在检测重复漏洞的时候考虑补丁的存在性，借此设计了能够更加精确地描述漏洞和补丁特性的提取方法，在该方向上是一个很大的突破，能够推动漏洞检测和补丁存在性检测方向的共同发展。</p>',32),h=[c];function o(g,p){return a(),n("div",null,h)}const u=e(s,[["render",o],["__file","28-白泽带你读论文丨MVP Detecting Vulnerabilities using Patch-Enhanced.html.vue"]]);export{u as default};
