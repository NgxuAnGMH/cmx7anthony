import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as p,o as c,c as l,a as n,b as s,e,d as o}from"./app-cdabc73c.js";const r="/assets/85320245cd80ce61e69c8391958240de-7bcd7332.jpeg",i="/assets/e9c2b4c67f8784a8eec7392628ce6cd6-2b925bff.jpg",d="/assets/1d8de36a58a98a53352b40efa81e9660-df83751c.jpg",u="/assets/465b740b86ccc6ad3f8e38de25336bf6-89319867.jpg",k="/assets/4de740c10670a92bbaa58348e66b7b16-b8fb9930.jpeg",m="/assets/dbd8785da6c3ce3fe1abb7bb5934b7a9-9a88b394.jpeg",b={},v=o(`<h1 id="_10-进程-公司接这么多项目-如何管" tabindex="-1"><a class="header-anchor" href="#_10-进程-公司接这么多项目-如何管" aria-hidden="true">#</a> 10 | 进程：公司接这么多项目，如何管？</h1><p>有了系统调用，咱们公司就能开始批量接项目啦！对应到 Linux 操作系统，就是可以创建进程了。</p><p>在命令行那一节，我们讲了使用命令创建 Linux 进程的几种方式。现在学习了系统调用，你是不是想尝试一下，如何通过写代码使用系统调用创建一个进程呢？我们一起来看看。</p><h2 id="写代码-用系统调用创建进程" tabindex="-1"><a class="header-anchor" href="#写代码-用系统调用创建进程" aria-hidden="true">#</a> 写代码：用系统调用创建进程</h2><p>在 Linux 上写程序和编译程序，也需要一系列的开发套件，就像 Visual Studio 一样。运行下面的命令，就可以在 centOS 7 操作系统上安装开发套件。在以后的章节里面，我们的实验都是基于 centOS 7 操作系统进行的。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>yum <span class="token operator">-</span>y groupinstall <span class="token string">&quot;Development Tools&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>接下来，我们要开始写程序了。<strong>在 Windows 上写的程序，都会被保存成==.h== 或者==.c== 文件</strong>，容易让人感觉这是某种有特殊格式的文件，但其实这些文件只是<mark>普普通通的文本文件</mark>。因而在 Linux 上，我们用 Vim 来创建并编辑一个文件就行了。</p><p>我们先来创建一个文件，里面用一个函数封装通用的创建进程的逻辑，名字叫 process.c，代码如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
    
    
    <span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token function">create_process</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> program<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> arg_list<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    
    <span class="token keyword">int</span> <span class="token function">create_process</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> program<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> arg_list<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token class-name">pid_t</span> child_pid<span class="token punctuation">;</span>
        child_pid <span class="token operator">=</span> <span class="token function">fork</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>child_pid <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> child_pid<span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token function">execvp</span> <span class="token punctuation">(</span>program<span class="token punctuation">,</span> arg_list<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">abort</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里面用到了咱们学过的 fork 系统调用，通过这里面的 if-else，我们可以看到，根据 fork 的返回值不同，父进程和子进程就此分道扬镳了。在子进程里面，我们需要通过 execvp 运行一个新的程序。</p><p>接下来我们创建第二个文件，调用上面这个函数。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token function">create_process</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> program<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> arg_list<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char</span><span class="token operator">*</span> arg_list<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token string">&quot;ls&quot;</span><span class="token punctuation">,</span>
        <span class="token string">&quot;-l&quot;</span><span class="token punctuation">,</span>
        <span class="token string">&quot;/etc/yum.repos.d/&quot;</span><span class="token punctuation">,</span>
        <span class="token constant">NULL</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">create_process</span> <span class="token punctuation">(</span><span class="token string">&quot;ls&quot;</span><span class="token punctuation">,</span> arg_list<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这里，我们创建的子程序运行了一个最最简单的命令 ls。学过命令行的那一节之后，这里你应该很熟悉了。</p><h2 id="进行编译-程序的二进制格式" tabindex="-1"><a class="header-anchor" href="#进行编译-程序的二进制格式" aria-hidden="true">#</a> 进行编译：程序的二进制格式</h2><p>程序写完了，是不是很简单？你可能要问了，这是不是就是我们所谓的项目执行计划书了呢？当然不是了，这两个文件只是<mark>文本文件</mark>，CPU 是不能执行文本文件里面的指令的，这些指令只有人能看懂，CPU 能够执行的命令是二进制的，比如“0101”这种，所以这些指令还需要翻译一下，这个翻译的过程就是**<code>编译</code>**（Compile）。<mark>编译好的二进制文件</mark>才是项目执行计划书。</p><p>现在咱们是正规的公司了，接项目要有章法，项目执行计划书也要有统一的格式，这样才能保证无论项目交到哪个项目组手里，都能以固定的流程执行。按照里面的指令来，项目也能达到预期的效果。</p><p>在 Linux 下面，二进制的程序也要有严格的格式，这个格式我们称为 <strong>ELF</strong>（Executeable and Linkable Format，可执行与可链接格式）。这个格式可以根据编译的结果不同，分为不同的格式。</p><p>接下来我们看一下，如何从文本文件编译成二进制格式。</p><img src="`+r+`" alt="img" style="zoom:25%;"><p>在上面两段代码中，上面 include 的部分是头文件，而我们写的这个.c 结尾的是源文件。</p><p>接下来我们编译这两个程序。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>gcc <span class="token parameter variable">-c</span> <span class="token parameter variable">-fPIC</span> process.c
gcc <span class="token parameter variable">-c</span> <span class="token parameter variable">-fPIC</span> createprocess.c
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-可重定位-文件" tabindex="-1"><a class="header-anchor" href="#_1-可重定位-文件" aria-hidden="true">#</a> 1. 可重定位/文件</h3><p>在编译的时候，先做预处理工作，例如将头文件嵌入到正文中，将定义的宏展开，然后就是真正的编译过程，最终编译成为.o 文件，这就是 ELF 的第一种类型，<strong><code>可重定位文件</code></strong>（Relocatable File）。</p><p>这个文件的格式是这样的：</p><img src="`+i+`" alt="img" style="zoom:25%;"><h4 id="_1-elf-header" tabindex="-1"><a class="header-anchor" href="#_1-elf-header" aria-hidden="true">#</a> 1）ELF Header</h4><p><mark>ELF 文件的头</mark>是用于描述整个文件的。这个<code>文件格式</code>在内核中有定义，分别为 <code>struct elf32_hdr</code> 和 <code>struct elf64_hdr</code>。</p><h4 id="_2-section-各种" tabindex="-1"><a class="header-anchor" href="#_2-section-各种" aria-hidden="true">#</a> 2）Section * 各种</h4><p>接下来我们来看一个一个的 <mark>section</mark>，我们也叫**<mark>节</mark>**。这里面的名字有点晦涩，不过你可以猜一下它们是干什么的。</p><p>这个编译好的二进制文件里面，应该是代码，还有一些全局变量、静态变量等等。没错，我们依次来看。</p><ul><li><p><code>.text</code>：放编译好的二进制可执行代码</p></li><li><p><code>.data</code>：已经初始化好的全局变量</p></li><li><p><code>.rodata</code>：只读数据，例如字符串常量、const 的变量</p></li><li><p><code>.bss</code>：未初始化全局变量，运行时会置 0</p></li><li><p><code>.symtab</code>：符号表，记录的则是函数和变量</p><ul><li><code>.rel.text</code>: 与重定位有关/记录一些相关的标注</li><li><code>.rel.data</code>: 与重定位有关/记录一些相关的标注</li></ul></li><li><p><code>.strtab</code>：字符串表、字符串常量和变量名</p></li></ul><p>为啥这里只有**<mark>全局变量</mark><strong>呢？其实前面我们讲函数栈的时候说过，</strong><mark>局部变量</mark>**是放在栈里面的，是程序运行过程中随时分配空间，随时释放的，现在我们讨论的是二进制文件，<strong>还没启动呢，所以只需要讨论在哪里保存全局变量</strong>。</p><h4 id="_3-section-header-table" tabindex="-1"><a class="header-anchor" href="#_3-section-header-table" aria-hidden="true">#</a> 3）Section Header Table</h4><p>这些**<mark>节的元数据信息</mark><strong>也需要有一个地方保存，就是最后的</strong><mark>节头部表（Section Header Table）</mark>**。在这个表里面，每一个 section 都有一项，在代码里面也有定义 <code>struct elf32_shdr</code> 和 <code>struct elf64_shdr</code>。</p><p>在 <mark>ELF 的头</mark>里面，有描述这个文件的==节头部表（Section Header Table）==的位置，有多少个表项等等信息。</p><h4 id="位置不确定-可重定位-哪里需要哪里搬" tabindex="-1"><a class="header-anchor" href="#位置不确定-可重定位-哪里需要哪里搬" aria-hidden="true">#</a> # 位置不确定/可重定位/哪里需要哪里搬</h4><p>我们刚才说了可重定位，为啥叫<strong>可重定位</strong>呢？我们可以想象一下，这个编译好的代码和变量，将来加载到内存里面的时候，都是要加载到一定位置的。比如说，调用一个函数，其实就是跳到这个函数所在的代码位置执行；再比如修改一个全局变量，也是要到变量的位置那里去修改。但是现在这个时候，还是.o 文件，不是一个可以直接运行的程序，这里面只是部分代码片段。</p><p>例如这里的 create_process 函数，将来被谁调用，在哪里调用都不清楚，就更别提确定位置了。所以，<strong>.o 里面的位置是不确定的，但是必须是可重新定位的，因为它将来是要做函数库的嘛</strong>，就是一块砖，哪里需要哪里搬，搬到哪里就重新定位这些代码、变量的位置。</p><p>有的 section，例如<code>.rel.text</code>, <code>.rel.data</code> 就与<strong>重定位</strong>有关。例如这里的 createprocess.o，里面调用了 create_process 函数，但是这个函数在另外一个.o 里面，因而 createprocess.o 里面根本不可能知道被调用函数的位置，所以只好在 rel.text 里面标注，这个函数是需要重定位的。</p><h4 id="静态链接库-a文件" tabindex="-1"><a class="header-anchor" href="#静态链接库-a文件" aria-hidden="true">#</a> # 静态链接库.a文件</h4><p>要想让 create_process 这个函数作为库文件被重用，不能以.o 的形式存在，而是要形成库文件，最简单的类型是静态链接库.a 文件（Archives），仅仅将一系列对象文件（.o）归档为一个文件，使用命令 ar 创建。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>ar cr libstaticprocess.a process.o
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>虽然这里 libstaticprocess.a 里面只有一个.o，但是实际情况可以有多个.o。当有程序要使用这个静态连接库的时候，会将.o 文件提取出来，链接到程序中。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>gcc <span class="token parameter variable">-o</span> staticcreateprocess createprocess.o -L. <span class="token parameter variable">-lstaticprocess</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在这个命令里，-L 表示在当前目录下找.a 文件，-lstaticprocess 会自动补全文件名，比如加前缀 lib，后缀.a，变成 libstaticprocess.a，找到这个.a 文件后，将里面的 process.o 取出来，和 createprocess.o 做一个链接，形成二进制执行文件 staticcreateprocess。</p><p>这个链接的过程，重定位就起作用了，原来 createprocess.o 里面调用了 create_process 函数，但是不能确定位置，现在将 process.o 合并了进来，就知道位置了。</p><h3 id="_2-二进制-可执行-文件" tabindex="-1"><a class="header-anchor" href="#_2-二进制-可执行-文件" aria-hidden="true">#</a> 2. 二进制/可执行/文件</h3><p>形成的二进制文件叫**<code>可执行文件</code>**，是 ELF 的第二种格式，格式如下：</p><img src="`+d+`" alt="img" style="zoom:25%;"><p>这个格式和.o 文件大致相似，还是分成一个个的 section，并且被节头表描述。只不过这些 section 是多个.o 文件合并过的。但是这个时候，<strong>这个文件已经是马上就可以加载到内存里面执行的文件了</strong>，因而这些 section 被分成了需要加载到内存里面的<mark>代码段</mark>、<mark>数据段</mark>和不需要加载到内存里面的部分，将<mark>小的 section</mark> 合成了<mark>大的段 segment</mark>，并且在最前面加一个<mark>段头表（Segment Header Table）</mark>。在代码里面的定义为 <code>struct elf32_phdr</code> 和 <code>struct elf64_phdr</code>，这里面除了有对于段的描述之外，最重要的是 <code>p_vaddr</code>，这个是<strong>这个段加载到内存的虚拟地址</strong>。</p><p>在 ELF 头里面，有一项 <code>e_entry</code>，也是个虚拟地址，是<strong>这个程序运行的入口</strong>。</p><p>当程序运行起来之后，就是下面这个样子：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code># <span class="token punctuation">.</span><span class="token operator">/</span>staticcreateprocess
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">total</span> <span class="token expression"><span class="token number">40</span></span></span>
<span class="token operator">-</span>rw<span class="token operator">-</span>r<span class="token operator">--</span>r<span class="token operator">--</span><span class="token punctuation">.</span> <span class="token number">1</span> root root <span class="token number">1572</span> Oct <span class="token number">24</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">38</span> CentOS<span class="token operator">-</span>Base<span class="token punctuation">.</span>repo
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="静态链接库-vs-动态链接库" tabindex="-1"><a class="header-anchor" href="#静态链接库-vs-动态链接库" aria-hidden="true">#</a> ## 静态链接库 vs 动态链接库</h3><p>静态链接库一旦链接进去，</p><ul><li>优点: 代码和变量的 section 都合并了，因而程序运行的时候，<strong>就不依赖于这个库是否存在</strong>。</li><li>缺点: 但是这样有一个缺点，就是相同的代码段，<strong>如果被多个程序使用的话</strong>，在内存里面就有多份，</li><li><strong>而且一旦静态链接库更新了</strong>，如果二进制执行文件不重新编译，也不随着更新。</li></ul><p>因而就出现了另一种，<strong><code>动态链接库</code></strong>（Shared Libraries），不仅仅是一组对象文件的简单归档，而是<strong>多个对象文件的重新组合，可被多个程序共享</strong>。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>gcc <span class="token parameter variable">-shared</span> <span class="token parameter variable">-fPIC</span> <span class="token parameter variable">-o</span> libdynamicprocess.so process.o
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当一个动态链接库被链接到一个程序文件中的时候，最后的程序文件并不包括动态链接库中的代码，而仅仅包括<mark>对动态链接库的引用</mark>，并且不保存动态链接库的全路径，仅仅保存<mark>动态链接库的名称</mark>。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>gcc <span class="token parameter variable">-o</span> dynamiccreateprocess createprocess.o -L. <span class="token parameter variable">-ldynamicprocess</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当运行这个程序的时候，首先寻找动态链接库，然后加载它。默认情况下，系统在 <code>/lib</code> 和 <code>/usr/lib</code> 文件夹下寻找动态链接库。如果找不到就会报错，我们可以设定 <code>LD_LIBRARY_PATH</code> 环境变量，程序运行时会在此环境变量指定的文件夹下寻找动态链接库。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">export</span> <span class="token expression">LD_LIBRARY_PATH<span class="token operator">=</span><span class="token punctuation">.</span></span></span>
# <span class="token punctuation">.</span><span class="token operator">/</span>dynamiccreateprocess
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">total</span> <span class="token expression"><span class="token number">40</span></span></span>
<span class="token operator">-</span>rw<span class="token operator">-</span>r<span class="token operator">--</span>r<span class="token operator">--</span><span class="token punctuation">.</span> <span class="token number">1</span> root root <span class="token number">1572</span> Oct <span class="token number">24</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">38</span> CentOS<span class="token operator">-</span>Base<span class="token punctuation">.</span>repo
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-共享对象-文件" tabindex="-1"><a class="header-anchor" href="#_3-共享对象-文件" aria-hidden="true">#</a> 3. 共享对象/文件</h3><p><mark>动态链接库</mark>，就是 ELF 的第三种类型，<mark><strong>共享对象文件</strong>（Shared Object）</mark>。</p><p>基于动态链接库创建出来的二进制文件格式还是 ELF，但是稍有不同。</p><p>首先，多了一个<code>.interp</code> 的 Segment(段)，这里面是 <mark>ld-linux.so</mark>，这是==<strong>动态链接器</strong>==，也就是说，运行时的链接动作都是它做的。</p><p>另外，ELF 文件中还多了两个 section(节)，一个是<code>.plt</code>，<mark><strong>过程链接表</strong>（Procedure Linkage Table，PLT）</mark>，一个是<code>.got.plt</code>，<mark><strong>全局偏移量表</strong>（Global Offset Table，GOT）</mark>。</p><h4 id="_1-plt-过程链接表" tabindex="-1"><a class="header-anchor" href="#_1-plt-过程链接表" aria-hidden="true">#</a> 1) PLT 过程链接表</h4><p>它们是怎么工作的，使得程序运行的时候，可以将 so 文件动态链接到进程空间的呢？</p>`,70),h={href:"http://libdynamicprocess.so",target:"_blank",rel:"noopener noreferrer"},g=n("code",null,"PLT",-1),_=n("code",null,"PLT[x]",-1),y=n("strong",null,"有点像一个本地的代理",-1),f=n("strong",null,[s("而是调用 "),n("code",null,"PLT[x]"),s("里面的代理代码")],-1),x=n("h4",{id:"_2-got-全局偏移表",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_2-got-全局偏移表","aria-hidden":"true"},"#"),s(" 2) GOT 全局偏移表")],-1),w=n("p",null,[s("去哪里找代理代码呢？这就用到了 "),n("code",null,"GOT"),s("，这里面也会为 create_process 函数创建一项 "),n("code",null,"GOT[y]"),s("。这一项是运行时 create_process 函数在内存中真正的地址。")],-1),L=n("h4",{id:"搭配工作的流程",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#搭配工作的流程","aria-hidden":"true"},"#"),s(" # 搭配工作的流程")],-1),T=n("code",null,"PLT[x]",-1),E=n("code",null,"GOT",-1),P=n("code",null,"GOT[y]",-1),F={href:"http://libdynamicprocess.so",target:"_blank",rel:"noopener noreferrer"},O=n("p",null,[s("但是 GOT 怎么知道的呢？对于 create_process 函数，"),n("code",null,"GOT"),s(" 一开始就会创建一项 "),n("code",null,"GOT[y]"),s("，但是这里面没有真正的地址，因为它也不知道，但是它有办法，它又回调 "),n("code",null,"PLT"),s("，告诉它，你里面的代理代码来找我要 create_process 函数的真实地址，我不知道，你想想办法吧。")],-1),C=n("code",null,"PLT",-1),G=n("code",null,"PLT[0]",-1),S=n("code",null,"PLT[0]",-1),B=n("code",null,"GOT[2]",-1),I={href:"http://ld-linux.so",target:"_blank",rel:"noopener noreferrer"},j=n("strong",null,"动态链接器",-1),D={href:"http://libdynamicprocess.so",target:"_blank",rel:"noopener noreferrer"},H=n("code",null,"GOT[y]",-1),q=n("code",null,"PLT[x]",-1),A=o(`<p>这个过程有点绕，但是是不是也很巧妙？</p><h4 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> # 小结</h4><blockquote><p>统一PLT和GOT的作用，</p><ul><li>PLT就是用来放代理代码的，也即stub代码的，</li><li>GOT是用来存放so对应的真实代码的地址的。</li><li>ld-linux.so虽然默认会被加载，但是也是一个so，所以会放在GOT里面。 <ul><li>要调用这个so里面的代码，也是需要从stub里面统一调用进去的，所以要回到PLT去调用。</li></ul></li></ul><p>动态链接库查找的过程，是否可以理解为类似缓存原理：PLT[x]先直接找缓存（GOT[y]），没命中，然后从源头找(通过PLT[0]调用GOT[2])，找到了放入缓存(GOT[y])，下次就直接调用缓存了。只不过缓存没命中时通过PLT[0]调用GOT[2]，而不是直接调GOT[2]，因为调用都是由PLT发起的</p></blockquote><h2 id="运行程序为进程" tabindex="-1"><a class="header-anchor" href="#运行程序为进程" aria-hidden="true">#</a> 运行程序为进程</h2><p>知道了 ELF 这个格式，这个时候它还是个程序，那怎么把这个文件加载到内存里面呢？</p><p>在内核中，有这样一个数据结构，用来定义加载二进制文件的方法。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">linux_binfmt</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">list_head</span> lh<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">module</span> <span class="token operator">*</span>module<span class="token punctuation">;</span>
        <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>load_binary<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">linux_binprm</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>load_shlib<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>core_dump<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">coredump_params</span> <span class="token operator">*</span>cprm<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> min_coredump<span class="token punctuation">;</span>     <span class="token comment">/* minimal dump size */</span>
<span class="token punctuation">}</span> __randomize_layout<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于 ELF 文件格式，有对应的实现。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">linux_binfmt</span> elf_format <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span>module         <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>load_binary    <span class="token operator">=</span> load_elf_binary<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>load_shlib     <span class="token operator">=</span> load_elf_library<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>core_dump      <span class="token operator">=</span> elf_core_dump<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>min_coredump   <span class="token operator">=</span> ELF_EXEC_PAGESIZE<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>load_elf_binary</code> 是不是你很熟悉？没错，我们加载内核镜像的时候，用的也是这种格式。</p><p>还记得当时是谁调用的 load_elf_binary 函数吗？具体是这样的：do_execve-&gt;do_execveat_common-&gt;exec_binprm-&gt;search_binary_handler。</p><p>那 do_execve 又是被谁调用的呢？我们看下面的代码。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>execve<span class="token punctuation">,</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> filename<span class="token punctuation">,</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token keyword">const</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> argv<span class="token punctuation">,</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token keyword">const</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> envp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">do_execve</span><span class="token punctuation">(</span><span class="token function">getname</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">,</span> argv<span class="token punctuation">,</span> envp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>学过了系统调用一节，你会发现，原理是 <mark>exec 这个系统调用</mark>最终调用的 <code>load_elf_binary</code>。</p><h3 id="exec-p-v-l-e" tabindex="-1"><a class="header-anchor" href="#exec-p-v-l-e" aria-hidden="true">#</a> exec / p v l e</h3><p>exec 比较特殊，它是一组函数：</p><ul><li>包含 p 的函数（execvp, execlp）<code>会在 PATH 路径下面寻找程序</code>；</li><li>不包含 p 的函数<code>需要输入程序的全路径</code>；</li><li>包含 v 的函数（execv, execvp, execve）<code>以 数组 的形式接收 参数</code>；</li><li>包含 l 的函数（execl, execlp, execle）<code>以 列表 的形式接收 参数</code>；</li><li>包含 e 的函数（execve, execle）<code>以 数组 的形式接收 环境变量</code>。</li></ul><p>在上面 process.c 的代码中，我们创建 ls 进程，也是通过 exec。</p><img src="`+u+'" alt="img" style="zoom:25%;"><h2 id="进程树" tabindex="-1"><a class="header-anchor" href="#进程树" aria-hidden="true">#</a> 进程树</h2><p>既然所有的进程都是从父进程 fork 过来的，那总归有一个祖宗进程，这就是咱们系统启动的 init 进程。</p><img src="'+k+`" alt="img" style="zoom:25%;"><p>在解析 Linux 的启动过程的时候，<mark>1 号进程</mark>是 <code>/sbin/init</code>。如果在 centOS 7 里面，我们 <code>ls</code> 一下，可以看到，这个进程是被软链接到 <code>systemd</code> 的。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token operator">/</span>sbin<span class="token operator">/</span>init <span class="token operator">-&gt;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span>lib<span class="token operator">/</span>systemd<span class="token operator">/</span>systemd
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>系统启动之后，<mark>init 进程</mark>会启动很多的 <mark>daemon 进程</mark>，为系统运行提供服务，然后就是启动 getty，让用户登录，登录后运行 shell，用户启动的进程都是通过 shell 运行的，从而形成了一棵进程树。</p><p>我们可以通过 <code>ps -ef 命令</code>查看当前系统启动的进程，我们会发现有三类进程。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@deployer ~<span class="token punctuation">]</span><span class="token comment"># ps -ef</span>
<span class="token environment constant">UID</span>        PID  <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMD
root         <span class="token number">1</span>     <span class="token number">0</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?        00:00:29 /usr/lib/systemd/systemd <span class="token parameter variable">--system</span> <span class="token parameter variable">--deserialize</span> <span class="token number">21</span>
root         <span class="token number">2</span>     <span class="token number">0</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?        00:00:00 <span class="token punctuation">[</span>kthreadd<span class="token punctuation">]</span>
root         <span class="token number">3</span>     <span class="token number">2</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?        00:00:00 <span class="token punctuation">[</span>ksoftirqd/0<span class="token punctuation">]</span>
root         <span class="token number">5</span>     <span class="token number">2</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?        00:00:00 <span class="token punctuation">[</span>kworker/0:0H<span class="token punctuation">]</span>
root         <span class="token number">9</span>     <span class="token number">2</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?        00:00:40 <span class="token punctuation">[</span>rcu_sched<span class="token punctuation">]</span>
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
root       <span class="token number">337</span>     <span class="token number">2</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?        00:00:01 <span class="token punctuation">[</span>kworker/3:1H<span class="token punctuation">]</span>
root       <span class="token number">380</span>     <span class="token number">1</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?        00:00:00 /usr/lib/systemd/systemd-udevd
root       <span class="token number">415</span>     <span class="token number">1</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?        00:00:01 /sbin/auditd
root       <span class="token number">498</span>     <span class="token number">1</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?        00:00:03 /usr/lib/systemd/systemd-logind
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
root       <span class="token number">852</span>     <span class="token number">1</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?        00:06:25 /usr/sbin/rsyslogd <span class="token parameter variable">-n</span>
root      <span class="token number">2580</span>     <span class="token number">1</span>  <span class="token number">0</span>  <span class="token number">2018</span> ?        00:00:00 /usr/sbin/sshd <span class="token parameter variable">-D</span>
root     <span class="token number">29058</span>     <span class="token number">2</span>  <span class="token number">0</span> Jan03 ?        00:00:01 <span class="token punctuation">[</span>kworker/1:2<span class="token punctuation">]</span>
root     <span class="token number">29672</span>     <span class="token number">2</span>  <span class="token number">0</span> Jan04 ?        00:00:09 <span class="token punctuation">[</span>kworker/2:1<span class="token punctuation">]</span>
root     <span class="token number">30467</span>     <span class="token number">1</span>  <span class="token number">0</span> Jan06 ?        00:00:00 /usr/sbin/crond <span class="token parameter variable">-n</span>
root     <span class="token number">31574</span>     <span class="token number">2</span>  <span class="token number">0</span> Jan08 ?        00:00:01 <span class="token punctuation">[</span>kworker/u128:2<span class="token punctuation">]</span>
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
root     <span class="token number">32792</span>  <span class="token number">2580</span>  <span class="token number">0</span> Jan10 ?        00:00:00 sshd: root@pts/0
root     <span class="token number">32794</span> <span class="token number">32792</span>  <span class="token number">0</span> Jan10 pts/0    00:00:00 <span class="token parameter variable">-bash</span>
root     <span class="token number">32901</span> <span class="token number">32794</span>  <span class="token number">0</span> 00:01 pts/0    00:00:00 <span class="token function">ps</span> <span class="token parameter variable">-ef</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你会发现，</p><ol><li>[用户态总管] PID 1 的进程就是我们的 init 进程 systemd，</li><li>[内核态总管] PID 2 的进程是内核线程 kthreadd， <ol><li>这两个我们在内核启动的时候都见过。</li><li>CMD/中括号: 其中<mark>用户态</mark>的不带中括号，<mark>内核态</mark>的带中括号。</li><li>接下来进程号依次增大，但是你会看所有带中括号的内核态的进程，祖先都是 2 号进程。而用户态的进程，祖先都是 1 号进程。</li><li>tty 那一列，是问号的，说明不是前台启动的，一般都是后台的服务。</li></ol></li></ol><ul><li>pts 的父进程是 sshd，</li><li>bash 的父进程是 pts，</li><li>ps -ef 这个命令的<code>父进程是 bash</code>。</li><li>这样整个链条都比较清晰了。</li></ul><h2 id="总结时刻" tabindex="-1"><a class="header-anchor" href="#总结时刻" aria-hidden="true">#</a> 总结时刻</h2><p>这一节我们讲了一个进程从代码到二进制到运行时的一个过程，我们用一个图总结一下。</p><p>我们首先通过图右边的文件编译过程，生成 so 文件和可执行文件，放在硬盘上。下图左边的用户态的进程 A 执行 fork，创建进程 B，在进程 B 的处理逻辑中，执行 exec 系列系统调用。这个系统调用会通过 load_elf_binary 方法，<strong><code>将刚才生成的可执行文件，加载到进程 B 的内存中执行</code></strong>。</p><figure><img src="`+m+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li>写代码</li><li>编译成 ELF 格式的二进制文件, 有三种格式(可重定位 .o 文件; 可执行文件; 共享对象文件 .so)</li><li><mark>可重定位 .o 文件</mark>(ELF 第一种格式)</li><li>.h + .c 文件, 编译得到<mark>可重定位 .o 文件</mark><ul><li>.o 文件由: <mark>ELF 头</mark>, 多个<mark>节(section)</mark>, 节头部表组成(每个节有一项纪录); 节表的位置和纪录数由 ELF 头给出.</li><li>.o 文件只是程序部分代码片段</li><li><code>.rel.text</code> 和 <code>.rel.data</code> 标注了哪些函数/数据需要重定位</li><li>要函数可被调用, 要以库文件的形式存在, 最简单是创建<mark>静态链接库 .a 文件(Archives)</mark></li><li>通过 ar 创建<mark>静态链接库</mark>, 通过 gcc 提取<mark>库文件中的 .o 文件</mark>, 链接到程序中</li><li>链接合并后, 就可以定位到函数/数据的位置, 形成<mark>可执行文件</mark></li></ul></li><li><mark>可执行文件</mark>(ELF 第二种格式)</li><li>链接合并后, 形成可执行文件 <ul><li>同样包含: <mark>ELF 头</mark>, 多个<mark>节</mark>, 节头部表;</li><li>另外还有==<strong>段头表</strong>==(包含<strong>段的描述</strong>, <code>p_vaddr 段</code>加载到内存的虚拟地址)</li><li>ELF 头中有 <code>e_entry</code> , 指向<strong>程序入口</strong>的虚拟地址</li></ul></li><li><mark>共享对象 .so 文件</mark>(ELF 第三种格式)</li><li><mark>静态链接库</mark>合并进<mark>可执行文件</mark>, <strong>多个进程不能共享</strong><ul><li>动态链接库-链接了动态链接库的程序, 仅包含对该库的引用(且只保存名称)</li><li>通过 gcc 创建, 通过 gcc 链接</li><li>运行时, 先找到<mark>动态链接库</mark>(默认在 /lib 和 /usr/lib 找)</li><li>增加了 <code>.interp 段</code>, 里面是 <code>ld_linux.so (动态链接器)</code></li><li>增加了两个节 <code>.plt(过程链接表)</code>和 <code>.got.plt(全局偏移表)</code></li><li>一个动态链接函数对应 plt 中的一项 plt[x], plt[x] 中是代理代码, 调用 got 中的一项 got[y]</li><li>起始, got 没有动态链接函数的地址, 都指向 plt[0], plt[0] 又调用 got[2], got[2]指向 ld_linux.so</li><li>ld_linux.so 找到加载到内存的<code>动态链接函数</code>的地址, 并将地址存入 got[y]</li></ul></li><li>加载 ELF 文件到内存</li><li>通过<code>系统调用 exec</code> 调用 <code>load_elf_binary</code><ul><li>exec 是一组函数</li><li>包含 p: 在 <code>PATH</code> 中找程序 <ul><li>不包含 p: 需提供<code>全路径</code></li><li>包含 v: 以<code>数组</code>接收参数</li><li>包含 l: 以<code>列表</code>接收参数</li><li>包含 e: 以数组接收<code>环境变量</code></li></ul></li></ul></li><li>进程树</li><li>ps -ef:<br> - <code>用户进程</code>不带中括号,<br> - <code>内核进程</code>带中括号 <ul><li>用户进程祖先(1号进程, <code>systemd</code>); 内核进程祖先(2号进程, <code>kthreadd</code>)</li><li>tty ? 一般表示后台服务</li></ul></li></ul><h2 id="课堂练习" tabindex="-1"><a class="header-anchor" href="#课堂练习" aria-hidden="true">#</a> 课堂练习</h2><p>对于 ELF，有几个工具能帮你看这些文件的格式。readelf 工具用于分析 ELF 的信息，</p><ul><li><code>objdump 工具</code>用来显示二进制文件的信息，</li><li><code>hexdump 工具</code>用来查看文件的十六进制编码，</li><li><code>nm 工具</code>用来显示关于指定文件中符号的信息。</li></ul><p>你可以尝试用这几个工具，来解析这一节生成的.o, .so 和可执行文件。</p><p>欢迎留言和我分享你的疑惑和见解，也欢迎你收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习、进步。</p><h2 id="课后讨论" tabindex="-1"><a class="header-anchor" href="#课后讨论" aria-hidden="true">#</a> 课后讨论</h2><p>看到程序的编译链接和库的东西，我感觉很熟悉，我就想到了之前看的一本特别好的书，推荐一下==《程序员的自我修养-链接、装载和库》==，这本书讲的十分不错，之前毕业时我看过，读了好几遍，然后在做项目过程中给intel移植android系统到x86_64位cpu上时通过elf等知识解决了好几个bug，感觉很有成就感。<br> 作者回复: 这本书很赞</p>',42),z=n("mark",null,"动态链接的漏洞攻击",-1),J={href:"https://garlicspace.com/2019/06/11/elf-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/",target:"_blank",rel:"noopener noreferrer"},N=n("br",null,null,-1),V={href:"https://www.jianshu.com/p/863b279c941e",target:"_blank",rel:"noopener noreferrer"},M={href:"https://www.jianshu.com/p/863b279c941e",target:"_blank",rel:"noopener noreferrer"},R=o("<p>原来是A进程fork进程B，然后进程B通过系统调用接口exec加载ls命令（对应的可执行文件 ）的过程。看了好半天看出了头绪(笑哭)</p><p>运行程序时会从ELF头文件中找到入口地址（类似0x400510）；这个时候应该是从用户态调用内核陷入吗？才能触发系统调用？<br> 作者回复: <strong>exec本来就是系统调用，要到内核的</strong></p><p>.class文件转为二进制文件好像要去访问动态链接库的<br> 作者回复: <strong>对的，到了二进制就需要动态连接库了</strong></p><p>JDK 语言中的 jar 包是一种静态连接文件吗？<br> 作者回复: 不是的，<strong>java有自己的方式，例如classloader去加载类</strong></p><p>前半段代码编译解释应该是 GCC 编译 C 语言的过程。<code>不同的语言编译原理不一样</code>。我想老师您是不是应该注明一下，讲的是 C 语言编译原理。<br> 作者回复: 是的，是C语言的，<strong>C语言更接近底层，所以能够看清操作系统原貌</strong></p><p>想问下老师，你们写代码都是在vim的编辑器下面嘛？这样不是没有代码提示功能嘛？？<br> 作者回复: vim插件不要太多</p>",6);function U(Y,K){const a=p("ExternalLinkIcon");return c(),l("div",null,[v,n("p",null,[s("dynamiccreateprocess 这个程序要调用 "),n("a",h,[s("libdynamicprocess.so"),e(a)]),s(" 里的 create_process 函数。由于是运行时才去找，编译的时候，压根不知道这个函数在哪里，所以就在 "),g,s(" 里面建立一项 "),_,s("。这一项也是一些代码，"),y,s("，在二进制程序里面，不直接调用 create_process 函数，"),f,s("，这个代理代码会在运行的时候找真正的 create_process 函数。")]),x,w,L,n("p",null,[s("如果这个地址在 dynamiccreateprocess 调用 "),T,s("里面的代理代码，代理代码调用 "),E,s(" 表中对应项 "),P,s("，调用的就是加载到内存中的 "),n("a",F,[s("libdynamicprocess.so"),e(a)]),s(" 里面的 create_process 函数了。")]),O,n("p",null,[C,s(" 这个时候会转而调用 "),G,s("，也即第一项，"),S,s("转而调用 "),B,s("，这里面是 "),n("mark",null,[n("a",I,[s("ld-linux.so"),e(a)]),s("("),j,s(")")]),s(" 的入口函数，这个函数会找到加载到内存中的 "),n("a",D,[s("libdynamicprocess.so"),e(a)]),s(" 里面的 create_process 函数的地址，然后把这个地址放在 "),H,s("里面。下次，"),q,s("的代理函数就能够直接调用了。")]),A,n("p",null,[s("源码文件经过编译，链接生成 可执行文件，加载到内存后化为进程，进程多了存在共享东西就多了， 通过动态库方式解决， 安全方面通ret2libc， ret2plt 实现"),z,s(),n("a",J,[s("https://garlicspace.com/2019/06/11/elf-文件格式分析/"),e(a)]),N,s(" 作者回复: 赞")]),n("p",null,[s("使用readelf和objdump解析.o目标文件 "),n("a",V,[s("https://www.jianshu.com/p/863b279c941e"),e(a)])]),n("p",null,[s("elf 工具分析文档，和自己手动模拟一样 "),n("a",M,[s("https://www.jianshu.com/p/863b279c941e"),e(a)])]),R])}const Z=t(b,[["render",U],["__file","H10-进程.html.vue"]]);export{Z as default};
