import{_ as e}from"./640-edc8dc9c.js";import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as n,c as s,a as i,b as a,e as p,d as l}from"./app-cdabc73c.js";const d="/assets/640-1691111926595-1-eed32d7e.png",c="/assets/640-1691111926595-2-b0ae7ff4.png",h="/assets/640-1691111926595-3-87cb2bd6.png",g="/assets/640-1691111926595-4-436cd924.png",f="/assets/640-1691111926596-5-aac8244e.png",m="/assets/640-1691111926596-6-ad727e5c.png",P="/assets/640-1691111926596-7-5c24e7ec.png",A={},u=i("h1",{id:"_77-白泽带你读论文-poirot",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#_77-白泽带你读论文-poirot","aria-hidden":"true"},"#"),a(" 77-白泽带你读论文 | Poirot")],-1),_={href:"https://dl.acm.org/doi/10.1145/3548606.3560710",target:"_blank",rel:"noopener noreferrer"},b=l('<p><strong>如需转载请注明出处，侵权必究。</strong></p><p><strong>论文题目：Poirot: Probabilistically Recommending Protections for the Android Framework</strong></p><p><strong>发表会议：CCS22</strong></p><p>安卓系统是一个经典的基于访问控制系统，它一直存在着权限控制的不一致性问题。安卓Framework层不一致的安全策略可能允许恶意攻击者不正确地访问敏感信息，此工作注重于研究此问题。</p><p>作者发现现有的工作有两个缺陷，首先它们不能准确识别访问控制的检查目标，而这可能产生误报，其次它们只检测显式的访问控制不一致性，但忽略了隐式的访问控制不一致性，这导致了一定的漏报。除此之外，作者观察到resource-to-access的控制关联在安卓环境中本质是高度不确定的，进而提出了<em>一个利用概率推理的工具</em>，在识别权限不一致性的同时也给安卓framework层API提供保护建议。</p><h2 id="贡献" tabindex="-1"><a class="header-anchor" href="#贡献" aria-hidden="true">#</a> 贡献</h2><ol><li>作者开发了<mark>Poirot</mark>，一种可以为Framework层资源提供概率保护建议的工具；Poirot融合了概率推理与静态程序分析，解决了静态访问控制推理的不确定性问题。</li><li>作者提出的方法能通过<em>丰富的语义、结构和数据流关系</em>补充了传统的可达性分析，这些关系更好的展示了安卓框架层资源和所需保护之间的联系。</li><li>Poirot在四个安卓image上大大减少了两个SOTA工具（AceDroid和Kratos）的FP。</li></ol><h2 id="背景" tabindex="-1"><a class="header-anchor" href="#背景" aria-hidden="true">#</a> 背景</h2><p>安卓框架层是位于安卓中间件的java库与系统服务的集合，为开发者提供公开的API，使开发者能访问完整的安卓功能，比如相机、蓝牙等。每个安卓API会访问一个或多个安卓资源来实现它的功能，这些资源可以分为三类：</p><ol><li>字段访问和更新</li><li>内部方法调用（比如native层的方法，文件访问方法，非公开服务方法）</li><li>API调用（一个API可能会调用另一个API，这时另一个API也算是资源）</li></ol><p>框架层的开发人员需要实现基于资源类别、敏感性的访问控制，比如LocationManagerService 中的 API requestLocationUpdates()需要实现位置的访问控制。访问控制检查需要确保两点：</p><ol><li>调用的应用程序拥有特定权限或满足特定条件（例如，分配了一个特定的 UID）</li><li>调用的用户有足够的权限访问资源。</li></ol><p>不幸的是，由于缺乏精确和完整的安全性规范，访问控制的实现可能存在不一致性的问题，这促使了不一致检测解决方案的研究。</p><h2 id="motivation" tabindex="-1"><a class="header-anchor" href="#motivation" aria-hidden="true">#</a> Motivation</h2><p>目前大部分检测访问控制不一致性的工作其实都在用“提取和比较访问相同资源的不同路径上的访问控制条件” 的方法</p><ol><li><strong>Kratos</strong>：给定一个安卓资源，使用路径不敏感分析来提取到该资源路径上的显式安全检查（比如权限检查或包名检查），然后进行收敛分析确定汇聚到同一资源的路径，并比较每一条路径提取的检查的集合以检测潜在不一致。</li><li><strong>AceDroid</strong>：由于安卓访问控制的代码实现时具有语法多样而语义等价的特点，AceDroid能够基于路径敏感分析，对更广泛的安全检查进行建模并规范化不同的访问控制检查。</li><li><strong>ACMiner</strong>：前两者都是人工去定义表征安全检查的模式，ACMiner通过追溯抛出的安全异常来半自动的识别安全检查。</li></ol><p>如前面所述，它们有两个缺陷：</p><ol><li>首先它们不能准确识别访问控制的检查目标，而这可能产生误报。</li><li>其次它们只检测显式的访问控制不一致性，但忽略了隐式的访问控制不一致性，这会有一定的漏报。</li></ol><h2 id="缺陷1-不精确的访问控制检查目标识别" tabindex="-1"><a class="header-anchor" href="#缺陷1-不精确的访问控制检查目标识别" aria-hidden="true">#</a> 缺陷1: 不精确的访问控制检查目标识别</h2><p>现有的工具认为收敛于相似操作的API是关联的，比如下图中调用mSettings.writePackageRestrictionsLPr() 的两个API会被认为是关联的。然而A只进行user ownership/privilege 检查，B还需要signature permission检查，所以现有工具认为A需要的权限更少，存在不一致的权限检查。但实际上，根据人工分析，A和B由于功能不同，不同的访问控制检查要求是合理的，即现有工具的结果是FP。造成这样的FP是因为现有的不一致性分析无法精确的查明要进行访问控制检查的目标，因此作者提出第一个insight，在进行访问控制检查时，需进行精确的访问控制检查目标识别。作者提出一个基于推理的访问控制检查目标识别做法：</p><ol><li>A中的user检查部分（绿）针对的可能是黄色框中显示的所有操作（包汇聚点writePackageRestrictionsLPr ），因为它们的名字和参数值相关</li><li>而B中的权限检查（红）针对的可能是黄色区域的两个install方法</li><li>B中的user检查（绿）针对的可能是黄色部分以及writePackageRestrictionsLPr函数，因为它们都用userid。</li></ol><p>基于此分析可推断汇聚点writePackageRestrictionsLPr 函数很可能只与user检查相关，即A和B中很可能不存在不一致性，从而降低现有工作的fp。</p><figure><img src="'+e+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>- 左边 (A) PMS.flushPackageRestrictionsAsUser(): 刷新一个指定用户对磁盘的特定访问包限制</p><p>- 右边(B) PMS.installExistingPackageAsUser(): 为一个指定用户安装已有的包</p><h2 id="缺陷2-隐式访问控制不一致" tabindex="-1"><a class="header-anchor" href="#缺陷2-隐式访问控制不一致" aria-hidden="true">#</a> 缺陷2: 隐式访问控制不一致</h2><p>以前的工作基于可达性将目标资源和权限关联到一起，或者资源是否可以从受保护的 API 访问。比如A里调用的几个方法，因为都可以直接从这个API调用，因此应该至少需要A这个API的权限（绿色部分），这样显式的可达性分析可以进行资源和保护的大致关联。</p><p>尽管这种显式的可达性分析可以进行资源和保护的大致关联，作者观察到可以通过一些隐式关系（包括语义、数据流和结构），来推测资源所关联的相关保护，这样的关系即为隐式访问控制。</p><figure><img src="'+d+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图中这个例子B中，一个第三方应用可以操纵mAdminMaps中的内容，而这个资源用来触发setRuntimePermissionGrantState() ，紧接着就可以触发底层的特权操作（黄色部分）。由此可以看出，隐式访问控制不一致也会带来安全问题，作者提出第二个insight，即<em>通过对隐式访问控制建模</em>来检测隐式访问控制不一致问题。</p><p>作者处理隐式不一致问题的方式是对资源之间的各种关系进行推理，并聚合相关的控制访问信息，因为这样观察到的关系并不一定意味着某种保护关联，这种不一致存在不确定性。</p><p>举例来说，用作者的方法对上面例子进行分析：</p><ol><li>对C的静态分析表明grantRuntimePermission()方法需要权限ADJUST_RUNTIME_PERMISSION</li><li>作者将这个信息传递到它的调用者A setRuntimePermissionGrantState() ,这表明A至少应该进行至少相当于ADJUST_RUNTIME_PERMISSION的权限检查</li><li>作者观察到，A并没有进行这样的权限检查，与此同时，A使用与字段读取相关的触发条件检查，也就是mAdminMaps 控制访问，作者认为这种字段相关的检查要纳入考虑，它可能和权限检查起相同作用</li><li>作者将3中得到的隐式访问控制信息传播到mAdminMaps的写入点，也就是B</li><li>作者在B中发现了这一不一致性（红色部分）</li></ol><p>此外，图中其实还有一个辅助判别的信息，那就是A中6号紫色部分，这种相同判别条件的互斥操作大概率需要类似的访问控制，我们可以认为黄色的访问控制可以传播到6号紫色部分。</p><h2 id="作者的解决方案" tabindex="-1"><a class="header-anchor" href="#作者的解决方案" aria-hidden="true">#</a> 作者的解决方案</h2><p>围绕概率，根据安卓隐式关联给的提示（语义、数据流和结构）类型和数量，计算一个资源r关联到一个保护p的概率</p><h3 id="方法" tabindex="-1"><a class="header-anchor" href="#方法" aria-hidden="true">#</a> <strong>方法</strong></h3><p>Poirot首先会对给定的安卓ROM的框架层和系统类进行预处理，识别出系统服务以及它们的API，接着它会通过静态分析API来识别出其中可访问资源，并以路径敏感的方式进行访问控制检查。这里的可访问资源包括字段访问、内部方法调用，以及API调用。由于识别的资源数量过多时会严重影响概率推理，所以工具会通过预处理清除掉不相关的代码块以减少分析出的资源数目。</p><h3 id="基础facts收集" tabindex="-1"><a class="header-anchor" href="#基础facts收集" aria-hidden="true">#</a> <strong>基础facts收集</strong></h3><p>Poirot首先收集一些基础信息，使用过程间路径敏感分析，该工具识别通向每个资源的可能路径，对于每一个路径，工具提取所有的访问控制检查并将它们的集合作为这个路径的代表，然后它生成一个随机变量，用来表示路径上的一个资源要求这个集合里所有访问控制检查的概率，如果这个资源被发现要其他的保护，那么给它加一个新变量</p><h3 id="访问控制约束检测" tabindex="-1"><a class="header-anchor" href="#访问控制约束检测" aria-hidden="true">#</a> <strong>访问控制约束检测</strong></h3><p>对每个资源，Poirot生成访问控制约束，其实就是通过分析访问控制属性将先验概率分配给之前的那些随机数，也就是之前收集的基础facts里的访问控制检查和每个资源之间的联系。作者把一对一的访问控制依赖（一个访问控制检查只关联一个资源）概率设为0.95，一对多的设为0.6</p><h3 id="隐式约束检测" tabindex="-1"><a class="header-anchor" href="#隐式约束检测" aria-hidden="true">#</a> <strong>隐式约束检测</strong></h3><p>这种隐式约束（结构、语义、数据流关系）提供了一个资源链接到另一个资源的置信度。</p><p>作者一共建模了七种隐式约束，分别是：<mark>可达性</mark>、<mark>触发条件</mark>、<mark>互斥性</mark>、<mark>名称关联</mark>、<mark>Getter-to-Setter</mark>、<mark>数据流</mark>和<mark>参数流约束</mark>。</p><h3 id="概率推理" tabindex="-1"><a class="header-anchor" href="#概率推理" aria-hidden="true">#</a> <strong>概率推理</strong></h3><p>收集到的概率约束会传给概率推理引擎，并给出最后的保护建议，开发者可以将每个建议与对应API的实现进行比较，以检测访问的不一致性</p><h3 id="访问控制约束的提取方法" tabindex="-1"><a class="header-anchor" href="#访问控制约束的提取方法" aria-hidden="true">#</a> <strong>访问控制约束的提取方法</strong></h3><p>在从 API 收集访问控制约束之前，作者首先使用程序分析来减少需要分析的资源，具体来说，清除了一些常用的API里的资源，这些API常用于资源检查、日志记录和metric收集。</p><figure><img src="'+c+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h3 id="基础访问控制facts" tabindex="-1"><a class="header-anchor" href="#基础访问控制facts" aria-hidden="true">#</a> <strong>基础访问控制facts</strong></h3><p>首先，作者在ICFG上进行前向的控制流分析，识别目标资源所控制依赖的条件分支。</p><p>然后，作者处理分支来推断访问控制模式并使用defuse链提取其他相关约束，如果多条约束在相同路径上被发现，使用and进行合并，如果相反，有多个ICFG路径到达一个目标资源，就用OR进行合并</p><p>对于每一个路径，Poirot引入一个新的随机变量来表示目标需要这个路径上的约束集合的概率。</p><p>作者对于程序分析时的各种情况进行了建模，以完成隐式访问控制的推断，具体请见原文的table 1。</p><figure><img src="'+h+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h3 id="隐式约束" tabindex="-1"><a class="header-anchor" href="#隐式约束" aria-hidden="true">#</a> <strong>隐式约束</strong></h3><p>首先作者对隐式建模的结果如上图，然后进行每一种隐式约束的详细讨论</p><p>getter-to-setter里是将所有的get-set都联系起来，提到的FP是对一个共享Buffer可以append，但是不能读</p><p>需要注意的是它使用聚合算法，也就是说比如一条路径上资源r对保护p的概率是0.1，另一条路径上资源r对保护p的概率是0.9，那么最后聚合后的概率会比0.9大</p><h3 id="实现" tabindex="-1"><a class="header-anchor" href="#实现" aria-hidden="true">#</a> <strong>实现</strong></h3><p>Poirot由两个组件构成，一个是静态分析组件（建立在WALA上，并依赖Akka Typed进行并行分析），另一个是概率分析组件，使用（ProbLog作为概率分析引擎）</p><h2 id="实验" tabindex="-1"><a class="header-anchor" href="#实验" aria-hidden="true">#</a> 实验</h2><p><strong>评估Poirot的保护建议机制</strong></p><p>对于每个系统服务，作者收集10%API作为测试集，其他90% API作为基础facts的训练集，最后准确率分别为77%, 82%, 84%</p><figure><img src="'+g+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p><strong>概率约束的影响</strong></p><p>统计了每种约束类型的比例</p><figure><img src="'+f+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p><strong>检测不一致性的能力</strong></p><p>作者分析了来自 AOSP、亚马逊、小米和 LG 的四款 ROM，结果如下：</p><figure><img src="'+m+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p><strong>降低其他工作的FP</strong></p><p>作者将工具与AceDroid和Kratos结合，极大降低了FP，结果如下表。</p><figure><img src="'+P+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>作者提出了Poirot，一种新的Android资源概率访问控制检测框架。该框架的特点是使用定制的静态分析收集各种连接资源和访问控制的隐式关系，将它们转化为隐含约束，以将资源与固有的不确定性联系起来，并给出保护建议。作者用Poirot分析了四个Android ROM，评估表明，Poirot能有效地生成保护建议并检测到访问权限控制不一致性。</p><h2 id="静态分析基础" tabindex="-1"><a class="header-anchor" href="#静态分析基础" aria-hidden="true">#</a> ###静态分析基础</h2><blockquote><p>学习程序静态分析可以从以下指南和参考资料入手：</p><ol><li><p>静态分析原理和技术书籍：《静态程序分析基础》(Static Program Analysis) 、《程序分析原理与技术》(Principles of Program Analysis) 等是学习静态分析的经典教材，提供了关于静态分析的基本原理和常见技术的详细介绍。</p></li><li><p>静态分析工具文档：了解静态分析工具（如漏洞扫描工具、代码审查工具等）的使用可以帮助初学者快速入门。许多静态分析工具提供了官方文档和教程，例如：FindBugs、PMD、Clang Static Analyzer等。</p></li><li><p>学术论文和研究文章：阅读相关学术论文和研究文章可以深入了解当前静态分析领域的最新研究成果和技术进展。可以在学术会议（如ACM SIGPLAN、IEEE等）和期刊上查找相关文章，例如《ACM Transactions on Software Engineering and Methodology》、《IEEE Transactions on Software Engineering》等。</p></li></ol><p>静态分析的知识结构包括以下几个核心要点：</p><ol><li><p>编译原理：了解编译器的基本原理和编译过程对理解静态分析非常重要，包括词法分析、语法分析、语义分析等。</p></li><li><p>数据流分析：数据流分析是静态分析的基础，用于分析程序执行过程中数据的流动情况。掌握数据流分析的基本概念（如数据流图、数据流方程）、基本算法（如迭代求解、基于框架的方法）和常见数据流分析技术（如活性变量分析、指针分析）。</p></li><li><p>抽象解释：抽象解释是一种静态分析技术，用于对程序进行近似推理。了解抽象解释的基本原理和算法，以及如何建立抽象域和抽象操作，包括抽象值的构造和合并等。</p></li><li><p>符号执行：符号执行是一种静态分析方法，通过在符号层面对程序进行执行和推理。掌握符号执行的基本概念和技术，包括符号状态、路径约束、符号执行引擎等。</p></li><li><p>静态分析工具和技术：了解常见的静态分析工具和技术，如漏洞扫描工具、代码静态分析工具和静态分析框架。学习如何使用这些工具和技术进行静态程序分析和漏洞检测。</p></li></ol><p>在学习静态分析之前，建议具备以下前置知识：</p><ol><li><p>编程语言：了解至少一种常见的编程语言（如C、C++、Java等），熟悉基本的语法和编程原理。</p></li><li><p>数据结构和算法：对于静态分析的算法和数据结构有一定的了解，因为许多静态分析方法和技术都依赖于基本的数据结构和算法。</p></li><li><p>编译原理：掌握编译原理的基本概念和编译过程，了解词法分析、语法分析、语义分析等基本阶段的工作原理。</p></li></ol><p>通过深入学习上述资源和前置知识，可以打下坚实的静态分析基础，进一步探索和应用静态分析</p></blockquote>',79);function I(k,x){const r=o("ExternalLinkIcon");return n(),s("div",null,[u,i("p",null,[i("a",_,[a("Poirot | Proceedings of the 2022 ACM SIGSAC Conference on Computer and Communications Security"),p(r)]),a(".")]),b])}const R=t(A,[["render",I],["__file","77-白泽带你读论文  Poirot.html.vue"]]);export{R as default};
