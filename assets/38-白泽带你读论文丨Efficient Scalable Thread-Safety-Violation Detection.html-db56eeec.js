import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o,c as s,a as e,b as a,e as t,d as l}from"./app-cdabc73c.js";const c="/assets/640-1691474258012-243-c8de72dc.png",h="/assets/640-1691474258012-244-ca1f4531.png",p="/assets/640-1691474258012-245-d36071fc.png",d="/assets/640-1691474258012-246-f94ff04c.png",f="/assets/640-1691474258012-247-e6120e77.png",g={},_=e("h1",{id:"_38-白泽带你读论文丨efficient-scalable-thread-safety-violation-detection",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_38-白泽带你读论文丨efficient-scalable-thread-safety-violation-detection","aria-hidden":"true"},"#"),a(" 38-白泽带你读论文丨Efficient Scalable Thread-Safety-Violation Detection")],-1),u=e("p",null,[e("strong",null,"Efficient Scalable Thread-Safety-Violation Detection - Finding thousands of concurrency bugs during testing")],-1),b={href:"https://www.microsoft.com/en-us/research/uploads/prod/2019/09/sosp19-final193.pdf",target:"_blank",rel:"noopener noreferrer"},m={href:"https://github.com/microsoft/TSVD",target:"_blank",rel:"noopener noreferrer"},S={href:"https://sosp19.rcs.uwaterloo.ca/slides/li.pptx",target:"_blank",rel:"noopener noreferrer"},T={href:"http://cs.uchicago.edu/~shanlu/",target:"_blank",rel:"noopener noreferrer"},V=l('<h2 id="_1-主要内容" tabindex="-1"><a class="header-anchor" href="#_1-主要内容" aria-hidden="true">#</a> <strong>1. 主要内容</strong></h2><p>一般来说，<mark>并发漏洞</mark>是非常难以检测、重现和调试的，而且在内部测试中也很难找到并发漏洞，但并发漏洞一旦引爆，极有可能造成生产环境的大规模停机等糟糕后果。现有的并发漏洞检测工具不能很好地集成到现有测试环境中的原因在于没有很好地解决以下几个问题：如何处理庞大代码库中，风格各异的同步机制？如何降低工具的误报？如何尽可能的少占用测试资源？</p><p>为了解决上诉问题带来的挑战，本篇工作提出了TSVD，一款全新的并发漏洞检测工具。不同于先前工作采用运行时随机注入延迟时间的检测策略或者是采用开销巨大的静态同步检测方案来处理各种复杂的同步机制，TSVD提出了<em>一种轻量级的near-miss tracking策略</em>来初步识别可能存在并发漏洞的线程不安全调用，然后结合本文新提出的happens-before(HB) inferencing技术，TSVD能在测试过程中有效地从这些潜在不安全调用中发现真正存在并发漏洞的调用，并且排除掉不可能存在并发漏洞的调用，从而实现较低的误报。</p><p>作者在.NET平台上实现了TSVD的原型，包括两部分：TSVD runtime library，实现了TSVD核心算法；TSVD instrumenter，通过静态插桩的方式在.NET应用中集成TSVD runtime library。</p><p>最终TSVD在实验中找到了1134个并发漏洞，其中80个漏洞和相应的开发者联系后得到确认，包括了77个开发者之前未发现的并发漏洞。</p><h2 id="_2-设计实现" tabindex="-1"><a class="header-anchor" href="#_2-设计实现" aria-hidden="true">#</a> <strong>2. 设计实现</strong></h2><p>本文将类库自身规定的在多线程下的使用规范称为 thread-safety contract，而将违反规范的使用称为Thread Safety Violation（TSV），比如<em>线程A和线程B同时对一个共享的变量C进行了修改，就是一种TSV</em>。</p><p>为了找到真实存在的并发漏洞，首先，TSVD会用一个轻量级的分析工具定位出所有可能造成TSV[tx1] 的调用点，称为trap set，随后会在这些调用点进行插桩并调用以下OnCall函数。调用OnCall函数主要有两个目的：</p><p>1.通过向一个线程注入delay的方式来放大出现TSV的概率；</p><p>2.记录线程信息、对象信息、操作信息等要点来判断是否发生TSV，<br> 如果两个线程对一个对象进行了操作，而且其中有一个是写操作，则可以判断发生了TSV。</p><figure><img src="'+c+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>很明显，这种记录动态过程中触发的bug的机制在设计上不会有任何的false positive，问题的关键在于不能在所有的调用点都进行delay，这会带来很大的overhead。这里作者提出了两个巧妙的思路来进行should_delay的判断。</p><h3 id="_1-identifying-near-misses" tabindex="-1"><a class="header-anchor" href="#_1-identifying-near-misses" aria-hidden="true">#</a> 1）Identifying near misses</h3><p>该思路本质是通过“close-by physical”来找到“concurrent logical”。并发漏洞出现在多线程对一个变量的访问上，而逻辑上的并发在时间上的表现就是重合或者是相近，因此作者认为如果观察到两个线程对同一个变量的访问在时间上相近，而且其中有一个是写操作的话，他们就有可能是一组并发访问，就可以把它标记为需要delay的调用点。</p><h3 id="_2-inferring-likely-hb-relationship" tabindex="-1"><a class="header-anchor" href="#_2-inferring-likely-hb-relationship" aria-hidden="true">#</a> 2）Inferring likely HB relationship</h3><p>上一阶段找到的两个调用点虽然在时间上相近，但并不代表绝对会出现TSV，比如happens-before关系就是[tx2] 一个反面例子。happens-before关系确保了一个操作执行的结果对另一个操作的可见性，而且这种可见性是跨线程的，所以存在happens-before关系的两个线程不可能出现并发漏洞。</p><p>由于同步机制的复杂程度，采用传统的静态分析技术，往往不能很高效的检测出这些happens-before关系。作者在这里又提出了一个很巧妙的思路：虽然种类繁多的同步机制实现各不相同，但同步机制的效果是相似的。同步机制的存在会使得对一个线程的delay传播到其他线程，因此可以利用这种逻辑上的联系帮助推断是否存在可能的同步关系。</p><p>以下图为例，比如在thread 1插入了一定的延迟，如果两个线程的访问存在着happens-before关系的话，可以观察到thread 2也同样地发生了一定比例的延迟。</p><figure><img src="'+h+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>TSVD 实现在.NET平台上，由两部分组成，其中TSVD Runtime实现了前文的两个核心思路和对应算法，而TSVD Instrumenter会针对C#上的14个类，59个写操作函数，64个读操作函数进行代码插桩，插入OnCall函数。</p><h2 id="_3-实验评估" tabindex="-1"><a class="header-anchor" href="#_3-实验评估" aria-hidden="true">#</a> <strong>3. 实验评估</strong></h2><h3 id="_1-overall" tabindex="-1"><a class="header-anchor" href="#_1-overall" aria-hidden="true">#</a> 1）overall</h3><p>实验使用的 benchmark 如下：</p><ul><li>large benchmark：微软开发的1657个项目中使用的43000个模块，包含了约122000个多线程单元测试和约89000个二进制文件</li><li>small benchmark：从large benchmark中随机选取的1000个模块</li></ul><p>其中large benchmark用一台配置有Intel(R) Xeon(R) E5-2650 CPU，128G 内存以及6T SSD的服务器进行测试，而small benchmark用一台搭载Intel(R) Xeon(R) E5-1620 CPU，16G内存和1T SSD的服务器进行测试。</p><p>最终TSVD在large benchmark中找到了1134个TSV，在提交开发者验证确认的bug中，有96%的bug是之前未发现的 bug，并且有47%的bug会导致严重的问题。</p><h3 id="_2-和其他工具的对比" tabindex="-1"><a class="header-anchor" href="#_2-和其他工具的对比" aria-hidden="true">#</a> 2）和其他工具的对比</h3><p>通过在 small benchmark 上的测试结果可以看出，同其它工具相比，TSVD找到的bug更多，overhead更小：</p><figure><img src="'+p+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>同时，多次运行对TSVD找到bug同样有帮助作用。如下图展示的实验结果，在多次运行了TSVD和其它对比工具后，虽然不同工具找到的bug数目都有一定上升，但TSVD检出的bug数目依旧多于其他工具：</p><figure><img src="'+d+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h3 id="_3-在开源数据集上的评估" tabindex="-1"><a class="header-anchor" href="#_3-在开源数据集上的评估" aria-hidden="true">#</a> 3）在开源数据集上的评估</h3><p>为了证明TSVD也可以应用到除了Microsoft外的其它开源C#项目上，作者从Github上随机选取了9个开源项目进行测试，测试结果如下图所示，同样证明了TSVD的高效准确。</p><figure><img src="'+f+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h2 id="_4-总结" tabindex="-1"><a class="header-anchor" href="#_4-总结" aria-hidden="true">#</a> <strong>4. 总结</strong></h2><p>作为 SOSP 19 的 best paper，TSVD 基于用“推断”代替“分析”的两个 idea 都非常有意思而且高效可行，最后也取得了相当不错的效果。不过仍需注意的是， TSVD 还是牺牲了完备性来保证了精确度，即不保证找到全部的 bug，<strong>但确保所有找到的bug都是true positive</strong>，所以 TSVD 自然有一个无法解决的问题就是false negative。这里有一个值得思考的点是，和学术界有时候可能追求工具的完备性相比，<em>其实工业界更看重工具的精度和开销</em>。有些工具在学术研究过程中，跑几小时甚至一两天都是合理的，<u>但在工业界的代码量级和需求下</u>，更快开销更低的工具可能更贴近应用场景。</p>',36);function D(y,x){const r=i("ExternalLinkIcon");return o(),s("div",null,[_,u,e("p",null,[a("论文链接："),e("a",b,[a("https://www.microsoft.com/en-us/research/uploads/prod/2019/09/sosp19-final193.pdf"),t(r)])]),e("p",null,[a("项目地址："),e("a",m,[a("https://github.com/microsoft/TSVD"),t(r)])]),e("p",null,[a("会议 PPT："),e("a",S,[a("https://sosp19.rcs.uwaterloo.ca/slides/li.pptx"),t(r)])]),e("p",null,[a("本篇文章是 SOSP 2019 两篇best paper 之一，出自芝加哥大学的Shan Lu教授所带领的研究组，对于Shan Lu教授感兴趣的可以查看她的个人主页："),e("a",T,[a("http://cs.uchicago.edu/~shanlu/"),t(r)])]),V])}const E=n(g,[["render",D],["__file","38-白泽带你读论文丨Efficient Scalable Thread-Safety-Violation Detection.html.vue"]]);export{E as default};
