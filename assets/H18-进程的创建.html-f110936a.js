import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as a,d as t}from"./app-cdabc73c.js";const p="/assets/fda98b6c68605babb2036bf91782311d-03206387.png",e="/assets/9d9c5779436da40cabf8e8599eb85558-0a1e4e8b.jpeg",c={},o=t(`<h1 id="_18-进程的创建-如何发起一个新项目" tabindex="-1"><a class="header-anchor" href="#_18-进程的创建-如何发起一个新项目" aria-hidden="true">#</a> 18 | 进程的创建：如何发起一个新项目？</h1><p>前面我们学习了如何使用 fork 创建进程，也学习了进程管理和调度的相关数据结构。这一节，我们就来看一看，创建进程这个动作在内核里都做了什么事情。</p><h2 id="fork-sys-call-table-sys-fork-do-fork" tabindex="-1"><a class="header-anchor" href="#fork-sys-call-table-sys-fork-do-fork" aria-hidden="true">#</a> <code>fork</code>-&gt;<code>sys_call_table</code>-&gt;<code>sys_fork</code>-&gt;<code>_do_fork</code></h2><p><code>fork</code> 是一个系统调用，根据咱们讲过的系统调用的流程，流程的最后会在 <code>sys_call_table</code> 中找到相应的系统调用 <code>sys_fork</code>。</p><p>sys_fork 是如何定义的呢？根据 SYSCALL_DEFINE0 这个宏的定义，下面这段代码就定义了 sys_fork。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token function">SYSCALL_DEFINE0</span><span class="token punctuation">(</span>fork<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">return</span> <span class="token function">_do_fork</span><span class="token punctuation">(</span>SIGCHLD<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>sys_fork 会调用 <code>_do_fork</code>。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">long</span> <span class="token function">_do_fork</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> clone_flags<span class="token punctuation">,</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> stack_start<span class="token punctuation">,</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> stack_size<span class="token punctuation">,</span>
        <span class="token keyword">int</span> __user <span class="token operator">*</span>parent_tidptr<span class="token punctuation">,</span>
        <span class="token keyword">int</span> __user <span class="token operator">*</span>child_tidptr<span class="token punctuation">,</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> tls<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
  <span class="token keyword">int</span> trace <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">long</span> nr<span class="token punctuation">;</span>


<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  p <span class="token operator">=</span> <span class="token function">copy_process</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> stack_start<span class="token punctuation">,</span> stack_size<span class="token punctuation">,</span>
       child_tidptr<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> trace<span class="token punctuation">,</span> tls<span class="token punctuation">,</span> NUMA_NO_NODE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">pid</span> <span class="token operator">*</span>pid<span class="token punctuation">;</span>
    pid <span class="token operator">=</span> <span class="token function">get_task_pid</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> PIDTYPE_PID<span class="token punctuation">)</span><span class="token punctuation">;</span>
    nr <span class="token operator">=</span> <span class="token function">pid_vnr</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>


    <span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CLONE_PARENT_SETTID<span class="token punctuation">)</span>
      <span class="token function">put_user</span><span class="token punctuation">(</span>nr<span class="token punctuation">,</span> parent_tidptr<span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">wake_up_new_task</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">put_pid</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> 
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_1-复制结构-copy-process" tabindex="-1"><a class="header-anchor" href="#_1-复制结构-copy-process" aria-hidden="true">#</a> <strong>1：复制结构 <code>copy_process</code></strong></h2><p>_do_fork 里面做的第一件大事就是 copy_process，咱们前面讲过这个思想。如果所有数据结构都从头创建一份太麻烦了，还不如使用惯用“伎俩”，Ctrl C + Ctrl V。</p><p>这里我们再把 task_struct 的结构图拿出来，对比着看如何一个个复制。</p><img src="`+p+`" alt="img" style="zoom:25%;"><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> __latent_entropy <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token function">copy_process</span><span class="token punctuation">(</span>
          <span class="token keyword">unsigned</span> <span class="token keyword">long</span> clone_flags<span class="token punctuation">,</span>
          <span class="token keyword">unsigned</span> <span class="token keyword">long</span> stack_start<span class="token punctuation">,</span>
          <span class="token keyword">unsigned</span> <span class="token keyword">long</span> stack_size<span class="token punctuation">,</span>
          <span class="token keyword">int</span> __user <span class="token operator">*</span>child_tidptr<span class="token punctuation">,</span>
          <span class="token keyword">struct</span> <span class="token class-name">pid</span> <span class="token operator">*</span>pid<span class="token punctuation">,</span>
          <span class="token keyword">int</span> trace<span class="token punctuation">,</span>
          <span class="token keyword">unsigned</span> <span class="token keyword">long</span> tls<span class="token punctuation">,</span>
          <span class="token keyword">int</span> node<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> retval<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  p <span class="token operator">=</span> <span class="token function">dup_task_struct</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="dup-task-struct-内核task元数据" tabindex="-1"><a class="header-anchor" href="#dup-task-struct-内核task元数据" aria-hidden="true">#</a> <code>dup_task_struct</code> 内核Task元数据</h3><p>dup_task_struct 主要做了下面几件事情：</p><ul><li>调用 alloc_task_struct_node 分配<mark>一个 task_struct 结构</mark>；</li><li>调用 alloc_thread_stack_node 来创建<mark>内核栈</mark>，这里面调用 __vmalloc_node_range 分配一个连续的 THREAD_SIZE 的内存空间，赋值给 task_struct 的 void *stack 成员变量；</li><li>调用 arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)，将 task_struct 进行复制，其实就是调用 memcpy；</li><li>调用 setup_thread_stack 设置 thread_info。</li></ul><p>到这里，整个 <mark>task_struct</mark> 复制了一份，而且<mark>内核栈</mark>也创建好了。</p><h3 id="copy-creds-权限相关" tabindex="-1"><a class="header-anchor" href="#copy-creds-权限相关" aria-hidden="true">#</a> <code>copy_creds</code> 权限相关</h3><p>我们再接着看 copy_process。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>retval <span class="token operator">=</span> <span class="token function">copy_creds</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> clone_flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>轮到权限相关了，copy_creds 主要做了下面几件事情：</p><ul><li>调用 prepare_creds，准备一个新的 struct cred *new。如何准备呢？其实还是从内存中分配一个新的 struct cred 结构，然后调用 memcpy 复制一份父进程的 cred；</li><li>接着 p-&gt;cred = p-&gt;real_cred = get_cred(new)，将新进程的“我能操作谁”和“谁能操作我”两个权限都指向新的 cred。</li></ul><h3 id="重新设置进程运行的统计量" tabindex="-1"><a class="header-anchor" href="#重新设置进程运行的统计量" aria-hidden="true">#</a> ## 重新设置进程运行的统计量</h3><p>接下来，copy_process 重新设置进程运行的统计量。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>p<span class="token operator">-&gt;</span>utime <span class="token operator">=</span> p<span class="token operator">-&gt;</span>stime <span class="token operator">=</span> p<span class="token operator">-&gt;</span>gtime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>start_time <span class="token operator">=</span> <span class="token function">ktime_get_ns</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span>real_start_time <span class="token operator">=</span> <span class="token function">ktime_get_boot_ns</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="sched-fork-调度相关" tabindex="-1"><a class="header-anchor" href="#sched-fork-调度相关" aria-hidden="true">#</a> <code>sched_fork</code> 调度相关</h3><p>接下来，copy_process 开始设置调度相关的变量。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>retval <span class="token operator">=</span> <span class="token function">sched_fork</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>sched_fork 主要做了下面几件事情：</p><ul><li>调用 __sched_fork，在这里面将 on_rq 设为 0，初始化 sched_entity，将里面的 exec_start、sum_exec_runtime、prev_sum_exec_runtime、vruntime 都设为 0。你还记得吗，这几个变量涉及进程的实际运行时间和虚拟运行时间。是否到时间应该被调度了，就靠它们几个；</li></ul><ul><li>设置进程的状态 p-&gt;state = TASK_NEW；</li><li>初始化优先级 prio、normal_prio、static_prio；</li><li>设置调度类，如果是普通进程，就设置为 p-&gt;sched_class = &amp;fair_sched_class；</li><li>调用调度类的 task_fork 函数，对于 CFS 来讲，就是调用 task_fork_fair。在这个函数里，先调用 update_curr，对于当前的进程进行统计量更新，然后把子进程和父进程的 vruntime 设成一样，最后调用 place_entity，初始化 sched_entity。这里有一个变量 sysctl_sched_child_runs_first，可以设置父进程和子进程谁先运行。如果设置了子进程先运行，即便两个进程的 vruntime 一样，也要把子进程的 sched_entity 放在前面，然后调用 resched_curr，标记当前运行的进程 TIF_NEED_RESCHED，也就是说，把父进程设置为应该被调度，这样下次调度的时候，父进程会被子进程抢占。</li></ul><h3 id="files-fs-文件-文件系统" tabindex="-1"><a class="header-anchor" href="#files-fs-文件-文件系统" aria-hidden="true">#</a> ## <code>files</code> &amp; <code>fs</code> | 文件 文件系统</h3><p>接下来，copy_process 开始初始化与文件和文件系统相关的变量。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>retval <span class="token operator">=</span> <span class="token function">copy_files</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
retval <span class="token operator">=</span> <span class="token function">copy_fs</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>copy_files 主要用于复制一个进程打开的文件信息。这些信息用一个结构 files_struct 来维护，每个打开的文件都有一个文件描述符。在 copy_files 函数里面调用 dup_fd，在这里面会创建一个新的 files_struct，然后将所有的文件描述符数组 fdtable 拷贝一份。</p><p>copy_fs 主要用于复制一个进程的目录信息。这些信息用一个结构 fs_struct 来维护。一个进程有自己的根目录和根文件系统 root，也有当前目录 pwd 和当前目录的文件系统，都在 fs_struct 里面维护。copy_fs 函数里面调用 copy_fs_struct，创建一个新的 fs_struct，并复制原来进程的 fs_struct。</p><h3 id="sigpending-sighand-signal-信号相关" tabindex="-1"><a class="header-anchor" href="#sigpending-sighand-signal-信号相关" aria-hidden="true">#</a> ## <code>sigpending</code> &amp; <code>sighand</code> &amp; <code>signal</code> | 信号相关</h3><p>接下来，copy_process 开始初始化与信号相关的变量。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token function">init_sigpending</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>pending<span class="token punctuation">)</span><span class="token punctuation">;</span>
retval <span class="token operator">=</span> <span class="token function">copy_sighand</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
retval <span class="token operator">=</span> <span class="token function">copy_signal</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>copy_sighand 会分配一个新的 sighand_struct。这里最主要的是维护信号处理函数，在 copy_sighand 里面会调用 memcpy，将信号处理函数 sighand-&gt;action 从父进程复制到子进程。</p><p>init_sigpending 和 copy_signal 用于初始化，并且复制用于维护发给这个进程的信号的数据结构。copy_signal 函数会分配一个新的 signal_struct，并进行初始化。</p><h3 id="mm-struct-内存空间" tabindex="-1"><a class="header-anchor" href="#mm-struct-内存空间" aria-hidden="true">#</a> ## <code>mm_struct</code> 内存空间</h3><p>接下来，copy_process 开始复制进程内存空间。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>retval <span class="token operator">=</span> <span class="token function">copy_mm</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>进程都有自己的内存空间，用 mm_struct 结构来表示。copy_mm 函数中调用 dup_mm，分配一个新的 mm_struct 结构，调用 memcpy 复制这个结构。dup_mmap 用于复制内存空间中内存映射的部分。前面讲系统调用的时候，我们说过，mmap 可以分配大块的内存，其实 mmap 也可以将一个文件映射到内存中，方便可以像读写内存一样读写文件，这个在内存管理那节我们讲。</p><h3 id="分配-pid-tgid-group-leader-建立亲缘关系" tabindex="-1"><a class="header-anchor" href="#分配-pid-tgid-group-leader-建立亲缘关系" aria-hidden="true">#</a> ## 分配 <code>pid/tgid/group_leader</code> 建立亲缘关系</h3><p>接下来，copy_process 开始分配 pid，设置 tgid，group_leader，并且建立进程之间的亲缘关系。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>  <span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>children<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>sibling<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    p<span class="token operator">-&gt;</span>pid <span class="token operator">=</span> <span class="token function">pid_nr</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CLONE_THREAD<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    p<span class="token operator">-&gt;</span>exit_signal <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>group_leader <span class="token operator">=</span> current<span class="token operator">-&gt;</span>group_leader<span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>tgid <span class="token operator">=</span> current<span class="token operator">-&gt;</span>tgid<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CLONE_PARENT<span class="token punctuation">)</span>
      p<span class="token operator">-&gt;</span>exit_signal <span class="token operator">=</span> current<span class="token operator">-&gt;</span>group_leader<span class="token operator">-&gt;</span>exit_signal<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
      p<span class="token operator">-&gt;</span>exit_signal <span class="token operator">=</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CSIGNAL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>group_leader <span class="token operator">=</span> p<span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>tgid <span class="token operator">=</span> p<span class="token operator">-&gt;</span>pid<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> <span class="token punctuation">(</span>CLONE_PARENT<span class="token operator">|</span>CLONE_THREAD<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    p<span class="token operator">-&gt;</span>real_parent <span class="token operator">=</span> current<span class="token operator">-&gt;</span>real_parent<span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>parent_exec_id <span class="token operator">=</span> current<span class="token operator">-&gt;</span>parent_exec_id<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    p<span class="token operator">-&gt;</span>real_parent <span class="token operator">=</span> current<span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span>parent_exec_id <span class="token operator">=</span> current<span class="token operator">-&gt;</span>self_exec_id<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>好了，copy_process 要结束了，上面图中的组件也初始化的差不多了。</p><h2 id="_2-唤醒新进程-wake-up-new-task" tabindex="-1"><a class="header-anchor" href="#_2-唤醒新进程-wake-up-new-task" aria-hidden="true">#</a> <strong>2：唤醒新进程 <code>wake_up_new_task</code></strong></h2><p>_do_fork 做的第二件大事是 wake_up_new_task。新任务刚刚建立，有没有机会抢占别人，获得 CPU 呢？</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">wake_up_new_task</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> rf<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  p<span class="token operator">-&gt;</span>state <span class="token operator">=</span> TASK_RUNNING<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token function">activate_task</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> p<span class="token punctuation">,</span> ENQUEUE_NOCLOCK<span class="token punctuation">)</span><span class="token punctuation">;</span>
  p<span class="token operator">-&gt;</span>on_rq <span class="token operator">=</span> TASK_ON_RQ_QUEUED<span class="token punctuation">;</span>
  <span class="token function">trace_sched_wakeup_new</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">check_preempt_curr</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> p<span class="token punctuation">,</span> WF_FORK<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="state-task-running" tabindex="-1"><a class="header-anchor" href="#state-task-running" aria-hidden="true">#</a> state = TASK_RUNNING</h3><p>首先，我们需要将进程的状态设置为 TASK_RUNNING。</p><h3 id="activate-task" tabindex="-1"><a class="header-anchor" href="#activate-task" aria-hidden="true">#</a> activate_task</h3><p>activate_task 函数中会调用 enqueue_task。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">enqueue_task</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  p<span class="token operator">-&gt;</span>sched_class<span class="token operator">-&gt;</span><span class="token function">enqueue_task</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> p<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="enqueue-task" tabindex="-1"><a class="header-anchor" href="#enqueue-task" aria-hidden="true">#</a> enqueue_task</h4><p>如果是 CFS 的调度类，则执行相应的 enqueue_task_fair。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">void</span>
<span class="token function">enqueue_task_fair</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>se <span class="token operator">=</span> <span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>se<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  cfs_rq <span class="token operator">=</span> <span class="token function">cfs_rq_of</span><span class="token punctuation">(</span>se<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">enqueue_entity</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> se<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  cfs_rq<span class="token operator">-&gt;</span>h_nr_running<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="enqueue-task-fair" tabindex="-1"><a class="header-anchor" href="#enqueue-task-fair" aria-hidden="true">#</a> enqueue_task_fair</h5><p>在 enqueue_task_fair 中取出的队列就是 cfs_rq，然后调用 enqueue_entity。</p><p>在 enqueue_entity 函数里面，会调用 update_curr，更新运行的统计量，然后调用 __enqueue_entity，将 sched_entity 加入到红黑树里面，然后将 se-&gt;on_rq = 1 设置在队列上。</p><h3 id="check-preempt-curr" tabindex="-1"><a class="header-anchor" href="#check-preempt-curr" aria-hidden="true">#</a> check_preempt_curr</h3><p>回到 enqueue_task_fair 后，将这个队列上运行的进程数目加一。然后，wake_up_new_task 会调用 check_preempt_curr，看是否能够抢占当前进程。</p><p>在 check_preempt_curr 中，会调用相应的调度类的 rq-&gt;curr-&gt;sched_class-&gt;check_preempt_curr(rq, p, flags)。对于 CFS 调度类来讲，调用的是 check_preempt_wakeup。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">check_preempt_wakeup</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> wake_flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>curr <span class="token operator">=</span> rq<span class="token operator">-&gt;</span>curr<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>se <span class="token operator">=</span> <span class="token operator">&amp;</span>curr<span class="token operator">-&gt;</span>se<span class="token punctuation">,</span> <span class="token operator">*</span>pse <span class="token operator">=</span> <span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>se<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq <span class="token operator">=</span> <span class="token function">task_cfs_rq</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">test_tsk_need_resched</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token function">find_matching_se</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>se<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pse<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">update_curr</span><span class="token punctuation">(</span><span class="token function">cfs_rq_of</span><span class="token punctuation">(</span>se<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">wakeup_preempt_entity</span><span class="token punctuation">(</span>se<span class="token punctuation">,</span> pse<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">goto</span> preempt<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span><span class="token punctuation">;</span>
preempt<span class="token operator">:</span>
  <span class="token function">resched_curr</span><span class="token punctuation">(</span>rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="check-preempt-wakeup" tabindex="-1"><a class="header-anchor" href="#check-preempt-wakeup" aria-hidden="true">#</a> check_preempt_wakeup</h4><p>在 check_preempt_wakeup 函数中，前面调用 task_fork_fair 的时候，设置 sysctl_sched_child_runs_first 了，已经将当前父进程的 TIF_NEED_RESCHED 设置了，则直接返回。</p><h5 id="resched-curr-标记父进程为-tif-need-resched" tabindex="-1"><a class="header-anchor" href="#resched-curr-标记父进程为-tif-need-resched" aria-hidden="true">#</a> resched_curr 标记父进程为 TIF_NEED_RESCHED</h5><p>否则，check_preempt_wakeup 还是会调用 update_curr 更新一次统计量，然后 wakeup_preempt_entity 将父进程和子进程 PK 一次，看是不是要抢占，如果要则调用 resched_curr 标记父进程为 TIF_NEED_RESCHED。</p><h2 id="_3-return返回用户态之前进行调度" tabindex="-1"><a class="header-anchor" href="#_3-return返回用户态之前进行调度" aria-hidden="true">#</a> 3: return返回用户态之前进行调度</h2><p>如果新创建的进程应该抢占父进程，在什么时间抢占呢？别忘了 fork 是一个系统调用，从系统调用返回的时候，是抢占的一个好时机，如果父进程判断自己已经被设置为 TIF_NEED_RESCHED，就让子进程先跑，抢占自己。</p><h2 id="总结时刻" tabindex="-1"><a class="header-anchor" href="#总结时刻" aria-hidden="true">#</a> <strong>总结时刻</strong></h2><p>好了，fork 系统调用的过程咱们就解析完了。它包含两个重要的事件，</p><ol><li>一个是将 <code>task_struct</code> 结构<code>复制一份</code>并且<code>初始化</code>，</li><li>另一个是<code>试图唤醒</code>新创建的子进程。</li></ol><p>这个过程我画了一张图，你可以对照着这张图回顾进程创建的过程。</p><ul><li>这个图的上半部分是复制 task_struct 结构，你可以对照着右面的 task_struct 结构图，看这里面的成员是如何一部分一部分地被复制的。</li><li>图的下半部分是唤醒新创建的子进程，如果条件满足，就会将当前进程设置应该被调度的标识位，就等着当前进程执行 __schedule 了。</li></ul><figure><img src="`+e+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><blockquote><ul><li>fork -&gt; sys_call_table 转换为 sys_fork()-&gt;<code>_do_fork</code></li><li>创建进程做两件事: 复制初始化 task_struct; 唤醒新进程</li><li>复制并初始化 task_struct, copy_process()</li><li>dup_task_struct: 分配 task_struct 结构体; 创建内核栈, 赋给<code>* stack</code>; 复制 task_struct, 设置 thread_info; <ul><li>copy_creds: 分配 cred 结构体并复制, p-&gt;cred = p-&gt;real_cred = get_cred(new)</li><li>初始化运行时统计量</li><li>sched_fork 调度相关结构体: 分配并初始化 sched_entity; state = TASK_NEW; 设置优先级和调度类; task_fork_fair()-&gt;update_curr 更新当前进程运行统计量, 将当前进程 vruntime 赋给子进程, 通过 sysctl_sched_child_runs_first 设置是否让子进程抢占, 若是则将其 sched_entity 放前头, 并调用 resched_curr 做被抢占标记.</li><li>初始化文件和文件系统变量</li><li>copy_files: 复制进程<code>打开的文件信息</code>, 用 files_struct 维护; <ul><li>copy_fs: 复制进程目录信息, 包括根目录/根<code>文件系统</code>; pwd 等, 用 fs_struct 维护</li></ul></li><li>初始化信号相关内容: 复制信号和处理函数</li><li>复制内存空间: 分配并复制 mm_struct; 复制内存映射信息</li><li>分配 pid</li></ul></li><li>唤醒新进程 wake_up_new_task()</li><li>state = TASK_RUNNING; activate 用调度类将当前子进程入队列 <ul><li>其中 enqueue_entiry 中会调用 update_curr 更新运行统计量, 再加入队列</li><li>调用 check_preempt_curr 看是否能抢占, 若 task_fork_fair 中已设置 sysctl_sched_child_runs_first, 直接返回, 否则进一步比较并调用 resched_curr 做抢占标记</li><li>若父进程被标记会被抢占, 则系统调用 fork 返回过程会调度子进程</li></ul></li></ul></blockquote><h2 id="课堂练习" tabindex="-1"><a class="header-anchor" href="#课堂练习" aria-hidden="true">#</a> <strong>课堂练习</strong></h2><p>你可以试着设置 sysctl_sched_child_runs_first 参数，然后使用系统调用写程序创建进程，看看执行结果。</p><p>欢迎留言和我分享你的疑惑和见解，也欢迎你收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习、进步。</p><h2 id="课后讨论" tabindex="-1"><a class="header-anchor" href="#课后讨论" aria-hidden="true">#</a> 课后讨论</h2><p>文章中出现了SYSCALL_DEFINE0宏定义，不明白，就网上查了一下，一看吓一跳，宏定义里面又有一堆宏定义，其实就是一个函数调用，为什么弄得这么复杂呢？原来是为了修复一个bug。这让我意识到linux内核代码的复杂性。linux是一个集大成者，为了适应各种硬件架构平台，修复各种意想不到的bug，里面充斥着各种兼容性代码，修复补丁等等。而且里面的代码也是世界各路大神，黑客写出来的，为了保证内核的安全性，健壮性，扩展性，考虑的东西非常之多，充斥着各种奇技淫巧，不是我等普通人短时间能够理解。每一行代码，甚至一个宏定义，都是要花时间研究的。从这个角度上来说，linux就像是一个迷宫，如果没有一个向导，进去后估计就出不来了。也许这个专栏的作用就是充当一个向导，欣赏沿途风景的同时，带领我们穿越迷宫，找到出口...<br> 作者回复: 是的。</p><p>有个问题：<br> 在数据库中，有个事务的概念，也就是保证一连串操作的原子性，如果其中任何一步错误，整个操作回滚，回到原来的状态，好像什么也没发生。但是在文章中我看到，在创建进程的过程中，步骤太多了。每一步都要申请空间，复制数据。如果其中一步发生了错误，怎么保证释放这些空间，回到原来状态？<br> 作者回复: 错了会做错误处理的，没有啥捷径，都是代码里面自己做的，写c就要这样，每一步都要清楚自己创建了什么，万一错误应该销毁什么。如果程序员不做这个，没有人帮忙，不像java还有个gc</p><p>老师，要是能把对应代码路径给出就好了，有时候自己找不见，谢谢老师~<br> 作者回复: 其实不用纠结，因为代码过一阵就变了，<code>关键是理解原理和流程</code>。我原来做过代码逐行分析的这种，但是发现这种文章过一阵就没法看了。</p><p>刘老师，遇到一个问题。<br> 您在上面两个章节提到过“进程调度第一定律”，是说任何被调度的task（无论是获得还是交出运行权一方）都是在调用<code>__schedule</code>方法，并因此在进程实际切换完成后不需修改指令指针寄存器。<br> 以此来思考本节介绍的创建进程过程。父进程在交出运行权的时候没什么特殊的，一定是在执行<code>__schedule</code>方法。<br> 然而当子进程获得运行权的时候，因为之前它没运行过，不是通过<code>__schedule</code>方法交出运行权的，当前的指令指针寄存器和子进程运行状态的上下文（dup_task_struct中？）不相符吧？这样不会出问题吗？<br> 作者回复: 不会的，调度这个函数是在内核里面的，这个逻辑其实不属于任何一个进程，反而是上下文的数据才标志了属于哪个进程。而且子进程刚fork完之后，没有exec之前，所有都和父进程一模一样</p><p>超哥，Oracle 这种多进程的数据库，和mysql 这种单进程多线程的数据库，在进程管理上有什么优势呢？看见创建进程这么复杂，资源消耗也多<br> 作者回复: 创建复杂，创建起来就好了，很多多进程的软件，也不是任务来了，现创建进程的，而是事先创建好了，等待分配任务。</p><p>内核态的内核进程和用户态的用户进程创建过程有区别吗？<br> 作者回复: 有区别的</p><p>调度类是全局的吗？还是每个cpu核有自己的调度类集合？<br> 作者回复: 类是全局的。里面主要实现的是算法。</p><p>子进程是如何抢占父进程的呢？<br> 作者回复: 一旦创建了，就独立竞争了</p>',92),i=[o];function l(u,r){return s(),a("div",null,i)}const _=n(c,[["render",l],["__file","H18-进程的创建.html.vue"]]);export{_ as default};
