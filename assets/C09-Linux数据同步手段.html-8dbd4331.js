import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as a,d as p}from"./app-cdabc73c.js";const t="/assets/a2968832f3f1055cc7ba68628a25d924-3b0c8a03.jpg",e="/assets/70c2d2580e8ec4b138db2f2807ba9f08-6732d735.jpg",o="/assets/7fd3abc144bb40331ca2aeb05ab5b7a9-429c3c82.jpg",c={},l=p(`<h1 id="_09-瞧一瞧linux-linux的自旋锁和信号量如何实现" tabindex="-1"><a class="header-anchor" href="#_09-瞧一瞧linux-linux的自旋锁和信号量如何实现" aria-hidden="true">#</a> 09 | 瞧一瞧Linux：Linux的自旋锁和信号量如何实现？</h1><p>你好，我是 LMOS。</p><p>上节课，我们学习了解决数据同步问题的思路与方法。Linux 作为成熟的操作系统内核，当然也有很多数据同步的机制，它也有原子变量、开启和关闭中断、自旋锁、信号量。</p><p>那今天我们就来探讨一下这些机制在 Linux 中的实现。看看 Linux 的实现和前面我们自己的实现有什么区别，以及 Linux 为什么要这么实现，这么实现背后的机理是什么。</p><h2 id="linux-的原子变量" tabindex="-1"><a class="header-anchor" href="#linux-的原子变量" aria-hidden="true">#</a> Linux 的原子变量</h2><p>首先，我们一起来看看 Linux 下的原子变量的实现，在 Linux 中，有许多共享的资源可能只是一个简单的整型数值。</p><p>例如在文件描述符中，需要包含一个简单的计数器。这个计数器表示有多少个应用程序打开了文件。在文件系统的 open 函数中，将这个计数器变量加 1；在 close 函数中，将这个计数器变量减 1。</p><p>如果单个进程执行打开和关闭操作，那么这个计数器变量不会出现问题，但是 Linux 是支持多进程的系统，如果有多个进程同时打开或者关闭文件，那么就可能导致这个计数器变量多加或者少加，出现错误。</p><p>为了避免这个问题，Linux 提供了<strong>一个原子类型变量 atomic_t</strong>。该变量的定义如下。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> counter<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token class-name">atomic_t</span><span class="token punctuation">;</span><span class="token comment">//常用的32位的原子变量类型</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_64BIT</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    s64 counter<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token class-name">atomic64_t</span><span class="token punctuation">;</span><span class="token comment">//64位的原子变量类型</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码自然不能用普通的代码去读写加减，而是要用 Linux 专门提供的接口函数去操作，否则就不能保证原子性了，代码如下。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//原子读取变量中的值</span>
<span class="token keyword">static</span> __always_inline <span class="token keyword">int</span> <span class="token function">arch_atomic_read</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">atomic_t</span> <span class="token operator">*</span>v<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">__READ_ONCE</span><span class="token punctuation">(</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token operator">-&gt;</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//原子写入一个具体的值</span>
<span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token function">arch_atomic_set</span><span class="token punctuation">(</span><span class="token class-name">atomic_t</span> <span class="token operator">*</span>v<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">__WRITE_ONCE</span><span class="token punctuation">(</span>v<span class="token operator">-&gt;</span>counter<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//原子加上一个具体的值</span>
<span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token function">arch_atomic_add</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token class-name">atomic_t</span> <span class="token operator">*</span>v<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span>LOCK_PREFIX <span class="token string">&quot;addl %1,%0&quot;</span>
             <span class="token operator">:</span> <span class="token string">&quot;+m&quot;</span> <span class="token punctuation">(</span>v<span class="token operator">-&gt;</span>counter<span class="token punctuation">)</span>
             <span class="token operator">:</span> <span class="token string">&quot;ir&quot;</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">&quot;memory&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//原子减去一个具体的值</span>
<span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token function">arch_atomic_sub</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token class-name">atomic_t</span> <span class="token operator">*</span>v<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span>LOCK_PREFIX <span class="token string">&quot;subl %1,%0&quot;</span>
             <span class="token operator">:</span> <span class="token string">&quot;+m&quot;</span> <span class="token punctuation">(</span>v<span class="token operator">-&gt;</span>counter<span class="token punctuation">)</span>
             <span class="token operator">:</span> <span class="token string">&quot;ir&quot;</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">&quot;memory&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//原子加1</span>
<span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token function">arch_atomic_inc</span><span class="token punctuation">(</span><span class="token class-name">atomic_t</span> <span class="token operator">*</span>v<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span>LOCK_PREFIX <span class="token string">&quot;incl %0&quot;</span>
             <span class="token operator">:</span> <span class="token string">&quot;+m&quot;</span> <span class="token punctuation">(</span>v<span class="token operator">-&gt;</span>counter<span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token string">&quot;memory&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//原子减1</span>
<span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token function">arch_atomic_dec</span><span class="token punctuation">(</span><span class="token class-name">atomic_t</span> <span class="token operator">*</span>v<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span>LOCK_PREFIX <span class="token string">&quot;decl %0&quot;</span>
             <span class="token operator">:</span> <span class="token string">&quot;+m&quot;</span> <span class="token punctuation">(</span>v<span class="token operator">-&gt;</span>counter<span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token string">&quot;memory&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Linux 原子类型变量的操作函数有很多，这里我只是介绍了最基础的几个函数，其它的原子类型变量操作也依赖于上述几个基础的函数。</p><p>你会发现，Linux 的实现也同样采用了 x86 CPU 的原子指令，LOCK_PREFIX 是一个宏，根据需要展开成“lock;”或者空串。<strong>单核心 CPU 是不需要 lock 前缀的，只要在多核心 CPU 下才需要加上 lock 前缀。</strong></p><p>剩下 __READ_ONCE，__WRITE_ONCE 两个宏，我们来看看它们分别做了什么，如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__READ_ONCE</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  </span><span class="token punctuation">\\</span>
<span class="token expression"><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">volatile</span> <span class="token function">__unqual_scalar_typeof</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__WRITE_ONCE</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">,</span> val<span class="token punctuation">)</span> </span><span class="token punctuation">\\</span>
<span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>
<span class="token comment">//__unqual_scalar_typeof表示声明一个非限定的标量类型，非标量类型保持不变。说人话就是返回x变量的类型，这是GCC的功能，typeof只是纯粹返回x的类型。</span>
<span class="token comment">//如果 x 是int类型则返回“int” </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__READ_ONCE</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  </span><span class="token punctuation">\\</span>
<span class="token expression"><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__WRITE_ONCE</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">,</span> val<span class="token punctuation">)</span> </span><span class="token punctuation">\\</span>
<span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> </span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结合刚才的代码，我给你做个解读。Linux 定义了 __READ_ONCE，__WRITE_ONCE 这两个宏，是对代码封装并利用 GCC 的特性对代码进行检查，把让错误显现在编译阶段。其中的“volatile int *”是为了提醒编译器：<strong>这是对内存地址读写，不要有优化动作，每次都必须强制写入内存或从内存读取。</strong></p><h2 id="linux-控制中断" tabindex="-1"><a class="header-anchor" href="#linux-控制中断" aria-hidden="true">#</a> Linux 控制中断</h2><p>Linux 中有很多场景，需要在关中断下才可以安全执行一些操作。</p><p>比如，多个中断处理程序需要访问一些共享数据，一个中断程序在访问数据时必须保证自身（中断嵌套）和其它中断处理程序互斥，否则就会出错。再比如，设备驱动程序在设置设备寄存器时，也必须让 CPU 停止响应中断。</p><p>Linux 控制 CPU 响应中断的函数如下。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//实际保存eflags寄存器</span>
<span class="token keyword">extern</span> __always_inline <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">native_save_fl</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>
    <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span><span class="token string">&quot;# __raw_save_flags\\n\\t&quot;</span>
                 <span class="token string">&quot;pushf ; pop %0&quot;</span><span class="token operator">:</span><span class="token string">&quot;=rm&quot;</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token operator">::</span><span class="token string">&quot;memory&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> flags<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//实际恢复eflags寄存器</span>
<span class="token keyword">extern</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">native_restore_fl</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span><span class="token string">&quot;push %0 ; popf&quot;</span><span class="token operator">::</span><span class="token string">&quot;g&quot;</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token operator">:</span><span class="token string">&quot;memory&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;cc&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//实际关中断</span>
<span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token function">native_irq_disable</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span><span class="token string">&quot;cli&quot;</span><span class="token operator">::</span><span class="token operator">:</span><span class="token string">&quot;memory&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//实际开启中断</span>
<span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token function">native_irq_enable</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span><span class="token string">&quot;sti&quot;</span><span class="token operator">::</span><span class="token operator">:</span><span class="token string">&quot;memory&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//arch层关中断</span>
<span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token function">arch_local_irq_disable</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">native_irq_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//arch层开启中断</span>
<span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token function">arch_local_irq_enable</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
    <span class="token function">native_irq_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//arch层保存eflags寄存器</span>
<span class="token keyword">static</span> __always_inline <span class="token keyword">unsigned</span> <span class="token keyword">long</span>           <span class="token function">arch_local_save_flags</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">native_save_fl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//arch层恢复eflags寄存器</span>
<span class="token keyword">static</span>  __always_inline <span class="token keyword">void</span> <span class="token function">arch_local_irq_restore</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">native_restore_fl</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//实际保存eflags寄存器并关中断</span>
<span class="token keyword">static</span> __always_inline <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">arch_local_irq_save</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags <span class="token operator">=</span> <span class="token function">arch_local_save_flags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">arch_local_irq_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> flags<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//raw层关闭开启中断宏</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">raw_local_irq_disable</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token function">arch_local_irq_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">raw_local_irq_enable</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token function">arch_local_irq_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span></span>
<span class="token comment">//raw层保存恢复eflags寄存器宏</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">raw_local_irq_save</span><span class="token expression"><span class="token punctuation">(</span>flags<span class="token punctuation">)</span>           </span><span class="token punctuation">\\</span>
    <span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span>                        </span><span class="token punctuation">\\</span>
        <span class="token expression"><span class="token function">typecheck</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    </span><span class="token punctuation">\\</span>
        <span class="token expression">flags <span class="token operator">=</span> <span class="token function">arch_local_irq_save</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      </span><span class="token punctuation">\\</span>
    <span class="token expression"><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>
    
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">raw_local_irq_restore</span><span class="token expression"><span class="token punctuation">(</span>flags<span class="token punctuation">)</span>            </span><span class="token punctuation">\\</span>
    <span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span>                        </span><span class="token punctuation">\\</span>
        <span class="token expression"><span class="token function">typecheck</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    </span><span class="token punctuation">\\</span>
        <span class="token expression"><span class="token function">arch_local_irq_restore</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>      </span><span class="token punctuation">\\</span>
    <span class="token expression"><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>
    
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">raw_local_save_flags</span><span class="token expression"><span class="token punctuation">(</span>flags<span class="token punctuation">)</span>         </span><span class="token punctuation">\\</span>
    <span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span>                        </span><span class="token punctuation">\\</span>
        <span class="token expression"><span class="token function">typecheck</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    </span><span class="token punctuation">\\</span>
        <span class="token expression">flags <span class="token operator">=</span> <span class="token function">arch_local_save_flags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </span><span class="token punctuation">\\</span>
    <span class="token expression"><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>
<span class="token comment">//通用层接口宏 </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">local_irq_enable</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span>              </span><span class="token punctuation">\\</span>
    <span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span> </span><span class="token punctuation">\\</span>
        <span class="token expression"><span class="token function">raw_local_irq_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         </span><span class="token punctuation">\\</span>
    <span class="token expression"><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">local_irq_disable</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span>             </span><span class="token punctuation">\\</span>
    <span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span>                        </span><span class="token punctuation">\\</span>
        <span class="token expression"><span class="token function">raw_local_irq_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        </span><span class="token punctuation">\\</span>
    <span class="token expression"><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">local_irq_save</span><span class="token expression"><span class="token punctuation">(</span>flags<span class="token punctuation">)</span>               </span><span class="token punctuation">\\</span>
    <span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span>                        </span><span class="token punctuation">\\</span>
        <span class="token expression"><span class="token function">raw_local_irq_save</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>      </span><span class="token punctuation">\\</span>
    <span class="token expression"><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">local_irq_restore</span><span class="token expression"><span class="token punctuation">(</span>flags<span class="token punctuation">)</span>            </span><span class="token punctuation">\\</span>
    <span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span>                        </span><span class="token punctuation">\\</span>
        <span class="token expression"><span class="token function">raw_local_irq_restore</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>       </span><span class="token punctuation">\\</span>
    <span class="token expression"><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以发现，Linux 中通过定义的方式对一些底层函数进行了一些包装，为了让你抓住重点，前面这些宏我去掉了和中断控制无关的额外操作，详细信息你可以参阅相关代码。</p><p>编译 Linux 代码时，编译器自动对宏进行展开。其中，do{}while(0)是 Linux 代码中一种常用的技巧，do{}while(0) 表达式会保证{}中的代码片段执行一次，保证宏展开时这个代码片段是一个整体。</p><p>带 native_ 前缀之类的函数则跟我们之前实现的 hal_ 前缀对应，而 Linux 为了支持不同的硬件平台，做了多层封装。</p><h2 id="linux-自旋锁" tabindex="-1"><a class="header-anchor" href="#linux-自旋锁" aria-hidden="true">#</a> Linux 自旋锁</h2><p>Linux 也是支持多核心 CPU 的操作系统内核，因此 Linux 也需要自旋锁来对系统中的共享资源进行保护。同一时刻，只有获取了锁的进程才能使用共享资源。</p><p>根据上节课对自旋锁算法的理解，自旋锁不会引起加锁进程睡眠，如果自旋锁已经被别的进程持有，加锁进程就需要一直循环在那里，查看是否该自旋锁的持有者已经释放了锁，&quot;自旋&quot;一词就是因此而得名。</p><p>Linux 有多种自旋锁，我们这里只介绍两种，<strong>原始自旋锁和排队自旋锁</strong>，它们底层原理和我们之前实现的没什么不同，但多了一些优化和改进，下面我们一起去看看。</p><h2 id="linux-原始自旋锁" tabindex="-1"><a class="header-anchor" href="#linux-原始自旋锁" aria-hidden="true">#</a> Linux 原始自旋锁</h2><p>我们先看看 Linux 原始的自旋锁，Linux 的原始自旋锁本质上用一个整数来表示，值为 1 代表锁未被占用，为 0 或者负数则表示被占用。</p><p>你可以结合上节课的这张图，理解后面的内容。当某个 CPU 核心执行进程请求加锁时，如果锁是未加锁状态，则加锁，然后操作共享资源，最后释放锁；如果锁已被加锁，则进程并不会转入睡眠状态，而是循环等待该锁，一旦锁被释放，则第一个感知此信息的进程将获得锁。</p><img src="`+t+`" alt="img" style="zoom:15%;"><p>自旋锁原理示意图</p><p>我们先来看看 Linux 原始自旋锁的数据结构，为方便你阅读，我删除了用于调试的数据字段，代码如下。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//最底层的自旋锁数据结构</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>
<span class="token keyword">volatile</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> lock<span class="token punctuation">;</span><span class="token comment">//真正的锁值变量，用volatile标识</span>
<span class="token punctuation">}</span><span class="token class-name">spinlock_t</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Linux 原始自旋锁数据结构封装了一个 unsigned long 类型的变量。有了数据结构，我们再来看看操作这个数据结构的函数，即自旋锁接口，代码如下。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">spin_unlock_string</span> <span class="token expression">\\  </span></span>
    <span class="token string">&quot;movb $1,%0&quot;</span> \\ <span class="token comment">//写入1表示解锁</span>
    <span class="token operator">:</span><span class="token string">&quot;=m&quot;</span> <span class="token punctuation">(</span>lock<span class="token operator">-&gt;</span>lock<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token operator">:</span> <span class="token string">&quot;memory&quot;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">spin_lock_string</span> <span class="token punctuation">\\</span>
  <span class="token string">&quot;\\n1:\\t&quot;</span> <span class="token expression">\\  </span></span>
    <span class="token string">&quot;lock ; decb %0\\n\\t&quot;</span> \\ <span class="token comment">//原子减1</span>
  <span class="token string">&quot;js 2f\\n&quot;</span> \\    <span class="token comment">//当结果小于0则跳转到标号2处，表示加锁失败</span>
    <span class="token string">&quot;.section .text.lock,\\&quot;ax\\&quot;\\n&quot;</span> \\ <span class="token comment">//重新定义一个代码段，这是优化技术，避免后面的代码填充cache，因为大部分情况会加锁成功，链接器会处理好这个代码段的</span>
  <span class="token string">&quot;2:\\t&quot;</span> \\  
    <span class="token string">&quot;cmpb $0,%0\\n\\t&quot;</span> \\  <span class="token comment">//和0比较</span>
    <span class="token string">&quot;rep;nop\\n\\t&quot;</span> \\  <span class="token comment">//空指令</span>
    <span class="token string">&quot;jle 2b\\n\\t&quot;</span> \\   <span class="token comment">//小于或等于0跳转到标号2</span>
    <span class="token string">&quot;jmp 1b\\n&quot;</span> \\   <span class="token comment">//跳转到标号1  </span>
    <span class="token string">&quot;.previous&quot;</span>
<span class="token comment">//获取自旋锁</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">spin_lock</span><span class="token punctuation">(</span><span class="token class-name">spinlock_t</span><span class="token operator">*</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span>
    __asm__ <span class="token function">__volatile__</span><span class="token punctuation">(</span>
    spin_lock_string
    <span class="token operator">:</span><span class="token string">&quot;=m&quot;</span><span class="token punctuation">(</span>lock<span class="token operator">-&gt;</span>lock<span class="token punctuation">)</span><span class="token operator">::</span><span class="token string">&quot;memory&quot;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//释放自旋锁</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">spin_unlock</span><span class="token punctuation">(</span><span class="token class-name">spinlock_t</span><span class="token operator">*</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span>
__asm__ <span class="token function">__volatile__</span><span class="token punctuation">(</span>
    spin_unlock_string
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中用 spin_lock_string、spin_unlock_string 两个宏，定义了获取、释放自旋锁的汇编指令。spin_unlock_string 只是简单将锁值变量设置成 1，表示释放自旋锁，spin_lock_string 中并没有像我们 Cosmos 一样使用 xchg 指令，而是使用了 decb 指令，这条指令也能原子地执行减 1 操作。</p><p>开始锁值变量为 1 时，执行 decb 指令就变成了 0，0 就表示加锁成功。如果小于 0，则表示有其它进程已经加锁了，就会导致循环比较。</p><h2 id="linux-排队自旋锁" tabindex="-1"><a class="header-anchor" href="#linux-排队自旋锁" aria-hidden="true">#</a> Linux 排队自旋锁</h2><p>现在我们再来看看 100 个进程获取同一个自旋锁的情况，开始 1 个进程获取了自旋锁 L，后面继续来了 99 个进程，它们都要获取自旋锁 L，但是它们必须等待，这时第 1 进程释放了自旋锁 L。请问，这 99 个进程中谁能先获取自旋锁 L 呢？</p><p>答案是不确定，因为这个次序依赖于哪个 CPU 核心能最先访问内存，而哪个 CPU 核心可以访问内存是由<strong>总线仲裁协议</strong>决定的。</p><p>很有可能最后来的进程最先获取自旋锁 L，这对其它等待的进程极其不公平，为了解决获取自旋锁的<strong>公平性</strong>，Linux 开发出了排队自旋锁。</p><p>你可以这样理解，想要给进程排好队，就需要确定顺序，也就是进程申请获取锁的先后次序，Linux 的排队自旋锁通过保存这个信息，就能更公平地调度进程了。</p><p>为了保存顺序信息，排队自旋锁重新定义了数据结构。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//RAW层的自旋锁数据结构</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">raw_spinlock</span><span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> slock<span class="token punctuation">;</span><span class="token comment">//真正的锁值变量</span>
<span class="token punctuation">}</span><span class="token class-name">raw_spinlock_t</span><span class="token punctuation">;</span>
<span class="token comment">//最上层的自旋锁数据结构</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">spinlock</span><span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">raw_spinlock</span> rlock<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token class-name">spinlock_t</span><span class="token punctuation">;</span>
<span class="token comment">//Linux没有这样的结构，这只是为了描述方便</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">raw_spinlock</span><span class="token punctuation">{</span>
    <span class="token keyword">union</span> <span class="token punctuation">{</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> slock<span class="token punctuation">;</span><span class="token comment">//真正的锁值变量</span>
        <span class="token keyword">struct</span> <span class="token punctuation">{</span>
        u16 owner<span class="token punctuation">;</span>
        u16 next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token class-name">raw_spinlock_t</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>slock 域被分成两部分，分别保存<strong>锁持有者</strong>和<strong>未来锁申请者</strong>的序号，如上述代码 10～16 行所示。</p><p>只有 next 域与 owner 域相等时，才表示自旋锁处于未使用的状态（此时也没有进程申请该锁）。在排队自旋锁初始化时，slock 被置为 0，即 next 和 owner 被置为 0，Linux 进程执行申请自旋锁时，原子地将 next 域加 1，并将原值返回作为自己的序号。</p><p>如果返回的序号等于申请时的 owner 值，说明自旋锁处于未使用的状态，则进程直接获得锁；否则，该进程循环检查 owner 域是否等于自己持有的序号，一旦相等，则表明锁轮到自己获取。</p><p>进程释放自旋锁时，原子地将 owner 域加 1 即可，下一个进程将会发现这一变化，从循环状态中退出。进程将严格地按照申请顺序依次获取排队自旋锁。这样一来，原先进程无序竞争的乱象就迎刃而解了。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">__raw_spin_lock</span><span class="token punctuation">(</span><span class="token class-name">raw_spinlock_t</span><span class="token operator">*</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token keyword">int</span> inc <span class="token operator">=</span> <span class="token number">0x00010000</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> tmp<span class="token punctuation">;</span>
__asm__ <span class="token function">__volatile__</span><span class="token punctuation">(</span>
<span class="token string">&quot;lock ; xaddl %0, %1\\n&quot;</span> <span class="token comment">//将inc和slock交换，然后 inc=inc+slock</span>
                        <span class="token comment">//相当于原子读取next和owner并对next+1</span>
<span class="token string">&quot;movzwl %w0, %2\\n\\t&quot;</span><span class="token comment">//将inc的低16位做0扩展后送tmp tmp=(u16)inc</span>
<span class="token string">&quot;shrl $16, %0\\n\\t&quot;</span> <span class="token comment">//将inc右移16位 inc=inc&gt;&gt;16</span>
<span class="token string">&quot;1:\\t&quot;</span>
<span class="token string">&quot;cmpl %0, %2\\n\\t&quot;</span> <span class="token comment">//比较inc和tmp，即比较next和owner </span>
<span class="token string">&quot;je 2f\\n\\t&quot;</span> <span class="token comment">//相等则跳转到标号2处返回</span>
<span class="token string">&quot;rep ; nop\\n\\t&quot;</span> <span class="token comment">//空指令</span>
<span class="token string">&quot;movzwl %1, %2\\n\\t&quot;</span> <span class="token comment">//将slock的低16位做0扩展后送tmp 即tmp=owner</span>
<span class="token string">&quot;jmp 1b\\n&quot;</span> <span class="token comment">//跳转到标号1处继续比较</span>
<span class="token string">&quot;2:&quot;</span>
<span class="token operator">:</span><span class="token string">&quot;+Q&quot;</span><span class="token punctuation">(</span>inc<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">&quot;+m&quot;</span><span class="token punctuation">(</span>lock<span class="token operator">-&gt;</span>slock<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">&quot;=r&quot;</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>
<span class="token operator">::</span><span class="token string">&quot;memory&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;cc&quot;</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">UNLOCK_LOCK_PREFIX</span> <span class="token expression">LOCK_PREFIX</span></span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">__raw_spin_unlock</span><span class="token punctuation">(</span><span class="token class-name">raw_spinlock_t</span><span class="token operator">*</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span>
__asm__ <span class="token function">__volatile__</span><span class="token punctuation">(</span>
UNLOCK_LOCK_PREFIX<span class="token string">&quot;incw %0&quot;</span><span class="token comment">//将slock的低16位加1 即owner+1</span>
<span class="token operator">:</span><span class="token string">&quot;+m&quot;</span><span class="token punctuation">(</span>lock<span class="token operator">-&gt;</span>slock<span class="token punctuation">)</span>
<span class="token operator">::</span><span class="token string">&quot;memory&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;cc&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中的注释已经描述得很清楚了，每条指令都有注解，供你参考。这里需要注意的是 Linux 为了避免差异性，在 spinlock_t 结构体中包含了 raw_spinlock_t，而在 raw_spinlock_t 结构体中并没使用 next 和 owner 字段，而是在代码中直接操作 slock 的高 16 位和低 16 位来实现的。</p><p>不知道你有没有过这样的经历？当你去银行办事，又发现人很多时，你很可能会选择先去处理一些别的事情，等过一会人比较少了，再来办理我们自己的业务。</p><p>其实，在使用自旋锁时也有同样的情况，当一个进程发现另一个进程已经拥有自己所请求的自旋锁时，就自愿放弃，转而做其它别的工作，并不想在这里循环等待，浪费自己的时间。</p><p>对于这种情况，Linux 同样提供了相应的自旋锁接口，如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">__raw_spin_trylock</span><span class="token punctuation">(</span><span class="token class-name">raw_spinlock_t</span><span class="token operator">*</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> tmp<span class="token punctuation">;</span>
    <span class="token keyword">int</span> new<span class="token punctuation">;</span>
    <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span>
    <span class="token string">&quot;movl %2,%0\\n\\t&quot;</span><span class="token comment">//tmp=slock</span>
    <span class="token string">&quot;movl %0,%1\\n\\t&quot;</span><span class="token comment">//new=tmp</span>
    <span class="token string">&quot;roll $16, %0\\n\\t&quot;</span><span class="token comment">//tmp循环左移16位，即next和owner交换了</span>
    <span class="token string">&quot;cmpl %0,%1\\n\\t&quot;</span><span class="token comment">//比较tmp和new即（owner、next）？=（next、owner）</span>
    <span class="token string">&quot;jne 1f\\n\\t&quot;</span> <span class="token comment">//不等则跳转到标号1处 </span>
    <span class="token string">&quot;addl $0x00010000, %1\\n\\t&quot;</span><span class="token comment">//相当于next+1</span>
    <span class="token string">&quot;lock ; cmpxchgl %1,%2\\n\\t&quot;</span><span class="token comment">//new和slock交换比较    </span>
    <span class="token string">&quot;1:&quot;</span>
    <span class="token string">&quot;sete %b1\\n\\t&quot;</span> <span class="token comment">//new = eflags.ZF位，ZF取决于前面的判断是否相等</span>
    <span class="token string">&quot;movzbl %b1,%0\\n\\t&quot;</span> <span class="token comment">//tmp = new</span>
    <span class="token operator">:</span><span class="token string">&quot;=&amp;a&quot;</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">&quot;=Q&quot;</span><span class="token punctuation">(</span>new<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">&quot;+m&quot;</span><span class="token punctuation">(</span>lock<span class="token operator">-&gt;</span>slock<span class="token punctuation">)</span>
    <span class="token operator">::</span><span class="token string">&quot;memory&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;cc&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> __lockfunc <span class="token function">_spin_trylock</span><span class="token punctuation">(</span><span class="token class-name">spinlock_t</span><span class="token operator">*</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span> 
    <span class="token function">preempt_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">_raw_spin_trylock</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">spin_acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token operator">-&gt;</span>dep_map<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>_RET_IP_<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">preempt_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">spin_trylock</span><span class="token expression"><span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token function">__cond_lock</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> <span class="token function">_spin_trylock</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>_cond_lock 只用代码静态检查工作，一定要明白 _spin_trylock 返回 1 表示尝试加锁成功，可以安全的地问共享资源了；返回值为 0 则表示尝试加锁失败，不能操作共享资源，应该等一段时间，再次尝试加锁。</p><h2 id="linux-信号量" tabindex="-1"><a class="header-anchor" href="#linux-信号量" aria-hidden="true">#</a> Linux 信号量</h2><p>Linux 中的信号量同样是用来保护共享资源，能保证资源在一个时刻只有一个进程使用，这是单值信号量。也可以作为资源计数器，比如一种资源有五份，同时最多可以有五个进程，这是多值信号量。</p><p>单值信号量，类比于私人空间一次只进去一个人，其信号量的值初始值为 1，而多值信号量，相当于是客厅，可同时容纳多个人。其信号量的值初始值为 5，就可容纳 5 个人。</p><p>信号量的值为正的时候。所申请的进程可以锁定使用它。若为 0，说明它被其它进程占用，申请的进程要进入睡眠队列中，等待被唤醒。所以信号量最大的优势是既<strong>可以使申请失败的进程睡眠，还可以作为资源计数器使用。</strong></p><p>我们先来看看 Linux 实现信号量所使用的数据结构，如下所示：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">semaphore</span><span class="token punctuation">{</span>
    <span class="token class-name">raw_spinlock_t</span> lock<span class="token punctuation">;</span><span class="token comment">//保护信号量自身的自旋锁</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span><span class="token comment">//信号量值</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> wait_list<span class="token punctuation">;</span><span class="token comment">//挂载睡眠等待进程的链表</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面我们就跟着 Linux 信号量接口函数，一步步探索 Linux 信号量工作原理，和它对进程状态的影响，先来看看 Linux 信号量的使用案例，如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">down_console_sem</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">do</span> <span class="token punctuation">{</span> </span><span class="token punctuation">\\</span>
    <span class="token expression"><span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>console_sem<span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token punctuation">\\</span>
<span class="token expression"><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">__up_console_sem</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> ip<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>console_sem<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">up_console_sem</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">__up_console_sem</span><span class="token punctuation">(</span>_RET_IP_<span class="token punctuation">)</span></span></span>
<span class="token comment">//加锁console</span>
<span class="token keyword">void</span> <span class="token function">console_lock</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">might_sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">down_console_sem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取信号量console_sem</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>console_suspended<span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    console_locked <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    console_may_schedule <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//解锁console</span>
<span class="token keyword">void</span> <span class="token function">console_unlock</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">char</span> ext_text<span class="token punctuation">[</span>CONSOLE_EXT_LOG_MAX<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">char</span> text<span class="token punctuation">[</span>LOG_LINE_MAX <span class="token operator">+</span> PREFIX_MAX<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">//……删除了很多代码</span>
    <span class="token function">up_console_sem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放信号量console_sem</span>
    <span class="token function">raw_spin_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>logbuf_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//……删除了很多代码   </span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了简单说明问题，我删除了很多代码，上面代码中以 console 驱动为例说明了信号量的使用。</p><p>在 Linux 源代码的 kernel/printk.c 中，使用宏 DEFINE_SEMAPHORE 声明了一个单值信号量 console_sem，也可以说是<strong>互斥锁</strong>，它用于保护 console 驱动列表 console_drivers 以及同步对整个 console 驱动的访问。</p><p>其中定义了宏 down_console_sem() 来获得信号量 console_sem，定义了宏 up_console_sem() 来释放信号量 console_sem，console_lock 和 console_unlock 函数是用于互斥访问 console 驱动的，核心操作就是调用前面定义两个宏。</p><p>上面的情景中，down_console_sem() 和 up_console_sem() 宏的核心主要是调用了信号量的接口函数 down、up 函数，完成获取、释放信号量的核心操作，代码如下。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> __sched <span class="token function">__down_common</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">semaphore</span> <span class="token operator">*</span>sem<span class="token punctuation">,</span> <span class="token keyword">long</span> state<span class="token punctuation">,</span><span class="token keyword">long</span> timeout<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">semaphore_waiter</span> waiter<span class="token punctuation">;</span>
    <span class="token comment">//把waiter加入sem-&gt;wait_list的头部</span>
    <span class="token function">list_add_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>waiter<span class="token punctuation">.</span>list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sem<span class="token operator">-&gt;</span>wait_list<span class="token punctuation">)</span><span class="token punctuation">;</span>
    waiter<span class="token punctuation">.</span>task <span class="token operator">=</span> current<span class="token punctuation">;</span><span class="token comment">//current表示当前进程，即调用该函数的进程</span>
    waiter<span class="token punctuation">.</span>up <span class="token operator">=</span> false<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">signal_pending_state</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> current<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">goto</span> interrupted<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>timeout <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">goto</span> timed_out<span class="token punctuation">;</span>
        <span class="token function">__set_current_state</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设置当前进程的状态，进程睡眠，即先前__down函数中传入的TASK_UNINTERRUPTIBLE：该状态是等待资源有效时唤醒（比如等待键盘输入、socket连接、信号（signal）等等），但不可以被中断唤醒</span>
        <span class="token function">raw_spin_unlock_irq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-&gt;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放在down函数中加的锁</span>
        timeout <span class="token operator">=</span> <span class="token function">schedule_timeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//真正进入睡眠</span>
        <span class="token function">raw_spin_lock_irq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-&gt;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//进程下次运行会回到这里，所以要加锁</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>waiter<span class="token punctuation">.</span>up<span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 timed_out<span class="token operator">:</span>
    <span class="token function">list_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>waiter<span class="token punctuation">.</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">-</span>ETIME<span class="token punctuation">;</span>
 interrupted<span class="token operator">:</span>
    <span class="token function">list_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>waiter<span class="token punctuation">.</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">-</span>EINTR<span class="token punctuation">;</span>

    <span class="token comment">//为了简单起见处理进程信号（signal）和超时的逻辑代码我已经删除</span>
<span class="token punctuation">}</span>
<span class="token comment">//进入睡眠等待</span>
<span class="token keyword">static</span> noinline <span class="token keyword">void</span> __sched <span class="token function">__down</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">semaphore</span> <span class="token operator">*</span>sem<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">__down_common</span><span class="token punctuation">(</span>sem<span class="token punctuation">,</span> TASK_UNINTERRUPTIBLE<span class="token punctuation">,</span> MAX_SCHEDULE_TIMEOUT<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//获取信号量</span>
<span class="token keyword">void</span> <span class="token function">down</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">semaphore</span> <span class="token operator">*</span>sem<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>
    <span class="token comment">//对信号量本身加锁并关中断，也许另一段代码也在操作该信号量</span>
    <span class="token function">raw_spin_lock_irqsave</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-&gt;</span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>sem<span class="token operator">-&gt;</span>count <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        sem<span class="token operator">-&gt;</span>count<span class="token operator">--</span><span class="token punctuation">;</span><span class="token comment">//如果信号量值大于0,则对其减1</span>
    <span class="token keyword">else</span>
        <span class="token function">__down</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//否则让当前进程进入睡眠</span>
    <span class="token function">raw_spin_unlock_irqrestore</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-&gt;</span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//实际唤醒进程 </span>
<span class="token keyword">static</span> noinline <span class="token keyword">void</span> __sched <span class="token function">__up</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">semaphore</span> <span class="token operator">*</span>sem<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">semaphore_waiter</span> <span class="token operator">*</span>waiter <span class="token operator">=</span> <span class="token function">list_first_entry</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-&gt;</span>wait_list<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">semaphore_waiter</span><span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//获取信号量等待链表中的第一个数据结构semaphore_waiter，它里面保存着睡眠进程的指针</span>
    <span class="token function">list_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>waiter<span class="token operator">-&gt;</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
    waiter<span class="token operator">-&gt;</span>up <span class="token operator">=</span> true<span class="token punctuation">;</span>
    <span class="token function">wake_up_process</span><span class="token punctuation">(</span>waiter<span class="token operator">-&gt;</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//唤醒进程重新加入调度队列</span>
<span class="token punctuation">}</span>
<span class="token comment">//释放信号量</span>
<span class="token keyword">void</span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">semaphore</span> <span class="token operator">*</span>sem<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>
    <span class="token comment">//对信号量本身加锁并关中断，必须另一段代码也在操作该信号量</span>
    <span class="token function">raw_spin_lock_irqsave</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-&gt;</span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span><span class="token function">list_empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-&gt;</span>wait_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        sem<span class="token operator">-&gt;</span>count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//如果信号量等待链表中为空，则对信号量值加1</span>
    <span class="token keyword">else</span>
        <span class="token function">__up</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//否则执行唤醒进程相关的操作</span>
    <span class="token function">raw_spin_unlock_irqrestore</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-&gt;</span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中的逻辑，已经描述了信号量的工作原理。需要注意的是，一个进程进入了 __down 函数中，设置了一个不可中断的等待状态，然后执行了 schedule_timeout 函数。这个执行了进程的调度器，就直接调度到别的进程运行了。</p><p>这时，这个进程就不会返回了，直到下一次它被 up 函数唤醒。执行了 wake_up_process 函数以后，重新调度它就会回到 schedule_timeout 函数下一行代码，沿着调用路经返回，最后从 __down 函数中出来，即进程睡醒了。</p><h2 id="linux-读写锁" tabindex="-1"><a class="header-anchor" href="#linux-读写锁" aria-hidden="true">#</a> Linux 读写锁</h2><p>在操作系统中，有很多共享数据，进程对这些共享数据要进行修改的情况很少，而读取的情况却是非常多的，这些共享数据的操作基本都是在读取。</p><p>如果每次读取这些共享数据都加锁的话，那就太浪费时间了，会降低进程的运行效率。因为读操作不会导致修改数据，所以在读取数据的时候不用加锁了，而是可以共享的访问，只有涉及到对共享数据修改的时候，才需要加锁互斥访问。</p><p>想像一下 100 个进程同时读取一个共享数据，而每个进程都要加锁解锁，剩下的进程只能等待，这会大大降低整个系统性能，这时候就需要使用一种新的锁了——读写锁。</p><p>读写锁也称为共享 - 独占（shared-exclusive）锁，当读写锁用读取模式加锁时，它是以共享模式上锁的，当以写入修改模式加锁时，它是以独占模式上锁的（互斥）。</p><p>读写锁非常适合<strong>读取数据的频率远大于修改数据的频率</strong>的场景中。这样可以在任何时刻，保证多个进程的读取操作并发地执行，给系统带来了更高的并发度。</p><p>那读写锁是怎么工作的呢？<strong>读写之间是互斥的</strong>，读取的时候不能写入，写入的时候不能读取，而且读取和写入操作在竞争锁的时候，<strong>写会优先得到锁</strong>，步骤如下。</p><p>\\1. 当共享数据没有锁的时候，读取的加锁操作和写入的加锁操作都可以满足。</p><p>\\2. 当共享数据有读锁的时候，所有的读取加锁操作都可以满足，写入的加锁操作不能满足，读写是互斥的。</p><p>\\3. 当共享数据有写锁的时候，所有的读取的加锁操作都不能满足，所有的写入的加锁操作也不能满足，读与写之间是互斥的，写与写之间也是互斥的。</p><p>如果你感觉刚才说的步骤还是太复杂，那我再给你画一个表，你就清楚了，如下所示。</p><img src="`+e+`" alt="img" style="zoom:25%;"><p>好了，我们明白了读写锁的加锁规则，现在就去看看 Linux 中的读写锁的实现，<strong>Linux 中的读写锁本质上是自旋锁的变种</strong>。</p><p>后面这段代码是 Linux 中读写锁的核心代码，请你注意，<strong>实际操作的时候，我们不是直接使用上面的函数和数据结构，而是应该使用 Linux 提供的标准接口，如 read_lock、write_lock 等</strong>。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//读写锁初始化锁值</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RW_LOCK_BIAS</span>     <span class="token expression"><span class="token number">0x01000000</span></span></span>
<span class="token comment">//读写锁的底层数据结构</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> lock<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token class-name">arch_rwlock_t</span><span class="token punctuation">;</span>
<span class="token comment">//释放读锁 </span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">arch_read_unlock</span><span class="token punctuation">(</span><span class="token class-name">arch_rwlock_t</span><span class="token operator">*</span>rw<span class="token punctuation">)</span><span class="token punctuation">{</span> 
    <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span>
        LOCK_PREFIX<span class="token string">&quot;incl %0&quot;</span> <span class="token comment">//原子对lock加1</span>
        <span class="token operator">:</span><span class="token string">&quot;+m&quot;</span><span class="token punctuation">(</span>rw<span class="token operator">-&gt;</span>lock<span class="token punctuation">)</span><span class="token operator">::</span><span class="token string">&quot;memory&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//释放写锁</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">arch_write_unlock</span><span class="token punctuation">(</span><span class="token class-name">arch_rwlock_t</span><span class="token operator">*</span>rw<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span>
        LOCK_PREFIX<span class="token string">&quot;addl %1, %0&quot;</span><span class="token comment">//原子对lock加上RW_LOCK_BIAS</span>
        <span class="token operator">:</span><span class="token string">&quot;+m&quot;</span><span class="token punctuation">(</span>rw<span class="token operator">-&gt;</span>lock<span class="token punctuation">)</span><span class="token operator">:</span><span class="token string">&quot;i&quot;</span><span class="token punctuation">(</span>RW_LOCK_BIAS<span class="token punctuation">)</span><span class="token operator">:</span><span class="token string">&quot;memory&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//获取写锁失败时调用</span>
<span class="token function">ENTRY</span><span class="token punctuation">(</span>__write_lock_failed<span class="token punctuation">)</span>
    <span class="token comment">//(%eax)表示由eax指向的内存空间是调用者传进来的 </span>
    <span class="token number">2</span><span class="token operator">:</span>LOCK_PREFIX addl  $ RW_LOCK_BIAS<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">%</span>eax<span class="token punctuation">)</span>
    <span class="token number">1</span><span class="token operator">:</span>rep<span class="token punctuation">;</span>nop<span class="token comment">//空指令</span>
    cmpl $RW_LOCK_BIAS<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">%</span>eax<span class="token punctuation">)</span>
    <span class="token comment">//不等于初始值则循环比较，相等则表示有进程释放了写锁</span>
    jne   <span class="token number">1</span>b
    <span class="token comment">//执行加写锁</span>
    LOCK_PREFIX subl  $ RW_LOCK_BIAS<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">%</span>eax<span class="token punctuation">)</span>
    jnz <span class="token number">2</span>b <span class="token comment">//不为0则继续测试，为0则表示加写锁成功</span>
    ret <span class="token comment">//返回</span>
<span class="token function">ENDPROC</span><span class="token punctuation">(</span>__write_lock_failed<span class="token punctuation">)</span>
<span class="token comment">//获取读锁失败时调用</span>
<span class="token function">ENTRY</span><span class="token punctuation">(</span>__read_lock_failed<span class="token punctuation">)</span>
    <span class="token comment">//(%eax)表示由eax指向的内存空间是调用者传进来的 </span>
    <span class="token number">2</span><span class="token operator">:</span>LOCK_PREFIX <span class="token function">incl</span><span class="token punctuation">(</span><span class="token operator">%</span>eax<span class="token punctuation">)</span><span class="token comment">//原子加1</span>
    <span class="token number">1</span><span class="token operator">:</span>  rep<span class="token punctuation">;</span> nop<span class="token comment">//空指令</span>
    cmpl  $<span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">%</span>eax<span class="token punctuation">)</span> <span class="token comment">//和1比较 小于0则</span>
    js <span class="token number">1</span>b <span class="token comment">//为负则继续循环比较</span>
    LOCK_PREFIX <span class="token function">decl</span><span class="token punctuation">(</span><span class="token operator">%</span>eax<span class="token punctuation">)</span> <span class="token comment">//加读锁</span>
    js  <span class="token number">2</span>b  <span class="token comment">//为负则继续加1并比较，否则返回</span>
    ret <span class="token comment">//返回</span>
<span class="token function">ENDPROC</span><span class="token punctuation">(</span>__read_lock_failed<span class="token punctuation">)</span>
<span class="token comment">//获取读锁</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">arch_read_lock</span><span class="token punctuation">(</span><span class="token class-name">arch_rwlock_t</span><span class="token operator">*</span>rw<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span>
        LOCK_PREFIX<span class="token string">&quot; subl $1,(%0)\\n\\t&quot;</span><span class="token comment">//原子对lock减1</span>
        <span class="token string">&quot;jns 1f\\n&quot;</span><span class="token comment">//不为小于0则跳转标号1处，表示获取读锁成功</span>
        <span class="token string">&quot;call __read_lock_failed\\n\\t&quot;</span><span class="token comment">//调用__read_lock_failed</span>
        <span class="token string">&quot;1:\\n&quot;</span>
        <span class="token operator">::</span><span class="token function">LOCK_PTR_REG</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token operator">:</span><span class="token string">&quot;memory&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//获取写锁</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">arch_write_lock</span><span class="token punctuation">(</span><span class="token class-name">arch_rwlock_t</span><span class="token operator">*</span>rw<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span>
        LOCK_PREFIX<span class="token string">&quot;subl %1,(%0)\\n\\t&quot;</span><span class="token comment">//原子对lock减去RW_LOCK_BIAS</span>
        <span class="token string">&quot;jz 1f\\n&quot;</span><span class="token comment">//为0则跳转标号1处</span>
        <span class="token string">&quot;call __write_lock_failed\\n\\t&quot;</span><span class="token comment">//调用__write_lock_failed</span>
        <span class="token string">&quot;1:\\n&quot;</span>
        <span class="token operator">::</span><span class="token function">LOCK_PTR_REG</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">&quot;i&quot;</span><span class="token punctuation">(</span>RW_LOCK_BIAS<span class="token punctuation">)</span><span class="token operator">:</span><span class="token string">&quot;memory&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Linux 读写锁的原理本质是基于计数器，初始值为 0x01000000，获取读锁时对其减 1，结果不小于 0 则表示获取读锁成功，获取写锁时直接减去 0x01000000。</p><p>说到这里你可能要问了，为何要减去初始值呢？这是因为只有当锁值为初始值时，减去初始值结果才可以是 0，这是唯一没有进程持有任何锁的情况，这样才能保证获取写锁时是互斥的。</p><p>__read_lock_failed、__write_lock_failed 是两个汇编函数，注释写得很详细了，和前面自旋锁的套路是一样的。我们可以看出，读写锁其实是带计数的特殊自旋锁，能同时被多个读取数据的进程占有或一个修改数据的进程占有，但不能同时被读取数据的进程和修改数据的进程占有。</p><p>我们再次梳理一下获取、释放读写锁的流程，如下所示。</p><p>\\1. 获取读锁时，锁值变量 lock 计数减去 1，判断结果的符号位是否为 1。若结果符号位为 0 时，获取读锁成功，即表示 lock 大于 0。</p><p>\\2. 获取读锁时，锁值变量 lock 计数减去 1，判断结果的符号位是否为 1。若结果符号位为 1 时，获取读锁失败，表示此时读写锁被修改数据的进程占有，此时调用 __read_lock_failed 失败处理函数，循环测试 lock+1 的值，直到结果的值大于等于 1。</p><p>\\3. 获取写锁时，锁值变量 lock 计数减去 RW_LOCK_BIAS_STR，即 lock-0x01000000，判断结果是否为 0。若结果为 0 时，表示获取写锁成功。</p><p>\\4. 获取写锁时，锁值变量 lock 计数减去 RW_LOCK_BIAS_STR，即 lock-0x01000000，判断结果是否为 0。若结果不为 0 时，获取写锁失败，表示此时有读取数据的进程占有读锁或有修改数据的进程占有写锁，此时调用 __write_lock_failed 失败处理函数，循环测试 lock+0x01000000，直到结果的值等于 0x01000000。</p><h2 id="重点回顾" tabindex="-1"><a class="header-anchor" href="#重点回顾" aria-hidden="true">#</a> 重点回顾</h2><p>好了，这节课的内容讲完了。我们一起学习了 Linux 上实现数据同步的五大利器，分别是 Linux 原子变量、Linux 中断控制、Linux 自旋锁、Linux 信号量、Linux 读写锁。我把重点给你梳理一下。</p><img src="`+o+'" alt="img" style="zoom:25%;"><blockquote><p><strong>锁，保证了数据的安全访问，但是它给程序的并行性能造成了巨大损害，所以在设计一个算法时应尽量避免使用锁。若无法避免，则应根据实际情况使用相应类型的锁，以降低锁的不当使用带来的性能损失。</strong></p></blockquote><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题" aria-hidden="true">#</a> <strong>思考题</strong></h2><p>请试着回答：上述 Linux 的读写锁，支持多少个进程并发读取共享数据？这样的读写锁有什么不足？</p><p>欢迎你在留言区和我交流，相信通过积极参与，你将更好地理解这节课的内容。</p><p>我是 LMOS，我们下节课见！</p><h2 id="【】课后讨论" tabindex="-1"><a class="header-anchor" href="#【】课后讨论" aria-hidden="true">#</a> 【】课后讨论</h2><p>同步与锁<br> 操作系统是让应用程序认为当前有超大的内存空间和强大的cpu来工作的硬件环境，但其实硬件没有这么强大。那如何解决呢？比如在单核cpu上可以用分时技术，让进程交替执行。对于一个进程来说，我们可以把一个进程变成了多个线程来执行。但这样就产生了同一个资源可以是内存的某一具体地址，可以是鼠标可以是磁盘上的某一文件被多个线程访问和修改的问题。这两节课提供了解决思路，一个是cosmos操作系统的方案，一个是linux的方案。<br> 1.原子性。就是硬件执行指令时不被打断。对于x86是复杂指令集。一条指令可以做读修改内存值的操作，指令集中直接支持锁定操作。对于精简指令集，就相对麻烦些，硬件会提供bitband的操作。<br> 2.中断控制是在执行时，防止中断信号突然来了把当前执行的过程打断了。 解决方法就是关闭中断。让中断信号等到可以通知时，才发起通知。<br> 3.自旋锁。<strong>在多核的cpu环境下</strong>，当前核心的cpu要访问的资源是有可能被其他核的cpu来访问的。<strong>如果产生这种情况，那就让其他核的cpu自己执行空转。<strong>一直到当前核心的cpu把访问资源让出后，其他核的cpu通过检测到了可以访问资源，不在空转执行相关操作恢复正常运行。<strong>而这个过程就是自旋锁</strong>。这里会有一点浪费cpu的运行效率。<strong>毕竟有个cpu在空转</strong>。当空转时间过长时，浪费的效能更大。我们需要更好的利用cpu核的方式来解决这个问题。<strong>那就是互斥</strong>。<br> 4.信号量对于单一资源的信号量也可以说是</strong>互斥锁</strong>。互斥锁和自旋锁的区别就是原来那个空转的核<strong>不再空转</strong>，而是把当前运行的线程或者进程睡眠去执行其他的线程或者进程了。<strong>当资源被适当后</strong>，去通知睡眠线程或者进程。这就是信号量。linux下新版本的信号量在被移除。<br> 作者回复: 你好，铁子总结 到位</p><hr><p>回答思考题：Linux 的读写锁，因为每次读锁加锁计数-1，所以最多支持0x01000000个进程并发读取共享数据。<br> 这样的读写锁的不足：读或者写锁拿不到时忙等，可以优化成<code>trylock</code>，拿不到可以先干其他的，等一段时间再尝试拿锁。（不知道回答的对不对）<br> 感悟：不论是单值信号量还是多值信号量，亦或是原始自旋锁、trylock版本自旋锁还是读写锁，各种机制的设计和优化都是为了资源（CPU等）的更合理更高效的使用而优化。互斥机制有很多，理解每种锁机制重要，<strong>但是理解我们的业务更重要，这样才能因地制宜选择合适的锁</strong>。<br> 老师简明扼要，点到即止的文风太赞了，谢谢。<br> 作者回复: 是的</p><hr><p>像这样的清晰明了，言简意赅的Linux内核源码解读实在是太少了，这样的文章读起来实在是太爽了，强烈小编安排一下东哥的下一个专栏叫做 《纵览Linux源码，小白也能学透》。<br> 对于思考题答案，读并发进程的最大个数就是0x01000000，只要lock大于0都是可以共享数据的。<br> 至于读写锁的不足，我个人觉得最不友好的点在于读写互斥上，由于读锁对写锁是互斥的，如果一直有人读，那么计数器一直小于0x01000000，加写锁时也一直小于0，写锁一直也不会成功，会陷入长时间的写饥饿状态，并且一直自旋，浪费CPU资源。<br> 所以改进点就在于，给写进程配上一个休眠队列，待加锁失败进入队列休眠等待，待解读锁时判断计数器，决定是否唤醒队列中的写进程。<br> 当然还有很多其它的优化点，欢迎大家集思广益~<br> 作者回复: 哈哈 欢迎</p><hr><p>这个排队自旋锁的实现方式感觉很风骚啊。关于读锁最大支持进程数是0x01000000（学友们都已经解答了）关于写饥饿的问题，既然写锁和读锁在同时获取锁状态时候写锁优先，那么就应该对读锁做一个限制，不能让读锁朝着最大数奔去。比如，系统检测到有写锁在等待，那么就限制新的读锁加入，等已经存在的读锁都释放了，写锁马上加锁更新资源。然后等待的读锁再开始加锁读取。这个等待的队列要分为读锁队列和写锁队列。优先处理写锁队列，在没有写锁的时候才能继续加读锁，如果有写锁等待，那么新的读锁不管超没超出那个最大数，都要进入读锁队列等待写锁完成后再开始自己的表演。<br> 作者回复: 嗯嗯见解独到</p><hr><p>回答一下思考题<br> 1.理论上可以支持x01000000这么多进程，但实际上受限于文件句炳也就是文件描述符的限制，还有考虑多个线程的问题等等，注定最终远远小于这个值<br> 2.读写锁造成写饥饿的情况是不是可以参考jdk的读写锁的实现，在条件等待队列中判断队列第一个元素是不是一个写进程，如果是写进程，让其直接优先获取锁.<br> 作者回复: 嗯嗯</p><hr><p>请问老师，四种解决并发的方法中里是不是只有关中断是只和CPU的状态有关，也就是关闭了CPU接受中断调用的服务，<strong>其他的原子操作，自旋锁，信号量都需要内存和CPU各自的原子操作来配合</strong>？<br> 作者回复: 是的 是的</p><hr><p>我认为，支持并发读的数量是0x01000000,支持并行读的数量是cpu核心的数量；而不足之处就在于忙等浪费cpu时间了。读的时候可以让写的进程让出cpu休眠吗？期望老师高见！<br> 作者回复: 66666，对的</p><hr><p>说下自己对锁底层的理机，锁是依赖硬件提供的原子指令来执行的。普通互斥锁是lock值1 获取锁则对该值进行原子减，如果这个值本身就小于1，那说明被锁住了。。。独写锁的区别是他是0x01000000的值，读锁减1，写锁减0x01000000，读锁可以被0x01000000共享，写锁是互斥的只能被减一次。。。 突然感觉原子操作是计算机最底层的功能，以前在Java碰到这个问题就范懵，就是自己对底层理解太少导致的，无论是应用层的并发包，还是操作系统内核层，对原子操作都是非常依赖。。。<br> 作者回复: 对的 ，原子操作是硬件必须 提供的</p>',120),i=[l];function u(k,r){return s(),a("div",null,i)}const v=n(c,[["render",u],["__file","C09-Linux数据同步手段.html.vue"]]);export{v as default};
