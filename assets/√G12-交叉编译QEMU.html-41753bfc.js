import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as a,o as r,c,a as e,b as i,e as l,d as s}from"./app-cdabc73c.js";const o="/assets/782c1d620430ba46b584b0cdbd86dc28-f83004b5.jpg",d="/assets/a5fb7d81fa49da02bfeee45c35aef255-8a4637c4.jpg",u="/assets/778c6aea3fa8c112c732fc3d7b653f79-532ff356.jpg",p="/assets/e8307c6cabf00a3fccc4a0e0a93b3034-c5fe6ab9.jpg",b="/assets/86a3b65f445394f1e8be61e3470e9f5e-e65189e9.jpg",g="/assets/d62cf1b12d532aea1643118ea117febe-6cf8e785.jpg",v={},h=e("h1",{id:"√12-qemu-支持risc-v的qemu如何构建",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#√12-qemu-支持risc-v的qemu如何构建","aria-hidden":"true"},"#"),i(" √12｜QEMU：支持RISC-V的QEMU如何构建？")],-1),m=e("p",null,"你好，我是 LMOS。",-1),_=e("p",null,"工欲善其事，必先利其器。作为开发者，学习过程中我们尤其要重视动手实践，不断巩固和验证自己学到的知识点。而动手实践的前提，就是要建立一个开发环境，这个环境具体包括编译环境、执行环境，以及各种常用的工具软件。",-1),f=e("p",null,"我会用两节课带你动手搭好环境，今天这节课咱们先热个身，搞清楚什么是主环境，还有怎么基于它生成交叉编译工具。",-1),x={href:"https://gitee.com/lmos/Geek-time-computer-foundation/tree/master/lesson12~13",target:"_blank",rel:"noopener noreferrer"},C=s('<h2 id="主环境" tabindex="-1"><a class="header-anchor" href="#主环境" aria-hidden="true">#</a> 主环境</h2><p>主环境，有时也叫作 HOST 环境，也就是我们使用的计算机环境，即使用什么样的操作系统、什么架构的计算机作为开发环境。</p><p>比方说我们经常用 PC 机作为开发机使用，它实际就是一个基于 x86 架构（或其他架构）的硬件平台，再加上 Windows 或者 Linux 等操作系统共同组成的开发环境。</p><p>普通用户的电脑上经常安装的操作系统是 Windows，因为界面友好方便、操作简单且娱乐影音、游戏办公等应用软件也是不胜枚举。</p><p>Windows 对普通用户来说的确非常友好。但是作为软件开发者，对于志存高远、想要精研技术的我们而言，更喜欢用的是 Linux 系统。</p><p>它虽然没有漂亮的 GUI，却暴露了更多的计算机底层接口，也生产了更多的开发工具和各种各样的工具软件。比如大名鼎鼎的编译器 GCC、声名远扬的编辑器 EMACS、VIM，还有自动化的脚本工具 shell、make 等。这些工具对开发者非常友好，配合使用可以让我们的工作事半功倍，后面你会逐渐体会到这点。</p><p>当然 Linux 只是一个内核，我们不能直接使用，还需要各种工具、库和桌面 GUI，把这些和 Linux 打包在一起发行，这就构成了我们常说的 <code>Linux 发行版</code>。</p><p>我最喜欢的 Linux 发行版是 Deepin 和 Ubuntu。为了统一，我建议你使用 Deepin 最新版，你也可以使用 Ubuntu，它们是差不多的。只是操作界面稍有不同。我先给你展示下我的 Deepin，如下图，刚装上它的时候，我就觉得它颇为惊艳。</p><figure><img src="'+o+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>',9),S={href:"https://www.deepin.org/zh/installation/",target:"_blank",rel:"noopener noreferrer"},R=s('<p>这两种方式我也替你对比过，虚拟机中的 Linux 较物理机上的 Linux 性能稍差一点，但并不影响我们实验操作和结果。</p><h2 id="为什么需要交叉编译" tabindex="-1"><a class="header-anchor" href="#为什么需要交叉编译" aria-hidden="true">#</a> 为什么需要交叉编译</h2><p>虽然主环境搞定了，但现在我们还不能直接跑代码。为什么呢？</p><p>先回想一下，平时我们正常开发软件需要什么？我猜，哪怕你不能抢答，也会知道个大概：需要电脑（PC）、特定的操作系统（比如 Windows 或 Linux 等），在这个操作系统上还能运行相应的编辑器和编译器。编辑器用来编写源代码，而编译器用来把源代码编译成可执行程序。</p><p>似乎不需要更多东西了，毕竟我们日常开发的软件，宿主平台和目标平台是相同的。如果我们把限制条件变一变，情况就不同了。如果我们想尝试在 RISC-V 平台上跑程序，要怎么办呢？</p><p>你或许会说，这简单，买一台 RISC-V 的机器不就行了。可是先不说购买硬件的经济成本，实际上，很多 RISC-V 平台硬件资源（如内存、SD 卡容量）有限，不足以运行复杂的编译器软件，有的甚至没有操作系统，更别说在上面运行编译器或者编辑器软件了。</p><p>面对这样的困境，就要用到<strong>交叉编译</strong>了。什么是交叉编译呢？简单来说，就是在一个硬件平台上，生成另一个硬件平台的可执行程序。</p><p>举个例子，我们在 x86 平台上编译生成 ARM 平台的可执行程序；再比如说，之后的课里我们将在 x86 平台上，生成 RISC-V 的可执行程序。这些都属于交叉编译，在这个过程中编译生成可执行程序的平台，称为<mark>宿主机</mark>或者主机；执行特定程序的平台（如 ARM 或者 RISC-V 平台），称为<mark>目标机</mark>。</p><p>我特意准备了图解，为你展示在 x86 平台上，交叉编译生成 RISC-V 平台可执行程序的过程，你可以仔细看看：</p><figure><img src="'+d+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="如何构建-risc-v-交叉编译器" tabindex="-1"><a class="header-anchor" href="#如何构建-risc-v-交叉编译器" aria-hidden="true">#</a> 如何构建 RISC-V 交叉编译器</h2><p>前面说了交叉编译的本质就是生成其他平台体系上的可执行程序，这个体系又不同于我们宿主平台。我们的目的很简单，就是要<strong>在 x86 平台上编写源代码，然后编译出 RISC-V 平台的可执行程序，最后放在 RISC-V 平台上去运行</strong>。</p><p>因此，我们需要用<mark>宿主机编译器 A</mark>，编译出一个编译器 B，这个编译器 B 是本地平台上的可执行程序。</p><p>说得再具体点，你可以把<mark>编译器 B</mark> 看作是 <strong>x86 Linux 上的一个应用</strong>。但它的特殊之处就是，能根据源代码生成 RISC-V 平台上的可执行程序。补充一句，这里的编译器 A 和 B 都是 <em>C 语言编译器</em>。</p><h3 id="工具链" tabindex="-1"><a class="header-anchor" href="#工具链" aria-hidden="true">#</a> 工具链</h3><p>下面我们开始构造编译器 B。编译器 B 不仅仅是 C 语言编译器，还有很多额外的程序。比如 RISC-V 平台上使用的二进制文件分析（objcopy）、反汇编（objdump）、elf 结构分析工具（readelf）、静态库归档（ar）、汇编器（as）、链接器（ld）、GDB、C 语言库（Newlib、Glib、Multlib）等。</p><p>为了简单、便于区分，我们把这些对应于 RISC-V 平台的编译器相关的软件，统称为 <strong>RISC-V 工具链</strong>。</p><p>构建 RISC-V 工具链的主要步骤如下：</p><ol><li>安装依赖工具：在宿主平台上安装编译器 A，以及相应的工具和库。</li><li>下载 RISC-V 工具链的源代码；</li><li>配置 RISC-V 工具链；</li><li>编译 RISC-V 工具链，并安装在宿主平台上。</li></ol><h3 id="第一步-安装依赖工具" tabindex="-1"><a class="header-anchor" href="#第一步-安装依赖工具" aria-hidden="true">#</a> 第一步：安装依赖工具</h3><p>我们先从第一步开始，编译器 A 主要是宿主平台上的 GCC，工具主要是 Make、Git、Autoconf、Automake、CURL、Python3、Bison、Flex 等。这里 GCC 主要在 build-essential 包中，我们只要在 Linux 终端中输入如下指令就可以了：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token function">git</span> autoconf automake autotools-dev <span class="token function">curl</span> python3 libmpc-dev libmpfr-dev libgmp-dev <span class="token function">gawk</span> build-essential bison flex texinfo gperf patchutils <span class="token function">bc</span> libexpat-dev libglib2.0-dev ninja-build zlib1g-dev pkg-config libboost-all-dev libtool libssl-dev libpixman-1-dev libpython-dev virtualenv libmount-dev libsdl2-dev
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+u+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>如果不出意外，这些工具和库会通过网络由 Linux 的 apt 包管理器，全自动地给你安装完毕。</p><h3 id="第二步-下载工具链源代码" tabindex="-1"><a class="header-anchor" href="#第二步-下载工具链源代码" aria-hidden="true">#</a> 第二步：下载工具链源代码</h3><p>接着进入第二步下载 RISC-V 工具链源代码。通常来说，我们只要用 Git 克隆一个 riscv-gnu-toolchain 仓库即可，其它的由 riscv-gnu-toolchain 仓库中的仓库子模块自动处理。</p><h4 id="手动配置环节" tabindex="-1"><a class="header-anchor" href="#手动配置环节" aria-hidden="true">#</a> 手动配置环节</h4><p>由于众所周知的网络原因，你可能连 riscv-gnu-toolchain 仓库都下载不下来，更别说自动下载仓库子模块了。为了照顾卡壳的人，我把手动处理的情况也顺便讲一下，能够直接自动安装的同学可以跳过这部分，直接翻到 7 条指令之后的最终截图对一下结果就行。</p><p>子模块如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>riscv-qemu（虚拟机）
riscv-newlib (用嵌入式的轻量级C库)
riscv-binutils(包含一些二进制工具集合，如objcopy等)
riscv-gdb(用于调试代码的调试器)
riscv-dejagnu(用于测试其它程序的框架)
riscv-glibc(GNU的C库)
riscv-gcc (C语言编译器)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些子模块我们需要手动从 Gitee 网站上下载。下载前，我们先在终端上输入后面的指令，建立一个目录，并切换到该目录中：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mkdir RISCV_TOOLS
cd RISCV_TOOLS
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>把 RISC-V 工具链的源代码手动下载好，步骤稍微多了一些，我在后面分步骤列出，方便你跟上节奏。</p><p>其实也就是 7 条指令的事儿，并不复杂。先统一说明下，<strong>后面这些命令都是切换到 riscv-gnu-toolchain 目录的终端下</strong>，输入我给你列出的指令即可。</p><ol><li>开始下载 riscv-gnu-toolchain，命令如下：</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git clone https://gitee.com/mirrors/riscv-gnu-toolchain
cd riscv-gnu-toolchain
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>下载 RISC-V 平台的 C 语言编译器源代码仓库，输入如下指令：</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git clone -b riscv-gcc-10.2.0 https://gitee.com/mirrors/riscv-gcc
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="3"><li>下载测试框架源代码仓库，即 riscv-dejagnu。输入如下指令：</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git clone https://gitee.com/mirrors/riscv-dejagnu
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="4"><li>下载 GNU 的 C 库源代码仓库，也就是 riscv-glibc，输入如下指令：</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git clone -b riscv-glibc-2.29 https://gitee.com/mirrors/riscv-glibc
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="5"><li>下载用于嵌入式的轻量级 C 库源代码仓库，即 riscv-newlib。输入如下指令：</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git clone https://gitee.com/mirrors/riscv-newlib
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="6"><li>下载二进制工具集合源代码仓库 riscv-binutils，输入如下指令：</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git clone -b riscv-binutils-2.35 https://gitee.com/mirrors/riscv-binutils-gdb riscv-binutils
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="7"><li>最后，下载 GDB 软件调试器源代码仓库 riscv-gdb，输入如下指令：</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git clone -b fsf-gdb-10.1-with-sim https://gitee.com/mirrors/riscv-binutils-gdb riscv-gdb
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>好，现在所有的 RISC-V 工具链的源代码，我们已经下载完了。我们一起来同步一下，确保你我的 riscv-gnu-toolchain 目录下的目录和文件，完全一致。</p><p>在 riscv-gnu-toolchain 目录的终端下输入 ls 指令，你应该得到和后面这张图一样的结果。</p><figure><img src="`+p+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="第三步-配置工具链" tabindex="-1"><a class="header-anchor" href="#第三步-配置工具链" aria-hidden="true">#</a> 第三步：配置工具链</h3><p>在我们用宿主编译器编译所有的 RISC-V 工具链的源代码之前，还有最重要的一步，那就是配置 RISC-V 工具链的功能。</p><p>RISC-V 工具链有很多配置选项，不同的配置操作会生成具有特定功能的 RISC-V 工具链。此外，配置操作还有一个功能，就是检查编译 RISC-V 工具链所依赖的工具和库。检查通过，就会生成相应的配置选项文件，还有用于编译操作的 Makefile 文件。</p><p>下面我们开始配置操作。为了不污染源代码目录，我们可以在 riscv-gnu-toolchain 目录下建立一个 build 目录，用于存放编译 RISC-V 工具链所产生的文件。还是在切换到 riscv-gnu-toolchain 目录的终端下，输入如下指令：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">mkdir</span> build  <span class="token comment">#建立build目录</span>
<span class="token comment">#配置操作，终端一定要切换到build目录下再执行如下指令</span>
<span class="token punctuation">..</span>/configure <span class="token parameter variable">--prefix</span><span class="token operator">=</span>/opt/riscv/gcc --enable-multilib <span class="token parameter variable">--target</span><span class="token operator">=</span>riscv64-multlib-elf
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我给你解释一下指令里的关键内容。</p><ol><li><p><code>–prefix</code> 表示 RISC-V 的工具链的安装目录，我们一起约定为“/opt/riscv/gcc”这个目录。</p></li><li><p><code>–enable-multilib</code> 表示使用 multlib 库，使用该库编译出的 RISC-V 工具链，既可以生成 RISCV32 的可执行程序，也可以生成 RISCV64 的可执行程序，而默认的 Newlib 库则不行，它只能生成 RISCV（32/64）其中之一的可执行程序。</p></li><li><p><code>–target</code> 表示生成的 RISC-V 工具链中，软件名称的前缀是 riscv64-multlib-elf-xxxx。若配置操作执行成功了，build 目录中会出现如下所示的文件：</p></li></ol><figure><img src="`+b+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="第四步-编译工具链" tabindex="-1"><a class="header-anchor" href="#第四步-编译工具链" aria-hidden="true">#</a> 第四步：编译工具链</h3><p>最后我们来完成第四步，编译 RISC-V 工具链。只要配置操作成功了，就已经成功了 90%。其实编译操作是简单且高度自动化的，我们只要在切换到 build 目录的终端下，输入如下指令即可：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>sudo make -j8
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个指令在编译完成后会自动安装到“/opt/riscv/gcc”目录，由于要操作“/opt/riscv/gcc”目录需要超级管理员权限，所以我们要记得加上 sudo。</p><p>另外，如果你的宿主机的 CPU 有 n 个核心，就在 make 后面加 -j（n*2），这样才能使用多线程加速编译。</p><p>好了，一通操作猛如虎，现在最重要的事情是等待计算机“搬砖”了。你不妨播放音乐，泡上一杯新鲜的热茶，一边听歌，一边喝茶……估计要喝很多杯茶，才会编译完成。最最重要的是这期间不能断电，否则几个小时就白费了。</p><p>如果终端中不出现任何错误，就说明编译成功了。我们在终端中切换到“/opt/riscv/gcc/bin”目录下，执行如下指令：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>riscv64-unknown-elf-gcc -v
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上述指令执行以后，会输出 riscv64-unknown-elf-gcc 的版本信息，这证明 RISC-V 工具链构建成功了。如下所示：</p><figure><img src="`+g+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>到这里，我们环境已经成功了一半，有了交叉编译器，并且这种交叉编译器能生成 32 位的 RISC-V 平台的可执行程序，也能生成 64 位的 RISC-V 平台的可执行程序。</p><p>你可能会好奇，成功了一半，那另一半呢？这需要我们接着干另一件事。什么事呢？容我先在这里卖个关子，下节课再揭秘。</p><h2 id="重点回顾" tabindex="-1"><a class="header-anchor" href="#重点回顾" aria-hidden="true">#</a> 重点回顾</h2><p>通过这节课的学习，我们成功构建了 RISC-V 工具链，这样就能在 X86 平台上生成 RISC-V 平台的可执行程序了。下面让我们一起回顾一下，这节课中都做了些什么。</p><p>我们首先约定了宿主环境，需要用到 Ubuntu 或者 Deepin 的 Linux 发行版，无论你是将它们安装在物理 PC 上，还是安装在虚拟机上。</p><p>然后我们了解了什么是交叉编译。为了方便后面课程学习动手实践，我们要在 x86 平台的宿主机上编译生成 RISC-V 平台的可执行程序。</p><p>明确了目标，我们一起动手开始构建了一个 RISC-V 交叉编译器。你会发现其中不只是 C/C++ 编译器，还有很多处理二进制可执行程序的工具，我们把这些统称为 RISC-V 工具链。</p><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题" aria-hidden="true">#</a> 思考题</h2><p>请你说一说交叉编译的过程？</p><p>期待你再留言区分享自己的实验笔记，或者与我交流讨论。也推荐你把这节课分享给更多朋友，我们一起玩转交叉编译。</p>',79),k=e("br",null,null,-1),V=e("br",null,null,-1),I=e("br",null,null,-1),w=e("br",null,null,-1),L=e("br",null,null,-1),O={href:"https://gitee.com/mirrors/riscv-gnu-toolchain",target:"_blank",rel:"noopener noreferrer"},G=e("br",null,null,-1),T=e("br",null,null,-1),y=e("br",null,null,-1),j=e("br",null,null,-1),U=e("br",null,null,-1),E=e("br",null,null,-1),M=e("br",null,null,-1),A=e("br",null,null,-1),B=e("br",null,null,-1),z=e("br",null,null,-1),D=e("br",null,null,-1),P=e("br",null,null,-1),q=e("br",null,null,-1),N=e("br",null,null,-1),W=e("br",null,null,-1),F=e("br",null,null,-1),Q=e("br",null,null,-1),X=e("br",null,null,-1),H=e("br",null,null,-1),J=e("br",null,null,-1),K=e("br",null,null,-1),Y=e("hr",null,null,-1),Z=e("br",null,null,-1),$=e("br",null,null,-1),ee={href:"http://README.md",target:"_blank",rel:"noopener noreferrer"},ie=s("<p>../configure --prefix=/opt/riscv/gcc <br> --enable-multilib <br> --target=riscv64-multlib-elf <br> --with-gcc-src=/home/name/RISCV_TOOLS/riscv-gnu-toolchain/riscv-gcc <br> --with-binutils-src=/home/name/RISCV_TOOLS/riscv-gnu-toolchain/riscv-binutils <br> --with-newlib-src=/home/name/RISCV_TOOLS/riscv-gnu-toolchain/riscv-newlib <br> --with-glibc-src=/home/name/RISCV_TOOLS/riscv-gnu-toolchain/riscv-glibc <br> --with-gdb-src=/home/name/RISCV_TOOLS/riscv-gnu-toolchain/riscv-gdb<br> 作者回复: 哈哈 成功了 吧</p><hr><p>老师我在编译时一直报这个错误，这个该怎么处理啊？<br> 作者回复: 安装 库<br> sudo apt-get install git autoconf automake autotools-dev curl python3 libmpc-dev libmpfr-dev libgmp-dev gawk build-essential bison flex texinfo gperf patchutils bc libexpat-dev libglib2.0-dev ninja-build zlib1g-dev pkg-config libboost-all-dev libtool libssl-dev libpixman-1-dev libpython-dev virtualenv libmount-dev libsdl2-dev</p><hr><p>用虚拟机的需要注意下，CPU核数，内存，磁盘，都要尽可能大一些，我设置的是4核/8G/100G，这样才能一路通关。不然要么卡死要么到最后提示空间不足，你连系统都启动不了。<br> 作者回复: 哈哈 你在虚拟机中弄的吗</p><hr><p>老师我在M1的环境下用虚拟机折腾，一直编译不过去，我可以用其他环境吗？比如直接在M1的环境下学习<br> 作者回复: M1可能不行，我没有试过</p>",7);function ne(le,se){const n=a("ExternalLinkIcon");return r(),c("div",null,[h,m,_,f,e("p",null,[e("a",x,[i("代码你可以从这里下载"),l(n)]),i("。")]),C,e("p",null,[i("这里最基础的安装我就不讲了，因为安装 Deepin 十分简单，无论是虚拟机还是在物理机上安装，我相信你通过互联网都可以自行解决，"),e("a",S,[i("搞不定也可以看看这里"),l(n)]),i("。")]),R,e("blockquote",null,[e("p",null,[i("host使用的是Ubuntu 20.04 Desktop, 在Windows 11的笔记本, 用Virtualbox 6.1 搭建的虚机 (cpu 2 cores, 40GB 存储，4GB内存) ，按照老师的教程，以下是我的实验笔记："),k,i(" 1、在我的环境就只有一个libpython-dev 报错，因为有提示换成libpython2-dev，不碍事，而且不同的os，不同的版本，可能不会有这个问题，可以先用老师的命令。"),V,i(" sudo apt-get install git autoconf automake autotools-dev curl python3 libmpc-dev libmpfr-dev libgmp-dev gawk build-essential bison flex texinfo gperf patchutils bc libexpat-dev libglib2.0-dev ninja-build zlib1g-dev pkg-config libboost-all-dev libtool libssl-dev libpixman-1-dev libpython2-dev virtualenv libmount-dev libsdl2-dev"),I,i(" 2、mkdir RISCV_TOOLS; cd RISCV_TOOLS"),w,i(" 3、"),L,i(" git clone "),e("a",O,[i("https://gitee.com/mirrors/riscv-gnu-toolchain"),l(n)]),G,i(" cd riscv-gnu-toolchain"),T,i(" 4、"),y,i(" mkdir build"),j,i(" cd build"),U,i(" ../configure --prefix=/opt/riscv/gcc --enable-multilib --target=riscv64-multlib-elf"),E,i(" 5、因为我的host环境是建在2cpu core的虚机上"),M,i(" sudo make -j 2"),A,i(" 6、大约3个多小时，终于完成了。"),B,i(" 7、cd /opt/riscv/gcc/bin"),z,i(" ./riscv64-unknown-elf-gcc -v"),D,i(" 8、结果输出："),P,i(" Using built-in specs."),q,i(" COLLECT_GCC=./riscv64-unknown-elf-gcc"),N,i(" COLLECT_LTO_WRAPPER=/opt/riscv/gcc/libexec/gcc/riscv64-unknown-elf/12.1.0/lto-wrapper"),W,i(" Target: riscv64-unknown-elf"),F,i(" Configured with: /home/vic/RISCV_TOOLS/riscv-gnu-toolchain/build/../gcc/configure --target=riscv64-unknown-elf --prefix=/opt/riscv/gcc --disable-shared --disable-threads --enable-languages=c,c++ --with-pkgversion= --with-system-zlib --enable-tls --with-newlib --with-sysroot=/opt/riscv/gcc/riscv64-unknown-elf --with-native-system-header-dir=/include --disable-libmudflap --disable-libssp --disable-libquadmath --disable-libgomp --disable-nls --disable-tm-clone-registry --src=/home/vic/RISCV_TOOLS/riscv-gnu-toolchain/gcc --enable-multilib --with-abi=lp64d --with-arch=rv64imafdc --with-tune=rocket --with-isa-spec=2.2 'CFLAGS_FOR_TARGET=-Os -mcmodel=medlow' 'CXXFLAGS_FOR_TARGET=-Os -mcmodel=medlow'"),Q,i(" Thread model: single"),X,i(" Supported LTO compression algorithms: zlib"),H,i(" gcc version 12.1.0 ()"),J,i(" 9、收工。"),K,i(" 作者回复: 66666")]),Y,e("p",null,[i("编译中会卡在"),Z,i(" Cloning into '/home/qing/RISCV_TOOLS/riscv-gnu-toolchain/gcc'..."),$,i(" 还是会去下载仓库，应该是我们下载的文件夹名称不是默认的，查看 "),e("a",ee,[i("README.md"),l(n)]),i(" 文件，在最后说明了如何指定子模块的路径，在配置环节添加配置之后，戴尔笔记本双核 i5-4200U CPU @ 1.60GHz 编译，编译完成四十多分钟，系统使用 Debian 4.19.181-1")]),ie])])}const re=t(v,[["render",ne],["__file","√G12-交叉编译QEMU.html.vue"]]);export{re as default};
