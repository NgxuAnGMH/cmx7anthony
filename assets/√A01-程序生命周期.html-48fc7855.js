import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as c,c as i,a as n,b as s,e as p,d as t}from"./app-cdabc73c.js";const l="/assets/957691f0ac44315ebf5619d553df4ac2-e7682de4.jpg",u="/assets/a3797cfb319938f359812da1baf3b316-6db8283c.jpg",r={},d=t('<h1 id="√01-快速回顾-一个-c-程序的完整生命周期" tabindex="-1"><a class="header-anchor" href="#√01-快速回顾-一个-c-程序的完整生命周期" aria-hidden="true">#</a> √01｜快速回顾：一个 C 程序的完整生命周期</h1><p>你好，我是于航。</p><p>在深入了解 C 语言、做到“知其所以然”之前，我们需要先做到“知其然”，也就是知道 C 语言是如何使用的。所以这一讲，我会从语法细节和语言特性、微观和宏观相结合的角度，带你快速、直观地回顾 C 语言的一些基础内容。而通过本讲的学习，你也会更容易理解这门课接下来的内容。</p><p>首先，我会带你回顾一个 C 程序<code>从 源代码编写 到 编译，再到最后运行的完整过程</code>。除此之外，我还会用一段相对复杂的示例代码，来带你快速回顾 C 语言中最常见的那些语法及使用方式。最后，我们还会从语言本身的角度，来探讨 C 语言与其他编程语言在编程范式上的不同之处。</p><p><strong>学习这门课，需要怎样的实践开发环境？</strong></p><p>在开始回顾这些内容之前，我要先向你推荐一些学习这门课时会用到的开发工具。你可以利用这些工具，自行编译和运行课程中给出的示例代码，以加深你对课程内容的理解。</p><h2 id="编译工具-编译器" tabindex="-1"><a class="header-anchor" href="#编译工具-编译器" aria-hidden="true">#</a> 编译工具 编译器</h2><p>对于编译工具，这门课会穿插使用运行于 x86-64 平台的 <code>GCC 11.2 或 Clang 13.0.0 版本编译器</code>。市面上有很多成熟的 C 编译器可以选择，但不同的编译器可能存在着<code>所支持平台（类 Unix、Windows）</code>以及 <code>C 标准（C89、C99、C11、C17）</code>上的差异，因此在选择时需要特别注意这些问题。这门课里使用的 GCC 和 Clang 都支持 C 语言的最新标准 C17，并且都可以运行在类 Unix 与 Windows 系统上。</p>',8),k={href:"https://godbolt.org/",target:"_blank",rel:"noopener noreferrer"},m=n("p",null,[s("相较于本地编译器，云编译器即开即用，"),n("em",null,"而且可以随时灵活切换不同的编译器版本"),s("。")],-1),v={href:"https://github.com/Becavalier/geektime-c",target:"_blank",rel:"noopener noreferrer"},b=t(`<h2 id="快速回顾" tabindex="-1"><a class="header-anchor" href="#快速回顾" aria-hidden="true">#</a> 快速回顾</h2><p><strong>用一个程序快速回顾 C 核心语法</strong></p><p>为了让你比较完整地回顾 C 语言的核心语法，我设计了一个相对复杂的 C 语言程序作为例子。在这里，你可以先试着阅读这段代码，思考下 C 语言的使用方式。代码如下所示：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span> </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdbool.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BOOL_TRUE</span> <span class="token expression"><span class="token number">1</span>  </span><span class="token comment">// 定义用到的宏常量与宏函数；</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BOOL_FALSE</span> <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">typename</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">_Generic</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> </span><span class="token punctuation">\\</span>
  <span class="token expression"><span class="token keyword">unsigned</span> <span class="token keyword">short</span><span class="token operator">:</span> </span><span class="token string">&quot;unsigned short int&quot;</span><span class="token expression"><span class="token punctuation">,</span> </span><span class="token punctuation">\\</span>
  <span class="token expression"><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token operator">:</span> </span><span class="token string">&quot;unsigned long int&quot;</span><span class="token expression"><span class="token punctuation">,</span> </span><span class="token punctuation">\\</span>
  <span class="token expression"><span class="token keyword">default</span><span class="token operator">:</span> </span><span class="token string">&quot;unknown&quot;</span><span class="token expression"><span class="token punctuation">)</span></span></span>

<span class="token keyword">typedef</span> <span class="token keyword">enum</span> <span class="token punctuation">{</span> Host<span class="token punctuation">,</span> IP <span class="token punctuation">}</span> IP_ADDR_TYPE<span class="token punctuation">;</span>  <span class="token comment">// 定义枚举类型 IP_ADDR_TYPE，用于表示联合中生效的字段；</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>  <span class="token comment">// 定义结构 CONN；// Java中一切皆对象 因此缺失结构体</span>
  <span class="token class-name">size_t</span> id<span class="token punctuation">;</span>
  <span class="token class-name">uint16_t</span> port<span class="token punctuation">;</span>
  bool closed<span class="token punctuation">;</span>
  IP_ADDR_TYPE addr_type<span class="token punctuation">;</span>
  <span class="token keyword">union</span> <span class="token punctuation">{</span>
    <span class="token keyword">char</span> host_name<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> ip<span class="token punctuation">[</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> CONN<span class="token punctuation">;</span>

<span class="token keyword">inline</span> <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">findAddr</span><span class="token punctuation">(</span><span class="token keyword">const</span> CONN<span class="token operator">*</span> pip<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 定义函数 findAddr，用于打印 CONN 对象的信息；</span>
  <span class="token function">assert</span><span class="token punctuation">(</span>pip <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 运行时断言，判断传入的 CONN 指针是否有效；</span>
  <span class="token keyword">return</span> pip<span class="token operator">-&gt;</span>addr_type <span class="token operator">==</span> Host <span class="token operator">?</span> pip<span class="token operator">-&gt;</span>host_name <span class="token operator">:</span> pip<span class="token operator">-&gt;</span>ip<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 入口函数；</span>
  <span class="token function">static_assert</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>CONN<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0x400</span><span class="token punctuation">,</span> <span class="token string">&quot;the size of CONN object exceeds limit.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//静态断言，判断CONN对象的大小是否符合要求</span>
  <span class="token keyword">const</span> CONN conns<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token comment">// 构造一个数组，包含三个 CONN 对象；</span>
    <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">,</span> BOOL_TRUE<span class="token punctuation">,</span> IP<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span>ip <span class="token operator">=</span> <span class="token string">&quot;127.0.0.1&quot;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">8080</span><span class="token punctuation">,</span> BOOL_FALSE<span class="token punctuation">,</span> IP<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span>ip <span class="token operator">=</span> <span class="token string">&quot;192.168.1.1&quot;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">8088</span><span class="token punctuation">,</span> BOOL_FALSE<span class="token punctuation">,</span> Host<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span>host_name <span class="token operator">=</span> <span class="token string">&quot;http://localhost/&quot;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>conns<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>CONN<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 遍历上述 CONN 数组，并打印其中的内容；</span>
    <span class="token function">printf</span><span class="token punctuation">(</span>
      <span class="token string">&quot;Port: %d\\n&quot;</span>
      <span class="token string">&quot;Host/Addr: %s\\n&quot;</span>
      <span class="token string">&quot;Internal type of \`id\` is: %s\\n\\n&quot;</span><span class="token punctuation">,</span>
      conns<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>port<span class="token punctuation">,</span>
      <span class="token function">findAddr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>conns<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token function">typename</span><span class="token punctuation">(</span>conns<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>id<span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> EXIT_SUCCESS<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码用到了横跨 K&amp;R C 到 C17 标准的许多语言特性，创建了多个基于自定义类型构建的对象，并在程序的最后将这些对象的相关信息打印了出来。</p><p>下面，就来跟着我一起梳理这段代码中用到的 C 语法特性吧。我会按照程序代码的执行顺序，来分别介绍每一个执行步骤中涉及到的关键语言知识点。其中，相关的语言结构和语法特性可以被分为下面这些类别。</p><h2 id="_1-入口函数main" tabindex="-1"><a class="header-anchor" href="#_1-入口函数main" aria-hidden="true">#</a> 1. 入口函数main</h2><p>现在，让我们来仔细观察这个程序。首先，我们的目光来到第 31 行上名为 main 的函数。</p><p>所有的 C 程序都会使用 main 函数作为入口函数。入口函数，就是指程序开始运行时，代码中会被首先调用的那个函数。在 main 函数中，我们可以通过它接收到的实际参数，来选择性地访问程序在开始运行时，由用户传递给程序的外部参数。</p><p>**main 函数在执行结束时会<code>返回一个整数</code>，用于表示<code>程序执行完毕时的状态</code>，通常返回数字 0 表示程序<code>正常退出</code>，返回其他数字则代表<code>异常退出</code>。**为了保持代码的可读性，这里我们使用<mark>标准库</mark>中定义的<em>宏常量 EXIT_SUCCESS</em> ，作为程序退出的返回值。顾名思义，这个宏常量对应的实际值就是<em>数字 0</em>。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 入口函数；</span>
  <span class="token comment">// 静态断言，判断 CONN 对象的大小是否符合要求；</span>
  <span class="token function">static_assert</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>CONN<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0x400</span><span class="token punctuation">,</span> <span class="token string">&quot;the size of CONN object exceeds limit.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> CONN conns<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token comment">// 构造一个数组，包含三个 CONN 对象；</span>
    <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">,</span> BOOL_TRUE<span class="token punctuation">,</span> IP<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span>ip <span class="token operator">=</span> <span class="token string">&quot;127.0.0.1&quot;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">8080</span><span class="token punctuation">,</span> BOOL_FALSE<span class="token punctuation">,</span> IP<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span>ip <span class="token operator">=</span> <span class="token string">&quot;192.168.1.1&quot;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">8088</span><span class="token punctuation">,</span> BOOL_FALSE<span class="token punctuation">,</span> Host<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span>host_name <span class="token operator">=</span> <span class="token string">&quot;http://localhost/&quot;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>conns<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>CONN<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 遍历上述 CONN 数组，并打印其中的内容；</span>
    <span class="token function">printf</span><span class="token punctuation">(</span>
      <span class="token string">&quot;Port: %d\\n&quot;</span>
      <span class="token string">&quot;Host/Addr: %s\\n&quot;</span>
      <span class="token string">&quot;Internal type of \`id\` is: %s\\n\\n&quot;</span><span class="token punctuation">,</span>
      conns<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>port<span class="token punctuation">,</span>
      <span class="token function">findAddr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>conns<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token function">typename</span><span class="token punctuation">(</span>conns<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>id<span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> EXIT_SUCCESS<span class="token punctuation">;</span> <span class="token comment">// 为了保持代码的可读性，这里我们使用 ==标准库== 中定义的宏常量 EXIT_SUCCESS ，作为程序退出的返回值。</span>
    <span class="token comment">// 顾名思义，这个宏常量对应的实际值就是数字 0。</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BOOL_TRUE</span> <span class="token expression"><span class="token number">1</span>  </span><span class="token comment">// 除去引入的STL标准库 自定义用到的宏常量与宏函数；</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BOOL_FALSE</span> <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">typename</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">_Generic</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> </span><span class="token punctuation">\\</span>
  <span class="token expression"><span class="token keyword">unsigned</span> <span class="token keyword">short</span><span class="token operator">:</span> </span><span class="token string">&quot;unsigned short int&quot;</span><span class="token expression"><span class="token punctuation">,</span> </span><span class="token punctuation">\\</span>
  <span class="token expression"><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token operator">:</span> </span><span class="token string">&quot;unsigned long int&quot;</span><span class="token expression"><span class="token punctuation">,</span> </span><span class="token punctuation">\\</span>
  <span class="token expression"><span class="token keyword">default</span><span class="token operator">:</span> </span><span class="token string">&quot;unknown&quot;</span><span class="token expression"><span class="token punctuation">)</span></span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-数组" tabindex="-1"><a class="header-anchor" href="#_2-数组" aria-hidden="true">#</a> 2. 数组</h2><p>接下来，我们来到第 33 行。可以看到，在 main 函数内部，我们使用了“<em>括号列表</em>（brace-enclosed lists）”的方式，完成了对数组 conns 的初始化过程。而在初始化列表中，我们还使用了<em>指派初始化</em>（为初始化列表中的项设定“<em>指派符</em>”）的方式，来明确指定这些项在数组中的具体位置。比如这里第一项对应的 “[2]” ，就表示将该项设置为数组 conns 中的第 3 个元素（索引从 0 开始）。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>  <span class="token keyword">const</span> CONN conns<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token comment">// 构造一个数组，包含三个 CONN 对象；</span>
    <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">,</span> BOOL_TRUE<span class="token punctuation">,</span> IP<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span>ip <span class="token operator">=</span> <span class="token string">&quot;127.0.0.1&quot;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>				<span class="token comment">// 指派初始化</span>
    <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">8080</span><span class="token punctuation">,</span> BOOL_FALSE<span class="token punctuation">,</span> IP<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span>ip <span class="token operator">=</span> <span class="token string">&quot;192.168.1.1&quot;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>			<span class="token comment">// 指派初始化</span>
    <span class="token punctuation">{</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">8088</span><span class="token punctuation">,</span> BOOL_FALSE<span class="token punctuation">,</span> Host<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span>host_name <span class="token operator">=</span> <span class="token string">&quot;http://localhost/&quot;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token comment">// 括号列表初始化</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>数组定义完毕后，第 44 到第 46 行的代码访问了其内部存放的元素。这里我们直接使用方括号加索引值的语法形式做到了这一点。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>      conns<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>port<span class="token punctuation">,</span>
      <span class="token function">findAddr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>conns<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token function">typename</span><span class="token punctuation">(</span>conns<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>id<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3-结构与联合-java中无" tabindex="-1"><a class="header-anchor" href="#_3-结构与联合-java中无" aria-hidden="true">#</a> 3. 结构与联合（Java中无）</h2><p>数组 conns 内部，存放有若干个类型为 CONN 的结构对象。</p><p>在 C 语言中，<mark><strong>结构<code>和</code>联合</strong></mark>（有时也被称为<code>结构体</code>与<code>联合体</code>）通常用来组织<code>复杂类型的自定义数据</code>。</p><ul><li>==【内存连续】==在**<code>结构</code>**中，所有定义字段的对应数据<code>按照内存连续的方向排列</code>；</li><li>==【唯一生效】==而在**<code>联合</code>**中，定义的字段<code>同一时间只会有一个“生效”</code>。</li></ul><p>观察第 15 行到 24 行，可以看到：在我们对<mark>结构 CONN</mark> 的定义过程中，使用了来自 C99 标准的 _Bool 类型（这里的宏 bool 会展开为该类型），以及来自 C11 标准的<mark>匿名联合体</mark>。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>  <span class="token comment">// 定义结构 CONN；// Java中一切皆对象 因此缺失结构体</span>
  <span class="token class-name">size_t</span> id<span class="token punctuation">;</span>
  <span class="token class-name">uint16_t</span> port<span class="token punctuation">;</span>
  bool closed<span class="token punctuation">;</span>
  IP_ADDR_TYPE addr_type<span class="token punctuation">;</span>
  <span class="token keyword">union</span> <span class="token punctuation">{</span>		<span class="token comment">// C11 标准的\`匿名联合体\`</span>
    <span class="token keyword">char</span> host_name<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> ip<span class="token punctuation">[</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> CONN<span class="token punctuation">;</span> <span class="token comment">// 定义结构 CONN</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第 34 到第 36 行，在我们对<mark>结构 CONN 对象</mark>的初始化过程中，也同样使用了类似数组的括号列表初始化，以及指派初始化。但和前面数组初始化不同的是，这里的指派是针对<code>结构与联合类型内部的成员字段的</code>，因此需要使用 <mark>“.” 符号</mark>来引用某个具体成员，而非数组所使用的形式。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>    <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">,</span> BOOL_TRUE<span class="token punctuation">,</span> IP<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span>ip <span class="token operator">=</span> <span class="token string">&quot;127.0.0.1&quot;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>				<span class="token comment">// 指派初始化</span>
    <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">8080</span><span class="token punctuation">,</span> BOOL_FALSE<span class="token punctuation">,</span> IP<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span>ip <span class="token operator">=</span> <span class="token string">&quot;192.168.1.1&quot;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>			<span class="token comment">// 指派初始化</span>
    <span class="token punctuation">{</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">8088</span><span class="token punctuation">,</span> BOOL_FALSE<span class="token punctuation">,</span> Host<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span>host_name <span class="token operator">=</span> <span class="token string">&quot;http://localhost/&quot;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span>	<span class="token comment">// 括号列表初始化</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_4-控制结构" tabindex="-1"><a class="header-anchor" href="#_4-控制结构" aria-hidden="true">#</a> 4. 控制结构</h2><p>在这段代码的第 39 行，我们使用了 for 语句以循环的形式遍历了数组 conns 中的内容。除此之外，C 语言中常用的控制结构还有 switch 语句、while 语句、以及 goto 语句等等。这些语句分别以<code>选择、迭代，及跳转</code>这三种不同方式控制着程序的实际执行逻辑。而程序本身也可以在这些控制语句的灵活组合下变得更加复杂。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>conns<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>CONN<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 遍历上述 CONN 数组，并打印其中的内容；</span>
    <span class="token function">printf</span><span class="token punctuation">(</span>
      <span class="token string">&quot;Port: %d\\n&quot;</span>
      <span class="token string">&quot;Host/Addr: %s\\n&quot;</span>
      <span class="token string">&quot;Internal type of \`id\` is: %s\\n\\n&quot;</span><span class="token punctuation">,</span>
      conns<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>port<span class="token punctuation">,</span>
      <span class="token function">findAddr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>conns<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token function">typename</span><span class="token punctuation">(</span>conns<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>id<span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_5-指针-const常量指针" tabindex="-1"><a class="header-anchor" href="#_5-指针-const常量指针" aria-hidden="true">#</a> 5. 指针/const常量指针</h2><p>指针是 C 语言中最危险但也最强大的“武器”之一。借助指针，我们能够灵活地操控程序享有的内存资源。</p><p>在上面代码的第 45 行，我们将数组 conns 中各个元素的地址传递给了函数 findAddr，</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>      <span class="token function">findAddr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>conns<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 将数组 conns 中各个元素的地址传递给了函数 findAddr</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>而该函数则接收一个指向 CONN 类型对象的<code>常量指针</code>。所以，通过该常量指针，我们<em>无法在函数内部修改</em>指针所指向对象的值。而这在一定程度上<code>保证了函数仅能够拥有足够完成其任务的最小权限</code>。</p><blockquote><p>作者回复: 这里的指针是一个 const 指针（常量指针），所以我们无法通过该指针来修改指向变量的值。</p></blockquote><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>																<span class="token comment">// 常量指针，我们无法在函数内部修改指针所指向对象的值。</span>
<span class="token keyword">inline</span> <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">findAddr</span><span class="token punctuation">(</span><span class="token keyword">const</span> CONN<span class="token operator">*</span> pip<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
  <span class="token comment">// 定义函数 findAddr，用于打印 CONN 对象的信息；</span>
  <span class="token function">assert</span><span class="token punctuation">(</span>pip <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 运行时断言，判断传入的 CONN 指针是否有效；</span>
  <span class="token keyword">return</span> pip<span class="token operator">-&gt;</span>addr_type <span class="token operator">==</span> Host <span class="token operator">?</span> pip<span class="token operator">-&gt;</span>host_name <span class="token operator">:</span> pip<span class="token operator">-&gt;</span>ip<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_6-宏-include-define" tabindex="-1"><a class="header-anchor" href="#_6-宏-include-define" aria-hidden="true">#</a> 6. 宏/#include/#define</h2><p>编译器对 C 源代码的处理过程分为几个阶段，其中，宏是最先被处理的一个部分。在这段代码的开头处，</p><ol><li>我们通过宏指令 <code>“#include”</code> 引入了程序正常运行需要的<em>一些外部依赖项</em>，<br> 这些引入的内容会<strong>在程序编译时</strong>得到替换。</li><li>随后，我们又通过 <code>“#define”</code> 指令定义了相应的<em>宏常量与宏函数</em>，</li><li>而其中的宏函数 typename 则使用到了 C11 标准新引入的 <code>_Generic 关键字</code>，以用来实现<em>基于宏的泛型</em>。</li></ol><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span>	<span class="token comment">// 通过宏指令 “#include” 引入了程序正常运行需要的一些外部依赖项，</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span>	<span class="token comment">// 这些引入的内容会在程序编译时得到替换。</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdbool.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BOOL_TRUE</span> <span class="token expression"><span class="token number">1</span>  </span><span class="token comment">// 通过 “#define” 指令定义了相应的宏常量与宏函数</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BOOL_FALSE</span> <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">typename</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">_Generic</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> \\	</span></span>
<span class="token comment">// 而其中的宏函数 typename 则使用到了 C11 标准新引入的 _Generic 关键字，</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">short</span><span class="token operator">:</span> <span class="token string">&quot;unsigned short int&quot;</span><span class="token punctuation">,</span> \\	<span class="token comment">// 以用来实现基于宏的泛型</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token operator">:</span> <span class="token string">&quot;unsigned long int&quot;</span><span class="token punctuation">,</span> \\
  <span class="token keyword">default</span><span class="token operator">:</span> <span class="token string">&quot;unknown&quot;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_7-断言assert" tabindex="-1"><a class="header-anchor" href="#_7-断言assert" aria-hidden="true">#</a> 7. 断言assert</h2><p>在 C 代码中，我们通常会使用断言，<code>来对某种需要支持程序正常运行的假设性条件进行检查</code>。而当条件不满足时，则在程序编译或运行时终止，并向用户抛出相应的错误信息。C 语言提供<code>静态与动态</code>两种类型的断言，</p><ul><li>其中静态断言会在代码<code>编译时</code>进行检查；</li><li>而动态断言则会在程序<code>运行过程中</code>，执行到该断言语句时再进行检查。</li></ul><h3 id="静态断言static-assert" tabindex="-1"><a class="header-anchor" href="#静态断言static-assert" aria-hidden="true">#</a> 静态断言static_assert</h3><p>在这段代码的第 32 行，我们使用了 C11 标准中提供的**<code>静态断言能力(编译时静态检查?)</code>**，来保证结构类型 CONN 的大小不会超过一定的阈值。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>  <span class="token function">static_assert</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>CONN<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0x400</span><span class="token punctuation">,</span> <span class="token string">&quot;the size of CONN object exceeds limit.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//静态断言，判断 CONN 对象的大小是否符合要求</span>
<span class="token comment">// 静态断言会在代码\`编译时\`进行检查</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="运行时断言assert" tabindex="-1"><a class="header-anchor" href="#运行时断言assert" aria-hidden="true">#</a> 运行时断言assert</h3><p>而在代码的第 27 行，我们还使用了**<code>运行时断言(运行时动态检查?)</code>**来保证传递给函数 findAddr 的 CONN 对象指针不为空。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>  <span class="token function">assert</span><span class="token punctuation">(</span>pip <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 运行时断言，判断传入的 CONN 指针是否有效</span>
<span class="token comment">// 动态断言则会在程序\`运行过程中\`，执行到该断言语句时再进行检查</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_8-inline-函数内联" tabindex="-1"><a class="header-anchor" href="#_8-inline-函数内联" aria-hidden="true">#</a> 8. inline 函数内联</h2><p>在函数 findAddr 的定义代码中，我们为其添加了名为 <code>inline 的关键字</code>。</p><p>通过使用该关键字，我们可以“建议”<mark>编译器</mark>将<strong>该函数的内部逻辑</strong>直接替换到<strong>函数的调用位置处</strong>，以减少函数调用时产生的开销。</p><blockquote><p>这种方式通常使用在<em>那些函数体较小，且会被多次调用的函数</em>上，以产生较为显著的性能提升。</p></blockquote><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//  inline 的关键字				// 常量指针。所以，通过该指针，我们无法在函数内部修改指针所指向对象的值。</span>
<span class="token keyword">inline</span> <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">findAddr</span><span class="token punctuation">(</span><span class="token keyword">const</span> CONN<span class="token operator">*</span> pip<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 定义函数 findAddr，用于打印 CONN 对象的信息；</span>
  <span class="token function">assert</span><span class="token punctuation">(</span>pip <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 运行时断言，判断传入的 CONN 指针是否有效；</span>
  <span class="token keyword">return</span> pip<span class="token operator">-&gt;</span>addr_type <span class="token operator">==</span> Host <span class="token operator">?</span> pip<span class="token operator">-&gt;</span>host_name <span class="token operator">:</span> pip<span class="token operator">-&gt;</span>ip<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="其他特性" tabindex="-1"><a class="header-anchor" href="#其他特性" aria-hidden="true">#</a> <strong>其他特性</strong></h2><p>除了上面提到的内容，这段代码中还涉及到了一些基本的 C 语言特性：</p><ul><li>使用 <code>const</code> 定义只读变量；</li><li>使用 <code>typedef</code> 定义新类型；</li><li>使用 <code>static</code> 声明静态函数；</li><li>使用各类运算符；</li><li>调用标准库函数；</li><li>使用 enum 定义枚举类型；</li><li>……</li></ul>`,56),h={href:"https://www.geeksforgeeks.org/c-programming-language/?ref=ghm",target:"_blank",rel:"noopener noreferrer"},g=t(`<p>到这里，我们就把 C 语言的核心语法大致捋了一遍。你可以看到，C 语言的语法并不复杂。C 语言在设计上就十分精简，截止到 C17 标准，<em>语言本身也仅有 44 个关键字</em>。C 语言的强大并不是源于复杂的语法设计，相反，简单的语法给了 C 开发者更高的自由度，让我们可以更加灵活地设计程序的运行逻辑。</p><h2 id="c-语言的编程范式是怎样的" tabindex="-1"><a class="header-anchor" href="#c-语言的编程范式是怎样的" aria-hidden="true">#</a> C 语言的编程范式是怎样的？</h2><h3 id="命令式" tabindex="-1"><a class="header-anchor" href="#命令式" aria-hidden="true">#</a> 命令式</h3><p>抛开语法细节，从总体上来看，C 语言是一种“<code>命令式</code>”编程语言，和它类似的还有 <code>Java、C#、Go</code> 等语言。</p><blockquote><p>命令式编程（Imperative Programming）是这样一种编程范式：使用可以<code>改变程序状态</code>的代码语句，描述程序应该如何运行。这种方式更关注计算机<code>完成任务所需要执行的具体步骤</code>。</p></blockquote><p>下面我们来看一个例子。对于“从一个包含有指定数字的集合中，筛选出大于 7 的所有数字”这个需求，按照命令式编程的思路，我们需要通过编程语言来告诉计算机具体的执行步骤。</p><p>以 C 语言为例，解决这个需求的步骤可能会是这样：</p><p>1.使用数组，构造一块可以存放这些数字的内存空间；</p><p>2.使用循环控制语句，依次检查内存中的这些数字是否满足要求（即大于 7）；</p><p>3.对于满足要求的数字，将它们拷贝到新的内存空间中，暂存为结果。</p><p>对应的代码可能如下所示：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ARR_LEN</span> <span class="token expression"><span class="token number">5</span></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token keyword">int</span> arr<span class="token punctuation">[</span>ARR_LEN<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ARR_LEN<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// save this element somewhere else.</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="声明式" tabindex="-1"><a class="header-anchor" href="#声明式" aria-hidden="true">#</a> 声明式</h3><p>相对于命令式编程语言，其他语言一般会被归类为“<code>声明式</code>”编程语言。</p><blockquote><p>声明式编程（Declarative Programming）也是一种常见的编程范式。<code>JavaScript</code></p><p><strong>不同的是，这种范式更倾向于表达<code>计算的逻辑</code>，而非解决问题时计算机需要执行的具体步骤。</strong></p></blockquote><p>比如说，还是刚才那个需求，在使用声明式编程语言时，对应的解决步骤可能是：</p><ol><li><p>构建一个容器来存放数据；</p></li><li><p>按照条件对容器数据进行筛选，并将符合条件的数据作为结果返回。</p></li></ol><p>如果以 JavaScript 为例，对应的代码可能如下所示：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> result <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">n</span> <span class="token operator">=&gt;</span> n <span class="token operator">&gt;</span> <span class="token number">7</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="对比" tabindex="-1"><a class="header-anchor" href="#对比" aria-hidden="true">#</a> 对比</h3><blockquote><p>可以看到的是，相较于命令式编程，声明式编程更倾向于表达在解决问题时应该做什么<code>（构建容器、筛选）</code>，</p><p>而不是具体怎么做<code>（分配内存、遍历、拷贝）</code>。</p></blockquote><p>通常来说，命令式编程语言和声明式编程语言的差异，主要体现在<code>两者的语言特性</code>相较于<code>计算机指令集</code>的<mark>抽象程度</mark>。</p><ul><li>其中，<code>命令式编程语言的抽象程度更低</code>，这意味着该类语言的语法结构可以直接由相应的机器指令来实现。</li><li><code>而声明式编程语言的抽象程度更高</code>，这类语言更倾向于以叙事的方式来描述程序逻辑，开发者无需关心语言背后在机器指令层面的实现细节。</li><li>两种语言在使用上各有其适用场景，并无孰好孰坏之分。</li></ul><p>那么，C 语言作为一种低抽象层次的命令式编程语言，它的各类语法结构是如何对应到不同机器指令的？我会在下一个模块“语法核心实现篇”里为你详细介绍。</p><h2 id="c-程序的编译和运行" tabindex="-1"><a class="header-anchor" href="#c-程序的编译和运行" aria-hidden="true">#</a> C 程序的编译和运行</h2><p>编写完一段 C 代码，接下来的步骤就是对这段代码进行编译了。</p><blockquote><p>在执行编译命令时，为了保证程序的健壮性，我们一般会同时附带参数 <code>“-Wall”</code>，让编译器明确指出<code>程序代码中存在的所有语法使用不恰当的地方</code>。</p></blockquote><p>如果将那段用来回顾核心语法的 C 代码存放在名为 “demo.c” 的文件中，那我们可以使用下面这行命令来<code>编译并运行</code>这个程序：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>gcc demo.c <span class="token parameter variable">-o</span> demo <span class="token parameter variable">-Wall</span> <span class="token operator">&amp;&amp;</span> ./demo
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>一般来说，C 代码的完整编译过程可以分为如下四个阶段：</p><figure><img src="`+l+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="_1-代码预处理" tabindex="-1"><a class="header-anchor" href="#_1-代码预处理" aria-hidden="true">#</a> 1. 代码预处理</h3><p><strong>代码预处理</strong>：【移除注释，处理宏指令】</p><p>编译器会首先移除源代码中的所有注释信息，并处理所有宏指令。其中包括进行宏展开、宏替换，以及条件编译等。</p><h3 id="_2-分析优化" tabindex="-1"><a class="header-anchor" href="#_2-分析优化" aria-hidden="true">#</a> 2. 分析优化</h3><p><strong>编译优化</strong>：【分析并优化代码，生成汇编代码】</p><p>编译器会分析和优化源代码，并将其编译成对应的汇编格式代码，这部分代码中含有<code>使用汇编指令描述的</code>原始 C 程序逻辑。</p><h3 id="_3-汇编生成" tabindex="-1"><a class="header-anchor" href="#_3-汇编生成" aria-hidden="true">#</a> 3. 汇编生成</h3><p><strong>汇编</strong>：【生成对象格式文件】</p><p>编译器会将这些汇编代码编译成具有一定格式，<code>可以被操作系统使用的某种对象</code>文件格式。</p><h3 id="_4-链接" tabindex="-1"><a class="header-anchor" href="#_4-链接" aria-hidden="true">#</a> 4. 链接</h3><p><strong>链接</strong>：【地址重定位，生成二进制可执行文件】</p><p>通过链接处理，编译器会将所有程序目前需要的对象文件<code>进行整合、设置好程序中所有调用函数的正确地址，并生成对应的二进制可执行文件</code>。</p><h3 id="完成编译最终" tabindex="-1"><a class="header-anchor" href="#完成编译最终" aria-hidden="true">#</a> 完成编译最终</h3><p>编译结束后，我们就得到了<mark>可以直接运行的二进制文件ELF (进程)</mark>。在不同的操作系统上，你可以通过不同的方式来运行这个程序，比如双击或通过命令行。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>讲到这里，今天的内容也就基本结束了，最后我来给你总结一下。</p><p>这一讲，我们通过一个实例，带你快速回顾了 C 语言的一些重要语法特性。为了方便你复习，我把这些涉及到的核心语法特性总结成了一张表格：</p><img src="'+u+'" alt="img" style="zoom:25%;"><p>我还带你回顾了一个 C 程序的完整生命周期：代码编写、编译、运行。其中，C 代码的完整编译过程可以分为代码预处理、编译优化、汇编、链接四个阶段。程序的汇编、链接与运行，都会涉及与所在操作系统相关的一系列精细处理过程。我会在这门课的第四个模块中带你深入了解这些内容。</p><p>除此之外，我们还从语言本身的角度，探讨了 C 语言与其他编程语言的不同之处。C 语言作为一种命令式编程语言，抽象程度更低，语法结构可以直接由相应的机器指令经过简单的组合来实现。</p><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题" aria-hidden="true">#</a> 思考题</h2><p>最后，我们一起来做一个思考题吧。</p><p>在这一讲第一部分的 C 代码实例中，我们为何要给函数 findAddr 添加 static 关键字？不添加这个关键字的话，程序是否可以编译运行？欢迎在评论区分享你的思考和见解。</p><p>希望这一讲可以让你对 C 语言的基本情况有一个整体的感知。下一讲，我们会从一个 C 程序的基石，数据和量值出发，正式开始我们的 “C 语言核心语法实现”之旅，一起来看编译器是如何在背后实现这些基本语法的。我们下一讲见！</p><h2 id="课后讨论" tabindex="-1"><a class="header-anchor" href="#课后讨论" aria-hidden="true">#</a> 课后讨论</h2><p><mark>宏和函数的区别是啥？</mark> C 中的宏你可以简单理解为根据一定规则对源代码进行的字符替换，并且这个过程是在编译器开始处理 C 语法代码之前就会进行的。这部分内容我们会在第 09 讲介绍哈。</p>',57),f=t("<p>我尝试去掉了 findAddr 函数中的 static 关键字，如下：<br> inline /<em>static</em>/ const char* findAddr(const CONN* pip)<br> 再次尝试编译，发现完全编译不过：<br> gcc -o demo -Wall ./example.c<br> /tmp/ccPazvp1.o: In function <code>main&#39;: example.c:(.text+0x14f): undefined reference to </code>findAddr&#39;<br> collect2: error: ld returned 1 exit status</p><p>评论区几乎无人去动手，差点误导了我，我猜测是与 const 这个关键词有关，请老师详解一下</p><p>作者回复: 哈哈哈，实践出真知！</p><p>我直接在这里解答一下这个问题。正确情况下是如果在非优化的情况下，inline 需要配合 static 或者 extern 才能够编译。而在优化情况下，inline 可以单独使用。为什么会这样呢？</p><p>实际上，在 C17 标准中我们使用的 inline 关键字来源于 C99 标准。而在这个标准中，仅带有 inline 的函数具有 inline definition，表明该函数定义仅用于内联。而在非优化情况下，编译器通常会去寻找对应符号的 external definition（可以通过添加 extern 而获得），因此这种情况下会出现 linker error。而通过添加 static 关键字，可以使得对应函数定义具有 internal linkage，从而被编译器使用。在优化情况下，编译器会直接使用 inline definition 进行内联。</p>",5),_={href:"http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1256.pdf%EF%BC%88112%E9%A1%B5%EF%BC%8C6.7.4.6%EF%BC%89",target:"_blank",rel:"noopener noreferrer"},C=t("<hr><p>C99里inline函数需要两套声明，一个inline的，一个非inline的。例子里的程序如果去掉static的话，如果编译时没有优化就不会用到inline的声明，而如果找不到非inline的声明的话就会报链接错误。</p><p>如果不想写两套声明的话，要么加上static（这样就内部链接了），要么加优化参数-O2以上。</p><hr><p>老师，为啥是inline static而不是static inline的？这里有点奇怪</p><p>作者回复: 这是一个好问题。首先，这两种写法都是可以正常工作的。在 C17 标准之前，declaration specifier 可以按照任意的顺序摆放。而自 C17 标准之后，便规定 storage-class specifier（包含 static）应该被放置在各类定义的最开始，其他形式则为过时的写法。</p><p>6.11.5 Storage-class specifier<br> The placement of a storage-class speciﬁer other than at the beginning of the declaration speciﬁers in a declaration is an obsolescent feature.</p><hr><p>老师，宏和函数的区别是啥？我之前听说他比函数访问更加快？执行上面是否一致呢，函数要进行call，压栈，完事儿出栈，还得ret返回调用前地址 ，但是宏相对简单一点？函数编译需要链接，宏相当于常量，操作系统全局，所以不需要么？函数处理内容更加多，宏比较固定？主要Java程序员没接触过宏，所以感觉是个很陌生的领域</p><p>作者回复: C 中的宏你可以简单理解为根据一定规则对源代码进行的字符替换，并且这个过程是在编译器开始处理 C 语法代码之前就会进行的。这部分内容我们会在第 09 讲介绍哈。</p><hr>",11),y=n("br",null,null,-1),w=n("br",null,null,-1),N={href:"https://en.cppreference.com/w/c",target:"_blank",rel:"noopener noreferrer"},x=n("hr",null,null,-1),O=n("p",null,[s("为啥我用VScode去掉static可以编译通过并且运行结果是和不加值一样的，因为对C语言不太了解，所以也不知道为啥。"),n("br"),s(" 作者回复: 可以看一下是不是编译时使用了 -O0 以上的优化等级。")],-1),q=n("hr",null,null,-1),E=n("p",null,"针对本程序，去掉static是不可以编译运行的。一开始没注意有个inline",-1),A=n("p",null,[s("之所以添加static修饰，是为了限定该接口只能被本编译单元使用。"),n("br"),s(" c的接口默认是extern的，外部只要添加接口声明即可引用该接口，因此需要显式地添加static来限定可能的引用以及同名符号冲突。")],-1),B=n("hr",null,null,-1),L={href:"https://godbolt.org/%E8%BF%99%E4%B8%AA%E5%B7%A5%E5%85%B7%EF%BC%8C%E5%BE%88%E7%89%9B%E5%95%8A%EF%BC%8C%E5%8E%9F%E6%9D%A5%E8%80%81%E5%B8%88%E5%BC%80%E7%AF%87%E9%87%8C%E7%9A%84c%E5%92%8C%E6%B1%87%E7%BC%96%E7%9A%84%E5%AF%B9%E6%AF%94%E5%9B%BE%E6%98%AF%E8%BF%99%E4%B9%88%E6%9D%A5%E7%9A%84%E5%91%80~",target:"_blank",rel:"noopener noreferrer"},S=n("br",null,null,-1),I=n("hr",null,null,-1),P=n("p",null,[n("em",null,"static修饰函数，表示该函数只能被本文件中的函数调用，而不能被同一程序其它文件中的函数调用"),s("。在本文的事例里，去掉也是可以的。")],-1);function F(z,R){const a=o("ExternalLinkIcon");return c(),i("div",null,[d,n("blockquote",null,[n("p",null,[s("当然，如果你在本地环境中没有安装上面这些编译器，那么也可以直接使用云编译器，比如 "),n("a",k,[s("Godbolt"),p(a)]),s("。")]),m]),n("p",null,[s("至于 IDE，那些常用的都可以，不过推荐你选择 Visual Studio Code，因为它较为轻量，且目前提供的插件能力也足够进行 C 语言开发。最后，这门课里出现的所有代码，我都会统一放在"),n("a",v,[s("这个代码库"),p(a)]),s("中，你可以根据需要自行获取。")]),b,n("p",null,[s("这些语法特性本身比较常用，且概念较为简单，这里我就不再单独介绍了。如果你对其中的一些特性感到陌生，可以选择在 "),n("a",h,[s("GeeksforGeeks"),p(a)]),s("网站上直接查找特定主题并学习，或者查阅==《C Primer Plus》==这些入门书籍。")]),g,n("blockquote",null,[f,n("p",null,[s("具体可以参考标准："),n("a",_,[s("http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1256.pdf（112页，6.7.4.6）"),p(a)])]),C,n("p",null,[s("类似的c11、c17中新用法在哪里查询呢"),y,s(" 有类似MSDN的文档么"),w,s(" 作者回复: 可以在这边看哈，不过需要科学上网："),n("a",N,[s("https://en.cppreference.com/w/c"),p(a)])]),x,O,q,E,A,B,n("p",null,[s("我们用的还是gcc 4.8.5，用老师介绍的"),n("a",L,[s("https://godbolt.org/这个工具，很牛啊，原来老师开篇里的c和汇编的对比图是这么来的呀~"),p(a)]),S,s(" 作者回复: 正解！")]),I,P])])}const D=e(r,[["render",F],["__file","√A01-程序生命周期.html.vue"]]);export{D as default};
