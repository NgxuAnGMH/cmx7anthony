import{_ as s}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as a,d as n}from"./app-cdabc73c.js";const r="/assets/f837811192730cc9c152afbcccf4eff8-fc1fb599.jpeg",i="/assets/14633ea933972e19f3439eb6aeab3d13-8a299f80.jpg",d="/assets/e8876e8561b949b8af5d5237e48f8757-b5be0de8.jpg",l="/assets/0f564d0aac8514245805eea31aa32c2a-4dd311f1.jpeg",t="/assets/d29yyb3f4ac30552e4c0835525d72b2b-16f582c1.jpg",o="/assets/b40a64dd5ca1dc1efd8957525e904634-d0232dac.jpg",c="/assets/ab203e85dd8468051eca238c3ebd81f7-c1399690.jpg",p="/assets/d08ec3163c80a5dd94e488a71588f8a4-47b55d93.jpg",m="/assets/e11b9de930a09fb41bd6ded9bf12620b-b5540a93.jpg",b="/assets/ff5c25c85a7fa28b17f386848f19fb5b-bcd91e2a.jpg",u="/assets/cce7aa5fe43552357bc51455cd86a734-f16dcf7e.jpg",v="/assets/974b59084976ddb3df9bdc3bea9325c4-48a89ed1.jpg",g="/assets/28f28817ca5a3e47f80ea798698dbdc4-950a8a8b.jpg",h={},P=n(`<h1 id="_05-cpu工作模式-执行程序的三种模式" tabindex="-1"><a class="header-anchor" href="#_05-cpu工作模式-执行程序的三种模式" aria-hidden="true">#</a> 05 | CPU工作模式：执行程序的三种模式</h1><p>你好，我是 LMOS。</p><p>我们在前面已经设计了我们的 OS 架构，你也许正在考虑怎么写代码实现它。恕我直言，现在我们还有很多东西没搞清楚。</p><p>由于 OS 内核直接运行在硬件之上，所以我们要对运行我们代码的硬件平台有一定的了解。接下来，我会通过三节课，带你搞懂硬件平台的关键内容。</p><p>今天我们先来学习 CPU 的工作模式，硬件中最重要的就是 CPU，它就是执行程序的核心部件。而我们常用的电脑就是 x86 平台，所以我们要对 x86 CPU 有一些基本的了解。</p><p>按照 CPU 功能升级迭代的顺序，CPU 的工作模式有<strong>实模式</strong>、<strong>保护模式</strong>、<strong>长模式</strong>，这几种工作模式下 CPU 执行程序的方式截然不同，下面我们一起来探讨这几种工作模式。</p><h2 id="从一段死循环的代码说起" tabindex="-1"><a class="header-anchor" href="#从一段死循环的代码说起" aria-hidden="true">#</a> 从一段死循环的代码说起</h2><p>请思考一下，如果下面这段应用程序代码能够成功运行，会有什么后果？</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span><span class="token operator">*</span> addr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">cli</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//关中断</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token operator">*</span>addr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        addr<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码首先关掉了 CPU 中断，<strong>（关中断）让 CPU 停止响应中断信号</strong>，然后进入死循环，最后从内存 0 地址开始写入 0。你马上就会想到，这段代码只做了两件事：一是锁住了 CPU，二是清空了内存，你也许会觉得如果这样的代码能正常运行，那简直太可怕了。</p><p>**不过如果是在实模式下，这样的代码确实是能正常运行。**因为在很久以前，计算机资源太少，内存太小，<strong>都是单道程序执行</strong>，程序大多是由专业人员编写调试好了，才能预约到一个时间去上机运行，没有现代操作系统的概念。</p><p>后来有 DOS 操作系统，也是单道程序系统，不具备执行多道程序的能力，所以 CPU 这种模式也能很好地工作。</p><p>下面我们就从最简单，也是最原始的实模式开始讲起。</p><h2 id="实模式-单道程序执行" tabindex="-1"><a class="header-anchor" href="#实模式-单道程序执行" aria-hidden="true">#</a> 实模式（单道程序执行）</h2><p>实模式又称实地址模式，实，即真实，这个真实分为两个方面，一个方面是<strong>运行真实的指令</strong>，对指令的动作不作区分，直接<strong>执行指令的真实功能</strong>，另一方面是<strong>发往内存的地址是真实的</strong>，对任何地址<strong>不加限制</strong>地发往内存。</p><h3 id="实模式寄存器" tabindex="-1"><a class="header-anchor" href="#实模式寄存器" aria-hidden="true">#</a> 实模式寄存器</h3><p>由于 CPU 是根据指令完成相应的功能，举个例子：ADD AX,CX；这条指令完成加法操作，AX、CX 为 ADD 指令的操作数，可以理解为 ADD 函数的两个参数，其功能就是把 AX、CX 中的数据相加。</p><p>指令的操作数，可以是寄存器、内存地址、常数，其实通常情况下是寄存器，AX、CX 就是 x86 CPU 中的寄存器。</p><p>下面我们就去看看 x86 CPU 在实模式下的寄存器。表中每个寄存器都是 16 位的。</p><img src="`+r+'" alt="img" style="zoom:50%;"><p>实模式下的寄存器</p><h3 id="实模式下访问内存" tabindex="-1"><a class="header-anchor" href="#实模式下访问内存" aria-hidden="true">#</a> 实模式下访问内存</h3><p>虽然有了寄存器，但是数据和指令都是存放在内存中的。通常情况下，需要把数据装载进寄存器中才能操作，还要有获取指令的动作，这些都要访问内存才行，而我们知道访问内存靠的是地址值。</p><p>那问题来了，这个值是如何计算的呢？计算过程如下图。</p><h4 id="_1-代码段-cs-ip" tabindex="-1"><a class="header-anchor" href="#_1-代码段-cs-ip" aria-hidden="true">#</a> 1 代码段 CS + IP</h4><ul><li><p>取指：获取指令，涉及的都是“控制单元 - 代码段 - 指令指针寄存器”</p></li><li><p>CS（Code Segment）代码段寄存器</p><ul><li><strong><code>代码段</code>的偏移量</strong>在 <mark>IP 寄存器</mark>中</li><li>IP（Instruction Pointer）指令指针寄存器 。</li></ul></li></ul><h4 id="_2-数据段-ds-通用" tabindex="-1"><a class="header-anchor" href="#_2-数据段-ds-通用" aria-hidden="true">#</a> 2 数据段 DS + 通用</h4><ul><li>访问内存数据：涉及的都是“数据单元 - 数据段 - 通用数据寄存器”</li><li><strong><code>数据段</code>的偏移量</strong>会放在<mark>通用寄存器</mark>中。 <ul><li>AH&amp;AL=AX（accumulator）累加寄存器</li><li>BH&amp;BL=BX（base）基址寄存器 <ul><li>CH&amp;CL=CX（count）计数寄存器</li><li>DH&amp;DL=DX（data）数据寄存器</li><li><code>SP</code>（Stack Pointer）堆栈指针寄存器 (段的起始地址)</li><li>BP（Base Pointer）基址指针寄存器</li><li>SI（Source Pointer）源变址寄存器</li><li>DI（Destination Index）目的变址寄存器</li></ul></li><li>段寄存器 &lt;--&gt; 运算单元需要</li><li>DS（Data Segment）数据段寄存器 <ul><li><code>SS</code>（Stack Segment）堆栈段/栈寄存器 (栈顶指针)</li><li>ES（Extra Segment）附加段寄存器</li></ul></li></ul></li></ul><img src="'+i+`" alt="img" style="zoom:20%;"><p>实模式下访问内存</p><p>结合上图可以发现，所有的内存地址都是由段寄存器左移 4 位，再加上一个通用寄存器中的值或者常数形成地址，然后由这个地址去访问内存。这就是大名鼎鼎的<mark>分段内存管理模型</mark>。</p><h4 id="_3-栈段-ss-sp" tabindex="-1"><a class="header-anchor" href="#_3-栈段-ss-sp" aria-hidden="true">#</a> 3 栈段 SS &amp; SP</h4><p>只不过这里要特别注意的是，<strong><code>代码段</code>是由 CS 和 IP 确定的，而<code>栈段</code>是由 SS 和 SP 段确定的。</strong></p><p>下面我们写一个 DOS 下的 Hello World 应用程序，这是一个工作在实模式下的汇编代码程序，一共 16 位，具体代码如下：</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>data SEGMENT ;定义一个数据段存放Hello World!
    hello  DB &#39;Hello World!$&#39; ;注意要以$结束
data ENDS
code SEGMENT ;定义一个代码段存放程序指令
    ASSUME CS:CODE,DS:DATA ;告诉汇编程序，DS指向数据段，CS指向代码段
start:
    MOV AX,data  ;将data段首地址赋值给AX                
    MOV DS,AX    ;将AX赋值给DS，使DS指向data段
    LEA DX,hello ;使DX指向hello首地址
    MOV AH,09h   ;给AH设置参数09H，AH是AX高8位，AL是AX低8位，其它类似
    INT 21h      ;执行DOS中断输出DS指向的DX指向的字符串hello
    MOV AX,4C00h ;给AX设置参数4C00h
    INT 21h      ;调用4C00h号功能，结束程序
code ENDS
END start
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中的结构模型，也是符合 CPU 实模式下<mark>分段内存管理模式</mark>的，它们被汇编器转换成二进制数据后，也是以<mark>段</mark>的形式存在的。</p><p>代码中的注释已经很明确了，你应该很容易就能理解，大多数是操作寄存器，其中 LEA 是取地址指令，MOV 是数据传输指令，就是 INT 中断你可能还不太明白，下面我们就来研究它。</p><h3 id="实模式中断" tabindex="-1"><a class="header-anchor" href="#实模式中断" aria-hidden="true">#</a> 实模式中断</h3><p>中断即中止执行当前程序，转而跳转到另一个特定的地址上，去运行特定的代码。在实模式下它的实现过程是先保存**（<code>代码段位置</code>） CS 和 IP 寄存器**，然后装载新的 CS 和 IP 寄存器（代码段位置），那么中断是如何产生的呢？</p><h4 id="_1-硬件-软件" tabindex="-1"><a class="header-anchor" href="#_1-硬件-软件" aria-hidden="true">#</a> 1 硬件/软件</h4><ol><li><p>第一种情况是，<mark>中断控制器</mark>给 CPU 发送了一个电子信号，CPU 会对这个信号作出应答。随后中断控制器会将中断号发送给 CPU，这是<strong>硬件中断</strong>。</p></li><li><p>第二种情况就是 CPU 执行了 <mark>INT 指令</mark>，这个指令后面会跟随一个常数，这个常数即是<mark>软中断号</mark>。这种情况是<strong>软件中断</strong>。</p></li></ol><h4 id="_2-idtr-中断向量表-存放代码段位置" tabindex="-1"><a class="header-anchor" href="#_2-idtr-中断向量表-存放代码段位置" aria-hidden="true">#</a> 2 IDTR -&gt; 中断向量表(存放代码段位置)</h4><p>无论是硬件中断还是软件中断，都是 CPU 响应外部事件的一种方式。</p><p>为了实现中断，就需要在内存中放一个==<strong>中断向量表</strong>==，这个表的地址和长度由 <mark>CPU 的特定寄存器 <strong>IDTR</strong></mark> 指向。</p><p>实模式下，表中的一个条目由<mark>代码段基地址</mark>和<mark>段内偏移</mark>组成，如下图所示。</p><img src="`+d+'" alt="img" style="zoom:20%;"><p>实模式中断表</p><p>有了中断号以后，CPU 就能根据 IDTR 寄存器中的信息，计算出中断向量中的条目，进而装载 **<code>CS</code>（装入代码段基地址）、<code>IP</code>（装入代码段内偏移）**寄存器，最终响应中断。</p><h2 id="保护模式-仍分段-接近分页" tabindex="-1"><a class="header-anchor" href="#保护模式-仍分段-接近分页" aria-hidden="true">#</a> 保护模式（仍分段/接近分页）</h2><p>随着软件的规模不断增加，需要更高的计算量、更大的内存容量。</p><p>内存一大，首先要解决的问题是<strong>寻址问题</strong>，因为 16 位的寄存器最多只能表示 2<sup>16</sup> 个地址，所以 CPU 的寄存器和运算单元都要扩展成 32 位的。</p><p>不过，虽然扩展 CPU 内部器件的位数解决了计算和寻址问题，但仍然没有解决前面那个实模式场景下的问题，导致前面场景出问题的原因有两点。</p><ul><li>第一，CPU 对任何指令不加区分地执行；(-&gt; 特权等级)</li><li>第二，CPU 对访问内存的地址不加限制。(物理地址 -&gt; 虚拟地址)</li></ul><p>基于这些原因，CPU 实现了保护模式。保护模式是如何实现保护功能的呢？我们接着往下看。</p><h3 id="保护模式寄存器" tabindex="-1"><a class="header-anchor" href="#保护模式寄存器" aria-hidden="true">#</a> 保护模式寄存器</h3><p>保护模式相比于实模式，增加了一些控制寄存器和段寄存器，扩展通用寄存器的位宽，所有的通用寄存器都是 32 位的，(为了兼容)还可以单独使用低 16 位，这个低 16 位又可以拆分成两个 8 位寄存器，如下表。</p><img src="'+l+'" alt="img" style="zoom:50%;"><p>保护模式下的寄存器</p><h3 id="保护模式特权级" tabindex="-1"><a class="header-anchor" href="#保护模式特权级" aria-hidden="true">#</a> 保护模式特权级</h3><p>为了区分哪些指令（如 in、out、cli）和哪些资源（如寄存器、I/O 端口、内存地址）可以被访问，CPU 实现了<mark>特权级</mark>。</p><p>特权级分为 4 级，R0~R3，每个特权级执行指令的数量不同，R0 可以执行所有指令，R1、R2、R3 依次递减，它们只能执行上一级指令数量的子集。而<mark>内存的访问</mark>则是靠后面所说的段描述符和特权级相互配合去实现的。如下图.</p><img src="'+t+'" alt="img" style="zoom:15%;"><p>CPU特权级示意图</p><p>**上面的圆环图，从外到内，既能体现权力的大小，又能体现各特权级对资源控制访问的多少，还能体现各特权级之间的包含关系。**R0 拥有最大权力，可以访问低特权级的资源，反之则不行。</p><h3 id="保护模式段描述符" tabindex="-1"><a class="header-anchor" href="#保护模式段描述符" aria-hidden="true">#</a> 保护模式段描述符</h3><p>目前为止，内存还是分段模型，要对内存进行保护，就可以转换成对段的保护。</p><p>由于 CPU 的扩展导致了 32 位的段基地址和段内偏移，(虚拟内存机制为了方便统一管理)还有一些其它信息，所以 16 位的段寄存器肯定放不下。放不下就要找内存借空间，然后把<strong>描述一个段的信息</strong>封装成特定格式的**<mark>段描述符</mark>**，<strong>放在内存中</strong>，其格式如下。</p><p>描述符: 虚拟内存 + 特权等级 , 让管理所需要的信息更加复杂了</p><img src="'+o+'" alt="img" style="zoom:15%;"><p>保护模式段描述符</p><p>一个段描述符有 64 位 8 字节数据，里面包含了段基地址、段长度、段权限、段类型（可以是<code>系统段、代码段、数据段</code>）、段是否可读写，可执行等。虽然数据分布有点乱，这是由于历史原因造成的。</p><p>多个<mark>段描述符</mark>在内存中形成<mark>全局段描述符表</mark>，该表的基地址和长度由 <mark>CPU 和 GDTR 寄存器</mark>指示。如下图所示。</p><img src="'+c+'" alt="img" style="zoom:15%;"><p>全局段描述符表</p><p>我们一眼就可以看出，<mark>段寄存器</mark>中不再存放<strong>段基地址</strong>，而是<strong>具体段描述符的索引</strong>，访问一个内存地址时，段寄存器中的<strong>索引</strong>首先会结合 <strong>GDTR 寄存器</strong>找到内存中的<strong>段描述符</strong>，再根据其中的段信息判断能不能访问成功。</p><h3 id="保护模式段选择子" tabindex="-1"><a class="header-anchor" href="#保护模式段选择子" aria-hidden="true">#</a> 保护模式段选择子</h3><p>如果你认为 CS、DS、ES、SS、FS、GS 这些段寄存器，里面存放的就是一个内存段的描述符索引，那你可就草率了，其实它们是由<strong>影子寄存器、段描述符索引、描述符表索引、权限级别</strong>组成的。如下图所示。</p><img src="'+p+`" alt="img" style="zoom:15%;"><p>保护模式段选择子</p><p>上图中<strong>影子寄存器</strong>是靠<mark>硬件</mark>来操作的，对系统程序员不可见，是硬件为了<strong>减少性能损耗</strong>而设计的一个段描述符的高速缓存，不然每次内存访问都要去内存中查表，那性能损失是巨大的，影子寄存器也正好是 64 位，里面存放了 <strong><code>8 字节</code>段描述符<code>数据</code></strong>。</p><p>低三位之所以能放 <code>TI</code> 和 <code>RPL</code>，是因为段描述符 8 字节对齐，每个索引低 3 位都为 0，我们不用关注 LDT，只需要使用 GDT 全局描述符表，所以 TI 永远设为 0。</p><p>通常情况下，CS 和 SS 中 <code>RPL</code> 就组成了 <code>CPL</code>（当前权限级别），所以常常是 RPL=CPL，进而 CPL 就表示发起访问者要以什么权限去访问目标段，当 CPL 大于目标段 DPL 时，则 CPU 禁止访问，只有 CPL 小于等于目标段 DPL 时才能访问。（R0高权限 R3低权限）</p><h3 id="保护模式平坦模型" tabindex="-1"><a class="header-anchor" href="#保护模式平坦模型" aria-hidden="true">#</a> 保护模式平坦模型</h3><p>分段模型有很多缺陷，这在后面课程讲内存管理时有详细介绍，其实现代操作系统都会使用<strong>分页模型</strong>（这点在后面讲 MMU 那节课再探讨）。</p><p><strong>但是 x86 CPU 并不能直接使用分页模型</strong>，而是要在分段模型的前提下，<strong>根据需要决定</strong>是否要开启分页。<strong>因为这是硬件的规定</strong>，程序员是无法改变的。但是我们可以简化设计，来使分段成为一种“<code>虚设</code>”，这就是<mark>保护模式的平坦模型</mark>。</p><p>根据前面的描述，我们发现 CPU32 位的寄存器最多只能产生 4GB 大小的地址，而一个段长度也只能是 4GB，所以我们把所有段的基地址设为 0，段的长度设为 0xFFFFF，段长度的粒度设为 4KB(固定大小/约等于分页)，这样所有的段都指向同一个（（段的长度 +1）* 粒度 - 1）字节大小的(虚拟)地址空间。</p><p>下面我们还是看一看前面 Hello OS 中段描述符表，如下所示。</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>GDT_START:
knull_dsc: dq 0
;第一个段描述符CPU硬件规定必须为0
kcode_dsc: dq 0x00cf9e000000ffff
;段基地址=0，段长度=0xfffff
;G=1,D/B=1,L=0,AVL=0 
;P=1,DPL=0,S=1
;T=1,C=1,R=1,A=0
kdata_dsc: dq 0x00cf92000000ffff
;段基地址=0，段长度=0xfffff
;G=1,D/B=1,L=0,AVL=0 
;P=1,DPL=0,S=1
;T=0,C=0,R=1,A=0
GDT_END:

GDT_PTR:
GDTLEN  dw GDT_END-GDT_START-1
GDTBASE  dd GDT_START
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中注释已经很明白了，段长度需要和 G 位配合，若 G 位为 1 则段长度等于 0xfffff 个 4KB。上面段描述符的 DPL=0，这说明需要最高权限即 CPL=0 才能访问。</p><h3 id="保护模式中断" tabindex="-1"><a class="header-anchor" href="#保护模式中断" aria-hidden="true">#</a> 保护模式中断</h3><p>你还记得实模式下 CPU 是如何处理中断的吗？如果不记得了请回到前面看一看。</p><p>因为实模式下 CPU 不需要做权限检查，所以它可以直接通过中断向量表中的值装载 CS:IP 寄存器就好了。</p><p>而保护模式下的中断要<strong>权限检查</strong>，还有<strong>特权级的切换</strong>，所以就需要<strong>扩展中断向量表的信息</strong>，即<strong>每个中断</strong>用<strong>一个中断门描述符</strong>来表示，也可以简称为<mark>中断门</mark>，中断门描述符依然有自己的格式，如下图所示。</p><p>描述符: 虚拟内存 + 特权等级 , 让管理所需要的信息更加复杂了</p><img src="`+m+'" alt="img" style="zoom:15%;"><p>保护模式中断门描述符</p><p>同样的，保护模式要实现中断，也必须在内存中有一个<mark>中断向量表</mark>，同样是由 <mark>IDTR 寄存器</mark>指向，只不过中断向量表中的条目变成了<mark>中断门描述符</mark>，如下图所示。</p><img src="'+b+`" alt="img" style="zoom:15%;"><p>保护模式段中断表</p><p>产生中断后，CPU 首先会检查中断号是否大于<strong>最后一个中断门描述符</strong>，x86 CPU 最大支持 256 个中断源（即中断号：0~255），然后检查描述符类型（是否是中断门或者陷阱门）、是否为系统描述符，是不是存在于内存中。</p><p>接着，检查中断门描述符中的段选择子指向的段描述符。</p><p>最后做<strong>权限检查</strong>，如果 CPL 小于等于中断门的 DPL，并且 CPL 大于等于中断门中的段选择子所指向的段描述符的 DPL，就指向段描述符的 DPL。</p><p>进一步的，CPL 等于中断门中的段选择子指向段描述符的 DPL，则为同级权限不进行栈切换，否则进行栈切换。如果进行栈切换，还需要从 TSS 中加载具体权限的 SS、ESP，当然也要对 SS 中段选择子指向的段描述符进行检查。</p><p>做完这一系列检查之后，CPU 才会加载中断门描述符中目标代码段选择子到 CS 寄存器中，把（内核的中断有关代码）目标代码段偏移加载到 EIP 寄存器中。进行操作产生中断。</p><h3 id="切换到保护模式" tabindex="-1"><a class="header-anchor" href="#切换到保护模式" aria-hidden="true">#</a> 切换到保护模式</h3><p>x86 CPU 在第一次加电和每次 reset 后，都会自动进入实模式，要想进入保护模式，就需要程序员写代码实现从实模式切换到保护模式。切换到保护模式的步骤如下。</p><p>第一步，准备全局段描述符表，代码如下。</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>GDT_START:
knull_dsc: dq 0
kcode_dsc: dq 0x00cf9e000000ffff
kdata_dsc: dq 0x00cf92000000ffff
GDT_END:
GDT_PTR:
GDTLEN  dw GDT_END-GDT_START-1
GDTBASE  dd GDT_START
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第二步，加载设置 GDTR 寄存器，使之指向全局段描述符表。</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>lgdt [GDT_PTR]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>第三步，设置 CR0 寄存器，开启保护模式。</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>;开启 PE
mov eax, cr0
bts eax, 0                      ; CR0.PE =1
mov cr0, eax         
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第四步，进行长跳转，加载 CS 段寄存器，即段选择子。</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>jmp dword 0x8 :_32bits_mode ;_32bits_mode为32位代码标号即段偏移
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>你也许会有疑问，为什么要进行长跳转，这是因为我们无法直接或间接 mov 一个数据到 CS 寄存器中，因为刚刚开启保护模式时，<strong>CS 的影子寄存器</strong>还是实模式下的值，所以需要告诉 CPU 加载新的段信息。</p><p>接下来，CPU 发现了 CRO 寄存器第 0 位的值是 1，就会按 GDTR 的指示找到全局描述符表，然后根据索引值 8，把新的段描述符信息加载到 CS 影子寄存器，当然这里的前提是进行一系列合法的检查。</p><p>到此为止，CPU 真正进入了保护模式，CPU 也有了 32 位的处理能力。</p><blockquote><p>请问实模式切换到保护模式的第四步中根据索引值8 到底是什么数据<br> 作者回复: 8 索引 GDT 中的第二条数据</p></blockquote><h2 id="长模式-mmu-必须分页" tabindex="-1"><a class="header-anchor" href="#长模式-mmu-必须分页" aria-hidden="true">#</a> 长模式（MMU/必须分页）</h2><p>长模式又名 AMD64，因为这个标准是 AMD 公司最早定义的，它使 CPU 在现有的基础上有了 64 位的处理能力，既能完成 64 位的数据运算，也能寻址 64 位的地址空间。这在大型计算机上犹为重要，因为它们的物理内存通常有几百 GB。</p><h3 id="长模式寄存器" tabindex="-1"><a class="header-anchor" href="#长模式寄存器" aria-hidden="true">#</a> 长模式寄存器</h3><p>长模式相比于保护模式，增加了一些通用寄存器，并扩展通用寄存器的位宽，所有的通用寄存器都是 64 位，（为了兼容）还可以单独使用低 32 位。</p><p>这个低 32 位（进一步兼容）可以拆分成一个低 16 位寄存器，低 16 位又可以拆分成两个 8 位寄存器，如下表。</p><img src="`+u+'" alt="img" style="zoom:33%;"><p>长模式下的寄存器</p><h3 id="长模式段描述符" tabindex="-1"><a class="header-anchor" href="#长模式段描述符" aria-hidden="true">#</a> 长模式段描述符</h3><p>长模式依然具备保护模式绝大多数特性，如<strong>特权等级</strong>和<strong>权限检查</strong>。相同的部分就不再重述了，这里只会说明长模式和保护模式下的<strong>差异</strong>。</p><p>下面我们来看看长模式下段描述的格式，如下图所示。</p><img src="'+v+`" alt="img" style="zoom:15%;"><p>长模式段描述符</p><p>在长模式下，CPU 不再对<mark>段基址</mark>和<mark>段长度</mark>进行检查，只对 DPL 进行相关的检查，这个检查流程和保护模式下一样。</p><p>当描述符中的 L=1，D/B=0 时，就是 64 位代码段，DPL 还是 0~3 的特权级。然后有多个段描述在内存中形成一个全局段描述符表，同样由 CPU 的 GDTR 寄存器指向。</p><p>下面我们来写一个长模式下的段描述符表，加深一下理解，如下所示.</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>ex64_GDT:
null_dsc:  dq 0
;第一个段描述符CPU硬件规定必须为0
c64_dsc:dq 0x0020980000000000  ;64位代码段
;无效位填0
;D/B=0,L=1,AVL=0 
;P=1,DPL=0,S=1
;T=1,C=0,R=0,A=0
d64_dsc:dq 0x0000920000000000  ;64位数据段
;无效位填0
;P=1,DPL=0,S=1
;T=0,C/E=0,R/W=1,A=0
eGdtLen   equ $ - null_dsc  ;GDT长度
eGdtPtr:dw eGdtLen - 1  ;GDT界限
     dq ex64_GDT
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中注释已经很清楚了，段长度和段基址都是无效的填充为 0，CPU 不做检查。但是上面段描述符的 DPL=0，这说明需要最高权限即 CPL=0 才能访问。若是数据段的话，G、D/B、L 位都是无效的。</p><h3 id="长模式中断" tabindex="-1"><a class="header-anchor" href="#长模式中断" aria-hidden="true">#</a> 长模式中断</h3><p>保护模式下为了实现对中断进行权限检查，实现了中断门描述符，在中断门描述符中存放了对应的段选择子和其段内偏移，还有 DPL 权限，如果权限检查通过，则用对应的段选择子和其段内偏移装载 CS:EIP 寄存器。</p><p>如果你还记得中断门描述符，就会发现其中的段内偏移只有 32 位，但是长模式支持 64 位内存寻址，所以要对中断门描述符进行修改和扩展，下面我们就来看看长模式下的中断门描述符的格式，如下图所示。</p><img src="`+g+`" alt="img" style="zoom:15%;"><p>长模式中断门描述符</p><p>结合上图，我们可以看出<strong>长模式下中断门描述符的格式变化</strong>。</p><p>首先为了支持 64 位寻址中断门描述符在原有基础上增加 8 字节，用于存放目标段偏移的高 32 位值。其次，目标代码段选择子对应的代码段描述符必须是 64 位的代码段。最后其中的 IST 是 64 位 TSS 中的 IST 指针，因为我们不使用这个特性，所以不作详细介绍。</p><p>长模式也同样在内存中有一个<mark>中断门描述符表</mark>，只不过表中的条目（如上图所示）是 16 字节大小，最多支持 256 个中断源，对中断的响应和相关权限的检查和保护模式一样，这里不再赘述。</p><h3 id="切换到长模式" tabindex="-1"><a class="header-anchor" href="#切换到长模式" aria-hidden="true">#</a> 切换到长模式</h3><p>我们既可以从实模式直接切换到长模式，也可以从保护模式切换长模式。切换到长模式的步骤如下。</p><p>第一步，准备长模式全局段描述符表。</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>ex64_GDT:
null_dsc:  dq 0
;第一个段描述符CPU硬件规定必须为0
c64_dsc:dq 0x0020980000000000  ;64位代码段
d64_dsc:dq 0x0000920000000000  ;64位数据段
eGdtLen   equ $ - null_dsc  ;GDT长度
eGdtPtr:dw eGdtLen - 1  ;GDT界限
     dq ex64_GDT
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第二步，准备长模式下的 MMU 页表，这个是为了开启分页模式，<strong>切换到<code>长模式</code>必须要开启<code>分页</code></strong>，想想看，长模式下已经不对段基址和段长度进行检查了，那么内存地址空间就得不到保护了。</p><p>而长模式下内存地址空间的保护交给了 MMU，MMU 依赖页表对地址进行转换，页表有特定的格式存放在内存中，其地址由 CPU 的 CR3 寄存器指向，这在后面讲 MMU 的那节课会专门讲。</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>mov eax, cr4
bts eax, 5   ;CR4.PAE = 1
mov cr4, eax ;开启 PAE
mov eax, PAGE_TLB_BADR ;页表物理地址
mov cr3, eax
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3.加载 GDTR 寄存器，使之指向全局段描述表：</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>lgdt [eGdtPtr]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>4.开启长模式，要同时开启保护模式和分页模式，在实现长模式时定义了 MSR 寄存器，需要用专用的指令 rdmsr、wrmsr 进行读写，IA32_EFER 寄存器的地址为 0xC0000080，它的第 8 位决定了是否开启长模式。</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>;开启 64位长模式
mov ecx, IA32_EFER
rdmsr
bts eax, 8  ;IA32_EFER.LME =1
wrmsr
;开启 保护模式和分页模式
mov eax, cr0
bts eax, 0    ;CR0.PE =1
bts eax, 31
mov cr0, eax 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>5.进行跳转，加载 CS 段寄存器，刷新其影子寄存器。</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>jmp 08:entry64 ;entry64为程序标号即64位偏移地址
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>切换到长模式和切换保护模式的流程差不多，只是需要准备的段描述符有所区别，还有就是要注意同时开启保护模式和分页模式。原因在上面已经说明了。</p><h2 id="重点回顾" tabindex="-1"><a class="header-anchor" href="#重点回顾" aria-hidden="true">#</a> 重点回顾</h2><p>好，这节课的内容告一段落了，我来给你做个总结。</p><p>今天我们从一段死循环的代码开始思考，研究这类代码产生的问题和解决思路，然后一步步探索 CPU 为了处理这些问题而做出的改进和升级。这些功能上的改进和升级，渐渐演变成了 CPU 的工作模式，这也是系统开发人员需要了解的编程模型。这三种模式梳理如下。</p><ol><li><p>实模式，早期 CPU 是为了支持单道程序运行而实现的，单道程序能掌控计算机所有的资源，早期的软件规模不大，内存资源也很少，所以实模式极其简单，仅支持 16 位地址空间，分段的内存模型，<strong>对指令不加限制地运行，对内存没有保护隔离作用</strong>。</p></li><li><p>保护模式，随着多道程序的出现，就需要操作系统了。内存需求量不断增加，所以 CPU 实现了保护模式以支持这些需求。</p></li></ol><p>保护模式包含<strong>特权级</strong>，对指令及其访问的资源进行控制，对内存段与段之间的访问进行严格检查，没有权限的绝不放行，对中断的响应也要进行严格的权限检查，扩展了 CPU 寄存器位宽，使之能够寻址 32 位的内存地址空间和处理 32 位的数据，从而 CPU 的性能大大提高。</p><ol start="3"><li>长模式，又名 AMD64 模式，最早由 AMD 公司制定。由于软件对 CPU 性能需求永无止境，所以长模式在保护模式的基础上，把寄存器扩展到 64 位同时增加了一些寄存器，使 CPU 具有了能处理 64 位数据和寻址 64 位的内存地址空间的能力。</li></ol><p>长模式<strong>弱化段模式管理</strong>，只保留了权限级别的检查，忽略了段基址和段长度，而地址的检查则交给了 <mark>MMU</mark>。</p><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题" aria-hidden="true">#</a> 思考题</h2><p>请问实模式下能寻址多大的内存空间？</p><p>期待你在留言区跟我交流互动，如果你身边有对 CPU 工作模式感兴趣的朋友，也欢迎把这节课的内容转发给他，我们一起学习进步。</p><h2 id="课后讨论" tabindex="-1"><a class="header-anchor" href="#课后讨论" aria-hidden="true">#</a> 课后讨论</h2><p>这篇文章信息量很大，但是问题比较简单，我先回答一下问题吧。<br><mark>实模式</mark>下的<strong>寻址空间</strong>跟<strong>地址总线的个数</strong>是密切相关的，早期的 x86 物理机，虽然<mark>寄存器</mark>是 16 位，但是<mark>地址总线</mark>却有 20 根，根据计算 2^20 = 1M，寻址空间肯定得有 1M 啊，但是寄存器只有 16 位，即 2^16，没有这么大的空间啊，臣妾办不到啊～ 那怎么办呢？聪明的 intel 工程师（挖坑师）想到了一个办法，即段寄存器左移 4 位，然后加上另外一个通用寄存器的值就可以组合出这个 20 位了，即 2^16 * 2^4 + 2*16，哦嚯一下子组装出来了。 这样 20 根地址总线都用上了，得到了 1M 的寻址空间，可把工程师给乐坏了。<strong>但是，后面的事情大家都知道了</strong>，16 位不够了，32 位也不够了，在 64 位的情况下，完全不用考虑地址空间的大小问题了，变成了内存不够的问题了，而这个时候，保护模式下的虚拟地址映射又完美解决了这个问题（虚拟地址后面有），哟嚯，又把 intel 的这群挖坑师给乐坏了。</p><p>稍微总结一下：<br><mark>1、x86 CPU的位数越来越高，从16到32到64，每次进步都尽量的去<strong>兼容</strong>了之前的CPU架构，所以：</mark><br> ---A、（寻址能力）<br> 16位时寻址能力不足，所以要借助额外的寄存器进行1M空间的寻址；<br> 32位时，每个程序都有自己独立的4G寻址空间，操作系统用低位的1G-2G，其余留给用户程序；<br> 64位后，暂时就遇不到寻址能力不足的事情了；<br> ---B、前一代的寄存器尽量保留，不够用就扩展新的<br> ---C、寄存器的长度升级后，其低位可以兼容上一代的寄存器<br><mark>2、CPU同时在安全性上也要提升，</mark><br> 从只有实模式【可以随意执行全部CPU指令，内存可以直接通过物理地址访问，随意访问随意读写】，<br> 到了32的保护模式【将指令划分为ring0到ring3，CPU指令不是你想调用就能调用；内存不是你想访问就能访问，首先CPU要允许，而且操作系统允许】，<br> 而64的长模式在安全方面与32并没有本至区别；<br><mark>3、从实模式到保护模式，访问内存时，需要访问的地址变大了，需要控制的内容变多了，于是引入了<strong>段描述符</strong>，</mark><br> 所有的段描述符组成了<strong>描述符表</strong>，包括唯一的<strong>全局描述符<code>GDT</code><strong>和多个</strong>局部描述符号<code>LDT</code></strong>。<br> 1）GDT是操作系统特供，要重点关注。<br> 2）CPU寻址的时候，要通过段寄存器+GDTR寄存器定位到的内存中的描述符，判断是否允许访问。然后，再根据段描述符中地址进行访问。<br><mark>4、同时内存中内存管理有段、页、段页三种常用模式。</mark><br> 一般在应用层，程序员感受不太到，操作系统全给咱们做完了。<br> ==5、中断，其实是通过<strong>硬件</strong>或<strong>软件</strong>方式告诉CPU，来执行一段特殊的代码。==比如咱们键盘输入，就是通过硬件中断的方式，告知操作系统的。<br><strong>在实模式下</strong>，中断是直接执行的。<strong>但到了保护模式和长模式下</strong>，就要特权级别校验通过才能执行，所以引入了<strong>中断门</strong>进行控制。<br> 在ring3调用中断一般是要<strong>通过操作系统</strong>切换到内核态ring0进行的，与内存类似，要通过中断向量表，确认中断门中权限是否允许，然后定位到指定代码执行。<br><mark>6、BIOS引导后，系统直接进入最简单、特权最大的实模式；而后告知CPU，切换到保护模式，并运行在ring0。</mark><br> 后续的用户进程，一般就在ring3，想执行特权指令要通过操作系统来执行。</p><hr><p>建議大家讀讀李忠老師的《穿越計算機的迷霧》，學習一點硬件原理，對後續學習會有很大幫助。很薄的小冊子，三兩天就能讀完。</p><hr><p>看到后面，回头再看一遍，记点笔记。<br> 实模式，保护模式，长模式，逐渐演进<br><mark>1、实模式：</mark><br> (1)代码段地址+左移4位+ IP = 取指<br> 数据段+左移4位+ 通用寄存器值 = 数据地址<br> 栈段SS+左移4位 + SP = 栈地址<br> (2)实模式中断：<br> 中断号+ IDTR 寄存器(指向中断表的地址和长度) ---&gt; 根据中断号，找到中断表中的对应条目 ---&gt; 解析出中断函数基地址填充CS、中断函数偏移填充IP ---&gt; 响应中断。<br><mark>2、保护模式：</mark><br> (1)保护模式寄存器：通用寄存器，IP，SP 16位-&gt;32位。添加了EFLAGS cpu标志寄存器和几个cpu控制寄存器。 CS DS SS 中改为存放内存段的索引，用于寻找内存中的段描述符。<br> (2)保护模式下，R0 -- R3的特权级别访问。通过内存中存放64位段描述符实现特权划分，段地址寻址。<br> CS | DS | SS （段描述符索引）+ GDTR（指向全局段描述符表基地址） -- &gt; 找到段描述符 --&gt; 解析代码段还是数据段，地址，访问权限<br> 其中影子寄存器 : 通过硬件实现，是段描述符的高速缓存, 防止反复读内存，提高效率。<br> 权限问题：当前执行程序的CS RPL、SS RPL = CPL, 要访问的段描述符中拿到DPL， CPL &gt; DPL 禁止程序访问目标段， CPL &lt;= DPL , 可以访问<br> (3)保护模式的平坦模型: 段基址为0，段长度为4G的<strong>特殊段管理模式，规避历史原因导致的分段模型缺陷</strong>。<br> (4)保护模式中断:中断号+ IDTR 寄存器(指向中断表) ---&gt; 根据中断号，找到中断表指向的内存中的中断门描述符 ---&gt; 中断门和中断描述符中段选择子的权限检查--&gt; 中断门描述符中目标代码段选择子填充CS， 目标代码段偏移填充EIP ---&gt; 响应中断。<br> 权限问题：当前CPL小于等于中断门DPL，才可进中断门，当前CPL，大于段选择子的DPL，则设置CPL=段选择子DPL。<br> 例：当前运行代码CPL=R3级别，遇R3中断门进门，执行特权级中断程序R0，此时CRL=R0。<br> (5) 切换保护模式： 准备全局描述附表GDT，<br> GDTR指向GDT，<br> 设置CR0开启保护模式，<br> 执行长跳转,CPU根据8索引值索引GDT中第二条数据，加载CS<br><mark>3、长模式：</mark><br> （1）寄存器扩展到64位<br> （2）长模式段描述符, L=1，D/B=0 时是64 位代码段， L ， D/B, 无效是数据段<br> （3）长模式中断：中断们描述符比保护模式多了8字节64位，用于存放64位的目标代码段偏移多出来的高32位。<br> 其他中断过程同保护模式。<br> （4）长模式切换：准备长模式全局段描述符表,<br> 准备长模式下的MMU页表,开启<strong>分页模式</strong><br> CR3指向<strong>页表</strong>物理地址<br> GDTR指向<strong>全局段描述符表</strong><br> IA32_EFER寄存器第8位开启长模式，CR0寄存器= 0x31开启<strong>保护模式</strong>和<strong>分页模式</strong><br> 进行跳转，索引GDT， 加载 CS 段寄存器，刷新其影子寄存器</p><blockquote><p>（5）<strong><mark>长模式</mark>弱化段模式管理</strong>，只保留了权限级别的检查，忽略了段基址和段长度，而地址的检查则交给了 MMU，分页管理。</p></blockquote><hr><p>实模式下能寻址多大内存空间？ 答案是可能是4G，也可能是1M. 为什么呢，老师也讲过段寄存器的影子寄存器，实模式下你要看你的影子寄存器里面的base 和 limit。 目前主流的CPU 开机是实模式，但是他执行的地址是在FFFF FFF0 处,远超实模式下的1M. 这是因为reset的时候CS base 是0xFFFF0000 IP是0xFFF0. limit 是0xFFFF. 所以也可以实验一下，如何在实模式下访问1M以上地址空间。BIOS在intel 平台上都叫UEFI 了。支持64bit都快20年了，而且跳到OS，可以参考boot protocol， 目前主流像linux 直接进入EFI_STUB64 入口了。希望老师普及一下这些知识，以目前intel平台，uefi直接64bit flat跳入到内核，内核也直接工作在64bit了，况且intel 不是也宣布2020年之后不支持legacy bios。<br> 作者回复: 是的，你说的对，UEFI 是非常先进的设计。</p>`,177),C=[P];function k(D,S){return e(),a("div",null,C)}const x=s(h,[["render",k],["__file","C05-CPU工作模式.html.vue"]]);export{x as default};
