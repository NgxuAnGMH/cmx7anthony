import{_ as s}from"./plugin-vue_export-helper-c27b6911.js";import{o as n,c as a,d as e}from"./app-cdabc73c.js";const t="/assets/aec865abccf0308155f4138cc905972e-e8e71109.jpg",p="/assets/770b0036a8b2695463cd95869f5adec0-6a061740.jpg",c="/assets/31d15bcd2a053235b5590977d12ffa2d-c3dc4b80.jpeg",o="/assets/82ba663aad4f6bd946d48424196e515c-f43f7ced.jpeg",i={},l=e(`<h1 id="_14-进程数据结构-下-项目多了就需要项目管理系统" tabindex="-1"><a class="header-anchor" href="#_14-进程数据结构-下-项目多了就需要项目管理系统" aria-hidden="true">#</a> 14 | 进程数据结构（下）：项目多了就需要项目管理系统</h1><p>上两节，我们解读了 task_struct 的大部分的成员变量。这样一个任务执行的方方面面，都可以很好地管理起来，但是其中有一个问题我们没有谈。在程序执行过程中，<code>一旦调用到系统调用，就需要进入内核继续执行</code>。那如何将用户态的执行和内核态的执行串起来呢？</p><h2 id="关键的成员变量-stack-thread-info" tabindex="-1"><a class="header-anchor" href="#关键的成员变量-stack-thread-info" aria-hidden="true">#</a> 关键的成员变量 stack -&gt; thread_info</h2><p>这就需要以下两个重要的成员变量：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">thread_info</span>    thread_info<span class="token punctuation">;</span>
<span class="token keyword">void</span>  <span class="token operator">*</span>stack<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="用户态函数栈" tabindex="-1"><a class="header-anchor" href="#用户态函数栈" aria-hidden="true">#</a> 用户态函数栈</h2><p>在用户态中，程序的执行往往是一个函数调用另一个函数。函数调用都是通过栈来进行的。我们前面大致讲过函数栈的原理，今天我们仔细分析一下。</p><p>函数调用其实也很简单。如果你去看汇编语言的代码，其实就是指令跳转，从代码的一个地方跳到另外一个地方。这里比较棘手的问题是，参数和返回地址应该怎么传递过去呢？</p><p>我们看函数的调用过程，A 调用 B、调用 C、调用 D，然后返回 C、返回 B、返回 A，这是一个后进先出的过程。有没有觉得这个过程很熟悉？没错，咱们数据结构里学的栈，也是后进先出的，所以用栈保存这些最合适。</p><p>在进程的内存空间里面，栈是一个从高地址到低地址，往下增长的结构，也就是上面是栈底，下面是栈顶，入栈和出栈的操作都是从下面的栈顶开始的。</p><img src="`+t+'" alt="img" style="zoom:25%;"><h3 id="_32-位" tabindex="-1"><a class="header-anchor" href="#_32-位" aria-hidden="true">#</a> 32 位</h3><p>我们先来看 32 位操作系统的情况。在 CPU 里，<strong>ESP</strong>（Extended Stack Pointer）是栈顶指针寄存器，入栈操作 Push 和出栈操作 Pop 指令，会自动调整 ESP 的值。另外有一个寄存器 <strong>EBP</strong>（Extended Base Pointer），是栈基地址指针寄存器，指向当前栈帧的最底部。</p><p>例如，A 调用 B，A 的栈里面包含 A 函数的局部变量，然后是调用 B 的时候要传给它的参数，然后返回 A 的地址，这个地址也应该入栈，这就形成了 A 的栈帧。接下来就是 B 的栈帧部分了，先保存的是 A 栈帧的栈底位置，也就是 EBP。因为在 B 函数里面获取 A 传进来的参数，就是通过这个指针获取的，接下来保存的是 B 的局部变量等等。</p><p>当 B 返回的时候，返回值会保存在 EAX 寄存器中，从栈中弹出返回地址，将指令跳转回去，参数也从栈中弹出，然后继续执行 A。</p><h3 id="_64-位" tabindex="-1"><a class="header-anchor" href="#_64-位" aria-hidden="true">#</a> 64 位</h3><p>对于 64 位操作系统，模式多少有些不一样。因为 64 位操作系统的寄存器数目比较多。rax 用于保存函数调用的返回结果。栈顶指针寄存器变成了 rsp，指向栈顶位置。堆栈的 Pop 和 Push 操作会自动调整 rsp，栈基指针寄存器变成了 rbp，指向当前栈帧的起始位置。</p><p>改变比较多的是参数传递。rdi、rsi、rdx、rcx、r8、r9 这 6 个寄存器，用于传递存储函数调用时的 6 个参数。如果超过 6 的时候，还是需要放到栈里面。</p><p>然而，前 6 个参数有时候需要进行寻址，但是如果在寄存器里面，是没有地址的，因而还是会放到栈里面，只不过放到栈里面的操作是被调用函数做的。</p><img src="'+p+`" alt="img" style="zoom:25%;"><blockquote><p>以上的栈操作，都是在<code>进程的内存空间 VAS</code>里面进行的。</p></blockquote><h2 id="内核态函数栈" tabindex="-1"><a class="header-anchor" href="#内核态函数栈" aria-hidden="true">#</a> 内核态函数栈</h2><p>接下来，我们通过系统调用，从进程的内存空间到内核中了。内核中也有各种各样的函数调用来调用去的，也需要这样一个机制，这该怎么办呢？</p><p>这时候，上面的<code>成员变量 stack</code>，也就是内核栈，就派上了用场。</p><p>Linux 给每个 task 都分配了内核栈。在 32 位系统上 arch/x86/include/asm/page_32_types.h，是这样定义的：一个 PAGE_SIZE 是 4K，左移一位就是乘以 2，也就是 8K。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">THREAD_SIZE_ORDER</span>  <span class="token expression"><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">THREAD_SIZE</span>    <span class="token expression"><span class="token punctuation">(</span>PAGE_SIZE <span class="token operator">&lt;&lt;</span> THREAD_SIZE_ORDER<span class="token punctuation">)</span></span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>内核栈在 64 位系统上 arch/x86/include/asm/page_64_types.h，是这样定义的：在 PAGE_SIZE 的基础上左移两位，也即 16K，并且要求起始地址必须是 8192 的整数倍。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_KASAN</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">KASAN_STACK_ORDER</span> <span class="token expression"><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">KASAN_STACK_ORDER</span> <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>


<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">THREAD_SIZE_ORDER</span>  <span class="token expression"><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">+</span> KASAN_STACK_ORDER<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">THREAD_SIZE</span>  <span class="token expression"><span class="token punctuation">(</span>PAGE_SIZE <span class="token operator">&lt;&lt;</span> THREAD_SIZE_ORDER<span class="token punctuation">)</span></span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>内核栈是一个非常特殊的结构，如下图所示：</p><img src="`+c+`" alt="img" style="zoom:25%;"><h3 id="task-struct-通用-thread-info-cpu架构" tabindex="-1"><a class="header-anchor" href="#task-struct-通用-thread-info-cpu架构" aria-hidden="true">#</a> task_struct 通用 / thread_info CPU架构</h3><p>这段空间的最低位置，是一个 <code>thread_info 结构</code>。这个结构是对 task_struct 结构的补充。</p><p>因为 task_struct 结构庞大但是通用，不同的体系结构就需要保存不同的东西，所以往往与体系结构有关的，都放在 thread_info 里面。</p><h3 id="stack-thread-info" tabindex="-1"><a class="header-anchor" href="#stack-thread-info" aria-hidden="true">#</a> stack -&gt; thread_info</h3><p>在内核代码里面有这样一个 union，将 thread_info 和 stack 放在一起，在 include/linux/sched.h 文件中就有。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">union</span> thread_union <span class="token punctuation">{</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">CONFIG_THREAD_INFO_IN_TASK</span></span>
  <span class="token keyword">struct</span> <span class="token class-name">thread_info</span> thread_info<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> stack<span class="token punctuation">[</span>THREAD_SIZE<span class="token operator">/</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个 union 就是这样定义的，开头是 thread_info，后面是 stack。</p><h3 id="pt-regs" tabindex="-1"><a class="header-anchor" href="#pt-regs" aria-hidden="true">#</a> pt_regs</h3><p>在内核栈的最高地址端，存放的是另一个结构 pt_regs，定义如下。其中，32 位和 64 位的定义不一样。</p><p>看到这个是不是很熟悉？咱们在讲系统调用的时候，已经多次见过这个结构。<code>当系统调用从用户态到内核态的时候</code>，首先要做的第一件事情，就是将用户态运行过程中的 CPU 上下文保存起来，其实主要就是保存在这个结构的寄存器变量里。<code>这样当从内核系统调用返回的时候</code>，才能让进程在刚才的地方接着运行下去。</p><p>如果我们对比系统调用那一节的内容，<code>你会发现系统调用的时候</code>，<mark>压栈的值的顺序</mark>和 <mark>struct pt_regs 中寄存器定义的顺序</mark>是一样的。</p><p>在内核中，CPU 的寄存器 ESP 或者 RSP，已经指向内核栈的栈顶，在<code>内核态里的调用</code>都有和<code>用户态</code>相似的过程。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__i386__</span></span>
<span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token punctuation">{</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> bx<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> cx<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> dx<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> si<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> di<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> bp<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ax<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ds<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> es<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> fs<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> gs<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> orig_ax<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ip<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> cs<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> sp<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ss<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span> </span>
<span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token punctuation">{</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> r15<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> r14<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> r13<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> r12<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> bp<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> bx<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> r11<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> r10<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> r9<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> r8<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ax<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> cx<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> dx<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> si<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> di<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> orig_ax<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ip<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> cs<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> sp<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ss<span class="token punctuation">;</span>
<span class="token comment">/* top of stack page */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> </span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="通过-task-struct-找内核栈" tabindex="-1"><a class="header-anchor" href="#通过-task-struct-找内核栈" aria-hidden="true">#</a> 通过 task_struct 找内核栈</h2><h3 id="task-struct-stack-内核栈" tabindex="-1"><a class="header-anchor" href="#task-struct-stack-内核栈" aria-hidden="true">#</a> task_struct -&gt; stack 内核栈</h3><p>如果有一个 task_struct 的 stack 指针在手，你可以通过下面的函数找到这个线程内核栈：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">task_stack_page</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>task<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">return</span> task<span class="token operator">-&gt;</span>stack<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="task-struct-pt-regs-内核寄存器" tabindex="-1"><a class="header-anchor" href="#task-struct-pt-regs-内核寄存器" aria-hidden="true">#</a> task_struct -&gt; pt_regs 内核寄存器</h3><p>从 task_struct 如何得到相应的 pt_regs 呢？我们可以通过下面的函数：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/*
 * TOP_OF_KERNEL_STACK_PADDING reserves 8 bytes on top of the ring0 stack.
 * This is necessary to guarantee that the entire &quot;struct pt_regs&quot;
 * is accessible even if the CPU haven&#39;t stored the SS/ESP registers
 * on the stack (interrupt gate does not save these registers
 * when switching to the same priv ring).
 * Therefore beware: accessing the ss/esp fields of the
 * &quot;struct pt_regs&quot; is possible, but they may contain the
 * completely wrong values.
 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">task_pt_regs</span><span class="token expression"><span class="token punctuation">(</span>task<span class="token punctuation">)</span> </span><span class="token punctuation">\\</span>
<span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">{</span>                  </span><span class="token punctuation">\\</span>
  <span class="token expression"><span class="token keyword">unsigned</span> <span class="token keyword">long</span> __ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token function">task_stack_page</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>  </span><span class="token punctuation">\\</span>
  <span class="token expression">__ptr <span class="token operator">+=</span> THREAD_SIZE <span class="token operator">-</span> TOP_OF_KERNEL_STACK_PADDING<span class="token punctuation">;</span>    </span><span class="token punctuation">\\</span>
  <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token operator">*</span><span class="token punctuation">)</span>__ptr<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>          </span><span class="token punctuation">\\</span>
<span class="token expression"><span class="token punctuation">}</span><span class="token punctuation">)</span></span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="更细节的过程" tabindex="-1"><a class="header-anchor" href="#更细节的过程" aria-hidden="true">#</a> ## 更细节的过程</h3><p>你会发现，这是先从 task_struct 找到内核栈的开始位置。然后这个位置加上 THREAD_SIZE 就到了最后的位置，然后转换为 struct pt_regs，再减一，就相当于减少了一个 pt_regs 的位置，就到了这个结构的首地址。</p><p>这里面有一个 TOP_OF_KERNEL_STACK_PADDING，这个的定义如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_X86_32</span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_VM86</span></span>
<span class="token macro property"><span class="token directive-hash">#</span>  <span class="token directive keyword">define</span> <span class="token macro-name">TOP_OF_KERNEL_STACK_PADDING</span> <span class="token expression"><span class="token number">16</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">else</span></span>
<span class="token macro property"><span class="token directive-hash">#</span>  <span class="token directive keyword">define</span> <span class="token macro-name">TOP_OF_KERNEL_STACK_PADDING</span> <span class="token expression"><span class="token number">8</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">define</span> <span class="token macro-name">TOP_OF_KERNEL_STACK_PADDING</span> <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也就是说，32 位机器上是 8，其他是 0。这是为什么呢？因为压栈 pt_regs 有两种情况。我们知道，CPU 用 ring 来区分权限，从而 Linux 可以区分内核态和用户态。</p><p>因此，第一种情况，我们拿涉及从用户态到内核态的变化的系统调用来说。因为涉及权限的改变，会压栈保存 SS、ESP 寄存器的，这两个寄存器共占用 8 个 byte。</p><p>另一种情况是，不涉及权限的变化，就不会压栈这 8 个 byte。这样就会使得两种情况不兼容。如果没有压栈还访问，就会报错，所以还不如预留在这里，保证安全。在 64 位上，修改了这个问题，变成了定长的。</p><p>好了，现在如果你 task_struct 在手，就能够轻松得到<code>内核栈</code>和<code>内核寄存器</code>。</p><h2 id="通过内核栈找-task-struct" tabindex="-1"><a class="header-anchor" href="#通过内核栈找-task-struct" aria-hidden="true">#</a> 通过内核栈找 task_struct</h2><p>那如果一个当前在某个 CPU 上执行的进程，想知道自己的 task_struct 在哪里，又该怎么办呢？</p><h3 id="thread-info-task-struct" tabindex="-1"><a class="header-anchor" href="#thread-info-task-struct" aria-hidden="true">#</a> thread_info -&gt; task_struct</h3><p>这个艰巨的任务要交给 thread_info 这个结构。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">thread_info</span> <span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">task_struct</span>  <span class="token operator">*</span>task<span class="token punctuation">;</span>    <span class="token comment">/* main task structure */</span>
  __u32      flags<span class="token punctuation">;</span>    <span class="token comment">/* low level flags */</span>
  __u32      status<span class="token punctuation">;</span>    <span class="token comment">/* thread synchronous flags */</span>
  __u32      cpu<span class="token punctuation">;</span>    <span class="token comment">/* current CPU */</span>
  <span class="token class-name">mm_segment_t</span>    addr_limit<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span>    sig_on_uaccess_error<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span>    uaccess_err<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">/* uaccess failed */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里面有个成员变量 task 指向 task_struct，所以我们常用 current_thread_info()-&gt;task 来获取 task_struct。</p><h3 id="更细节的过程-1" tabindex="-1"><a class="header-anchor" href="#更细节的过程-1" aria-hidden="true">#</a> ## 更细节的过程</h3><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">struct</span> <span class="token class-name">thread_info</span> <span class="token operator">*</span><span class="token function">current_thread_info</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">thread_info</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">current_top_of_stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> THREAD_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而 thread_info 的位置就是内核栈的最高位置，减去 THREAD_SIZE，就到了 thread_info 的起始地址。</p><p>但是现在变成这样了，只剩下一个 flags。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">thread_info</span> <span class="token punctuation">{</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span>           flags<span class="token punctuation">;</span>          <span class="token comment">/* low level flags */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那这时候怎么获取当前运行中的 task_struct 呢？current_thread_info 有了新的实现方式。</p><p>在 include/linux/thread_info.h 中定义了 current_thread_info。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;asm/current.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">current_thread_info</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">thread_info</span> <span class="token operator">*</span><span class="token punctuation">)</span>current<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那 current 又是什么呢？在 arch/x86/include/asm/current.h 中定义了。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token punctuation">;</span>


<span class="token function">DECLARE_PER_CPU</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token punctuation">,</span> current_task<span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token keyword">static</span> __always_inline <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token function">get_current</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">this_cpu_read_stable</span><span class="token punctuation">(</span>current_task<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">current</span> <span class="token expression">get_current</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="per-cpu-变量-task-struct" tabindex="-1"><a class="header-anchor" href="#per-cpu-变量-task-struct" aria-hidden="true">#</a> Per CPU 变量 -&gt; task_struct</h3><p>到这里，你会发现，新的机制里面，每个 CPU 运行的 task_struct 不通过 thread_info 获取了，而是直接放在 Per CPU 变量里面了。</p><p>多核情况下，CPU 是同时运行的，但是它们共同使用其他的硬件资源的时候，我们需要解决多个 CPU 之间的同步问题。</p><p><code>Per CPU 变量</code>是内核中一种重要的<code>同步机制</code>。</p><p>顾名思义，Per CPU 变量就是为每个 CPU 构造一个变量的副本，这样多个 CPU 各自操作自己的副本，互不干涉。</p><p>比如，当前进程的变量 current_task 就被声明为 Per CPU 变量。</p><h3 id="更细节的过程-2" tabindex="-1"><a class="header-anchor" href="#更细节的过程-2" aria-hidden="true">#</a> ## 更细节的过程</h3><p>要使用 Per CPU 变量，首先要声明这个变量，在 arch/x86/include/asm/current.h 中有：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token function">DECLARE_PER_CPU</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token punctuation">,</span> current_task<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后是定义这个变量，在 arch/x86/kernel/cpu/common.c 中有：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token function">DEFINE_PER_CPU</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token punctuation">,</span> current_task<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>init_task<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>也就是说，系统刚刚初始化的时候，current_task 都指向 init_task。</p><p>当某个 CPU 上的进程进行切换的时候，current_task 被修改为将要切换到的目标进程。例如，进程切换函数 __switch_to 就会改变 current_task。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>__visible __notrace_funcgraph <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>
<span class="token function">__switch_to</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev_p<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>next_p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token function">this_cpu_write</span><span class="token punctuation">(</span>current_task<span class="token punctuation">,</span> next_p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">return</span> prev_p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当要获取当前的运行中的 task_struct 的时候，就需要调用 this_cpu_read_stable 进行读取。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">this_cpu_read_stable</span><span class="token expression"><span class="token punctuation">(</span>var<span class="token punctuation">)</span>       <span class="token function">percpu_stable_op</span><span class="token punctuation">(</span></span><span class="token string">&quot;mov&quot;</span><span class="token expression"><span class="token punctuation">,</span> var<span class="token punctuation">)</span></span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>好了，现在如果你是一个进程，正在某个 CPU 上运行，就能够轻松得到 task_struct 了。</p></blockquote><h2 id="总结时刻" tabindex="-1"><a class="header-anchor" href="#总结时刻" aria-hidden="true">#</a> 总结时刻</h2><p>这一节虽然只介绍了内核栈，但是内容更加重要。</p><ul><li>如果说 <mark>task_struct 的其他成员变量</mark>都是和<code>进程管理</code>有关的，</li><li><mark>内核栈</mark>是和<code>进程运行</code>有关系的。</li></ul><p>我这里画了一张图总结一下 32 位和 64 位的工作模式，左边是 32 位的，右边是 64 位的。</p><ul><li><p>在用户态，应用程序进行了至少一次函数调用。32 位和 64 的传递参数的方式稍有不同，</p><ul><li>32 位的就是用<code>函数栈</code>，</li><li>64 位的前 6 个参数用<code>寄存器</code>，其他的用<code>函数栈</code>。</li></ul></li><li><p>在内核态，32 位和 64 位都使用内核栈，格式也稍有不同，主要集中在 <code>pt_regs 结构</code>上。</p></li><li><p>在内核态，32 位和 64 位的内核栈和 task_struct 的关联关系不同。</p><ul><li>32 位主要靠 <code>thread_info</code>，</li><li>64 位主要靠 <code>Per-CPU 变量</code>。</li></ul></li></ul><figure><img src="`+o+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><blockquote><ul><li>用户态/内核态切换执行如何串起来</li><li>用户态函数栈; 通过 JMP + 参数 + 返回地址 调用函数</li><li>栈内存空间从高到低增长 <ul><li>32位栈结构: 栈帧包含 前一个帧的 EBP + 局部变量 + N个参数 + 返回地址</li><li>ESP: 栈顶指针; EBP: 栈基址(栈帧最底部, 局部变量起始) <ul><li>返回值保存在 EAX 中</li></ul></li><li>64位栈结构: 结构类似</li><li>rax 保存返回结果; rsp 栈顶指针; rbp 栈基指针 <ul><li>参数传递时, 前 6个放寄存器中(再由被调用函数 push 进自己的栈, 用以寻址), 参数超过 6个压入栈中</li></ul></li></ul></li><li>内核栈结构:</li><li>Linux 为每个 task 分配了内核栈, 32位(8K), 64位(16K) <ul><li>栈结构: [预留8字节 +] pt_regs + 内核栈 + 头部 thread_info</li><li>thread_info 是 task_struct 的补充, 存储于体系结构有关的内容</li><li>pt_regs 用以保存用户运行上下文, 通过 push 寄存器到栈中保存</li><li>通过 task_struct 找到内核栈</li><li>直接由 task_struct 内的 stack 直接得到指向 thread_info 的指针</li><li>通过内核栈找到 task_struct</li><li>32位 直接由 thread_info 中的指针得到 <ul><li>64位 每个 CPU 当前运行进程的 task_struct 的指针存放到 Per CPU 变量 current_task 中; 可调用 this_cpu_read_stable 进行读取</li></ul></li></ul></li></ul></blockquote><h2 id="课堂练习" tabindex="-1"><a class="header-anchor" href="#课堂练习" aria-hidden="true">#</a> 课堂练习</h2><p>这一节讲函数调用的时候，我们讲了函数栈的工作模式。请你写一个程序，然后编译为汇编语言，打开看一下，函数栈是如何起作用的。</p><p>欢迎留言和我分享你的疑惑和见解，也欢迎你收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习、进步。</p><h2 id="课后讨论" tabindex="-1"><a class="header-anchor" href="#课后讨论" aria-hidden="true">#</a> 课后讨论</h2><p>看这篇内容时，查了几篇资料。在汇编代码中，函数调用的参数传递是通过把参数依次放在靠近调用者的栈的顶部来实现的。调用者获取参数时，只要相对于当前帧指针的向上偏移即可取到参数。即取调用者函数参数时执行movl 8(%ebp), %edx。<br> 作者回复: 赞，推荐这种查资料的方式，这样学到的东西就多多了</p><p>有个疑问，两个进程切换时，用户栈的上下文保存在哪？<br> 作者回复: 后面讲切换的时候会讲，用户栈相关寄存器在pt_regs中，用户栈的内存在虚拟地址空间，不会冲突</p><p>为什么用户态的栈不需要 task_struct 维护一个类似 *stack 的指针呢？<br> 作者回复: mm里面有的</p><p>看懂这章，需要知道进程的内存分布图？</p><p>内核栈的最高地址的那8个字节没看懂，如果没压入ss,sp，那为什么还要访问呢？从源码注释看，加了8个字节保留，如果没有压入ss,sp,这时候访问也是没有意义的，既然没有意义，程序为什么还要访问他啊？一个在程序中不能控制吗？<br> 作者回复: 不会访问，但是访问到是错的，也比越界好。这样统一处理会方便很多。当然一路if else也是可以的</p>',107),r=[l];function d(u,k){return n(),a("div",null,r)}const h=s(i,[["render",d],["__file","H14-进程数据结构（下）.html.vue"]]);export{h as default};
