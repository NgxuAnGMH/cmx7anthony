import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o,c as l,a as n,b as s,e as c,d as a}from"./app-cdabc73c.js";const i="/assets/78c8d44d7d8c08c03eee6f7a94652d6d-e38188b6.png",u="/assets/274e22b3f5196a4c68bb6813fb643f9a-bcd09251.png",d={},r=a(`<h1 id="_26-内核态内存映射-如何找到正确的会议室" tabindex="-1"><a class="header-anchor" href="#_26-内核态内存映射-如何找到正确的会议室" aria-hidden="true">#</a> 26 | 内核态内存映射：如何找到正确的会议室？</h1><p>前面讲用户态内存映射机制的时候，我们已经多次引申出了内核的映射机制，但是咱们都暂时放了放，这一节我们就来详细解析一下，让你彻底搞懂它。</p><p>首先，你要知道，内核态的内存映射机制，主要包含以下几个部分：</p><ul><li>内核态内存映射函数 vmalloc、kmap_atomic 是如何工作的；</li><li>内核态页表是放在哪里的，如何工作的？swapper_pg_dir 是怎么回事；</li><li>出现了内核态缺页异常应该怎么办？</li></ul><h2 id="内核页表" tabindex="-1"><a class="header-anchor" href="#内核页表" aria-hidden="true">#</a> 内核页表</h2><p>和用户态页表不同，在系统初始化的时候，我们就要创建内核页表了。</p><p>我们从内核页表的根 <code>swapper_pg_dir</code> 开始找线索，在 arch/x86/include/asm/pgtable_64.h 中就能找到它的定义。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">extern</span> <span class="token class-name">pud_t</span> level3_kernel_pgt<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">extern</span> <span class="token class-name">pud_t</span> level3_ident_pgt<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">extern</span> <span class="token class-name">pmd_t</span> level2_kernel_pgt<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">extern</span> <span class="token class-name">pmd_t</span> level2_fixmap_pgt<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">extern</span> <span class="token class-name">pmd_t</span> level2_ident_pgt<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">extern</span> <span class="token class-name">pte_t</span> level1_fixmap_pgt<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">extern</span> <span class="token class-name">pgd_t</span> init_top_pgt<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>


<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">swapper_pg_dir</span> <span class="token expression">init_top_pgt</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>swapper_pg_dir 指向内核最顶级的目录 pgd，同时出现的还有几个页表目录。我们可以回忆一下，64 位系统的虚拟地址空间的布局，其中 XXX_ident_pgt 对应的是直接映射区，XXX_kernel_pgt 对应的是内核代码区，XXX_fixmap_pgt 对应的是固定映射区。</p><p>它们是在哪里初始化的呢？在汇编语言的文件里面的 arch\\x86\\kernel\\head_64.S。这段代码比较难看懂，你只要明白它是干什么的就行了。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>__INITDATA


<span class="token function">NEXT_PAGE</span><span class="token punctuation">(</span>init_top_pgt<span class="token punctuation">)</span>
  <span class="token punctuation">.</span>quad   level3_ident_pgt <span class="token operator">-</span> __START_KERNEL_map <span class="token operator">+</span> _KERNPG_TABLE
  <span class="token punctuation">.</span>org    init_top_pgt <span class="token operator">+</span> PGD_PAGE_OFFSET<span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">0</span>
  <span class="token punctuation">.</span>quad   level3_ident_pgt <span class="token operator">-</span> __START_KERNEL_map <span class="token operator">+</span> _KERNPG_TABLE
  <span class="token punctuation">.</span>org    init_top_pgt <span class="token operator">+</span> PGD_START_KERNEL<span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">0</span>
  <span class="token comment">/* (2^48-(2*1024*1024*1024))/(2^39) = 511 */</span>
  <span class="token punctuation">.</span>quad   level3_kernel_pgt <span class="token operator">-</span> __START_KERNEL_map <span class="token operator">+</span> _PAGE_TABLE


<span class="token function">NEXT_PAGE</span><span class="token punctuation">(</span>level3_ident_pgt<span class="token punctuation">)</span>
  <span class="token punctuation">.</span>quad  level2_ident_pgt <span class="token operator">-</span> __START_KERNEL_map <span class="token operator">+</span> _KERNPG_TABLE
  <span class="token punctuation">.</span>fill  <span class="token number">511</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">0</span>
<span class="token function">NEXT_PAGE</span><span class="token punctuation">(</span>level2_ident_pgt<span class="token punctuation">)</span>
  <span class="token comment">/* Since I easily can, map the first 1G.
   * Don&#39;t set NX because code runs from these pages.
   */</span>
  <span class="token function">PMDS</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> __PAGE_KERNEL_IDENT_LARGE_EXEC<span class="token punctuation">,</span> PTRS_PER_PMD<span class="token punctuation">)</span>


<span class="token function">NEXT_PAGE</span><span class="token punctuation">(</span>level3_kernel_pgt<span class="token punctuation">)</span>
  <span class="token punctuation">.</span>fill  L3_START_KERNEL<span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">0</span>
  <span class="token comment">/* (2^48-(2*1024*1024*1024)-((2^39)*511))/(2^30) = 510 */</span>
  <span class="token punctuation">.</span>quad  level2_kernel_pgt <span class="token operator">-</span> __START_KERNEL_map <span class="token operator">+</span> _KERNPG_TABLE
  <span class="token punctuation">.</span>quad  level2_fixmap_pgt <span class="token operator">-</span> __START_KERNEL_map <span class="token operator">+</span> _PAGE_TABLE


<span class="token function">NEXT_PAGE</span><span class="token punctuation">(</span>level2_kernel_pgt<span class="token punctuation">)</span>
  <span class="token comment">/*
   * 512 MB kernel mapping. We spend a full page on this pagetable
   * anyway.
   *
   * The kernel code+data+bss must not be bigger than that.
   *
   * (NOTE: at +512MB starts the module area, see MODULES_VADDR.
   *  If you want to increase this then increase MODULES_VADDR
   *  too.)
   */</span>
  <span class="token function">PMDS</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> __PAGE_KERNEL_LARGE_EXEC<span class="token punctuation">,</span>
    KERNEL_IMAGE_SIZE<span class="token operator">/</span>PMD_SIZE<span class="token punctuation">)</span>


<span class="token function">NEXT_PAGE</span><span class="token punctuation">(</span>level2_fixmap_pgt<span class="token punctuation">)</span>
  <span class="token punctuation">.</span>fill  <span class="token number">506</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">0</span>
  <span class="token punctuation">.</span>quad  level1_fixmap_pgt <span class="token operator">-</span> __START_KERNEL_map <span class="token operator">+</span> _PAGE_TABLE
  <span class="token comment">/* 8MB reserved for vsyscalls + a 2MB hole = 4 + 1 entries */</span>
  <span class="token punctuation">.</span>fill  <span class="token number">5</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">0</span>


<span class="token function">NEXT_PAGE</span><span class="token punctuation">(</span>level1_fixmap_pgt<span class="token punctuation">)</span>
  <span class="token punctuation">.</span>fill  <span class="token number">51</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>内核页表的顶级目录 init_top_pgt，定义在 __INITDATA 里面。咱们讲过 ELF 的格式，也讲过虚拟内存空间的布局。它们都有代码段，还有一些初始化了的全局变量，放在.init 区域。这些说的就是这个区域。可以看到，页表的根其实是全局变量，这就使得我们初始化的时候，甚至内存管理还没有初始化的时候，很容易就可以定位到。</p><p>接下来，定义 init_top_pgt 包含哪些项，这个汇编代码比较难懂了。你可以简单地认为，quad 是声明了一项的内容，org 是跳到了某个位置。</p><p>所以，init_top_pgt 有三项，上来先有一项，指向的是 level3_ident_pgt，也即直接映射区页表的三级目录。为什么要减去 __START_KERNEL_map 呢？因为 level3_ident_pgt 是定义在内核代码里的，写代码的时候，写的都是虚拟地址，谁写代码的时候也不知道将来加载的物理地址是多少呀，对不对？</p><p>因为 level3_ident_pgt 是在虚拟地址的内核代码段里的，而 <code>__START_KERNEL_map</code> 正是虚拟地址空间的内核代码段的起始地址，这在讲 64 位虚拟地址空间的时候都讲过了，要是想不起来就赶紧去回顾一下。这样，level3_ident_pgt 减去 <code>__START_KERNEL_map</code> 才是物理地址。</p><p>第一项定义完了以后，接下来我们跳到 PGD_PAGE_OFFSET 的位置，再定义一项。从定义可以看出，这一项就应该是 <code>__PAGE_OFFSET_BASE</code> 对应的。<code>__PAGE_OFFSET_BASE</code> 是虚拟地址空间里面内核的起始地址。第二项也指向 level3_ident_pgt，直接映射区。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>PGD_PAGE_OFFSET <span class="token operator">=</span> <span class="token function">pgd_index</span><span class="token punctuation">(</span>__PAGE_OFFSET_BASE<span class="token punctuation">)</span>
PGD_START_KERNEL <span class="token operator">=</span> <span class="token function">pgd_index</span><span class="token punctuation">(</span>__START_KERNEL_map<span class="token punctuation">)</span>
L3_START_KERNEL <span class="token operator">=</span> <span class="token function">pud_index</span><span class="token punctuation">(</span>__START_KERNEL_map<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第二项定义完了以后，接下来跳到 PGD_START_KERNEL 的位置，再定义一项。从定义可以看出，这一项应该是 __START_KERNEL_map 对应的项，__START_KERNEL_map 是虚拟地址空间里面内核代码段的起始地址。第三项指向 level3_kernel_pgt，内核代码区。</p><p>接下来的代码就很类似了，就是初始化个表项，然后指向下一级目录，最终形成下面这张图。</p><img src="`+i+`" alt="img" style="zoom:25%;"><p>内核页表定义完了，一开始这里面的页表能够覆盖的内存范围比较小。例如，内核代码区 512M，直接映射区 1G。这个时候，其实只要能够映射基本的内核代码和数据结构就可以了。可以看出，里面还空着很多项，可以用于将来映射巨大的内核虚拟地址空间，等用到的时候再进行映射。</p><p>如果是用户态进程页表，会有 mm_struct 指向进程顶级目录 pgd，对于内核来讲，也定义了一个 mm_struct，指向 swapper_pg_dir。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> init_mm <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span>mm_rb    <span class="token operator">=</span> RB_ROOT<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>pgd    <span class="token operator">=</span> swapper_pg_dir<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>mm_users  <span class="token operator">=</span> <span class="token function">ATOMIC_INIT</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">.</span>mm_count  <span class="token operator">=</span> <span class="token function">ATOMIC_INIT</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">.</span>mmap_sem  <span class="token operator">=</span> <span class="token function">__RWSEM_INITIALIZER</span><span class="token punctuation">(</span>init_mm<span class="token punctuation">.</span>mmap_sem<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">.</span>page_table_lock <span class="token operator">=</span>  <span class="token function">__SPIN_LOCK_UNLOCKED</span><span class="token punctuation">(</span>init_mm<span class="token punctuation">.</span>page_table_lock<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">.</span>mmlist    <span class="token operator">=</span> <span class="token function">LIST_HEAD_INIT</span><span class="token punctuation">(</span>init_mm<span class="token punctuation">.</span>mmlist<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">.</span>user_ns  <span class="token operator">=</span> <span class="token operator">&amp;</span>init_user_ns<span class="token punctuation">,</span>
  <span class="token function">INIT_MM_CONTEXT</span><span class="token punctuation">(</span>init_mm<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>定义完了内核页表，接下来是初始化内核页表，在系统启动的时候 start_kernel 会调用 setup_arch。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> __init <span class="token function">setup_arch</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>cmdline_p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token comment">/*
   * copy kernel address range established so far and switch
   * to the proper swapper page table
   */</span>
  <span class="token function">clone_pgd_range</span><span class="token punctuation">(</span>swapper_pg_dir     <span class="token operator">+</span> KERNEL_PGD_BOUNDARY<span class="token punctuation">,</span>
      initial_page_table <span class="token operator">+</span> KERNEL_PGD_BOUNDARY<span class="token punctuation">,</span>
      KERNEL_PGD_PTRS<span class="token punctuation">)</span><span class="token punctuation">;</span>


  <span class="token function">load_cr3</span><span class="token punctuation">(</span>swapper_pg_dir<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">__flush_tlb_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  init_mm<span class="token punctuation">.</span>start_code <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span> _text<span class="token punctuation">;</span>
  init_mm<span class="token punctuation">.</span>end_code <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span> _etext<span class="token punctuation">;</span>
  init_mm<span class="token punctuation">.</span>end_data <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span> _edata<span class="token punctuation">;</span>
  init_mm<span class="token punctuation">.</span>brk <span class="token operator">=</span> _brk_end<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token function">init_mem_mapping</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 setup_arch 中，load_cr3(swapper_pg_dir) 说明内核页表要开始起作用了，并且刷新了 TLB，初始化 init_mm 的成员变量，最重要的就是 init_mem_mapping。最终它会调用 kernel_physical_mapping_init。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/*
 * Create page table mapping for the physical memory for specific physical
 * addresses. The virtual and physical addresses have to be aligned on PMD level
 * down. It returns the last physical address mapped.
 */</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> __meminit
<span class="token function">kernel_physical_mapping_init</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> paddr_start<span class="token punctuation">,</span>
           <span class="token keyword">unsigned</span> <span class="token keyword">long</span> paddr_end<span class="token punctuation">,</span>
           <span class="token keyword">unsigned</span> <span class="token keyword">long</span> page_size_mask<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> vaddr<span class="token punctuation">,</span> vaddr_start<span class="token punctuation">,</span> vaddr_end<span class="token punctuation">,</span> vaddr_next<span class="token punctuation">,</span> paddr_last<span class="token punctuation">;</span>


  paddr_last <span class="token operator">=</span> paddr_end<span class="token punctuation">;</span>
  vaddr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token function">__va</span><span class="token punctuation">(</span>paddr_start<span class="token punctuation">)</span><span class="token punctuation">;</span>
  vaddr_end <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token function">__va</span><span class="token punctuation">(</span>paddr_end<span class="token punctuation">)</span><span class="token punctuation">;</span>
  vaddr_start <span class="token operator">=</span> vaddr<span class="token punctuation">;</span>


  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> vaddr <span class="token operator">&lt;</span> vaddr_end<span class="token punctuation">;</span> vaddr <span class="token operator">=</span> vaddr_next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">pgd_t</span> <span class="token operator">*</span>pgd <span class="token operator">=</span> <span class="token function">pgd_offset_k</span><span class="token punctuation">(</span>vaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">p4d_t</span> <span class="token operator">*</span>p4d<span class="token punctuation">;</span>


    vaddr_next <span class="token operator">=</span> <span class="token punctuation">(</span>vaddr <span class="token operator">&amp;</span> PGDIR_MASK<span class="token punctuation">)</span> <span class="token operator">+</span> PGDIR_SIZE<span class="token punctuation">;</span>


    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pgd_val</span><span class="token punctuation">(</span><span class="token operator">*</span>pgd<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      p4d <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">p4d_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">pgd_page_vaddr</span><span class="token punctuation">(</span><span class="token operator">*</span>pgd<span class="token punctuation">)</span><span class="token punctuation">;</span>
      paddr_last <span class="token operator">=</span> <span class="token function">phys_p4d_init</span><span class="token punctuation">(</span>p4d<span class="token punctuation">,</span> <span class="token function">__pa</span><span class="token punctuation">(</span>vaddr<span class="token punctuation">)</span><span class="token punctuation">,</span>
               <span class="token function">__pa</span><span class="token punctuation">(</span>vaddr_end<span class="token punctuation">)</span><span class="token punctuation">,</span>
               page_size_mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


    p4d <span class="token operator">=</span> <span class="token function">alloc_low_page</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    paddr_last <span class="token operator">=</span> <span class="token function">phys_p4d_init</span><span class="token punctuation">(</span>p4d<span class="token punctuation">,</span> <span class="token function">__pa</span><span class="token punctuation">(</span>vaddr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">__pa</span><span class="token punctuation">(</span>vaddr_end<span class="token punctuation">)</span><span class="token punctuation">,</span>
             page_size_mask<span class="token punctuation">)</span><span class="token punctuation">;</span>


    <span class="token function">p4d_populate</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>init_mm<span class="token punctuation">,</span> <span class="token function">p4d_offset</span><span class="token punctuation">(</span>pgd<span class="token punctuation">,</span> vaddr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">pud_t</span> <span class="token operator">*</span><span class="token punctuation">)</span> p4d<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">__flush_tlb_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


  <span class="token keyword">return</span> paddr_l
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 kernel_physical_mapping_init 里，我们先通过 __va 将物理地址转换为虚拟地址，然后再创建虚拟地址和物理地址的映射页表。</p><p>你可能会问，怎么这么麻烦啊？既然对于内核来讲，我们可以用 __va 和 __pa 直接在虚拟地址和物理地址之间直接转来转去，为啥还要辛辛苦苦建立页表呢？因为这是 CPU 和内存的硬件的需求，也就是说，CPU 在保护模式下访问虚拟地址的时候，就会用 CR3 这个寄存器，这个寄存器是 CPU 定义的，作为操作系统，我们是软件，只能按照硬件的要求来。</p><p>你可能又会问了，按照咱们讲初始化的时候的过程，系统早早就进入了保护模式，到了 setup_arch 里面才 load_cr3，如果使用 cr3 是硬件的要求，那之前是怎么办的呢？如果你仔细去看 arch\\x86\\kernel\\head_64.S，这里面除了初始化内核页表之外，在这之前，还有另一个页表 early_top_pgt。看到关键字 early 了嘛？这个页表就是专门用在真正的内核页表初始化之前，为了遵循硬件的要求而设置的。早期页表不是我们这节的重点，这里我就不展开多说了。</p><h2 id="vmalloc-和-kmap-atomic-原理" tabindex="-1"><a class="header-anchor" href="#vmalloc-和-kmap-atomic-原理" aria-hidden="true">#</a> vmalloc 和 kmap_atomic 原理</h2><p>在用户态可以通过 malloc 函数分配内存，当然 malloc 在分配比较大的内存的时候，底层调用的是 mmap，当然也可以直接通过 mmap 做内存映射，在内核里面也有相应的函数。</p><p>在虚拟地址空间里面，有个 vmalloc 区域，从 VMALLOC_START 开始到 VMALLOC_END，可以用于映射一段物理内存。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/**
 *  vmalloc  -  allocate virtually contiguous memory
 *  @size:    allocation size
 *  Allocate enough pages to cover @size from the page level
 *  allocator and map them into contiguous kernel virtual space.
 *
 *  For tight control over page level allocator and protection flags
 *  use __vmalloc() instead.
 */</span>
<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">vmalloc</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">__vmalloc_node_flags</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> NUMA_NO_NODE<span class="token punctuation">,</span>
            GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">__vmalloc_node</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> align<span class="token punctuation">,</span>
          <span class="token class-name">gfp_t</span> gfp_mask<span class="token punctuation">,</span> <span class="token class-name">pgprot_t</span> prot<span class="token punctuation">,</span>
          <span class="token keyword">int</span> node<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>caller<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">__vmalloc_node_range</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> align<span class="token punctuation">,</span> VMALLOC_START<span class="token punctuation">,</span> VMALLOC_END<span class="token punctuation">,</span>
        gfp_mask<span class="token punctuation">,</span> prot<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> node<span class="token punctuation">,</span> caller<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们再来看内核的临时映射函数 kmap_atomic 的实现。从下面的代码我们可以看出，如果是 32 位有高端地址的，就需要调用 set_pte 通过内核页表进行临时映射；如果是 64 位没有高端地址的，就调用 page_address，里面会调用 lowmem_page_address。其实低端内存的映射，会直接使用 __va 进行临时映射。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">kmap_atomic_prot</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">,</span> <span class="token class-name">pgprot_t</span> prot<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">PageHighMem</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token function">page_address</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  vaddr <span class="token operator">=</span> <span class="token function">__fix_to_virt</span><span class="token punctuation">(</span>FIX_KMAP_BEGIN <span class="token operator">+</span> idx<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">set_pte</span><span class="token punctuation">(</span>kmap_pte<span class="token operator">-</span>idx<span class="token punctuation">,</span> <span class="token function">mk_pte</span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> prot<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>vaddr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">kmap_atomic</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">kmap_atomic_prot</span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> kmap_prot<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">lowmem_page_address</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">page_to_virt</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">page_to_virt</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token function">__va</span><span class="token punctuation">(</span><span class="token function">PFN_PHYS</span><span class="token punctuation">(</span><span class="token function">page_to_pfn</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span></span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="内核态缺页异常" tabindex="-1"><a class="header-anchor" href="#内核态缺页异常" aria-hidden="true">#</a> 内核态缺页异常</h2><p>可以看出，kmap_atomic 和 vmalloc 不同。kmap_atomic 发现，没有页表的时候，就直接创建页表进行映射了。而 vmalloc 没有，它只分配了内核的虚拟地址。所以，访问它的时候，会产生缺页异常。</p><p>内核态的缺页异常还是会调用 do_page_fault，但是会走到咱们上面用户态缺页异常中没有解析的那部分 vmalloc_fault。这个函数并不复杂，主要用于关联内核页表项。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/*
 * 32-bit:
 *
 *   Handle a fault on the vmalloc or module mapping area
 */</span>
<span class="token keyword">static</span> noinline <span class="token keyword">int</span> <span class="token function">vmalloc_fault</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> address<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> pgd_paddr<span class="token punctuation">;</span>
  <span class="token class-name">pmd_t</span> <span class="token operator">*</span>pmd_k<span class="token punctuation">;</span>
  <span class="token class-name">pte_t</span> <span class="token operator">*</span>pte_k<span class="token punctuation">;</span>


  <span class="token comment">/* Make sure we are in vmalloc area: */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>address <span class="token operator">&gt;=</span> VMALLOC_START <span class="token operator">&amp;&amp;</span> address <span class="token operator">&lt;</span> VMALLOC_END<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>


  <span class="token comment">/*
   * Synchronize this task&#39;s top level page-table
   * with the &#39;reference&#39; page table.
   *
   * Do _not_ use &quot;current&quot; here. We might be inside
   * an interrupt in the middle of a task switch..
   */</span>
  pgd_paddr <span class="token operator">=</span> <span class="token function">read_cr3_pa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  pmd_k <span class="token operator">=</span> <span class="token function">vmalloc_sync_one</span><span class="token punctuation">(</span><span class="token function">__va</span><span class="token punctuation">(</span>pgd_paddr<span class="token punctuation">)</span><span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pmd_k<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>


  pte_k <span class="token operator">=</span> <span class="token function">pte_offset_kernel</span><span class="token punctuation">(</span>pmd_k<span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">pte_present</span><span class="token punctuation">(</span><span class="token operator">*</span>pte_k<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>


  <span class="token keyword">return</span> <span class="token number">0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="总结时刻" tabindex="-1"><a class="header-anchor" href="#总结时刻" aria-hidden="true">#</a> 总结时刻</h2><p>至此，内核态的内存映射也讲完了。这下，我们可以将整个内存管理的体系串起来了。</p><ol><li><p>物理内存根据 NUMA 架构分节点。每个节点里面再分区域。每个区域里面再分页。</p></li><li><p>物理页面通过伙伴系统进行分配。分配的物理页面要变成虚拟地址让上层可以访问，kswapd 可以根据物理页面的使用情况对页面进行换入换出。</p></li><li><p>对于内存的分配需求，可能来自内核态，也可能来自用户态。</p></li><li><p>对于内核态，kmalloc 在分配大内存的时候，以及 vmalloc 分配不连续物理页的时候，直接使用伙伴系统，分配后转换为虚拟地址，访问的时候需要通过内核页表进行映射。</p><pre><code>1. 对于 kmem_cache 以及 kmalloc 分配小内存，则使用 slub 分配器，将伙伴系统分配出来的大块内存切成一小块一小块进行分配。

2. kmem_cache 和 kmalloc 的部分不会被换出，因为用这两个函数分配的内存多用于保持内核关键的数据结构。内核态中 vmalloc 分配的部分会被换出，因而当访问的时候，发现不在，就会调用 do_page_fault。
</code></pre><ol start="2"><li>对于用户态的内存分配，或者直接调用 mmap 系统调用分配，或者调用 malloc。调用 malloc 的时候，如果分配小的内存，就用 sys_brk 系统调用；如果分配大的内存，还是用 sys_mmap 系统调用。正常情况下，用户态的内存都是可以换出的，因而一旦发现内存中不存在，就会调用 do_page_fault。</li></ol></li></ol><img src="`+u+'" alt="img" style="zoom:25%;"><blockquote><ul><li>涉及三块内容:</li><li>内存映射函数 vmalloc, kmap_atomic <ul><li>内核态页表存放位置和工作流程</li><li>内核态缺页异常处理</li></ul></li><li>内核态页表, 系统初始化时就创建</li><li>swapper_pg_dir 指向内核顶级页目录 pgd<br> - xxx_ident/kernel/fixmap_pgt 分别是直接映射/内核代码/固定映射的 xxx 级页表目录 <ul><li>创建内核态页表</li><li>swapper_pg_dir 指向 init_top_pgt, 是 ELF 文件的全局变量, 因此再内存管理初始化之间就存在 <ul><li>init_top_pgt 先初始化了三项</li><li>第一项指向 level3_ident_pgt (内核代码段的某个虚拟地址) 减去 __START_KERNEL_MAP (内核代码起始虚拟地址) 得到实际物理地址 <ul><li>第二项也是指向 level3_ident_pgt</li><li>第三项指向 level3_kernel_pgt 内核代码区</li></ul></li></ul></li><li>初始化各页表项, 指向下一集目录</li><li>页表覆盖范围较小, 内核代码 512MB, 直接映射区 1GB <ul><li>内核态也定义 mm_struct 指向 swapper_pg_dir</li><li>初始化内核态页表, start_kernel→ setup_arch</li><li>load_cr3(swapper_pg_dir) 并刷新 TLB <ul><li>调用 init_mem_mapping→kernel_physical_mapping_init, 用 __va 将物理地址映射到虚拟地址, 再创建映射页表项</li><li>CPU 在保护模式下访问虚拟地址都必须通过 cr3, 系统只能照做</li><li>在 load_cr3 之前, 通过 early_top_pgt 完成映射</li></ul></li></ul></li></ul></li><li>vmalloc 和 kmap_atomic</li><li>内核的虚拟地址空间 vmalloc 区域用于映射 <ul><li>kmap_atomic 临时映射</li><li>32 位, 调用 set_pte 通过内核页表临时映射 <ul><li>64 位, 调用 page_address→lowmem_page_address 进行映射</li></ul></li></ul></li><li>内核态缺页异常</li><li>kmap_atomic 直接创建页表进行映射 <ul><li>vmalloc 只分配内核虚拟地址, 访问时触发缺页中断, 调用 do_page_fault→vmalloc_fault 用于关联内核页表项</li></ul></li><li>kmem_cache 和 kmalloc 用于保存内核数据结构, 不会被换出; 而内核 vmalloc 会被换出</li></ul></blockquote><h2 id="课堂练习" tabindex="-1"><a class="header-anchor" href="#课堂练习" aria-hidden="true">#</a> 课堂练习</h2><p>伙伴系统分配好了物理页面之后，如何转换成为虚拟地址呢？请研究一下 page_address 函数的实现。</p><p>欢迎留言和我分享你的疑惑和见解，也欢迎你收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习、进步。</p><h2 id="课后讨论" tabindex="-1"><a class="header-anchor" href="#课后讨论" aria-hidden="true">#</a> 课后讨论</h2><p>内核能用c语言编写，是不是意味着用c可以直接操作物理内存，另外linux上的c语言编译器是用什么语言开发的，c语言实现了自举吗，c语言跨平台底层原理是什么，请老师答疑解惑。<br> 作者回复: 是因为C语言编译完了就直接是硬件能够识别的二进制，不像java，需要jvm才能运行。C语言不用自举，除了第一个开发C语言的，需要用汇编来做，后面都可以用锤子造锤子<br> 网友回复：c语言是可以操作物理内存的，玩过单片机的都知道。<strong>不同架构的cpu需要不同的c编译器</strong>。</p><p>整个内存的讲解（这个专栏内容如果一下看不懂直接跳总结部分，甚至每章的最后，现有个整体认识，再返回去看细节，会容易很多）</p><p>看起来很有感觉，先讲用户态、内核态虚拟内存的管理，然后讲物理内存的管理，最后讲用户态、内核态虚拟内存与物理内存如何建立关联。<br> 作者回复: 赞，有感觉就好，要的就是心动</p>',52),k=n("br",null,null,-1),v=n("strong",null,"1.申请时转换，",-1),_=n("br",null,null,-1),m=n("br",null,null,-1),b=n("br",null,null,-1),g=n("strong",null,"2.有虚拟地址挂载页面",-1),f=n("br",null,null,-1),h=n("br",null,null,-1),E={href:"https://garlicspace.com/2020/08/12/%e4%bc%99%e4%bc%b4%e7%b3%bb%e7%bb%9f%e5%88%86%e9%85%8d%e7%89%a9%e7%90%86%e9%a1%b5%e5%90%8e%e5%a6%82%e4%bd%95%e8%bd%ac%e6%8d%a2%e6%88%90%e4%b8%ba%e8%99%9a%e6%8b%9f%e5%9c%b0%e5%9d%80/",target:"_blank",rel:"noopener noreferrer"},y=a("<p>-1如果不是高端内存，物理地址和虚拟地址之间的转换相对比较简单，直接使用lowmme_page_address进行转换，前面提到过这个函数；<br> -2对于非高端内存页，通过page_slot计算出pas，pas保存在由pagez作为key的hash表page_address_htable中；<br> -3遍历pas-&gt;lh双向链表，链表的节点保存有page的地址和page所对应的虚拟地址，通过page，可以确定page对应的虚拟地址。</p><p>page_address_map结构体中保存了page和对应虚拟地址的映射关系。<br> 每个page对象保存在page_address_htable中，映射到相同slot的pages会形成一个链表。page_address方法就是根据page找到slot，遍历对应slot的链表，找到page相同的那项，返回其对应的虚拟地址。</p><p>用malloc申请的内存，进程退出时，操作系统是否会释放<br> 作者回复: 当然会啊，虚拟内存嘛</p><p>老师，看到这里我是不是可以认为在用户态使用mmap和内核态使用mmap是两码事，我们一般应用场景比如将图片内存直接映射到用户空间上访问避免多次拷贝从而提高图片加载速度，那么这个场景是发生在用户态上面，期间不需要通过内核态吗？调用系统函数触发的mmap是发生在内核态吗，比如strace ls -l<br> 作者回复: 不是的，mmap是系统调用，不存在内核调用他的</p><p>作者回复: kmalloc内核空间内存申请函数。</p>",5);function w(T,A){const p=t("ExternalLinkIcon");return o(),l("div",null,[r,n("p",null,[s("伙伴系统分配好了物理页面到虚拟地址:有两种情况"),k,v,_,s(" 直接使用伙伴系统申请页,通过page_address进行地址转换，如kmalloc申请大于2个页面时"),m,s(" 通过SLAB从伙伴系统申请页,创建new slab时通过page_address进行地址转换, 如vmalloc, VMA结构体申请时"),b,g,f,s(" 有指定虚拟地址范围，再通过伙伴系统申请空间，申请释放时统一进行更新页表项, 如vmalloc"),h,n("a",E,[s("课堂学习笔记"),c(p)])]),y])}const L=e(d,[["render",w],["__file","I26-内核态内存映射.html.vue"]]);export{L as default};
