import{_ as p}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as c,c as i,a as n,b as s,e,d as t}from"./app-cdabc73c.js";const r="/assets/d39b0f2b3962d646133d450541fb75a6-1679747137002-15-574d33c4.png",l="/assets/23adbbc656243ce85fdb8c7fab42ecf6-236601cc.jpeg",u="/assets/9330b8fb1e8de3f62d34c6f85f268db1-b313a92d.jpeg",d="/assets/659082942118e7c69eb3807b00f5f556-e6667e4e.jpeg",k="/assets/45d4c7c8b0cb1f056684199e39660f0e-f4b51ffa.jpeg",m={},h=t(`<h1 id="_54-理解disruptor-上-带你体会cpu高速缓存的风驰电掣" tabindex="-1"><a class="header-anchor" href="#_54-理解disruptor-上-带你体会cpu高速缓存的风驰电掣" aria-hidden="true">#</a> 54 | 理解Disruptor（上）：带你体会CPU高速缓存的风驰电掣</h1><p>坚持到底就是胜利，终于我们一起来到了专栏的最后一个主题。让我一起带你来看一看，CPU 到底能有多快。在接下来的两讲里，我会带你一起来看一个开源项目 Disruptor。看看我们怎么利用 CPU 和高速缓存的硬件特性，来设计一个对于性能有极限追求的系统。</p><p>不知道你还记不记得，在第 37 讲里，为了优化 4 毫秒专门铺设光纤的故事。实际上，最在意极限性能的并不是互联网公司，而是高频交易公司。我们今天讲解的 Disruptor 就是由 <code>一家专门做高频交易的公司 LMAX</code> 开源出来的。</p><p>有意思的是，Disruptor 的开发语言，并不是很多人心目中最容易做到性能极限的 C/C++，而是性能受限于 JVM 的 Java。这到底是怎么一回事呢？那通过这一讲，你就能体会到，<em>其实只要通晓硬件层面的原理</em>，即使是像 Java 这样的高级语言，也能够把 CPU 的性能发挥到极限。</p><h2 id="padding-cache-line-体验高速缓存的威力" tabindex="-1"><a class="header-anchor" href="#padding-cache-line-体验高速缓存的威力" aria-hidden="true">#</a> Padding Cache Line，体验高速缓存的威力</h2><p>我们先来看看 Disruptor 里面一段神奇的代码。这段代码里，Disruptor 在 <mark>RingBufferPad</mark> 这个类里面定义了 p1，p2 一直到 p7 这样 7 个 long 类型的变量。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">RingBufferPad</span>
<span class="token punctuation">{</span>
    <span class="token keyword">protected</span> <span class="token keyword">long</span> p1<span class="token punctuation">,</span> p2<span class="token punctuation">,</span> p3<span class="token punctuation">,</span> p4<span class="token punctuation">,</span> p5<span class="token punctuation">,</span> p6<span class="token punctuation">,</span> p7<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我在看到这段代码的第一反应是，变量名取得不规范，p1-p7 这样的变量名没有明确的意义啊。不过，当我深入了解了 Disruptor 的设计和源代码，才发现这些变量名取得恰如其分。<em>因为这些变量就是没有实际意义</em>，只是帮助我们进行<strong>缓存行填充</strong>（Padding Cache Line），使得我们能够尽可能地用上 <code>CPU 高速缓存（CPU Cache）</code>。那么缓存行填充这个黑科技到底是什么样的呢？我们接着往下看。</p><p>不知道你还记不记得，我们在35 讲里面的这个表格。如果访问内置在 CPU 里的 L1 Cache 或者 L2 Cache，访问延时是内存的 1/15 乃至 1/100。而内存的访问速度，其实是远远慢于 CPU 的。<em>想要追求极限性能，需要我们尽可能地多从 <code>CPU Cache</code> 里面拿数据</em>，而不是从内存里面拿数据。</p><img src="`+r+'" alt="img" style="zoom:50%;"><p>CPU Cache 装载内存里面的数据，不是一个一个字段加载的，而是加载<strong>一整个缓存行</strong>。举个例子，如果我们定义了一个长度为 64 的 long 类型的数组。那么数据从内存加载到 CPU Cache 里面的时候，不是一个一个数组元素加载的，而是一次性加载<strong>固定长度的一个缓存行</strong>。</p><p>我们现在的 64 位 Intel CPU 的计算机，<mark>缓存行</mark>通常是 <strong>64 个字节（Bytes）</strong>。一个 long 类型的数据需要 8 个字节，所以我们一下子会加载 8 个 long 类型的数据。也就是说，<em>一次加载数组里面连续的 8 个数值</em>。这样的加载方式使得我们<code>遍历数组元素</code>的时候会很快。<em>因为后面连续 7 次的数据访问都会命中缓存，不需要重新从内存里面去读取数据</em>。这个性能层面的好处，我在第 37 讲的第一个例子里面为你演示过，印象不深的话，可以返回去看看。</p><h2 id="_1-因前后数据存在而导致的无辜失效" tabindex="-1"><a class="header-anchor" href="#_1-因前后数据存在而导致的无辜失效" aria-hidden="true">#</a> 1 因前后数据存在而导致的无辜失效</h2><p>但是，在我们不使用数组，而是使用==<strong>单独的变量</strong>==的时候，这里就会出现问题了。在 Disruptor 的 **RingBuffer（环形缓冲区）**的代码里面，定义了一个 <strong>RingBufferFields</strong> 类，里面有 <strong>indexMask</strong> 和其他几个变量，用来存放 <code>RingBuffer 的内部状态信息</code>。</p><img src="'+l+`" alt="img" style="zoom:25%;"><p>CPU 在加载数据的时候，自然也会把这个数据<em>从内存加载到高速缓存里面来</em>。不过，这个时候，高速缓存里面除了这个数据，还会加载<code>这个数据前后定义的其他变量</code>。这个时候，问题就来了。Disruptor 是一个多线程的服务器框架，<code>在这个数据前后定义的其他变量</code>，可能会被多个不同的线程去更新数据、读取数据。这些写入以及读取的请求，<em>会来自于不同的 CPU Core</em>。于是，<em>为了保证数据的同步更新</em>，我们<code>不得不</code>把 CPU Cache 里面的数据，重新写回到内存里面去或者重新从内存里面加载数据。</p><p>而我们刚刚说过，这些 CPU Cache 的写回和加载，<em>都不是以一个变量作为单位的</em>。这些动作都是以<em>整个 Cache Line</em> 作为单位的。所以，当 INITIAL_CURSOR_VALUE 前后的那些变量被写回到内存的时候，这个字段自己也写回到了内存，<em>这个常量的缓存也就（无辜）失效了</em>。当我们要再次读取这个值的时候，<em>要再重新从内存读取</em>。这也就意味着，读取速度大大变慢了。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">RingBufferPad</span>
<span class="token punctuation">{</span>
    <span class="token keyword">protected</span> <span class="token keyword">long</span> p1<span class="token punctuation">,</span> p2<span class="token punctuation">,</span> p3<span class="token punctuation">,</span> p4<span class="token punctuation">,</span> p5<span class="token punctuation">,</span> p6<span class="token punctuation">,</span> p7<span class="token punctuation">;</span> <span class="token comment">// 7个long</span>
<span class="token punctuation">}</span>
  

<span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">RingBufferFields</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">RingBufferPad</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">long</span> indexMask<span class="token punctuation">;</span>				<span class="token comment">// 全都是final</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> entries<span class="token punctuation">;</span>
    <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">int</span> bufferSize<span class="token punctuation">;</span>
    <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token class-name">Sequencer</span> sequencer<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">RingBuffer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">RingBufferFields</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Cursored</span><span class="token punctuation">,</span> <span class="token class-name">EventSequencer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">EventSink</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    
    <span class="token keyword">protected</span> <span class="token keyword">long</span> p1<span class="token punctuation">,</span> p2<span class="token punctuation">,</span> p3<span class="token punctuation">,</span> p4<span class="token punctuation">,</span> p5<span class="token punctuation">,</span> p6<span class="token punctuation">,</span> p7<span class="token punctuation">;</span> <span class="token comment">// 7个long</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>最好说明一下，这种填充cache line的手法是为了防止False Sharing<br> 作者回复: 是的，篇幅有限，所以没有太具体解释False Sharing和Memory Fence，欢迎大家留言分析这两部分知识点。</p><p>在java8中，jvm团队搞出了@Contended注解来进行支持，在你需要避免“false sharing”的字段上标记注解，这可以暗示虚拟机“这个字段可以分离到不同的cache line中”，这是JEP 142的目标。<br> 作者回复: 👍</p></blockquote><img src="`+u+'" alt="img" style="zoom:25%;"><blockquote><p>注意一下类是abstract。父子类属性原理。pad父类填充属性在前，field父类的属性（final）被保护在中间，ringbuffer子类填充属性在最后。这样就杜绝被其他cache line影响。</p></blockquote><h2 id="_2-缓存行填充-可以很好解决问题" tabindex="-1"><a class="header-anchor" href="#_2-缓存行填充-可以很好解决问题" aria-hidden="true">#</a> 2 缓存行填充：可以很好解决问题</h2><p>面临这样一个情况，Disruptor 里发明了一个神奇的代码技巧，这个技巧就是<strong>缓存行填充</strong>。Disruptor 在 <code>RingBufferFields</code> 里面定义的变量的前后，分别定义了 7 个 long 类型的变量。</p><ol><li>前面的 7 个来自继承的 RingBufferPad 类，【父类的】</li><li>后面的 7 个则是直接定义在 RingBuffer 类里面。【子类的】</li><li>这 14 个变量没有任何实际的用途。我们既不会去读他们，也不会去写他们。</li></ol><p>而 RingBufferFields 里面定义的这些变量都是 <code>final</code> 的，<em><code>第一次写入之后不会再进行修改</code>。所以，一旦它被加载到 CPU Cache 之后，只要被频繁地读取访问，就不会再被换出 Cache 了</em>。这也就意味着，对于这个值的读取速度，<strong>会是一直是 CPU Cache 的访问速度</strong>，而不是内存的访问速度。</p><h2 id="使用-ringbuffer-利用缓存和分支预测" tabindex="-1"><a class="header-anchor" href="#使用-ringbuffer-利用缓存和分支预测" aria-hidden="true">#</a> 使用 RingBuffer，利用缓存和分支预测</h2><p><strong>其实这个利用 CPU Cache 的性能的思路，贯穿了整个 Disruptor</strong>。Disruptor 整个框架，其实就是<strong>一个高速的<code>生产者 - 消费者模型</code>（Producer-Consumer）下的<code>队列</code></strong>。生产者不停地往队列里面生产新的需要处理的任务，而消费者不停地从队列里面处理掉这些任务。</p><img src="'+d+'" alt="img" style="zoom:25%;"><h2 id="_1-linkedblockingqueue-传统的链表" tabindex="-1"><a class="header-anchor" href="#_1-linkedblockingqueue-传统的链表" aria-hidden="true">#</a> 1 LinkedBlockingQueue 传统的链表</h2><p>如果你熟悉算法和数据结构，那你应该非常清楚，如果要实现一个队列，最合适的数据结构应该是<code>链表</code>。我们只要维护好链表的头和尾，就能很容易实现一个队列。生产者只要不断地往链表的尾部不断插入新的节点，而消费者只需要不断从头部取出最老的节点进行处理就好了。我们可以很容易实现生产者 - 消费者模型。实际上，Java 自己的基础库里面就有 <code>LinkedBlockingQueue</code> 这样的队列库，可以直接用在生产者 - 消费者模式上。</p><img src="'+k+'" alt="img" style="zoom:25%;"><h2 id="_2-ringbuffer-数组-空间局部性-分支预测" tabindex="-1"><a class="header-anchor" href="#_2-ringbuffer-数组-空间局部性-分支预测" aria-hidden="true">#</a> 2 RingBuffer 数组 空间局部性 分支预测</h2><p>不过，Disruptor 里面并没有用 LinkedBlockingQueue，而是使用了一个 <code>RingBuffer</code> 这样的数据结构，这个 RingBuffer 的底层实现则是<code>一个固定长度的数组</code>。比起链表形式的实现，数组的数据在内存里面会存在<code>空间局部性</code>。</p><p>就像上面我们看到的，数组的连续多个元素会一并加载到 CPU Cache 里面来，<em>所以访问遍历的速度会更快</em>。而链表里面各个节点的数据，多半不会出现在相邻的内存空间，自然也就享受不到整个 Cache Line 加载后数据连续从高速缓存里面被访问到的优势。</p><p>除此之外，数据的遍历访问还有一个很大的优势，<em>就是 CPU 层面的分支预测会很准确</em>。这可以使得我们更有效地利用了 CPU 里面的多级流水线，我们的程序就会跑得更快。这一部分的原理如果你已经不太记得了，可以回过头去复习一下第 25 讲关于分支预测的内容。</p><h2 id="总结延伸" tabindex="-1"><a class="header-anchor" href="#总结延伸" aria-hidden="true">#</a> 总结延伸</h2><p>好了，不知道讲完这些，你有没有体会到 Disruptor 这个框架的神奇之处呢？</p><p>CPU 从内存加载数据到 CPU Cache 里面的时候，不是一个变量一个变量加载的，<em>而是加载固定长度的 Cache Line</em>。如果是加载数组里面的数据，那么 CPU 就会加载到数组里面连续的多个数据。所以，<em><code>数组的遍历</code>很容易享受到 CPU Cache 那风驰电掣的速度带来的红利</em>。</p><p><strong>对于类里面定义的单独的变量</strong>，就不容易享受到 CPU Cache 红利了。因为这些字段虽然在内存层面会分配到一起，但是实际应用的时候往往没有什么关联。于是，就会出现多个 CPU Core 访问的情况下，数据频繁在 CPU Cache 和内存里面来来回回的情况。<em>而 Disruptor 很取巧地在</em>需要频繁高速访问的变量，也就是 RingBufferFields 里面的 indexMask 这些字段<em>前后，各定义了 7 个没有任何作用和读写请求的 long 类型的变量</em>。</p><p>这样，无论在内存的什么位置上，这些变量所在的 Cache Line 都不会有任何写更新的请求。<em>我们就可以始终在 Cache Line 里面读到它的值，而不需要从内存里面去读取数据</em>，也就大大加速了 Disruptor 的性能。</p><p>这样的思路，其实渗透在 Disruptor 这个开源框架的方方面面。作为<mark>一个生产者 - 消费者模型</mark>，Disruptor 并没有选择使用链表来实现一个队列，而是使用了 RingBuffer。<em><code>RingBuffer</code> 底层的数据结构则是<code>一个固定长度的数组</code></em>。这个数组不仅让我们更容易用好 CPU Cache，<em>对 CPU 执行过程中的分支预测也非常有利</em>。更准确的分支预测，可以使得我们更好地利用好 CPU 的流水线，<em>让代码跑得更快</em>。</p><h2 id="推荐阅读" tabindex="-1"><a class="header-anchor" href="#推荐阅读" aria-hidden="true">#</a> 推荐阅读</h2>',42),g={href:"https://github.com/LMAX-Exchange/disruptor/wiki/Introduction",target:"_blank",rel:"noopener noreferrer"},f=n("p",null,"这里面不仅包含了怎么用好 Disruptor，也包含了整个 Disruptor 框架的设计思路，是一份很好的阅读学习材料。另外，Disruptor 的官方文档里，还有很多文章、演讲，详细介绍了这个框架，很值得深入去看一看。Disruptor 的源代码其实并不复杂，很适合用来学习怎么阅读开源框架代码。",-1),b=n("h2",{id:"课后思考",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#课后思考","aria-hidden":"true"},"#"),s(" 课后思考")],-1),v={href:"https://github.com/LMAX-Exchange/disruptor/blob/master/src/perftest/java/com/lmax/disruptor/immutable/CustomPerformanceTest.java",target:"_blank",rel:"noopener noreferrer"},C=n("p",null,"欢迎你把你的测试结果写在留言区，和大家一起讨论、分享。如果有收获，你也可以把这篇文章分享给你的朋友。",-1),_=t("<p>老师，有个疑惑的地方：文中讲了RingBuffer类利用缓存行填充来解决INITIAL_CURSOR_VALUE伪共享的问题，但是我记得Java对象内存布局是：实例变量放在堆区，静态变量属于类，放在方法区，而堆区和方法区在内存里肯定是隔离开的，但是RingBuffer的前后填充字段都是实例字段，而INITIAL_CURSOR_VALUE是静态常量，所以实际运行中他们肯定不是紧密排列在一起的，那么就解决不了伪共享的问题了，况且RingBuffer的子类RingBufferFields还有其他实例字段，如：indexMask、entries、bufferSize、sequencer，这些字段都是final修饰的，即对象构建后不会再修改，所以我理解前后的缓存行填充守护的应该是这几个字段，而且从子类RingBufferFields的命名也可以看出前面那几个字段才是想要缓存的字段。希望得到老师的回复，另外课程快结束了，一路跟下来收获很大，我准备这段时间二刷来巩固下<sup>_</sup><br> 作者回复: 我回头重新看了一下代码，我觉得你说的是对的，Padding对应的是RingBufferFields里面的字段，而不应该是INITIAL_CURSOR_VALUE，我去订正一下。</p><hr><p>这个是不是和前面讲的msei有一定关系啊，请徐老师点拨<br> 作者回复: 没错，看来你读的时候很仔细地思考过。当我们的对于数据修改，修改了cache之后，这个数据如果要同步到主内存，那么就会需要通过MSEI协议来在各个CPU Core的Cache里面保持数据同步。<br> 那么是否需要同步主内存，会引发另外一个知识点，就是Memory Barrier/Fence，这部分知识点其实还可以单独拿来说两讲。你可以先去搜索上面的关键词，了解一下。</p><hr><p>“而 Disruptor 很取巧地在需要频繁高速访问的变量，也就是 RingBufferFields 里面的 indexMask 这些字段前后，各定义了 7 个没有任何作用和读写请求的 long 类型的变量。”为什么前后各7个，cache line 就没有写的请求，就是因为8个long正好64byte吗，为什么没有写的呢？<br> 作者回复: ，indexMask是一个第一次写入之后就不变动的变量了。你可以看到在代码里面这是一个Java的final变量。前后7个就是因为8个long正好64byte，这样cache line无论在哪个位置被加载，这64个byte在第一次加载到cache line之后就不再需要更新了。</p><hr><p>老师今天说的这个东西其实就是MQ：只不过现在的MQ基本上是在充分利用内存/缓存，而disruptor其实是在利用CPU cache。刘超老师有一点确实没有说错“计算机组成原理和操作系统相辅相成”：学到今天去相互结合确实发现这种收益远比单独学习好。</p><hr>",8),P=n("br",null,null,-1),U=n("br",null,null,-1),y={href:"https://www.bilibili.com/video/av46710093/",target:"_blank",rel:"noopener noreferrer"},B=n("hr",null,null,-1),R=n("p",null,[s("老师， 我对于前后7个long有点疑惑， 我大概知道是为了防止被换出， 但就是不知道为什么可以😂， 可以举例说明一下吗？"),n("br"),s(" 其他网友：字段都是final的，不会被改动。假如字段是a,b，那么缓存行里面可能是p2,p3,p4,p5,p6,p7,a,b，都不可改动，所以就不会往主内存更新了。64个字节加载后，没有修改，所以不需要换出。")],-1);function w(D,x){const a=o("ExternalLinkIcon");return c(),i("div",null,[h,n("p",null,[s("今天讲的是 Disruptor，推荐的阅读内容自然是 Disruptor 的官方文档。作为一个开源项目，"),n("a",g,[s("Disruptor 在自己GitHub上"),e(a)]),s("有很详细的设计文档，推荐你好好阅读一下。")]),f,b,n("p",null,[s("今天我们讲解了缓存行填充，你可以试试修改 Disruptor 的代码，看看在没有缓存行填充和有缓存行填充的情况下的性能差异。你也可以尝试直接修改 Disruptor 的源码和"),n("a",v,[s("性能测试代码"),e(a)]),s("，看看运行的结果是什么样的。")]),C,n("blockquote",null,[_,n("p",null,[s("扩展的问老师一个问题：现在所谓的智能芯片或者说前端时间提出的智能芯片，会对后续产生革命性影响么？毕竟硬件的i5到现在差不多十多年了其实进步不大，这十余年最大的变化莫过于内存容量的暴涨造就了nosql、MQ的兴起，如果说将来cache的变化是吧同样可能早就类似于老师今天所说的Disruptor这种基于CPU Cache技术的兴起。"),P,s(" 今年华为的AI CPU、老美那边的云计算CPU似乎实验室测试已经通过了：毕竟从奔腾4之后到现在近20年了，老师今天所说的又刚好符合现在关键硬件CPU的革新时期？老师对此是如何看待？希望老师能提点。"),U,s(" 作者回复: 提点谈不上，对于芯片和硬件我连从业者都还算不上。不过过去几年的繁荣主要是来自于Intel CPU的极限性能提升已经到头了。所以反而大家回头去找其他的解决方案，在体系结构层面又有了很多新的机会。我觉得大家都可以去读一读 David Patterson 老爷爷的 <计算机体系结构新黄金时代：历史、挑战和机遇> 这个访谈 "),n("a",y,[s("https://www.bilibili.com/video/av46710093/"),e(a)])]),B,R])])}const E=p(m,[["render",w],["__file","H54-理解Disruptor（上）.html.vue"]]);export{E as default};
