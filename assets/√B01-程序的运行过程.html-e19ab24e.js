import{_ as p}from"./plugin-vue_export-helper-c27b6911.js";import{r as c,o as n,c as a,a as l,b as r,e as o,d as s}from"./app-cdabc73c.js";const t="/assets/418b94aed8aab2abf6538a103d9f2856-954ed0cb.png",d="/assets/f2b10135ed52436888a793327e4d5a4a-d731e7a3.jpg",i="/assets/6914497643dbb0aaefffc32b865dcf7d-727017d1.png",b="/assets/43812abfe104d6885815825f07622e87-864e8dd4.jpg",u="/assets/bde34df011c397yy42dc00fe6bd35226-be06f77f.jpg",h="/assets/3991a042107b90612122b14596c65614-8242abfe.jpeg",m="/assets/5d4889e7bf20e670ee71cc9b6285c96e-96435550.jpg",_={},g=l("h1",{id:"√01-程序的运行过程-从代码到机器运行",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#√01-程序的运行过程-从代码到机器运行","aria-hidden":"true"},"#"),r(" √01 | 程序的运行过程：从代码到机器运行")],-1),f=l("p",null,"你好，我是 LMOS。",-1),P=l("p",null,"欢迎来到操作系统第一课。在真正打造操作系统前，有一条必经之路：你知道程序是如何运行的吗？",-1),H=l("p",null,"一个熟练的编程老手只需肉眼看着代码，就能对其运行的过程了如指掌。但对于初学者来说，这常常是很困难的事，这需要好几年的程序开发经验，和在长期的程序开发过程中对编程基本功的积累。",-1),k=l("p",null,"我记得自己最初学习操作系统的时候，面对逻辑稍微复杂的一些程序，在编写、调试代码时，就会陷入代码的迷宫，找不到东南西北。",-1),W=l("p",null,[r("不知道你现在处在什么阶段，是否曾有同样的感受？"),l("strong",null,[r("我常常说，扎实的基本功就像手里的指南针，"),l("code",null,"你可以一步步强大到不依赖它，但是不能没有"),r("。")])],-1),C={href:"https://gitee.com/lmos/cosmos/tree/master/lesson01/HelloWorld",target:"_blank",rel:"noopener noreferrer"},v=s('<p><strong>一切要从牛人做的牛逼事说起</strong></p><p><strong>第一位牛人，是世界级计算机大佬的传奇——Unix 之父 Ken Thompson</strong>。</p><p>在上世纪 60 年代的一个夏天，Ken Thompson 的妻子要回娘家一个月。呆在贝尔实验室的他，竟然利用这极为孤独的一个月，开发出了 UNiplexed Information and Computing System（UNICS）——即 UNIX 的雏形，一个全新的操作系统。</p><p>要知道，在当时 C 语言并没有诞生，从严格意义上说，他是用 B 语言和汇编语言在 PDP-7 的机器上完成的。</p><img src="'+t+`" alt="img" style="zoom:25%;"><p><strong>牛人的朋友也是牛人，他的朋友 Dennis Ritchie 也随之加入其中，共同创造了大名鼎鼎的 C 语言，并用 C 语言写出了 UNIX 和后来的类 UNIX 体系的几十种操作系统，也写出了对后世影响深远的第一版“Hello World”</strong>：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;stdio.h&quot;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Hello World!\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>计算机硬件是无法直接运行这个 C 语言文本程序代码的，需要 <mark>C 语言编译器</mark>，把这个代码编译成<em>具体硬件平台的二进制代码</em>。再由具体操作系统建立进程，把这个二进制文件装进其进程的内存空间中，才能运行。</p><p>听起来很复杂？别急，接着往下看。</p><h2 id="程序编译过程" tabindex="-1"><a class="header-anchor" href="#程序编译过程" aria-hidden="true">#</a> 程序编译过程</h2><p>我们暂且不急着摸清操作系统所做的工作，先来研究一下编译过程和硬件执行程序的过程，约定使用 GCC 相关的工具链。</p><p>那么使用命令：<code>gcc HelloWorld.c -o HelloWorld</code> 或者 <code>gcc ./HelloWorld.c -o ./HelloWorld</code> ，就可以编译这段代码。其实，GCC 只是完成编译工作的驱动程序，它会根据编译流程分别调用<code>1 预处理程序、2 编译程序、3 汇编程序、4 链接程序</code>来完成具体工作。</p><p>下图就是编译这段代码的过程：</p><img src="`+d+'" alt="img" style="zoom:15%;"><p>HelloWorld编译流程</p><p>其实，我们也可以手动控制以上这个编译流程，从而留下中间文件方便研究：</p><ul><li>gcc HelloWorld.c -E -o HelloWorld.i <code>预处理</code>：加入头文件，替换宏。</li><li>gcc HelloWorld.c -S -c -o HelloWorld.s <code>编译</code>：包含预处理，将 C 程序转换成==.s 汇编程序==。</li><li>gcc HelloWorld.c -c -o HelloWorld.o <code>汇编</code>：包含预处理和编译，将汇编程序转换成==.o 可链接的二进制程序==。</li><li>gcc HelloWorld.c -o HelloWorld <code>链接</code>：包含以上所有操作，将可链接的二进制程序和其它别的库链接在一起，形成<mark>ELF 可执行的程序文件</mark>。</li></ul><h2 id="程序装载执行" tabindex="-1"><a class="header-anchor" href="#程序装载执行" aria-hidden="true">#</a> 程序装载执行</h2><p>对运行内容有了了解后，我们开始程序的装载执行。</p><p>我们将请出<strong>第三位牛人——大名鼎鼎的阿兰·图灵。在他的众多贡献中，很重要的一个就是提出了一种理想中的机器：图灵机。</strong></p><p>图灵机是一个抽象的模型，它是这样的：有一条无限长的纸带，纸带上有无限个小格子，小格子中写有相关的信息，纸带上有一个读头，读头能根据纸带小格子里的信息做相关的操作并能来回移动。</p><p>文字叙述还不够形象，我们来画一幅插图：</p><img src="'+i+'" alt="img" style="zoom:50%;"><p>不理解？下面我再带你用图灵机执行一下“1+1=2”的计算，你就明白了。我们定义读头读到“+”之后，就依次移动读头两次并读取格子中的数据，最后读头计算把结果写入第二个数据的下一个格子里，整个过程如下图：</p><img src="'+b+'" alt="img" style="zoom:15%;"><p>图灵机计算过程演示</p><p>这个理想的模型是好，但是理想终归是理想，想要成为现实，我们得想其它办法。</p><p><strong>于是，第四位牛人来了，他提出了电子计算机使用<em>二进制数制系统</em>和<em>储存程序</em>，并按照程序顺序执行，他叫冯诺依曼，他的电子计算机理论叫冯诺依曼体系结构。</strong></p><h3 id="基本功能" tabindex="-1"><a class="header-anchor" href="#基本功能" aria-hidden="true">#</a> 基本功能</h3><p>根据冯诺依曼体系结构构成的计算机，必须具有如下功能：</p><ul><li>把程序和数据装入到计算机中；</li><li>必须具有长期记住程序、数据的中间结果及最终运算结果；</li><li>完成各种算术、逻辑运算和数据传送等数据加工处理；</li><li>根据需要控制程序走向，并能根据指令控制机器的各部件协调操作；</li><li>能够按照要求将处理的数据结果显示给用户。</li></ul><h3 id="基本组成" tabindex="-1"><a class="header-anchor" href="#基本组成" aria-hidden="true">#</a> 基本组成</h3><p>为了完成上述的功能，计算机必须具备五大基本组成部件：</p><ul><li>装载数据和程序的<mark>输入设备</mark>；</li><li>记住程序和数据的<mark>存储器</mark>；</li><li>完成数据加工处理的<mark>运算器</mark>；</li><li>控制程序执行的<mark>控制器</mark>；</li><li>显示处理结果的<mark>输出设备</mark>。</li></ul><p>根据冯诺依曼的理论，我们只要把图灵机的几个部件换成电子设备，就可以变成一个最小核心的电子计算机，如下图：</p><img src="'+u+'" alt="img" style="zoom:25%;"><p>是不是非常简单？这次我们发现读头不再来回移动了，而是靠<code>地址总线</code>寻找对应的“纸带格子”。读取写入数据由<code>数据总线</code>完成，而动作的控制就是<code>控制总线</code>的职责了。</p><h2 id="更形象" tabindex="-1"><a class="header-anchor" href="#更形象" aria-hidden="true">#</a> 更形象</h2><p>更形象地将 HelloWorld 程序装入原型计算机</p><p>下面，我们尝试将 HelloWorld 程序装入这个原型计算机，在装入之前，我们先要搞清楚 HelloWorld 程序中有什么。</p><p>我们可以通过 <code>gcc -c -S HelloWorld</code> 得到（只能得到其汇编代码，而不能得到二进制数据）。我们用 <code>objdump -d HelloWorld</code> 程序，得到 <code>/lesson01/HelloWorld.dump</code>，其中有很多库代码（只需关注 main 函数相关的代码），如下图：</p><img src="'+h+'" alt="img"><p>以上图中，分成四列：</p><ol><li>第一列为地址；</li><li>第二列为十六进制，表示真正装入机器中的代码数据；</li><li>第三列是对应的汇编代码；</li><li>第四列是相关代码的注释。</li></ol><blockquote><p>这是 x86_64 体系的代码，由此可以看出 x86 CPU 是变长指令集。</p></blockquote><p>接下来，我们把这段代码数据装入最小电子计算机，状态如下图：</p><img src="'+m+'" alt="img" style="zoom:15%;"><p>PS：上图内存条中，一个小格子中只要一个字节，但是图中放的字节数目不等，这是为了方便阅读，不然图要画得很大。</p><h2 id="重点回顾" tabindex="-1"><a class="header-anchor" href="#重点回顾" aria-hidden="true">#</a> 重点回顾</h2><p>以上，对应图中的伪代码你应该明白了：现代电子计算机正是通过内存中的信息（指令和数据）做出相应的操作，并通过内存地址的变化，达到程序读取数据，控制程序流程（顺序、跳转对应该图灵机的读头来回移动）的功能。</p><p>这和图灵机的核心思想相比，没有根本性的变化。只要配合一些 I/O 设备，让用户输入并显示计算结果给用户，就是一台现代意义的电子计算机。</p><p>到这里，我们理清了程序运行的所有细节和原理。还有一点，你可能有点疑惑，即 printf 对应的 puts 函数，到底做了什么？而这正是我们后面的课程要探索的！</p><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题" aria-hidden="true">#</a> 思考题</h2><p>为了实现 C 语言中函数的调用和返回功能，CPU 实现了函数调用和返回指令，即上图汇编代码中的“call”，“ret”指令，请你思考一下：call 和 ret 指令在逻辑上执行的操作是怎样的呢？</p><p>期待你在留言区跟我交流互动。如果这节课对你有所启发，也欢迎转发给你的朋友、同事，跟他们一起学习进步。</p><h2 id="评论区" tabindex="-1"><a class="header-anchor" href="#评论区" aria-hidden="true">#</a> 评论区</h2>',56),x=s("<p>思考题: 首先假设CPU执行指令是顺序执行的，那么程序的调用需要考虑几个问题:<br> 1，call指令要执行的代码在哪？也就是被调用函数的第一条指令所在的内存地址<br> 2，被调用函数执行完之后，返回哪个位置继续执行？<br> 只要解决上面这两个问题，那么函数调用时指令的间的跳转就迎刃而解了。<br> （1）针对第一个问题，在gcc编译完成之后，函数对应的指令序列所在的位置就已经确定了，因此这是编译阶段需要考虑的问题<br> （2）至于第二个问题，在执行完call指令的同时，需要将call指令下面一条指令的地址保存到栈内存中，同时更新%rsp寄存器指向的位置，然后就可以开始执行被调函数的指令序列，执行完毕后，由ret指令从rsp中获取栈顶的returnadress地址，然后跳转到call的下一条指令继续执行。<br> 以上答案参考csapp 3.7.2小节的内容，加上自己的理解</p><p>作者回复：666</p><p>其他网友：感觉有点疑问，这里函数调用地址不是应该运行时确定吗？不然一个可执行程序，从电脑 a复制到电脑b，它的函数地址还是a1b2f3e4这样？</p><p>其他网友：可能是由于程序运行时使用的是虚拟地址空间，比如某个程序中某条mov指令的地址是5，在电脑a里，假设虚拟地址空间的0号地址映射到真实地址为100，那么mov指令的真实地址就是105；在电脑b里，假设虚拟地址空间的0号地址映射到真实地址为200，那么mov指令的真实地址就是205。虽然换了电脑，但指令mov的地址可以一直是5。</p><p>其他网友：就像&quot;bl&quot;,保存link register，然后bx lr返回保存的地址</p><hr><p>macOS 环境填坑。</p><ol><li>gcc 要改成 gcc-11。</li><li>HelloWorld.dump 文件通过管道生成，即 objdump -d HelloWorld &gt;&gt; HelloWorld.dump<br> 作者回复: 正确</li></ol><hr><p>我们可以通过 gcc -c -S HelloWorld 得到（只能得到其汇编代码，而不能得到二进制数据）。我们用 objdump -d HelloWorld 程序，得到 /lesson01/HelloWorld.dump</p><p>这一段里的两个命令是不是错了啊，我在macOS和centos尝试都是不行啊!应该是 gcc -c -S HelloWorld.c 和 objdump -d HelloWorld &gt; HelloWorld.dump 吧<br> 作者回复: 是的</p><hr><p>call和ret其实是一对相反指令，调用call时会将当前IP入栈，即push IP，然后执行跳转即jmp，而ret也是将栈中的IP推出写入IP寄存器，即pop IP。<br> 作者回复: 你好，pedro，我看的出你的x86汇编语言的功底深厚<br> 其他网友：补充一点，在执行ret时，程序逻辑需要保证栈顶指针esp指向的的确是返回地址</p><hr><p>call 指令会把当前的 PC(CS:IP) 寄存器里的下一条指令的地址压栈，然后进行JMP跳转指令；<br> ret 指令则把 call 调用时压入的 PC 寄存器里的下一条指令出栈，更新到 PC 寄存器中<br> 作者回复: 你好，回答正确</p><hr><p>实验环境补充：<br> 上面没讲到实验环境。可以这样做：<br> 1、安装虚拟机，windows/macos上都可以装vmware虚拟机，具体百度<br> 2、在虚拟机中安装linux发行版系统，如centos或ubuntu，具体百度<br> 3、在linux系统里安装gcc工具<br> 4、写好源代码，然后就能gcc编译它了，编译命令，引用 AIK 同学的：</p><p>程序编译过程填坑<br> 源文件生成预处理文件： gcc -E HelloWorld.c -o HelloWorld.i<br> 预处理文件生成编译文件： gcc -S HelloWorld.i -o HelloWorld.s<br> 编译文件生成汇编文件： gcc -c HelloWorld.s -o HelloWorld.o<br> 汇编文件生成可执行文件：gcc HelloWorld.o -o HelloWorld<br> 源文件生成可执行文件：gcc HelloWorld.c -o HelloWorld<br> Linux系统运行可执行文件：./HelloWorld<br> —— 引用自 AIK 同学<br> 作者回复: 你好，技术66666啊<br> 其他网友：我也多补充一点，在windows上使用完整编译链工具可以使用msys2+Mingw</p><hr><p>编译四步骤：预处理（gcc -E -o）、编译（gcc -s -c）、汇编（gcc -c）、链接（gcc -o）。</p><hr>",21),I=l("br",null,null,-1),S={href:"https://blog.csdn.net/u013570834/article/details/108753839",target:"_blank",rel:"noopener noreferrer"},y=l("br",null,null,-1),w=l("hr",null,null,-1),j=l("p",null,"编译是不是就是作了个词法分析和语法分析。汇编是把分析的结果翻译成平台相关的机器指令，这个时候的里面的地址都是相对地址。然后连接就是把其他库考虑进来，加上CPU的具体特性，生成绝对的虚拟地址？所以对于一个可执行文件或者二进制目标文件而言，所涉及的地址都是虚拟地址，实地址是程序执行的时候，操作系统动态映射的。我这样理解不知道对不对？",-1),U=l("hr",null,null,-1),z=l("p",null,[r("老师能否推荐一份快速入门汇编语言的阅读材料，让我们能看懂这些汇编代码"),l("br"),r(" 作者回复: 其实汇编代码很少的 王爽的《汇编语言》")],-1),q=l("hr",null,null,-1),N=l("p",null,[r("什么时候可以出书，八九百页那种，贵一点没关系，比较喜欢纸质。"),l("br"),r(" 作者回复: 哈哈 刚好用来垫显示器")],-1),E=l("hr",null,null,-1),O=l("br",null,null,-1),B=l("br",null,null,-1),L=l("br",null,null,-1),M=l("br",null,null,-1),A=l("br",null,null,-1),K={href:"https://zhuanlan.zhihu.com/p/373996858",target:"_blank",rel:"noopener noreferrer"},R=l("br",null,null,-1),T=s("<hr><p>书跟专栏在内容上有什么区别呢？<br> 作者回复: 你好，Fan，书比较单一，书中是lmosem基于arm920非常古老了。专栏是基于X86-64，每章节在讲解原理并实践后再去和linux对比，自己学会的同时，加深了对linux的理解 ，增加了虚拟化和云相关的内容</p><hr><p>1.call和ret指令都是转移指令，它们都修改IP的值，或同时修改CS和IP的值。它们经常共同用语实现子程序的设计。</p><p>2.CPU执行ret指令时，<br> （1）(IP)=((ss)*16+(sp))<br> 得到IP地址，并将IP出栈<br> （2）(sp)=(sp)+2<br> 将IP更新到 PC 寄存器中</p><p>3.CPU执行call指令时，进行两步操作：<br> (1)将当前的IP或CS和IP压入栈中；<br> (2)转移(jmp)到对应的ip或cs执行代码</p><p>注释：ss sp就是栈堆的指针,和cs ip 是代码段指针，知道ss，sp求物理地址的公式是 物理地址=ss* 16+ sp，或者物理地址=ss* 10H+ sp 也就是对于2进制来说，ss里的数要加上4个0 再加sp得到物理地址。比如ss存放 1234H sp 存放 2000H ，那么物理地址就是 1234H*10H+2000H=14340H<br> 作者回复: 对的</p><hr><p>最强生产力是老婆回娘家<br> 作者回复: 哈哈</p><hr><p>不太了解汇编的知识，读着稍微有点压力，老师能给点意见吗？<br> 作者回复: 不要害怕 汇编代码很少 可以看看王爽的《汇编程序》</p><hr><p>call子程序调用和jump的区别是call会把pc下一个指令压栈，同时也会把逻辑运算等寄存器也进行压栈，等待执行ret的时候，把栈弹出来到pc指定继续执行，同时也会把一些栈数据弹到特殊的寄存器也。这样可以继续执行。而jump d执行很简单就是pc + d执行指令就好了<br> 作者回复: 是啊</p><hr><p>call S 本质上就是 push ip 然后 jmp S<br> ret 就是 pop ip<br> 通俗的来讲就是将 ip寄存器中的指令地址存放到栈中保存<br> ip 寄存器就是存放下次取指地址，所以只要改变这个寄存器里的数据就能做到跳转<br> 作者回复: 对的</p><hr><p>冯诺依曼体系中，程序运行离不开三个总线： 地址总线 ，参数是地址，可以寻找到内存中的地址，然后通过数据总线进行数据的读写，读写完成之后，需要确定并执行后面的指令，这个时候就需要控制总线，顺序执行或者跳转来获取下一个执行的指令。</p><p>call是进行函数调用，函数本质是一系列指令的集合，会被加载到内存的某个位置，call调用就是跳转到函数指令集的首地址开始执行。执行完毕后ret指令从rsp中获取栈顶的returnadress地址，跳转到call的下一条指令执行<br> 作者回复: 正确</p><hr>",19),V={href:"https://github.com/cymcarlos/Cosmos.git",target:"_blank",rel:"noopener noreferrer"},X=l("br",null,null,-1),D=l("br",null,null,-1),J=s(`<hr><p>我来整体的描述一下call指令的执行过程.首先其实call前面的地址是一个假地址,也就是当这个可执行文件没有转换成进程的时候call的函数入口的地址是一个假地址,只有在放入进程的时候通过某些操作才能产生一个真实的地址,然后call才能去调用这个函数.依次是创建进程-&gt;找到链接器-&gt;找到动态库-&gt;根据plt和got表找到函数地址-&gt;加载器加载-&gt;地址改变-&gt;调用puts函数.<br> 而对于ret指令,当进入一个函数的调用前,会将call的下一条指令的地址放入栈中,执行被调用函数序列后,获得原call指令下一条指令地址,返回调用函数<br> 作者回复: 啊，这样也对</p><hr><p>call指令会跳转到目标地址 在跳转前会保存返回地址 。ret指令会取出栈帧中的地址，跳转回之前保存的返回地址<br> 作者回复: 你好，你说的对，正确的</p><hr><p>老师。我一直有个问题 操作系统是c语言写的 c语言需要编译器编译 启动的时候是不要先运行编译器呢 这个过程 没明白<br> 作者回复: 最开始的操作系统 不是用 C语言写的</p><p>其他网友：个人这么理解的：编译器就是个二进制，二进制就是需要放在操作系统中执行，而操作系统是已经编译过的二进制，不需要再次编译，所以操作系统启动的时候不需要启动编译器，而编译器启动的时候需要依赖操作系统。那么一开始操作系统是怎么编译成二进制的呢。猜测，操作系统一开始用汇编写的简版，运行起来后，再在操作系统上写对应的c编译器，然后在用这编译器编译操作系统代码生成功能比较完善的操作系统，然后再运行功能比较完善的操作系统。如此反复，编译器和操作系统都一直都完善</p><p>其他网友：最开始的操作系统是通过二进制代码写的，写了第一个操作系统以后，并完成相应功能，再在操作系统上完善其他功能</p><p>其他网友：始祖编译器是机器码写的，有了第一个就可以搞出无数个</p><hr><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker pull ubuntu
docker run -itd --name myubuntu ubuntu /bin/bash
docker exec -it myubuntu /bin/bash
apt-get update
apt-get install vim gcc
vim HelloWorld.c
gcc ./HelloWorld.c -o HelloWorld
./helloWorld
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><p>1、Ken Thompson 和 Dennis Ritchie共同创造出了C语言。但由C语言写成的源程序，计算机硬件并不能直接执行，需要经过预处理、编译、汇编和链接形成可执行的机器语言。由操作系统加载执行。<br> 2、阿兰图灵提出了图灵机概念，即读头通过读取纸带上的信息来进行相应的操作和运算。之后冯诺依曼提出了在使用二进制数值系统和存储程序，以及程序顺序执行的概念，并将现代计算机组成分为5大部分：<br>  输入设备：输入数据和程序<br>  输出设备：显示计算结果<br>  运算器：进行算术运算和逻辑运算<br>  控制器：控制程序的执行<br>  存储器：存储程序和数据<br> 其中输入/输出设备统称为I/O设备，而运算器，控制器和内存组成CPU。<br> 3、call指令操作：<br>  将当前CS和IP寄存器中的内容入栈。<br>  Push IP<br>  修改IP寄存器指向被调用函数的入口。<br>  JMP near ptr 标号<br> 4、ret指令操作：<br>  执行出栈操作，使得CS和IP指向调用前的指令<br>  Pop IP<br> 我看王爽老师的汇编语言中提到call指令可进行位移和段间转移。对于位移，call指令只将IP入栈，之后根据标号修改IP内容，执行段内近转移。而在执行段间转移时，会将CS和IP都入栈，然后修改CS和IP的内容。<br> 但ret指令只修改IP的内容，实现近转移。Retf指令同时修改CS和IP的内容实现远转移。<br> 因此我理解的是当使用call和ret指令来调用函数时，应该是进行段内近转移，即只修改IP的内容，因此只将IP入栈和出栈。<br> 作者回复: 嗯嗯 是的</p><hr><p>老师，主调函数调用被调函数时，传递给被调函数的实参是压入主调函数的栈里面的吗？这部分工作是编译器做的吗？被调函数是怎么取得传给它的参数的呢？是按照什么约定好的顺序还是什么的？<br> 作者回复: 编译器做的 有标准约定的</p><hr><p>没有时间刷CSAPP的同学，也可以参考一本科普级别的书籍：《程序是怎么跑起来的》</p><hr><p>call指令用于函数调用，被调用过程使用call执行调用过程，期间需要执行操作有被调用过程寄存器保存，传入参数保存在寄存器或者栈中，将返回地址压栈，跳转至调用过程的首地址（修改PC寄存器值）<br> ret指令用于函数返回，函数的返回值保存在寄存器中，当栈帧区清理完成后，ret将出栈的函数返回地址压入PC寄存器中，实现程序执行返回<br> 作者回复: 是的，你非常聪明</p><hr><p>老师，当前主流的架构主要是x86和arm，他们的指令集对应的是复杂级和精简级。我对x86这一块的汇编不是很了解，老师可不可以将这方面的知识或者相关的资料分享我们先学习一下，也方便后续课程的理解。<br> 作者回复: 王爽的《汇编程序》</p><hr><p>从用户栈和机器代码的角度进行分析call和ret指令，在执行call指令的时候，首先知道栈的原则是由高地址到低地址进行增长的，其中有一个rsp寄存器始终指向用户的栈的最低的地址，call指令(在调用新的函数)执行的时候(因为函数需要返回所以首先是rsp寄存器-8,然后将rip寄存器也就是当前函数的下一条指令的地址位置放到rsp-8之后的用户栈的地方)，然后rip会指向下一个函数指令的起始位置。ret指令相当于是上面的相反操作，某种情况下就是popq rip，弹出用户栈相关的数据到rip寄存器里面，然后rsp寄存器+8.<br> 作者回复: 是的 正确</p><hr><p>学习过《计算机组成原理与系统结构》的孩子表示学起来轻松很多，强烈推荐《深入理解计算机系统》一书，即《Computer Systems: A Programmer&#39;s Perspective》（《CSAPP》）一书，我们也是用来当教材，特别是去做书上配套的Lab，可以更深入理解计算机底层的一些东西，我想应该有利于之后的操作系统的学习吧。<br> 作者回复: 是的</p><hr><p>其实，我们也可以手动控制以上这个编译流程，从而留下中间文件方便研究：<br> • gcc HelloWorld.c -E -o HelloWorld.i 预处理：加入头文件，替换宏。<br> • gcc HelloWorld.c -s -c HelloWorld.s 编译：包含预处理，将 C 程序转换成汇编程序。(勘误：$ gcc -S HelloWorld.c, 会输出 HelloWorld.s 文件）<br> • gcc HelloWorld.c -c HelloWorld.o 汇编：包含预处理和编译，将汇编程序转换成可链接的二进制程序。（勘误： $ gcc HelloWorld.c -c ，会输出 HelloWorld.o 文件）<br> • gcc HelloWorld.c -o HelloWorld 链接：包含以上所有操作，将可链接的二进制程序和其它别的库链接在一起，形成可执行的程序文件。</p><hr><p>在苹果M1上尝试了下，arm64RISC的果然与x86这种CISC不一样<br> 0000000100003f38 &lt;_main&gt;:<br> 100003f38: ff c3 00 d1 sub sp, sp, #48<br> 100003f3c: fd 7b 02 a9 stp x29, x30, [sp, #32]<br> 100003f40: fd 83 00 91 add x29, sp, #32<br> 100003f44: 08 00 80 52 mov w8, #0<br> 100003f48: bf c3 1f b8 stur wzr, [x29, #-4]<br> 100003f4c: a0 83 1f b8 stur w0, [x29, #-8]<br> 100003f50: e1 0b 00 f9 str x1, [sp, #16]<br> 100003f54: 00 00 00 90 adrp x0, #0<br> 100003f58: 00 a0 3e 91 add x0, x0, #4008<br> 100003f5c: e8 0f 00 b9 str w8, [sp, #12]<br> 100003f60: 06 00 00 94 bl 0x100003f78 &lt;dyld_stub_binder+0x100003f78&gt;<br> 100003f64: e8 0f 40 b9 ldr w8, [sp, #12]<br> 100003f68: e0 03 08 aa mov x0, x8<br> 100003f6c: fd 7b 42 a9 ldp x29, x30, [sp, #32]<br> 100003f70: ff c3 00 91 add sp, sp, #48<br> 100003f74: c0 03 5f d6 ret<br> 作者回复: 是的</p><hr><p>逻辑上调用函数之前调用者会保存当前现场，然后再进行调用，被调用者进入后会保存父函数的栈帧，然后创建自己的栈帧后执行函数部分。<br> 作者回复: 是的</p><hr><p>思考题：<br> 1\\当调用call指令时，会先将当前的IP指针的下一条代码的地址入栈（段地址也有可能要入栈），接着将继续执行PC指针所指向的下一条程序的代码段（这个时候已经进入被call函数中了）。<br> 2\\当代码段执行完毕之后ret指令会将栈顶元素弹出给PC指针返回到原来位置继续执行。<br> 作者回复: 是的</p><hr><p>call和ret分别代表压栈和入栈操作。<br> 1、call将寄存器的值和程序计数器的值存入栈当中；<br> 2、ret则是将栈中的值弹出，赋值给寄存器和程序计数器<br> 作者回复: 是的</p><hr><p>刚学过一点汇编，对于作者的提问：<br> call和ret指令是完成子程序设计所必要，CPU只会根据CS:IP寄存器的值进行取指令、执行指令的操作，因此要实现程序的跳转执行，那么必要的就是改变CS、IP的指向，也就是它们对应存储的地址，执行完子程序还要实现返回到主程序继续执行，怎么半，当然只能是再重复上面的操作-&gt; 改变CS、IP，那么，此时我们又怎样去获取主程序的位置呢，没办法，只能在调用子程序前保存主程序中的执行状态（此时的执行位置），用栈是一个不错的选择，那么call指令执行实质完成的操作就清晰了，首先，将当前的IP或CS和IP压入栈中，随后，修改CS、IP完成转移；<br> 反之，从子程序返回需要做的事情就恰好与call相反，这就是ret指令完成的工作，首先从栈中获取之前的状态，再对IP进行修改，实现程序间的跳转。<br> 作者回复: 对 对</p><hr><p>call 调用函数，指定“读头”转到被调用函数的内存地址去，执行被调用函数的内容<br> ret 返回，被调用函数执行完毕后，返回到之前该函数被调用的位置，继续之前的动作<br> 作者回复: 是的</p><hr><p>call指令调用别的函数：（1）函数参数压栈（2）返回地址压栈（3）跳转<br> 被调用函数：（1）旧的ebp压栈（2）ebp=esp (3) 分配栈空间<br> ret返回调用自己的函数：（1）esp=ebp (2) 弹出ebp，调用函数栈帧还原（3）弹出返回地址并跳转<br> 作者回复: 是的</p><hr><p>刚把计算机组成原理给搞完~<br> call:指令会把当前的寄存器里的下一条指令的地址压栈，然后进行JMP跳转指令。<br> ret:指令则把call调用时压入的寄存器里的下一条指令出栈，更新到PC寄存器中。<br> 作者回复: 哈哈回答正确</p><hr>`,44),F={href:"https://yzhe819.github.io/blogs/Operation_System/000001.html",target:"_blank",rel:"noopener noreferrer"},G=l("br",null,null,-1),$=l("br",null,null,-1),Q=s("<hr><p>Call指令和ret指令依赖栈对pc指向进行操作。call分为直接或间接，且call所对应的程序代码段在符号被解析前还拥有自调整参数。<br> 作者回复: 是的 正确的</p><hr><p>call和ret的一般用法很多人都说了，来补充call和ret的一些其他作用。<br> ret指令常见的长返回和返回，还能实现带有特权级转换的长返回。<br> 在调用门的实现中，从低特权级到高特权级通过调用门和call来实现；从高特权级到低特权级通过ret来实现。<br> 作者回复: 6666，你功底深厚啊</p><hr><p>“call” 把程序计数器设置为函数调用的起始位置<br> “ret” 把程序计数器设置为调用函数后面那条语句指令的地址<br> 作者回复: 赞！</p><hr><p>call和ret都是跳转，call 程序调转到函数的代码段并且os做出一个栈，执行完逻辑后，ret跳转到函数的调用处（入栈会保留一个调用地址）<br> 作者回复: 你好 是的</p><hr><p>如果是保护模式下不需要加载ds段选择子情况下执行call调用另一个函数，那么在程序运行的当前栈里压入指令指针寄存器，并加载call操作数到指令指针寄存器开始执行新的程序片段，执行完毕后通过执行ret将栈指针寄存器指向的栈内容（正确情况下是被保存的旧指令指针寄存器内容）<br> 作者回复: 是的 正确的</p><hr><p>call指令：<br> 1.当前程序指令执行完的下条指令的cs和ip地址入栈：pusu cs；push ip<br> 2.直接寻址跳转指令jump + 访问程序地址</p><p>ret指令：返回原调用程序的地址<br> pop cs<br> pop ip<br> 地址返回到call指令的下条指令处</p><p>linux 线程切换时候，就用了函数调用的原理来实现线程栈的切换以及线程地址切换，进而实现线程的切换<br> 作者回复: 对对对</p><hr>",15);function Y(Z,ll){const e=c("ExternalLinkIcon");return n(),a("div",null,[g,f,P,H,k,W,l("p",null,[r("因此今天，我将带领你从“Hello World”起，扎实基本功，探索程序如何运行的所有细节和原理。这节课的配套代码，你可以从"),l("a",C,[r("这里下载"),o(e)]),r("。")]),v,l("blockquote",null,[x,l("p",null,[r("王爽汇编的笔记 快速入门，最近在啃 csapp"),I,l("a",S,[r("https://blog.csdn.net/u013570834/article/details/108753839"),o(e)]),y,r(" 作者回复: 是的 汇编代码很少 却很重要")]),w,j,U,z,q,N,E,l("p",null,[r("思考题：答：“call”即“打电话”，“ret”即”返回某个地方“。要想实现这两个指令，那么首先call需要知道调用的东西在哪，ret需要返回的地方在哪。"),O,r(" 对于call，在程序编译完成之后，所有的指令代码都已按顺序存储至计算机中，事先在call 之后附上相应的存储地址即可；"),B,r(" 对于ret，其实计算机是使用一种叫做“栈”的结构，简单来说“栈”就好像是一个桶，计算机不停地往里扔东西（压栈），只有拿起上面的东西（出栈），才能拿到下面的东西。ret即是利用栈的结构，来存储自己将要返回的地方。"),L,r(" 另外，call与ret是配套使用的。call的时候会将此时运行到的位置压入栈中，ret会从栈中弹出自己将要返回的位置。"),M,r(" 彭东老师写的真的不错，后面会把笔记精简一下："),A,l("a",K,[r("https://zhuanlan.zhihu.com/p/373996858"),o(e)]),R,r(" 作者回复: “栈”就好像是一个桶，计算机不停地往里扔东西（压栈），只有拿起上面的东西（出栈），才能拿到下面的东西。 这个比喻绝了")]),T,l("p",null,[l("a",V,[r("https://github.com/cymcarlos/Cosmos.git"),o(e)]),X,r(" 课程代码注释版，还有xmind思维导图的梳理。 有兴趣的同学可以看看， 有错误的地方可以多多指正。"),D,r(" 作者回复: 6666666")]),J,l("p",null,[l("a",F,[r("https://yzhe819.github.io/blogs/Operation_System/000001.html"),o(e)]),G,r(" 把老师的课程和我大学elf分析作业结合了一下，知识点不记下来发现都忘得差不多了"),$,r(" 作者回复: 6666")]),Q])])}const ol=p(_,[["render",Y],["__file","√B01-程序的运行过程.html.vue"]]);export{ol as default};
