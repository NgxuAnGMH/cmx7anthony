import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o as r,c as s,a as e,b as o,e as l,d as c}from"./app-cdabc73c.js";const n="/assets/1ed21092022057ed192a7d9aff76144c-5d21b284.jpg",i="/assets/383bfbb085c1eeb9b9473ae6f18e97a0-d3928fbb.jpeg",d="/assets/4002b5f8f60a913e655d5268348ee201-2562e489.jpeg",h="/assets/6863e10fc635791878d1ecd57618b871-8efadccf.jpeg",_={},m=c('<h1 id="_19-建立数据通路-下-指令-运算-cpu" tabindex="-1"><a class="header-anchor" href="#_19-建立数据通路-下-指令-运算-cpu" aria-hidden="true">#</a> 19 | 建立数据通路（下）：指令+运算=CPU</h1><p>上一讲，我们讲解了时钟信号是怎么实现的，以及怎么利用这个时钟信号，来控制数据的读写，可以使得我们能把需要的数据“存储”下来。那么，这一讲，我们要让计算机“<code>自动</code>”跑起来。</p><p>通过一个时钟信号，我们可以实现计数器，这个会成为我们的 PC 寄存器。然后，我们还需要一个能够帮我们<em>在内存里面寻找指定数据地址</em>的译码器，以及<em>解析读取到的机器指令</em>的译码器。这样，我们就能把所有学习到的硬件组件串联起来，变成一个 CPU，实现我们在计算机指令的执行部分的运行步骤。</p><h2 id="pc-寄存器所需要的计数器" tabindex="-1"><a class="header-anchor" href="#pc-寄存器所需要的计数器" aria-hidden="true">#</a> PC 寄存器所需要的计数器</h2><p>我们常说的 PC 寄存器，还有个名字叫程序计数器。下面我们就来看看，它为什么叫作程序计数器。</p><ul><li>有了时钟信号，我们可以提供定时的输入；</li><li>有了 D 型触发器，我们可以在时钟信号控制的时间点写入数据。</li></ul><p>我们把这两个功能组合起来，就可以实现一个自动的计数器了。</p><p>加法器的两个输入，一个始终设置成 1，另外一个来自于一个 D 型触发器 A。我们把加法器的输出结果，写到这个 D 型触发器 A 里面。于是，D 型触发器里面的数据就会在固定的时钟信号为 1 的时候更新一次。</p><img src="'+n+'" alt="img" style="zoom:25%;"><p>这样，我们就有了一个每过一个时钟周期，就能固定自增 1 的自动计数器了。这个自动计数器，可以拿来当我们的 PC 寄存器。事实上，PC 寄存器的这个 PC，英文就是 Program Counter，也就是<strong>程序计数器</strong>的意思。</p><p>每次自增之后，我们可以去对应的 D 型触发器里面取值，这也是我们下一条需要运行指令的地址。前面第 5 讲我们讲过，同一个程序的指令应该要顺序地存放在内存里面。这里就和前面对应上了，顺序地存放指令，就是为了让我们通过程序计数器就能定时地不断执行新指令。</p><p>加法计数、内存取值，乃至后面的命令执行，最终其实都是由我们一开始讲的时钟信号，来控制执行时间点和先后顺序的，这也是我们需要时序电路最核心的原因。</p><p>在最简单的情况下，我们需要让每一条指令，从程序计数，到获取指令、执行指令，都在一个时钟周期内完成。如果 PC 寄存器自增地太快，程序就会出错。因为前一次的运算结果还没有写回到对应的寄存器里面的时候，后面一条指令已经开始读取里面的数据来做下一次计算了。这个时候，如果我们的指令使用同样的寄存器，前一条指令的计算就会没有效果，计算结果就错了。</p><p>在这种设计下，我们需要在一个时钟周期里，确保执行完一条最复杂的 CPU 指令，也就是耗时最长的一条 CPU 指令。这样的 CPU 设计，我们称之为<strong>单指令周期处理器</strong>（Single Cycle Processor）。</p><p>很显然，这样的设计有点儿浪费。因为即便只调用一条非常简单的指令，我们也需要等待整个时钟周期的时间走完，才能执行下一条指令。在后面章节里我们会讲到，通过流水线技术进行性能优化，可以减少需要等待的时间，这里我们暂且说到这里。</p><h2 id="读写数据所需要的译码器" tabindex="-1"><a class="header-anchor" href="#读写数据所需要的译码器" aria-hidden="true">#</a> 读写数据所需要的译码器</h2><p>现在，我们的数据能够存储在 D 型触发器里了。如果我们把很多个 D 型触发器放在一起，就可以形成一块很大的存储空间，甚至可以当成一块内存来用。像我现在手头这台电脑，有 16G 内存。那我们怎么才能知道，写入和读取的数据，是在这么大的内存的哪几个比特呢？</p><p>于是，我们就需要有一个电路，来完成“寻址”的工作。这个“寻址”电路，就是我们接下来要讲的<mark>译码器</mark>。</p><p>在现在实际使用的计算机里面，内存所使用的 DRAM，并不是通过上面的 D 型触发器来实现的，而是使用了一种 CMOS 芯片来实现的。不过，这并不影响我们从基础原理方面来理解译码器。在这里，我们还是可以把内存芯片，当成是很多个连在一起的 D 型触发器来实现的。</p><p>如果把“寻址”这件事情退化到最简单的情况，就是在两个地址中，去选择一个地址。这样的电路，我们叫作 <strong>2-1 选择器</strong>。我把它的电路实现画在了这里。</p><p>我们通过一个反相器、两个与门和一个或门，就可以实现一个 2-1 选择器。通过控制反相器的输入是 0 还是 1，能够决定对应的输出信号，是和地址 A，还是地址 B 的输入信号一致。</p><img src="'+i+'" alt="img" style="zoom:25%;"><p>2-1 选择器电路示意图</p><p>一个反向器只能有 0 和 1 这样两个状态，所以我们只能从两个地址中选择一个。如果输入的信号有三个不同的开关，我们就能从 23，也就是 8 个地址中选择一个了。这样的电路，我们就叫 <strong>3-8 译码器</strong>。现代的计算机，如果 CPU 是 64 位的，就意味着我们的寻址空间也是 264，那么我们就需要一个有 64 个开关的译码器。</p><img src="'+d+'" alt="img" style="zoom:25%;"><p>当我们把译码器和内存连到一起时，通常会组成这样一个电路</p><p>所以说，其实译码器的本质，就是从输入的多个位的信号中，根据一定的开关和电路组合，选择出自己想要的信号。除了能够进行“寻址”之外，我们还可以把对应的需要运行的指令码，同样通过译码器，找出我们期望执行的指令，也就是在之前我们讲到过的 opcode，以及后面对应的操作数或者寄存器地址。只是，这样的“译码器”，比起 2-1 选择器和 3-8 译码器，要复杂的多。</p><h2 id="建立数据通路-构造一个最简单的-cpu" tabindex="-1"><a class="header-anchor" href="#建立数据通路-构造一个最简单的-cpu" aria-hidden="true">#</a> 建立数据通路，构造一个最简单的 CPU</h2><p>D 触发器、自动计数以及译码器，再加上一个我们之前说过的 ALU，我们就凑齐了一个拼装一个 CPU 必须要的零件了。下面，我们就来看一看，怎么把这些零件组合起来，才能实现指令执行和算术逻辑计算的 CPU。</p><img src="'+h+'" alt="img" style="zoom:25%;"><p>CPU 实现的抽象逻辑图</p><ol><li>首先，我们有一个自动计数器。这个自动计数器会随着时钟主频不断地自增，来作为我们的 PC 寄存器。</li><li>在这个自动计数器的后面，我们连上一个译码器。译码器还要同时连着我们通过大量的 D 触发器组成的内存。</li><li>自动计数器会随着时钟主频不断自增，从译码器当中，找到对应的计数器所表示的内存地址，然后读取出里面的 CPU 指令。</li><li>读取出来的 CPU 指令会通过我们的 CPU 时钟的控制，写入到一个由 D 触发器组成的寄存器，也就是指令寄存器当中。</li><li>在指令寄存器后面，我们可以再跟一个译码器。这个译码器不再是用来寻址的了，而是把我们拿到的指令，解析成 opcode 和对应的操作数。</li><li>当我们拿到对应的 opcode 和操作数，对应的输出线路就要连接 ALU，开始进行各种算术和逻辑运算。对应的计算结果，则会再写回到 D 触发器组成的寄存器或者内存当中。</li></ol><p><em>这样的一个完整的通路，也就完成了我们的 CPU 的一条指令的执行过程</em>。在这个过程中，你会发现这样几个有意思的问题。</p><p><strong>第一个，是我们之前在第 6 讲讲过的程序跳转所使用的条件码寄存器</strong>。那时，讲计算机的指令执行的时候，我们说高级语言中的 if…else，其实是变成了一条 cmp 指令和一条 jmp 指令。cmp 指令是在进行对应的比较，比较的结果会更新到条件码寄存器当中。jmp 指令则是根据条件码寄存器当中的标志位，来决定是否进行跳转以及跳转到什么地址。</p><p>不知道你当时看到这个知识点的时候，有没有一些疑惑，为什么我们的 if…else 会变成这样两条指令，而不是设计成一个复杂的电路，变成一条指令？到这里，我们就可以解释了。这样分成两个指令实现，完全匹配好了我们在电路层面，“译码 - 执行 - 更新寄存器“这样的步骤。</p><p>cmp 指令的执行结果放到了条件码寄存器里面，我们的条件跳转指令也是在 ALU 层面执行的，而不是在控制器里面执行的。这样的实现方式在电路层面非常直观，我们不需要一个非常复杂的电路，就能实现 if…else 的功能。</p><p><strong>第二个，是关于我们在第17 讲里讲到的指令周期、CPU 周期和时钟周期的差异</strong>。在上面的抽象的逻辑模型中，你很容易发现，我们执行一条指令，其实可以不放在一个时钟周期里面，可以直接拆分到多个时钟周期。</p><p>我们可以在一个时钟周期里面，去自增 PC 寄存器的值，也就是指令对应的内存地址。然后，我们要根据这个地址从 D 触发器里面读取指令，这个还是可以在刚才那个时钟周期内。但是对应的指令写入到指令寄存器，我们可以放在一个新的时钟周期里面。指令译码给到 ALU 之后的计算结果，要写回到寄存器，又可以放到另一个新的时钟周期。所以，执行一条计算机指令，其实可以拆分到很多个时钟周期，而不是必须使用单指令周期处理器的设计。</p><p>因为从内存里面读取指令时间很长，所以如果使用单指令周期处理器，就意味着我们的指令都要去等待一些慢速的操作。这些不同指令执行速度的差异，也正是计算机指令有指令周期、CPU 周期和时钟周期之分的原因。因此，现代我们优化 CPU 的性能时，用的 CPU 都不是单指令周期处理器，而是通过流水线、分支预测等技术，来实现在一个周期里同时执行多个指令。</p><h2 id="总结延伸" tabindex="-1"><a class="header-anchor" href="#总结延伸" aria-hidden="true">#</a> 总结延伸</h2><p>好了，今天我们讲完了，怎么通过连接不同功能的电路，实现出一个完整的 CPU。</p><ol><li>我们可以通过自动计数器的电路，来实现<mark>一个 PC 寄存器</mark>，不断生成下一条要执行的计算机指令的内存地址。</li><li>然后通过<mark>译码器</mark>，从内存里面读出对应的指令，写入到 D 触发器实现的指令寄存器中。</li><li>再通过另外一个<mark>译码器</mark>，把它解析成我们需要执行的指令和操作数的地址。</li><li>这些电路，组成了我们计算机五大组成部分里面的<mark>控制器</mark>。</li></ol><p>我们把 opcode 和对应的操作数，发送给 ALU 进行计算，得到计算结果，再写回到寄存器以及内存里面来，这个就是我们计算机五大组成部分里面的运算器。</p><p>我们的时钟信号，则提供了协调这样一条条指令的执行时间和先后顺序的机制。同样的，这也带来了一个挑战，那就是单指令周期处理器去执行一条指令的时间太长了。而这个挑战，也是我们接下来的几讲里要解答的问题。</p><h2 id="推荐阅读" tabindex="-1"><a class="header-anchor" href="#推荐阅读" aria-hidden="true">#</a> 推荐阅读</h2><p>《<code>编码：隐匿在计算机软硬件背后的语言</code>》的第 17 章，用更多细节的流程来讲解了 CPU 的数据通路。《<code>计算机组成与设计 硬件 / 软件接口</code>》的 4.1 到 4.4 小节，从另外一个层面和角度讲解了 CPU 的数据通路的建立，推荐你阅读一下。</p><h2 id="课后思考" tabindex="-1"><a class="header-anchor" href="#课后思考" aria-hidden="true">#</a> 课后思考</h2><p>CPU 在执行无条件跳转的时候，不需要通过运算器以及 ALU，可以直接在控制器里面完成，你能说说这是为什么吗？</p><p>欢迎在留言区写下你的思考和疑惑，你也可以把今天的内容分享给你的朋友，和他一起学习和进步。</p>',49),C=e("p",null,"强烈推荐一本书《自己动手写CPU》，使用这本书，再结合老师的课程，可以自己实现一个简单的CPU！这本书比较友好，是入门级书籍，理论+实战，能够更好地掌握计算机组成原理的理论知识~~",-1),P=e("p",null,"我的理解无条件跳转就是goto，是没有比较结果的. 无条件跳转意味着没有计算的逻辑，应该是可以不经过ALU的，但是要控制器把PC设置成跳转后的指令地址.",-1),u=e("p",null,[o("老师，对于图1的PC计数器，有个疑问，如果图中的D触发器，是电平触发的，那CLK置1的时间段内，触发器输出->加法器+1->触发器输出...... 应该一直进行该循环计算并自增，只有当D触发器是 沿触发的，才会在时钟上升沿只加1次，不知道理解是否有误"),e("br"),o(" 作者回复: 这样理解没有问题.")],-1),g=e("p",null,[o("应该是无条件跳转没有cmp吧"),e("br"),o(" 作者回复: cmp是一条单独的指令，和跳转是否是有条件的没有关系。无条件跳转不需要检查条件码寄存器哦。可以想想这样的话，在硬件上有什么区别呢?")],-1),U=e("br",null,null,-1),f={href:"https://www.cnblogs.com/luoahong/p/11431367.html",target:"_blank",rel:"noopener noreferrer"},b=e("p",null,[o("一个指令的执行想用多少个时钟周期都可以吗？"),e("br"),o(" 作者回复: 一个指令需要的时钟周期是固定的，并不是多少个都可以啊。")],-1),D=e("p",null,[o("无条件跳转不需要依赖于比较结果吗？"),e("br"),o(" 作者回复: 既然是“无条件”了，当然不依赖比较结果啦。")],-1),k=e("p",null,"无条件跳转不需要进行计算，将数据地址信号输入地址译码器后可直接获得下一条指令。无条件跳转不需要进行运算，也不需要寄存器，只要更新pc寄存器即可",-1),x=e("p",null,"总结：我们的程序计数器pc寄存器，随着时钟周期的自增会去内存中通过地址译码器去拿到指令，指令会写入到指令寄存器，指令寄存器会通过译码器去解析opcode和操作数据，连接逻辑运算单元alu进行计算，alu会把计算结果最后写入内存，这样完成了一个指令周期。这一整个时钟周期太长，内存与cpu的速度相差太大，就把整个指令周期进行细分，再通过流水线和分支预测来操作指令的运行顺序性和提高性能。",-1);function A(L,j){const p=t("ExternalLinkIcon");return r(),s("div",null,[m,e("blockquote",null,[C,P,u,g,e("p",null,[o("“怎样通过连接不同功能的电路，实现出一个完整的CPU” 讲的真好"),U,o(" day19 笔记："),e("a",f,[o("https://www.cnblogs.com/luoahong/p/11431367.html"),l(p)])]),b,D,k,x])])}const z=a(_,[["render",A],["__file","C19-建立数据通路（下）.html.vue"]]);export{z as default};
