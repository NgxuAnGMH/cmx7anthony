import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o as t,c as o,a as r,b as e,e as s,d as p}from"./app-cdabc73c.js";const g="/assets/640-1689738695145-51-4b7a2ce6.png",m="/assets/640-1689738695145-52-c34a21d6.png",l="/assets/640-1689738695146-53-f8a9092b.png",d="/assets/640-1689738695146-54-25a74d27.png",c="/assets/640-1689738695146-55-d686ed35.png",u="/assets/640-1689738695146-56-24bb2a36.png",h="/assets/640-1689738695146-57-85c0340f.png",F="/assets/640-1689738695146-58-e1b86eb0.png",z="/assets/640-1689738695146-59-64000c35.png",f={},E=r("h1",{id:"_80-白泽带你读论文-alfore",tabindex:"-1"},[r("a",{class:"header-anchor",href:"#_80-白泽带你读论文-alfore","aria-hidden":"true"},"#"),e(" 80-白泽带你读论文｜ALFORE")],-1),k={href:"https://www.usenix.org/system/files/sec23summer_427-shi_ji-prepub.pdf",target:"_blank",rel:"noopener noreferrer"},_=p('<p><strong>如需转载请注明出处，侵权必究。</strong></p><p><strong>论文题目：AIFORE: Smart Fuzzing Based on Automatic Input Format Reverse Engineering</strong></p><p><strong>发表会议：Security 23</strong></p><p>本篇论文的第一作者是来自清华大学的 Ji Shi 和 Zhun Wang ，来自张超老师的课题组，课题组主要研究方向为漏洞挖掘和 AI 安全。</p><h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><p>Fuzzing 是一种高效的寻找程序中漏洞的技术。通常情况下，Fuzzing 产生大量的输入提供给被测试程序来检测程序漏洞。<mark>输入格式</mark>描述了<em>程序希望输入的字节</em>是如何组织的。理想情况下，格式良好的输入将被正确地解析和处理，以达到预期的结果。<em>不符合格式的输入</em>将被程序中的<mark>解析器</mark>过滤掉，并提前丢弃。因此<em>对一个程序的输入格式的了解程度</em>对于有效生成 Fuzzing 的输入至关重要。<mark>自动输入格式逆向工程</mark>是一种有吸引力但具有挑战性的分析格式的方法。</p><p>本文提出了一个智能Fuzzing解决方案AIFORE，AIFORE充分利用<em>逆向格式</em>智能指导 Fuzzing。输入字段的结构和语义是由处理它们的<mark>基本块 (Basic Block, BB)</mark> 而不是输入规范决定的。AIFORE首先使用<strong>字节级的污点分析</strong>来识别每个BB处理的输入字节，然后用最小集群算法来识别总是一起处理的不可分割的输入字段，并用一个神经网络模型来学习它们的类型，该模型描述了基本块的行为。最后，作者根据推断出的<em>格式知识</em>设计了一种新的能量调度算法来指导智能Fuzzing。本文实现了AIFORE的原型，并评估了格式推断的准确性和对最先进的<em>格式逆向解决方案</em>和Fuzzer的性能。AIFORE在<mark>字段边界</mark>和<mark>类型识别</mark>的准确性上大大超过了SOTA的基准(baseline)。通过AIFORE，本文在15个程序中发现了20个被其他Fuzzer遗漏的Bug。</p><h2 id="贡献" tabindex="-1"><a class="header-anchor" href="#贡献" aria-hidden="true">#</a> 贡献</h2><p>本文的贡献主要有以下四点：</p><ol><li>本文提出了一种字段边界识别方法，该方法使用污点分析来识别输入字节与基本块之间的关系，并利用最小集群算法分割出不可分割的输入字段。</li><li>本文提出了一种新颖的基于深度学习的方法来预测基本块所处理的输入字段的类型。</li><li>本文提出了一种新的基于格式的能量调度算法，以探索不经常出现的输入类型。</li><li>本文实现了一个新的智能Fuzzing解决方案 AIFORE，并对其进行评估。评估结果表明，AIFORE在输入格式识别和基于格式的Fuzzer的性能优于目前SOTA的解决方案。</li></ol><h2 id="挑战" tabindex="-1"><a class="header-anchor" href="#挑战" aria-hidden="true">#</a> 挑战</h2><p>在格式知识的指导下，Fuzzer 可以产生有价值的输入用于探索程序<mark>新的路径</mark>和<mark>利用漏洞</mark>。在输入格式推断和格式引导的 Fuzzing 方面目前有很多研究工作，他们试图回答关于输入格式的三个核心问题：</p><ol><li>不同输入字段的边界在哪里、</li><li>这些字段属于哪种类型、</li><li>如何利用输入格式知识来指导 Fuzzing 。</li></ol><p><code>关于输入字段的边界识别</code>，现有的研究主要依靠统计分析或动态污点分析。动态污点分析将<em>由同一指令处理的字节</em>归入<em>一个单一字段</em>，但是这种方法的局限性在于<strong>一条指令可能会处理多个输入字段</strong>或者<strong>一个长字段会被不同指令处理</strong>而造成字段的错误识别。统计分析需要大量的输入，这些输入往往不可用。</p><p><code>关于输入字段类型的识别</code>，现有的解决方案一般都依赖于<em>先验知识</em>来提取被传入的字段的类型，这些先验知识比较分散且需要大量的人工分析来构造启发式规则并应用，<em>这将不可避免的引入假阳性和假阴性</em>，另外现有的工作只能识别字段的<mark>基本类型</mark>，例如 int ，而不能识别其<mark>语义类型</mark>，例如校验和。</p><p><code>关于输入格式的利用</code>，现有的解决方案一般使用<em>输入格式</em>来指导输入的生成或突变，以尝试测试目标程序中更深的代码，或者使用<em>格式知识</em>来验证种子的有效性。然而，现有的工作（如 AFLSmart）需要人工编写输入格式规范，而如果缺乏字段关系约束的简单模版，就无法区分格式的质量。</p><blockquote><p>在Fuzz领域，动态污点分析（Dynamic Taint Analysis）是一种技术，用于识别和跟踪程序执行过程中的数据流和数据变化。它通过标记（或污点）特定的数据，以识别其如何传播到其他程序的部分。这种技术可以帮助发现潜在的漏洞和安全问题。</p><p>动态污点分析首先会给特定的数据（如用户输入）打上标记，使其成为“污点数据”。当程序执行时，动态污点分析会跟踪这些污点数据在程序中传播的路径和影响范围。它会监测程序中的数据操作，<em>如读/写、复制、传递等</em>，并更新这些数据的污点标记。通过分析污点数据的传播和操作，可以揭示程序中如何处理这些数据，并发现潜在的漏洞或安全问题。</p><p>动态污点分析在Fuzz领域中具有重要的应用。通过对输入数据施加污点标记，它可以帮助确定哪些部分的输入数据与程序的执行路径相关，进而引导模糊测试引擎生成更有针对性的测试用例。例如，如果通过动态污点分析发现输入数据的某部分会直接影响程序中的条件分支语句，那么模糊测试引擎可以重点测试这部分输入数据，<em>以触发潜在的不同执行路径，提高漏洞发现的能力</em>。</p><p>总结来说，动态污点分析是通过标记特定数据并分析其在程序中的传播和操作，以识别潜在漏洞和安全问题的技术。在Fuzz领域中，它可用于指导模糊测试引擎生成更有效的测试用例，提高漏洞发现的效果。</p></blockquote><h2 id="insight" tabindex="-1"><a class="header-anchor" href="#insight" aria-hidden="true">#</a> Insight</h2><p>作者分析程序发现以下三点：</p><ol><li>在大多数情况下，一个不可分割的字段中的字节被放在一个基本块中一起解析</li><li>当程序处理不同类型字段时，程序代码显示出不同的模式</li><li>程序可能会根据输入结构的不同调度不同的代码来解析输入</li></ol><p>作者根据以上三点观察，认为由于输入字段是由基本块分析的，无论输入格式规范如何，都可以从基本块中推断出输入的结构和语义信息，因此可以通过分析处理不同输入字段的基本块来学习输入字段的结构和语义，然后利用这些知识来进行智能 Fuzzing 。</p><h2 id="工作流程" tabindex="-1"><a class="header-anchor" href="#工作流程" aria-hidden="true">#</a> 工作流程</h2><p>AIFORE的工作流程图1所示。在Fuzzing的过程中，<em>如果一个种子会带来显著的覆盖率提升</em>，就把它称之为有价值的种子。对于每一个有价值的种子，AIFORE分析<em>它的的格式知识，包括字段边界和字段类型知识</em>，来指导Fuzzing。AIFORE使用三个模块共同逆向输入格式知识。</p><ul><li>第一个模块分析字段边界并<strong>将输入分成字段</strong>，即具有相同语义的连续字节。</li><li>第二个模块通过一个基于CNN的模型<strong>预测字段类型信息</strong>。</li><li>第三个模块<strong>决定哪些种子值得进行格式分析</strong>，并将更多的能量分配给那些变异次数较少的格式。</li></ul><figure><img src="'+g+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图 1</p><h3 id="字段边界分析" tabindex="-1"><a class="header-anchor" href="#字段边界分析" aria-hidden="true">#</a> <strong>字段边界分析</strong></h3><p>考虑到一个由连续的输入字节组成的字段通常在BB中被作为一个整体处理。因此AIFORE使用最小集群( MC )的方法从块级分割字段。首先，作者<em>将二进制代码分割成基本块</em>，如图2所示。然后，作者收集并合并在一个基本块中处理的输入字节。</p><p>以图2为例，在第一个基本块中收集了偏移量为18、19的两个字节，在第二个BB 中收集了偏移量为16-19和40-51的字节。最后，作者利用<em>污点分析</em>和<em>最小集群算法</em>来分割字段，例如图2中的18、19字节将被识别成一个字段。</p><figure><img src="'+m+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图 2</p><h3 id="字段类型分类" tabindex="-1"><a class="header-anchor" href="#字段类型分类" aria-hidden="true">#</a> <strong>字段类型分类</strong></h3><p>因为当程序处理不同类型字段时，程序代码会显示出不同的模式，AIFORE 据此通过对 BB 进行分类以推断出它们所处理的输入字段的类型。具体来说，给定<mark>一个字段类型</mark>和<mark>解析使用这个字段的代码片断</mark>，建立<mark>一个 CNN 模型</mark>将后者映射到前者。</p><p>对于 CNN 模型的训练，首先定义支持的六种语义信息：<em>大小、枚举、magic number、字符串、校验和、偏移</em>。</p><p>然后根据 010 editor 所提供的输入格式知识作为基础知识，并挑选一些著名的程序进行污点分析。</p><p>给定一个输入字段，作者定位其偏移，从基础知识中确定其类型，使用污点分析确定其相关的 BB 并对 BB 进行前向切片，以合并对给定字段有重要语义依赖的连续子 BB 。</p><p>在训练 CNN 之前，作者需要对代码片段与类型成对的数据进行数据矢量化得到<mark>特征向量</mark>。</p><p>首先对 BB 中的指令进行简化，作者选择了<em>100种常用 IR 语法</em>，将 BB 中的指令转化为中间表示，并用热编码对相应的 IR 操作进行量化。</p><p>BB中使用的<strong>标准库函数</strong>和<strong>格式化字符串</strong>也会作为重要的量化信息。</p><p>如果一个字段被多个代码片段处理，那么这些代码片段的特征向量将被加在一起，得到这个字段的总特征向量。</p><p>最后作者使用 (特征向量，字段类型)对来训练 CNN 模型。</p><h3 id="能量调度" tabindex="-1"><a class="header-anchor" href="#能量调度" aria-hidden="true">#</a> <strong>能量调度</strong></h3><p>通过以上两个模块就可以获得输入字段的边界和类型作为输入格式知识。能量调度模块根据输入格式知识对种子进行变异。首先，能量调度模块将分析初始种子以建立格式模型。然后在格式知识的指导下对种子进行变异，如果新变异的种子是有价值的，那么就重新分析它的格式，<em>当Fuzzer未能在规定时间获得新的覆盖率</em>，能量调度模块把能量分配给那些变异较少的格式多对应的种子。</p><h2 id="实验评估" tabindex="-1"><a class="header-anchor" href="#实验评估" aria-hidden="true">#</a> 实验评估</h2><h3 id="_010-editor" tabindex="-1"><a class="header-anchor" href="#_010-editor" aria-hidden="true">#</a> ###010 Editor？</h3><blockquote><p>010 Editor是一款功能强大、专业的二进制文件编辑器和数据分析工具。它允许用户查看和编辑各种文件，包括二进制文件、磁盘映像、文本文件和其他类型的数据文件。010 Editor提供了一个灵活的界面和强大的工具，使用户能够深入分析和操作各种数据。</p><p>010 Editor的主要特点包括：</p><ol><li><strong>二进制编辑和分析</strong>：010 Editor可以以二进制格式打开和编辑任何文件，并提供直观的界面和强大的编辑工具。用户可以对数据进行搜索、替换、剪切、粘贴和插入操作等。</li><li><strong>模板技术</strong>：010 Editor内置了多种模板，用于解析和解码各种常见的文件格式，包括图像、音频、视频、存档等。用户还可以创建自定义模板，以适应特定的数据结构。</li><li><strong>脚本支持</strong>：010 Editor提供了一个内置的脚本引擎，用户可以使用脚本编写自定义的数据分析和处理操作。脚本语言基于C/C++，并提供了丰富的API和函数库。</li><li><strong>数据可视化</strong>：010 Editor支持各种数据可视化工具，包括图表、图像预览、结构视图等，以帮助用户更直观地理解和分析数据。</li><li><strong>文件比较和合并</strong>：010 Editor可以比较和合并两个文件，找到差异并进行合并操作。</li></ol><p>010 Editor被广泛应用于各个领域，包括软件逆向工程、数据恢复、恶意代码分析、文件格式分析等。它提供了强大的功能和灵活性，使用户能够在处理和分析二进制数据时更高效和准确。</p></blockquote><p><strong>RQ1 : AIFORE 的每个格式提取模块的性能如何？</strong></p><p>在本文中，作者收集了17个程序以及15种格式来评估 AIFORE ，包括文件输入、网络协议类程序，并且使用<mark>010 editor的公共格式模板</mark>来解析文件，导出所有带有边界和类型信息的字段记录进行人工预处理作为<em>基础事实</em>。</p><p>对于字段边界识别的准确性评估，使用 AIFORE 正确识别的字段数除以基础知识中的字段总数作为准确性的衡量标准。评估结果如图3所示，根据评估结果得出了两个结论。</p><ol><li>首先，准确性与编译器优化水平无关，这是因为最小集群方法是从语义块的角度考虑的，他几乎不会收到编译器优化影响。</li><li>第二，作者手动调查了准确率低的目标，原因是程序解析字段的方式，例如程序逐字节检查输入的 magic number，将会导致每个字节使用不同 BB 处理，最小集群算法错误地将 magic number 的每个字节分成一个字段。虽然结果与规范不同，但作者认为这不会影响(甚至有利于) Fuzzing 的效果，因为 Fuzzing 是为了测试程序，而不是为了还原程序输入的规范。</li></ol><figure><img src="'+l+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图 3</p><p>对于字段类型识别的准确性，作者评估了CNN模型的性能。作者使用8种格式中收集的10,582个字段，以及对应的解析程序来训练模型，并且分别在不同的编译器优化下进行训练，结果如图4所示，CNN模型在不同编译器优化水平下平均准确率超过85%，即使有混合编译器优化，准确率结果也很稳定，这意味着该模型适用于现实世界的情况。</p><figure><img src="'+d+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图 4</p><p>作者进一步在不同数量的数据上训练模型并取得准确性，将10,582个字段设定为单位(即1.0)尺度，并使用不同的尺度(即0.2到2.0)来训练相应的模型，结果如图5所示，更多的训练数据会带来更高的模型精度。然而，当规模大于1.0时，增长率很快就会停滞。</p><figure><img src="'+c+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图 5</p><p>作者在对于经过训练的程序，测试了程序是否可以预测未见过的格式的字段类型，应用 AIFORE 对那些已经用某些格式训练过的程序进行测试，对于未经训练的程序，作者选择7个未经训练的程序和相应的格式来测试 AIFORE 的准确性，并验证 AIFORE 是否能识别这些程序的格式，结果如图6所示，<em>AIFORE 可以很准确地预测未见过的格式中的字段类型</em>，而Top-1的准确率平均超过80%，Top-2的准确率超过90%。对于未经训练的程序，AIFORE 能够以平均81%的Top-1准确率和88%的Top-2准确率来预测字段类型。</p><figure><img src="'+u+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图 6</p><p><strong>RQ2:格式提取的比较</strong></p><p>作者使用 AIFORE 与现有的输入格式逆向工程工具 <mark>ProFuzzer</mark>、<mark>AFL-Analyze</mark>、<mark>TIFF-fuzzer</mark> 进行比较，以衡量确定格式逆向的性能。图7的结果显示了字段边界和类型分析的准确性，AIFORE 在字段边界识别和字段类型预测方面都取得了较高的准确性，此外，AIFORE 在训练过的程序中比未训练过的程序表现得更好。</p><figure><img src="'+h+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图 7</p><p>图8分别显示了解析一个输入的平均时间成本。平均来说，AIFORE 类型预测时间稳定，精确度较高。</p><figure><img src="'+F+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图 8</p><p><strong>RQ3: Fuzz 性能的比较</strong></p><p>作者使用AIFORE与6种Fuzzer进行了比较，分别是<mark>AFL</mark>、<mark>AFLFast</mark>、<mark>ProFuzzer</mark>、<mark>TIFF-fuzzer</mark>、<mark>WEIZZ</mark>、<mark>EcoFuzz</mark>，从图9的结果可以看出，AIFORE增加了代码覆盖率，但是在pngtest上WEIZZ表现更好，原因是WEIZZ不仅能检测到文件中的校验和字段，而且还能修正校验和值，而AIFORE不能进行修正。</p><figure><img src="'+z+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图 9</p><p>并且，为了探索AIFORE发现漏洞的能力，作者进行了为期7天的测试，AIFORE共发现了34 个bug，其中20个漏洞也被其他Fuzzer发现过。</p><p><strong>RQ4: 每个模块的贡献</strong></p><p>根据图9的第三栏到第五栏，字段边界识别模块帮助AIFORE对具有相同语义且属于一个字段的字节进行变异，它使AIFORE比AFL多覆盖9.3%的BB，AIFORE使用人工智能模型来预测字段类型，AIFORE对所有目标的代码覆盖率平均又增加了6.9%。最后，AIFORE利用一种新的能量调度算法，帮助Fuzzer为那些没有被充分变异的格式分配更多的能量，使覆盖率增长8.8%。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>输入格式知识对于Fuzzing发现程序中的漏洞非常有用。现有的方法在正确识别或应用输入格式方面存在困难。本文引入AIFORE来自动逆向输入格式，然后指导Fuzzing。具体来说，AIFORE利用污点分析来推断负责处理每个输入字节的 BB，并通过最小聚类算法对输入字节进行分组。此外，AIFORE利用一个CNN模型来推断基于BB行为的输入字段的类型。基于输入格式知识，AIFORE使用了一种新的能量调度算法。经过系统的评估表明，这个解决方案比现有的工具有更好的有效性和效率。</p>',77);function A(I,R){const a=n("ExternalLinkIcon");return t(),o("div",null,[E,r("p",null,[r("a",k,[e("usenix.org/system/files/sec23summer_427-shi_ji-prepub.pdf"),s(a)]),e("。")]),_])}const B=i(f,[["render",A],["__file","80-白泽带你读论文｜ALFORE.html.vue"]]);export{B as default};
