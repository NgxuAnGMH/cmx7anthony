import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{r as s,o as d,c as r,a as i,b as e,e as t,d as l}from"./app-cdabc73c.js";const p="/assets/f37b7a570f9dcf0538d39dd10d4d0cbd-5be88571.jpg",c="/assets/0fbcef90852ac8f9f6d46f3d61db2f35-9e40f572.jpg",o="/assets/a471379066a5224738c7193e6f07731d-b134a8a0.jpg",m="/assets/e0ede6aab2fcf0d087ef96bf2eec2680-354c32fb.jpg",v="/assets/d2e6807e636ecba5942605606d614a9d-362ce9d9.jpg",b="/assets/943b0fbc9065368574f0fddf1c62e85a-7b5beccd.jpg",u={},f=i("h1",{id:"_23-内存地址空间-程序中地址的三种产生方式",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#_23-内存地址空间-程序中地址的三种产生方式","aria-hidden":"true"},"#"),e(" 23｜内存地址空间：程序中地址的三种产生方式")],-1),g=i("p",null,"你好，我是 LMOS。",-1),x=i("p",null,"前面我们一起探讨了 RISC-V 芯片，设计和实现了一个迷你 CPU。之后还深入研究了 CPU 上面运行的语言和指令系统，它们是构成程序的重要要素。依托于芯片和语言、指令，我们就可以编写和执行程序了。",-1),_=i("p",null,"不过我们开发应用的时候，还有个打交道最频繁的模块——内存。很多工程问题你不懂内存，就会举步维艰。你也许觉得内存知识太难了，不但关联知识又多又散乱，而且深挖下去感觉没有尽头。但计算机的硬核基础，内存是必修关卡，只要你跟住我的节奏坚持下来，一定可以把内存的本质、内存系统的来龙去脉都弄明白，一起加油。",-1),h={href:"https://gitee.com/lmos/Geek-time-computer-foundation/tree/master/lesson23",target:"_blank",rel:"noopener noreferrer"},C=l('<h3 id="cpu-如何访问内存" tabindex="-1"><a class="header-anchor" href="#cpu-如何访问内存" aria-hidden="true">#</a> CPU 如何访问内存</h3><p>CPU 怎么访问内存？我们回想一下，之前讲过的高级语言和低级语言转化过程。</p><p>我们先思考一下，C 语言把我们写出来的变量和函数都转换成了什么呢？如果记不太清了，可以回顾第十五节课。没错，C 语言把变量名和函数名都转换成了汇编语言里的标号，而汇编语言的标号，就是机器更好理解的符号。符号具体包括符号类型、符号名称和符号地址这几个属性。其中，符号地址是由一个叫链接器的东西生成的。</p><p>**汇编语言的标号，就表示为一段内存地址的开始。**再根据我们 RISC-V 里访存指令的操作（可回顾第二十一节课和第二十二节课），进一步分析看看：加载字指令 lw 指令，它会从一个地址指向的内存单元中，把数据加载到寄存器上；储存字指令 sw 指令则是跟 lw 指令相反，把寄存器里的数据存到特定内存单元当中。这些指令里源寄存器和立即数组成的数据，其实就叫内存地址。</p><p>结合这些信息，我们就能推出这个结论：<strong>CPU 正是通过内存地址来访问内存的</strong>。这个地址本质上是一个整数数据。而这个整数代表了一个内存单元的索引号，CPU 访问内存的时候，硬件的地址译码器会负责把索引号，转换成相应的地址信号和片选信号，帮助 CPU“寻路”，找到特定的内存单元位置。</p><p>我来给你画图描述一下，对照图解你更容易理解。</p><figure><img src="'+p+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>从上图中得知，内存最小编址单位为一个字节，一个字节能储存 8 个二进制位，即给出一个地址，就能够精确地定位到某个内存字节单元。两个连续的字节为半字，储存 16 个二进制位，四个连续的字节为一个字，也就是储存 32 个二进制位。</p><p>我们对照上图看一下，看起来 0~0xFFFFFFFF 这之间任意整数形成的地址，都能索引并访问到对应的内存单元。不过这只是理想状态，现实里并非如此。真正的实现方案中，一些地址上对应的不一定是内存单元，还可能是系统寄存器，设备寄存器、设备内存、主内（即我们经常说内存），情况如下图所示：</p><figure><img src="'+c+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>示意图里描述的更接近真实情况，在一台现代的物理计算机上，各种设备和内存都是统一编址的，不同的地址段能访问到不同的设备。</p><p>比如上图中，CPU 发出了 0x00000004 地址，这时经过地址译码，访问的就不是某个内存单元了，而是系统寄存器；如果 CPU 发出的地址在 0xC0000000 到 0xE0000000 之间，就会访问到设备上的内存，而 CPU 发出的地址是 0x60000000 到 0xBFFFFFFF 之间和 0x100000000 到 0x19FFFFFFF 之间，才能访问到主存，也就是内存。</p><p>还有一些地址并没有对应到具体的设备，即为无效地址，如果 CPU 访问了无效地址，就会得到无效数据或者收到硬件错误的反馈。</p><p>现在，我们已经清楚地知道了，CPU 把一个整数数据当成地址，放在地址总线上，由地址译码器选择该地址正确索引的设备或者内存进行访问。</p><p>从另一个角度看，数据在物理电路上，是由不同的电子信号的组合来表示的。正是有了这些电子信号组合，才能做到索引相应的设备和内存。CPU 通过什么访问内存，以及地址的本质是什么，我们已经找到答案了，用一句话概括就是：<strong>CPU 通过地址访问内存，地址的本质是整数数据，而整数数据的本质是电子信号的组合。</strong></p><h3 id="内存地址从何而来" tabindex="-1"><a class="header-anchor" href="#内存地址从何而来" aria-hidden="true">#</a> 内存地址从何而来</h3><p>好，让我们继续分析，搞清楚地址是从何而来的。</p><p>你现在已经知道了 CPU 要通过地址访问内存。但是如果我问你，这个地址从何而来？你是不是有些惊讶，发现自己一下子可能回答不上来，或者只知道个大概。</p><p>比较容易想到的思路是，访问内存的是相应的程序，那么自然内存地址是从程序代码中来。只是我们没有认真思考过，程序代码的地址是怎么产生的？</p><p>下面，我们就通过几行代码来一步步探索这个问题，代码如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>//ls.S文件
.text
.globl sw_ins
#a0内存地址
#a1储存的值
sw_ins:
    sw a1, 0(a0)       #储存a1到a0+0地址处
    jr ra              #返回
//main.c文件
unsigned int word = 0xffffffff;
int main()
{
    sw_ins((unsigned int)&amp;word, 0);
    return 0;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码分别来源于工程目录中的 ls.S 文件和 main.c 文件，代码功能逻辑很简单，就是 C 语言的 main 函数调用汇编代码 sw_ins，对 word 变量做修改，把它从 0xffffffff 修改为 0。</p><p>请你注意，我们现在不是研究代码本身，而是<strong>研究代码编译后的链接过程</strong>，通过这个线索来分析程序代码地址如何产生。</p><p>为此，我帮你写了一个链接脚本来控制链接过程和传递相关信息。同时我们还要修改 Makefile 文件的内容，让链接脚本生效，Makefile 内容如下所示：</p><figure><img src="`+o+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>上图中红色框中是修改内容，尤其是第 7 行你要仔细看看，其中 -T ld.lds 表示使用 ld.lds 文件作为链接脚本文件，-Map main.map 表示链接器将链接后的内存 map 信息，输出到 main.map 文件里。</p><p>接下来，我们重点研究一下 ld.lds，代码如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>//输出格式
OUTPUT_FORMAT(elf32-littleriscv)
//配置内存空间，起始地址为0x10000，长度为0x50000
MEMORY
{
  RAM (xrw) : ORIGIN = 0x10000 , LENGTH = 0x50000
}
//定义输出节
SECTIONS
{
    //定义text节包含链接文件的所有以.text开头的节
  .text :
  {
    *(.text) *(.text.*)
  } &gt; RAM
    //定义data节包含链接文件的所有以.data、.sdata、.sdata2、.rodata开头的节
  .data :
  {
      *(.data .data.*) *(.sdata .sdata.*) *(.sdata2.*) *(.rodata) *(.rodata*)
  } &gt; RAM
    //定义bss节包含链接文件的所有以.bss、.sbss、.common开头的节
  .bss :
    {
        *(.sbss*) *(.bss*) *(COMMON*)
  } &gt; RAM
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从链接脚本中我们看到，Id.lds 文件首先配置了一个内存空间，这个空间从 0x10000 地址开始，一共有 0x50000 个字节。然后，链接器把所有参与链接文件里，</p><p>以.text、.data、.sdata、.bss、.sbss、.COMMON 开头的节，按照上述链接脚本的顺序，合并成可执行程序文件，这个文件的地址从 0x10000 地址开始，到 0x60000 结束。</p><p>这个合并过程中，需要对符号进行绑定和地址重定位，我特意为你画了一幅图，展示这个过程。</p><figure><img src="`+m+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>看了图片，你是不是对链接器生成地址的过程更加清楚了呢？如上图所示，ls.o、main.o 文件是可链接的目标文件，格式也是 ELF 的，其中有.text 节、.data 节、.bss 节等，不同的数据会放到不同的节里，如下表所示：</p><figure><img src="'+v+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>链接器所做的工作就是根据 lds 文件中的定义，完成“合并同类项”的整理工作，也就是把相同的节合并成一个更大的节。比如 ls.o 的.text 节与 main.o 的.text 节合并成 main.elf 的.text 节，而.data、.bss 节也是类似的合并过程，合并之后就要执行更重要的工作。</p><p>程序重定位也叫分配内存地址。我也举个例子帮助你理解，比如 main.elf 程序要从内存地址 0x10000 开始，并且这个地址开始存放的是.text 节，即指令部分，.data 节放在.text 节之后。</p><p>链接器根据.text 节的大小，就能算出.data 节的开始地址。比如在上面的例子里，就是 0x10030。.data 节中有一个变量 word 是一个字大小，所以 word 变量地址会从 0x10030 开始存放，占用 4 字节，下一个变量地址将从 0x10034 开始。</p><p>既然 word 变量存放内存地址是 0x10030，那么链接器就需要修改指令，具体就是修改指令中表示 word 变量地址的数据，让地址数据变成 0x10030，或者通过一种计算方式得到 0x10030，这样程序中的相关指令才能最终访问到 word 变量。这也是在 main.o 中的 main 函数里，一些指令数据与 main.elf 中的 main 函数指令数据不一样的原因。</p><p>还有一个关键的地方我再讲讲，main 函数中调用了 sw_ins 函数，链接器也要进行处理，确保 jalr 指令能跳转到 sw_ins 函数的地址上，即 0x10000 地址。</p><p>链接器产生地址的过程我们讲完了，概括说就是<strong>链接多个程序模块，并且分配程序在运行过程中的地址。</strong></p><p>当然了，除了这种方式，你可以在程序代码中直接给出一个地址，代码如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>int main()
{
    //把整数0x20000强制转换为int类型的指针
    int *p = (int*)0x20000;
    *p = 0;
    //动态分配一个int类型大小的内存空间，其首地址返回给addr指针
    void* addr = malloc(sizeof(int));
    return 0;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码就是让 p 直接指向 0x20000 地址，然后向这个地址上写入 0。**不过这个操作极其危险，**除非你确切地知道自己在干什么，因为 0x20000 可能是其它重要数据，也可能不是真正的内存单元，而是设备寄存器，更可能什么也没有，即这个地址没有连接任何有效设备。</p><p>代码中的第三种情况是程序在运行过程中动态分配的内存，返回该内存的首地址，这相对于第一种方式更加安全可靠。</p><p>现在我们已经搞清楚了程序中的地址是怎么产生的：<strong>第一种方式是链接器；第二种方式是直接定义；第三种方式是动态分配内存。</strong></p><h3 id="物理地址空间和虚拟地址空间" tabindex="-1"><a class="header-anchor" href="#物理地址空间和虚拟地址空间" aria-hidden="true">#</a> 物理地址空间和虚拟地址空间</h3><p>我们已经搞清楚了，地址从何而来，但一个地址肯定身处某一个地址空间中，我们下一个探讨话题正是地址空间。</p><p>首先，地址不过是一个整数而已，一旦这个整数被编码到 CPU 相应访存指令中的相关位段里，CPU 就会把它放到地址总线上。这样 CPU 访问内存的时候，就会通过地址译码器获得这段整数信息，从而索引到具体的设备单元上。这个设备单元可以是设备寄存器，可以是内存单元。</p><p>那么地址空间其实就是一个这样的整数所表示的范围。具体落实到 CPU 电路上，就是地址总线位数所表示的数据范围。</p><p>比方说，CPU 有 8 根地址线，它能编码 2 的 8 次方，即 256 个数据，地址 0 到地址 255 这个地址数据的范围，其实就是这个 8 位地址总线的 CPU 的地址空间；如果是 32 位地址总线的 CPU，那么它地址的空间范围就是 0~0xFFFFFFFF。从 0 到 0xFFFFFFFF，这之间的每个整数编码就是一个地址，合起来就是地址空间。</p><p>那什么是内存地址空间呢？当然就是<strong>能索引到内存单元的地址合集</strong>。我们再稍微扩展一下，你知道 CPU 的物理地址空间吗？其实它就是 CPU 地址总线位数所表示的数据范围，由于不同的 CPU，甚至同一体系 CPU 的不同版本，其地址总线数设计实现不同，物理地址空间也是不同的。</p><p>聊完了物理地址空间，咱们当然还得说说虚拟地址空间。现在的计算机系统中，我们写的程序链接时的地址和运行时的地址，都使用了虚拟地址。</p><p>虚拟地址空间的大小和 CPU 中的一个设备 MMU（内存管理单元）有关。虚拟地址之所以称为虚拟地址，是因为这种地址是假的，它不能真正索引到具体的设备单元，无论该单元属于设备寄存器还是内存，自然也就无法访问内存。还需要一个转换机构，把虚拟地址转换成真正的物理地址才能访问相应的设备。这个转换机构就是 CPU 的 MMU，关于 MMU 的细节，这里我先卖个关子，放在后面的课程再说。</p><p>讲到这里，我们知道了，地址空间和我们所在的自然空间的寓意不是一样的，它们仅仅是为了表示某一位宽下的二进制数所有的编码合集。所谓内存地址空间，自然也就是内存地址编码的合集。</p><p>有了这个概念，我们就知道，程序指令在内存中是如何组织的，一旦我们的程序出现了问题我们就能精准地分析定位问题所在。同时，我们也明白了 CPU 如何通过地址访问内存，读取其中指令和数据，也就是 CPU 运行程序的基本逻辑机理。</p><h3 id="重点回顾" tabindex="-1"><a class="header-anchor" href="#重点回顾" aria-hidden="true">#</a> 重点回顾</h3><p>今天我们为了弄明白内存地址空间是怎么一回事儿，做了不少探索，现在我带你回顾一下这节课的要点。</p><p>首先我们分析了 CPU 如何访问内存。一个整数数据就是一个地址，CPU 会把该数据放在地址总线上，由地址译码器选择该地址正确索引的设备或者内存进行访问。</p><p>访问内存要先知道“地址”，那内存地址是从何而来的，怎么产生的呢？我们结合例子，了解到内存地址有几种产生方式：<strong>一种是链接器对程序重定位后执行地址绑定，这地址是静态的；第二种是在代码中直接定义地址；第三种是动态分配内存，返回内存空间的首地址。</strong></p><p>明白了 CPU 访问内存的方式，也知道了内存地址如何产生，我们再理解内存地址空间也不是难事儿了。所谓内存地址空间，本质就是内存地址位宽下地址编码的合集。</p><figure><img src="`+b+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>内存的相关知识才刚刚开始，内存知识相对有点挑战，但跟着我的步伐，你也可以搞懂里面的门道。这节课最后我捎带讲了讲虚拟内存地址空间，更多虚拟内存的故事，且听我下节课分解。</p><h3 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题" aria-hidden="true">#</a> 思考题</h3><p>你觉得链接器使用的地址是物理内存地址，还是虚拟内存地址？</p><p>欢迎在留言区记录你的思考或疑问，也推荐你把今天这节课分享给更多朋友，说不定也能刷新他对内存的认识。</p><blockquote><p>连接器使用的地址是虚拟内存地址。物理内存地址要在发起访存操作之后通过MMU单元进行转换才能得到（这个过程设计页表和TLB等机制）。如果虚拟内存地址还未跟物理内存地址绑定，此时还会发生缺页异常陷入内核进行物理内存分配。<br> 作者回复: 是的</p><hr><p>操作系统安装会给定一个最低内存条存储要求，实际上只要过了这个要求，内存条容量大小操作系统不怎么关心，反正MMU完事<br> 通过原子锁等功能，来维护数据一致性，监控进程/线程。至于软件需求，那好办，通过时间轮换原则，每个线程跑一会就换另一个的！<br> 这也导致一个问题，如果线程过多，那么排队等待时间就会变长！像大型游戏厂商对cpu性能及内存条和显存容量都有要求，也就是帮cpu减负（可以通过显卡芯片完成的就尽量少用cpu，还有驻存在内存条上的数据交换时间总好过内存条与硬盘交换数据）<br> 在大型游戏运行时，显卡驱动也在运行（加载在内存条上，帮助cpu完成部分数据分流给显卡芯片），这也是软硬件方式优化MMU效率的一个案例！<br> 作者回复: 是的 正确</p><hr><p>只能是虚拟内存，如果用的物理内层就很麻烦，没有可扩展性和可移植性了，而且如果直接操作物理内存，那对应程序员的要求就不是CRUD了。虚拟内存就是那句经典的计算机的话：“计算机什么问题都可以靠增加一层中间层来解决的”<br> 作者回复: 哈哈是的</p><hr><p>链接器用的是虚拟内存地址（就不用关心是不是和物理设备地址覆盖）使用时通过操作系统内核加载到物理地址上，操作系统通过进程/线程进行管理！<br> MMU地址转换功能，在保护模式下运行（尽可能避免因虚拟地址相同而导致的数据覆盖）<br> 32位内存应为0到0xefffffff<br> 那么问题来了，对普通程序而言，有虚拟地址方便！但对操作系统开发者而言，恐怕还是得清楚设备地址吧？这个设备地址应该有个标准吧？这样操作系统本身数据才能不与物理设备地址冲突！<br> 如果设备地址的标准不一，预估cpu应该按照设备地址寻址优先原则（允许覆盖），这也估计是为啥操作系统保护模式内核在高位的一个原因吧？（这样，即使不知新的设备地址（假如设备开发商不通知操作系统开发商）只要内核在高位，大不了重新引导程序加载在空的内存空间上的）<br> 作者回复: 是的</p><hr><p>链接器使用的是虚拟地址，如果使用物理地址那么链接的过程将及其复杂并且物理地址用完了就不能再编译，这显然是不行的。<br> 作者回复: 是的</p><hr><p>请教老师几个问题啊：<br> Q1：“设备寄存器”有哪些？只知道CPU有寄存器，难道CPU之外的设备也有寄存器？<br> Q2：“sw_ins((unsigned int)&amp;word, 0);”，调用sw_ins的时候传入了参数，但sw_ins函数的定义中并没有参数啊。<br> Q3：代码中动态分配的内存是怎么确定地址的？此时程序已经运行，链接器无法参与了。<br> 作者回复: Q1：很多设备都有自己的寄存器</p><hr><p>手动分配和动态分配的地址也是虚拟地址吗？<br> 作者回复: 是的 都是虚拟</p><hr><p>cpu给定低16位（64kb内的）可做为端口，物理设备开发商可以通过端口方式直接与cpu沟通（可绕过操作系统，不需要操作系统分配地址，但估计会引发中断方式来被操作系统知悉？）也可以通过设备软件加载在内存上通过进程/线程，来与cpu沟通（需要操作系统分配地址）<br> 作者回复: 嘿嘿 你真聪明</p></blockquote>',66);function U(F,P){const n=s("ExternalLinkIcon");return d(),r("div",null,[f,g,x,_,i("p",null,[e("这节课，让我们迈出认识内存的第一步，我们先搞清楚 CPU 怎么访问内存，然后再来分析内存地址从何而来，最终让你建立对内存地址空间的理解。这节课的配套代码，"),i("a",h,[e("你可以从这里下载"),t(n)]),e("。")]),C])}const k=a(u,[["render",U],["__file","J23-内存地址空间.html.vue"]]);export{k as default};
