import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o as t,c as a,a as e,b as c,e as s,d as o}from"./app-cdabc73c.js";const l="/assets/640-1691486524923-351-f0e7bdae.jpeg",h="/assets/640-1691486524923-352-21c7ac9a.jpeg",g={},u=e("h1",{id:"_07-白泽带你读论文丨checkitagain-detecting-lacking-recheck-bugs-in-os-kernel",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_07-白泽带你读论文丨checkitagain-detecting-lacking-recheck-bugs-in-os-kernel","aria-hidden":"true"},"#"),c(" 07-白泽带你读论文丨CheckItAgain:Detecting Lacking-Recheck Bugs in OS Kernel")],-1),p=e("p",null,[c("Check It Again: Detecting Lacking-Recheck "),e("strong",null,"Bugs in OS Kernels")],-1),k={href:"https://github.com/kengiter/lrsan",target:"_blank",rel:"noopener noreferrer"},d=o('<p>本文发表在<strong>ACM Conference on Computer and Communications Security（CCS）2018</strong>，第一作者是来自University of Minnesota的Wenwen Wang。第二作者是Kangjie Lu，发表过多篇有关内核安全的顶会文章。</p><h2 id="主要内容" tabindex="-1"><a class="header-anchor" href="#主要内容" aria-hidden="true">#</a> 主要内容</h2><p><strong>Security Checks</strong>在内核中是十分普遍的，常被用于检查敏感的或者存在漏洞风险的变量。比如，添加security check可以确保用户提供的指针不指向内核空间，确保访存用的offset不会造成越界读写等。但是在kernel的实现中，一些通过了security checks的变量在真正被使用前可能被修改，假如攻击者能够控制这种修改操作，就等同于越过了kernel的security checks。本文作者认为这样的security check是improper check，作者首次将这类问题归纳为<strong>Lacking-Recheck Bugs（后文简称为LRC）</strong>，并设计了对应的检测方法，实现了开源的静态分析工具<strong>LRSan</strong>。</p><p>作者在version 4.17的kernel上进行了实验，用LRSan发现了2808个潜在的LRC cases。通过两位安全研究人员约40小时的人工确认，总计发现了19个LRC Bugs，向Linux kernel开发者报告后，17个Bug被确认，其中的12个截止到投稿时已被修复。</p><h2 id="问题定义" tabindex="-1"><a class="header-anchor" href="#问题定义" aria-hidden="true">#</a> 问题定义</h2><p>作者在本文中首次归纳出了LRC这类Bug，给出了正式的定义，并阐述了其与已知漏洞类型的关系。</p><figure><img src="'+l+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>LRC Bugs的产生</p><p><strong>LRC Bugs的定义：</strong></p><ol><li>存在一条check-use chain，即存在一条执行路径包含了对security variable的检查和使用。</li><li>在check-use chain上，在检查和使用之间，必须存在对security variable的写操作。</li><li>在满足了条件（a）,(b)后，在真正使用security variable时没有进行re-check。</li><li>修改用的source三类：来自于用户态与kernel的竞争；来自于当前线程和其他kernel线程的竞争；来自于当前线程的自修改。</li></ol><p><strong>作者归纳的Security-check的pattern：</strong></p><ol><li>是有2个branch的条件判断语句。</li><li>其中一条分支一定返回kernel的error code。</li><li>另一条分支一定要有可能不返回kernel的error code。</li></ol><p><strong>LRC Bugs与已知漏洞类型的关系：</strong></p><ol><li>LRC Bugs是Time-of-Check-to-Time-of-Use Bugs的一个子类。</li><li>LRC Bugs与Double-fetch Bug之间有交集，因为LRC Bugs同样考虑用户态和内核态之间的race。</li></ol><h2 id="设计与实现" tabindex="-1"><a class="header-anchor" href="#设计与实现" aria-hidden="true">#</a> 设计与实现</h2><p>本文作者主要采用静态分析的方法来检测LRC Cases:</p><figure><img src="'+h+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>LRSan的工作机制</p><p><strong>核心的静态分析模块</strong>主要包含4个部分：</p><p>**1. Security-check identification。**该步骤主要为了找出kernel中所有符合作者提出的Pattern的security-checks。所用的方法是，首先收集kernel中所有的error code（定义在errno.h和errno-base.h中）。为了省去繁杂的data-flow analysis，作者构建了基于error code CFG（ECFG），只关心一个function的return value，以及对return value的写操作，标记出那些将return value置为error code的block，进而在ECFG上进行security-check的检测与定位。</p><p>**2. Critical-variable identification。**作者进一步基于所有找到的security checks，找到与之对应的critical variable，即敏感变量。该步骤中存在一个递归的过程，即先确认security check正在检查的变量，然后回溯得到该变量的源，之后从该源变量出发找到所有与之相关的变量，这些变量都有可能违反security check所定义的规则。</p><p>**3. Check-use chain construction。**找到所有的security check和与之对应的敏感变量后，就可以遍历所有的执行路径来构造check-use chain了。</p><p>**4. Modification inference。**在所有的check-use chain上确认是否存在对敏感变量的修改，同时缺乏recheck的情况，若有，则找到了一个LRC Cases。主要关注的llvm中的store指令，一直一些会包含写操作的api比如memcpy，copy_from_user等。</p><hr><p>作者对LRSan产生false postive和false negative的原因做了相对全面的解释：</p><p><strong>1. False Negative</strong>。作者在本文中采用了非常strong的pattern来检测security checks，比如，假设security-check都是简单的分支指令，并且作为error-handing的分支一定会返回error code。Strong的pattern带来的好处是减少了很多静态分析的challenge，但是坏处就是不可避免的带来了False Negative，因为kernel中真实存在不符合这种pattern的security check。</p><p>**2. False Positive。**产生false positive的原因较多，其中主要的3类为：（a）Checked Modification。即对敏感变量修改时的源值也是符合security check的值。（b）Satisfiable Modification。比如在range-check之后，index一直在范围内执行自增操作。（c）Uncontrollable Modification。即敏感变量被修改为定值，这种场景下攻击者难以进行bug利用，故也可认为是false positive。</p><h2 id="评价" tabindex="-1"><a class="header-anchor" href="#评价" aria-hidden="true">#</a> 评价</h2><p>从结果上来说，LRSan的确找到了19个kernel bug，其贡献值得肯定。但是LRC Bugs很难被认为是一种全新的bug类型，按照作者的定义，其所涵盖的范围与已知的漏洞都有交集，如TOCTTOU，Double fetch等。同时，因为引入了有关security check非常strong的pattern，technique challenge就大幅降低了。再者，该工具最终检测出的只是LRC cases，bug的确认需要人工的干预。但总的来说，文章的概念的定义上都比较formal，结果分析全面，从漏洞发现数量上来看结果也比较可观。</p>',29);function f(_,C){const r=i("ExternalLinkIcon");return t(),a("div",null,[u,p,e("p",null,[e("strong",null,[c("开源项目地址："),e("a",k,[c("https://github.com/kengiter/lrsan"),s(r)])])]),d])}const L=n(g,[["render",f],["__file","07-白泽带你读论文丨CheckItAgainDetecting Lacking-Recheck Bugs in OS Kernel.html.vue"]]);export{L as default};
