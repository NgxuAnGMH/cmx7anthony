import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r as p,o,c,a as n,b as s,e as t,d as l}from"./app-cdabc73c.js";const e="/assets/cdfc33db2fe1e07b6acf8faa3959cb01-6395e035.jpeg",r="/assets/d85b24af560f288847ea9f3e8776adf5-d67c6e8a.jpeg",u="/assets/2b53b470673cde8f9d8e2573f7d07242-fa264398.jpg",d="/assets/71b04097edb2d47f01ab5585fd2ea4e6-9c829f41.jpeg",k="/assets/d2fce8af88dd278670395ce1ca6d4d14-f400511f.jpg",_="/assets/758c283cf7633465d24ab3ef778328cd-6d7f93f2.jpeg",m={},v=l('<h1 id="_08-内核初始化-生意做大了就得成立公司" tabindex="-1"><a class="header-anchor" href="#_08-内核初始化-生意做大了就得成立公司" aria-hidden="true">#</a> 08 | 内核初始化：生意做大了就得成立公司</h1><p>上一节，你获得了一本《企业经营宝典》，完成了一件大事，切换到了老板角色，从实模式切换到了保护模式。有了更强的寻址能力，接下来，我们就要按照宝典里面的指引，开始经营企业了。</p><p>内核的启动从入口函数 start_kernel() 开始。在 init/main.c 文件中，start_kernel 相当于内核的 main 函数。打开这个函数，你会发现，里面是各种各样初始化函数 XXXX_init。</p><h2 id="初始化总览" tabindex="-1"><a class="header-anchor" href="#初始化总览" aria-hidden="true">#</a> 初始化总览</h2><p><mark>0号进程不属于内核态吗？属于的话为啥2号才是内核态祖先</mark>作者回复: 0号不运行. start_kernel()不属于任何进程，是内核代码.</p><blockquote><p>0号进程 不是一个实实在在可以看到的进程</p></blockquote><p>个人理解: 0号进程初始化一切, 过后消亡(或隐藏), 不保持后台运行. -&gt; 即0号是启动过程，完成自己的使命就可以退隐了。</p><ul><li>0号进程, 唯一一个没有通过fork或kernel_thread产生的进程，是进程列表的第一个。</li><li>1号进程, 是用户态祖先进程。</li><li>2号进程, 是内核态所有线程运行的祖先。</li></ul><img src="'+e+`" alt="img" style="zoom:25%;"><h3 id="_0号进程-初始化" tabindex="-1"><a class="header-anchor" href="#_0号进程-初始化" aria-hidden="true">#</a> 0号进程(初始化)</h3><p>进程0:</p><p>内核是一个大的程序，可以控制硬件，也可以创建、运行、终止、控制所有的进程。当内核被加载到内存后，</p><p>首先就会有完成内核初始化的函数start_kernel()从无到有的创建一个内核线程swap，并设置其PID为0，即进程0，它也叫闲逛进程；</p><p>进程0执行的是cpu_idle()函数，该函数仅有一条hlt汇编指令，就是在系统闲置时用来降低电力的使用和减少热的产生。</p><p>同时 进程0 的 PCB 叫做 init_task，在很多链表中起了表头的作用。</p><p>当就绪队列中再没有其他进程时，闲逛进程就会被调度程序选中，以此来省电，减少热量的产生。</p><p>也就是说当 Process List 里面有其他进程，那么 进程0 就不会运行了。</p><h3 id="_1号进程-用户态总管-进程" tabindex="-1"><a class="header-anchor" href="#_1号进程-用户态总管-进程" aria-hidden="true">#</a> 1号进程(用户态总管/进程)</h3><p>子进程都是由父进程fork出来的，fork出来之后就和父进程无关了吧？也就是父进程执行结束后，子进程还能一直存在？<br> 作者回复: 能一直存在</p><p>bash的父进程是pts？这个pts不是一个进程吧，不是一个伪终端吗？我觉得bash的父进程是sshd。<br> 作者回复: 伪终端也是进程呀</p><h3 id="_2号进程-内核态总管-不区分进程线程-任务" tabindex="-1"><a class="header-anchor" href="#_2号进程-内核态总管-不区分进程线程-任务" aria-hidden="true">#</a> 2号进程(内核态总管/不区分进程线程/任务)</h3><blockquote><p>我有个小小的疑问：kernel_thread创建的是进程么？例如：ps命令查看，发现kthreadd有pid，且在command的内容是[kthreadd]，[]包裹说明这是个内核线程。既然这样，大家都称呼kthreadd是一个进程，我就有点困惑了<br> 作者回复: 是<code>任务</code>，任务<code>也有pid</code>，<strong>内核里面<code>不区分</code>进程和线程</strong></p></blockquote><h2 id="梗概-start-kernel函数" tabindex="-1"><a class="header-anchor" href="#梗概-start-kernel函数" aria-hidden="true">#</a> 梗概: start_kernel函数</h2><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">start_kernel</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    
    <span class="token keyword">char</span> <span class="token operator">*</span>command_line<span class="token punctuation">;</span>    
    <span class="token keyword">char</span> <span class="token operator">*</span>after_dashes<span class="token punctuation">;</span>
    <span class="token comment">//CPU组早期初始化</span>
    <span class="token function">cgroup_init_early</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//关中断</span>
    <span class="token function">local_irq_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//ARCH层初始化</span>
    <span class="token function">setup_arch</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>command_line<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//日志初始化      </span>
    <span class="token function">setup_log_buf</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
    <span class="token function">sort_main_extable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//陷阱门初始化    </span>
    <span class="token function">trap_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//内存初始化    </span>
    <span class="token function">mm_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">ftrace_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//调度器初始化</span>
    <span class="token function">sched_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//工作队列初始化</span>
    <span class="token function">workqueue_init_early</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//RCU锁初始化</span>
    <span class="token function">rcu_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//IRQ 中断请求初始化</span>
    <span class="token function">early_irq_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
    <span class="token function">init_IRQ</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
    <span class="token function">tick_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
    <span class="token function">rcu_init_nohz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//定时器初始化 </span>
    <span class="token function">init_timers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
    <span class="token function">hrtimers_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//软中断初始化    </span>
    <span class="token function">softirq_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
    <span class="token function">timekeeping_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">mem_encrypt_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//每个cpu页面集初始化</span>
    <span class="token function">setup_per_cpu_pageset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
    <span class="token comment">//fork初始化建立进程的 </span>
    <span class="token function">fork_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
    <span class="token function">proc_caches_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
    <span class="token function">uts_ns_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//内核缓冲区初始化    </span>
    <span class="token function">buffer_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
    <span class="token function">key_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
    <span class="token comment">//安全相关的初始化</span>
    <span class="token function">security_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token comment">//VFS数据结构内存池初始化  </span>
    <span class="token function">vfs_caches_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//页缓存初始化    </span>
    <span class="token function">pagecache_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//进程信号初始化    </span>
    <span class="token function">signals_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
    <span class="token comment">//运行第一个进程 </span>
    <span class="token function">arch_call_rest_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>CPU组早期初始化</li><li>cgroup_init_early();</li><li>关中断</li><li>local_irq_disable();</li><li>ARCH层初始化</li><li>setup_arch(&amp;command_line);</li><li>日志初始化</li><li>setup_log_buf(0);<br> 2. sort_main_extable();</li><li>陷阱门初始化</li><li>trap_init();</li><li>内存初始化</li><li>mm_init();<br> 2. ftrace_init();</li><li>调度器初始化</li><li>sched_init();</li><li>工作队列初始化</li><li>workqueue_init_early();</li><li>RCU锁初始化</li><li>rcu_init();</li><li>IRQ 中断请求初始化 <ol><li>early_irq_init();</li><li>init_IRQ();</li><li>tick_init();</li><li>rcu_init_nohz();</li></ol></li><li>定时器初始化 <ol><li>init_timers();</li><li>hrtimers_init();</li></ol></li><li>软中断初始化 <ol><li>softirq_init();</li><li>timekeeping_init();</li><li>mem_encrypt_init();</li></ol></li><li>每个cpu页面集初始化 <ol><li>setup_per_cpu_pageset();</li></ol></li><li>fork初始化建立进程的 <ol><li>fork_init();</li><li>proc_caches_init();</li><li>uts_ns_init();</li></ol></li><li>内核缓冲区初始化 <ol><li>buffer_init();</li><li>key_init();</li></ol></li><li>安全相关的初始化 <ol><li>security_init();</li></ol></li><li>VFS数据结构内存池初始化 <ol><li>vfs_caches_init();</li></ol></li><li>页缓存初始化 <ol><li>pagecache_init();</li></ol></li><li>进程信号初始化 <ol><li>signals_init();</li></ol></li><li>运行第一个进程 <ol><li>arch_call_rest_init();</li></ol></li></ol><p>​</p><h2 id="初始化公司职能部门" tabindex="-1"><a class="header-anchor" href="#初始化公司职能部门" aria-hidden="true">#</a> 初始化公司职能部门</h2><p>于是，公司要开始建立各种职能部门了。</p><p>首先是<strong>项目管理部门</strong>。咱们将来肯定要接各种各样的项目，因此，项目管理体系和项目管理流程首先要建立起来。之前讲的创建项目都是复制老项目，现在咱们需要有第一个全新的项目。这个项目需要你这个老板来打个样。</p><p>在操作系统里面，先要有个创始进程，有一行指令 set_task_stack_end_magic(&amp;init_task)。这里面有一个参数 init_task，它的定义是 struct task_struct init_task = INIT_TASK(init_task)。它是系统创建的第一个进程，我们称为 <strong>0 号进程</strong>。这是唯一一个没有通过 fork 或者 kernel_thread 产生的进程，是进程列表的第一个。</p><p>所谓进程列表（Process List），就是咱们前面说的项目管理工具，里面列着我们所有接的项目。</p><p>第二个要初始化的就是<strong>办事大厅</strong>。有了办事大厅，我们就可以响应客户的需求。</p><p>这里面对应的函数是 trap_init()，里面设置了很多<strong>中断门</strong>（Interrupt Gate），用于处理各种中断。其中有一个 set_system_intr_gate(IA32_SYSCALL_VECTOR, entry_INT80_32)，这是系统调用的中断门。系统调用也是通过发送中断的方式进行的。当然，64 位的有另外的系统调用方法，这一点我们放到后面的系统调用章节详细谈。</p><p>接下来要初始化的是咱们的<strong>会议室管理系统</strong>。对应的，mm_init() 就是用来初始化内存管理模块。</p><p>项目需要项目管理进行调度，需要执行一定的调度策略。sched_init() 就是用于初始化调度模块。</p><p>vfs_caches_init() 会用来初始化基于内存的文件系统 rootfs。在这个函数里面，会调用 mnt_init()-&gt;init_rootfs()。这里面有一行代码，register_filesystem(&amp;rootfs_fs_type)。在 VFS 虚拟文件系统里面注册了一种类型，我们定义为 struct file_system_type rootfs_fs_type。</p><p>文件系统是我们的项目资料库，为了兼容各种各样的文件系统，我们需要将文件的相关数据结构和操作抽象出来，形成一个抽象层对上提供统一的接口，这个抽象层就是 VFS（Virtual File System），虚拟文件系统。</p><p>这里的 rootfs 还有其他用处，下面我们会用到。</p><img src="`+r+'" alt="img" style="zoom:25%;"><p>最后，start_kernel() 调用的是 rest_init()，用来做其他方面的初始化，这里面做了好多的工作。</p><h2 id="初始化-1-号进程" tabindex="-1"><a class="header-anchor" href="#初始化-1-号进程" aria-hidden="true">#</a> 初始化 1 号进程</h2><p>rest_init 的第一大工作是，用 kernel_thread(kernel_init, NULL, CLONE_FS) 创建第二个进程，这个是 <strong>1 号进程</strong>。</p><p>1 号进程对于操作系统来讲，有“划时代”的意义。因为它将运行一个用户进程，这意味着这个公司把一个老板独立完成的制度，变成了可以交付他人完成的制度。这个 1 号进程就相当于老板带了一个大徒弟，有了第一个，就有第二个，后面大徒弟开枝散叶，带了很多徒弟，形成一棵进程树。</p><p>一旦有了用户进程，公司的运行模式就要发生一定的变化。因为原来你是老板，没有雇佣其他人，所有东西都是你的，无论多么关键的资源，第一，不会有人给你抢，第二，不会有人恶意破坏、恶意使用。</p><p>但是现在有了其他人，你就要开始做一定的区分，哪些是核心资源，哪些是非核心资源；办公区也要分开，有普通的项目人员都能访问的项目工作区，还有职业核心人员能够访问的核心保密区。</p><p>好在 x86 提供了分层的权限机制，把区域分成了四个 Ring，越往里权限越高，越往外权限越低。</p><img src="'+u+'" alt="img" style="zoom:25%;"><p>操作系统很好地利用了这个机制，将能够访问关键资源的代码放在 Ring0，我们称为<strong>内核态</strong>（Kernel Mode）；将普通的程序代码放在 Ring3，我们称为<strong>用户态</strong>（User Mode）。</p><p>你别忘了，现在咱们的系统已经处于保护模式了，保护模式除了可访问空间大一些，还有另一个重要功能，就是“保护”，也就是说，当处于用户态的代码想要执行更高权限的指令，这种行为是被禁止的，要防止他们为所欲为。</p><p>如果用户态的代码想要访问核心资源，怎么办呢？咱们不是有提供系统调用的办事大厅吗？这里是统一的入口，用户态代码在这里请求就是了。办事大厅后面就是内核态，用户态代码不用管后面发生了什么，做完了返回结果就可以了。</p><p>当一个用户态的程序运行到一半，要访问一个核心资源，例如访问网卡发一个网络包，就需要暂停当前的运行，调用系统调用，接下来就轮到内核中的代码运行了。</p><p>首先，内核将从系统调用传过来的包，在网卡上排队，轮到的时候就发送。发送完了，系统调用就结束了，返回用户态，让暂停运行的程序接着运行。</p><p>这个暂停怎么实现呢？其实就是把程序运行到一半的情况保存下来。例如，我们知道，内存是用来保存程序运行时候的中间结果的，现在要暂时停下来，这些中间结果不能丢，因为再次运行的时候，还要基于这些中间结果接着来。另外就是，当前运行到代码的哪一行了，当前的栈在哪里，这些都是在寄存器里面的。</p><p>所以，暂停的那一刻，要把当时 CPU 的寄存器的值全部暂存到一个地方，这个地方可以放在进程管理系统很容易获取的地方。在后面讨论进程管理数据结构的时候，我们还会详细讲。当系统调用完毕，返回的时候，再从这个地方将寄存器的值恢复回去，就能接着运行了。</p><figure><img src="'+d+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>这个过程就是这样的：用户态 - 系统调用 - 保存寄存器 - 内核态执行系统调用 - 恢复寄存器 - 返回用户态，然后接着运行。</p><img src="'+k+`" alt="img" style="zoom:25%;"><h2 id="从内核态到用户态" tabindex="-1"><a class="header-anchor" href="#从内核态到用户态" aria-hidden="true">#</a> <strong>从内核态到用户态</strong></h2><blockquote><p>内核态到用户态的恢复过程： (rest_init-&gt;kernel_init)-&gt;run_in_process-&gt;do_execve-&gt;do_execveat_common-&gt;exec_binprm-&gt;search_binary_handler-&gt;load_elf_binary &amp; start_thread（start_thread中设置好用户态的寄存器）-&gt; radomdisk的init-&gt;实际文件系统的init</p><p>用户态执行系统调用： 执行系统调用时，先将用户态的寄存器等信息保存到内存中的某个地方（todo），再执行内核态逻辑，再从这个地方将寄存器的值恢复回去并继续执行。</p></blockquote><p>我们再回到 1 号进程启动的过程。当前执行 kernel_thread 这个函数的时候，我们还在内核态，现在我们就来跨越这道屏障，到用户态去运行一个程序。这该怎么办呢？很少听说“先内核态再用户态”的。</p><p>kernel_thread 的参数是一个函数 kernel_init，也就是这个进程会运行这个函数。在 kernel_init 里面，会调用 kernel_init_freeable()，里面有这样的代码：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ramdisk_execute_command<span class="token punctuation">)</span>
    ramdisk_execute_command <span class="token operator">=</span> <span class="token string">&quot;/init&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>先不管 ramdisk 是啥，我们回到 kernel_init 里面。这里面有这样的代码块：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>  <span class="token keyword">if</span> <span class="token punctuation">(</span>ramdisk_execute_command<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ret <span class="token operator">=</span> <span class="token function">run_init_process</span><span class="token punctuation">(</span>ramdisk_execute_command<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">try_to_run_init_process</span><span class="token punctuation">(</span><span class="token string">&quot;/sbin/init&quot;</span><span class="token punctuation">)</span> <span class="token operator">||</span>
      <span class="token operator">!</span><span class="token function">try_to_run_init_process</span><span class="token punctuation">(</span><span class="token string">&quot;/etc/init&quot;</span><span class="token punctuation">)</span> <span class="token operator">||</span>
      <span class="token operator">!</span><span class="token function">try_to_run_init_process</span><span class="token punctuation">(</span><span class="token string">&quot;/bin/init&quot;</span><span class="token punctuation">)</span> <span class="token operator">||</span>
      <span class="token operator">!</span><span class="token function">try_to_run_init_process</span><span class="token punctuation">(</span><span class="token string">&quot;/bin/sh&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这就说明，1 号进程运行的是一个文件。如果我们打开 run_init_process 函数，会发现它调用的是 do_execve。</p><p>这个名字是不是看起来很熟悉？前面讲系统调用的时候，execve 是一个系统调用，它的作用是运行一个执行文件。加一个 do_ 的往往是内核系统调用的实现。没错，这就是一个系统调用，它会尝试运行 ramdisk 的“/init”，或者普通文件系统上的“/sbin/init”“/etc/init”“/bin/init”“/bin/sh”。不同版本的 Linux 会选择不同的文件启动，但是只要有一个起来了就可以。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">run_init_process</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>init_filename<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  argv_init<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> init_filename<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">do_execve</span><span class="token punctuation">(</span><span class="token function">getname_kernel</span><span class="token punctuation">(</span>init_filename<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token keyword">const</span> __user <span class="token operator">*</span><span class="token punctuation">)</span>argv_init<span class="token punctuation">,</span>
    <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token keyword">const</span> __user <span class="token operator">*</span><span class="token punctuation">)</span>envp_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如何利用执行 init 文件的机会，从内核态回到用户态呢？</p><p>我们从系统调用的过程可以得到启发，“用户态 - 系统调用 - 保存寄存器 - 内核态执行系统调用 - 恢复寄存器 - 返回用户态”，然后接着运行。而咱们刚才运行 init，是调用 do_execve，正是上面的过程的后半部分，从内核态执行系统调用开始。</p><p>do_execve-&gt;do_execveat_common-&gt;exec_binprm-&gt;search_binary_handler，这里面会调用这段内容：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">search_binary_handler</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">linux_binprm</span> <span class="token operator">*</span>bprm<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">struct</span> <span class="token class-name">linux_binfmt</span> <span class="token operator">*</span>fmt<span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  retval <span class="token operator">=</span> fmt<span class="token operator">-&gt;</span><span class="token function">load_binary</span><span class="token punctuation">(</span>bprm<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也就是说，我要运行一个程序，需要加载这个二进制文件，这就是我们常说的<strong>项目执行计划书</strong>。它是有一定格式的。Linux 下一个常用的格式是 <strong>ELF</strong>（Executable and Linkable Format，可执行与可链接格式）。于是我们就有了下面这个定义：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">linux_binfmt</span> elf_format <span class="token operator">=</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span>module  <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span>
<span class="token punctuation">.</span>load_binary  <span class="token operator">=</span> load_elf_binary<span class="token punctuation">,</span>
<span class="token punctuation">.</span>load_shlib  <span class="token operator">=</span> load_elf_library<span class="token punctuation">,</span>
<span class="token punctuation">.</span>core_dump  <span class="token operator">=</span> elf_core_dump<span class="token punctuation">,</span>
<span class="token punctuation">.</span>min_coredump  <span class="token operator">=</span> ELF_EXEC_PAGESIZE<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这其实就是先调用 load_elf_binary，最后调用 start_thread。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">start_thread</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token operator">*</span>regs<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> new_ip<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> new_sp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token function">set_user_gs</span><span class="token punctuation">(</span>regs<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
regs<span class="token operator">-&gt;</span>fs  <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
regs<span class="token operator">-&gt;</span>ds  <span class="token operator">=</span> __USER_DS<span class="token punctuation">;</span>
regs<span class="token operator">-&gt;</span>es  <span class="token operator">=</span> __USER_DS<span class="token punctuation">;</span>
regs<span class="token operator">-&gt;</span>ss  <span class="token operator">=</span> __USER_DS<span class="token punctuation">;</span>
regs<span class="token operator">-&gt;</span>cs  <span class="token operator">=</span> __USER_CS<span class="token punctuation">;</span>
regs<span class="token operator">-&gt;</span>ip  <span class="token operator">=</span> new_ip<span class="token punctuation">;</span>
regs<span class="token operator">-&gt;</span>sp  <span class="token operator">=</span> new_sp<span class="token punctuation">;</span>
regs<span class="token operator">-&gt;</span>flags  <span class="token operator">=</span> X86_EFLAGS_IF<span class="token punctuation">;</span>
<span class="token function">force_iret</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">EXPORT_SYMBOL_GPL</span><span class="token punctuation">(</span>start_thread<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看到这里，你是不是有点感觉了？struct pt_regs，看名字里的 register，就是寄存器啊！这个结构就是在系统调用的时候，内核中保存用户态运行上下文的，里面将用户态的代码段 CS 设置为 __USER_CS，将用户态的数据段 DS 设置为 __USER_DS，以及指令指针寄存器 IP、栈指针寄存器 SP。这里相当于补上了原来系统调用里，保存寄存器的一个步骤。</p><p>最后的 iret 是干什么的呢？它是用于从系统调用中返回。这个时候会恢复寄存器。从哪里恢复呢？按说是从进入系统调用的时候，保存的寄存器里面拿出。好在上面的函数补上了寄存器。CS 和指令指针寄存器 IP 恢复了，指向用户态下一个要执行的语句。DS 和函数栈指针 SP 也被恢复了，指向用户态函数栈的栈顶。所以，下一条指令，就从用户态开始运行了。</p><h2 id="ramdisk-的作用" tabindex="-1"><a class="header-anchor" href="#ramdisk-的作用" aria-hidden="true">#</a> <strong>ramdisk 的作用</strong></h2><p>init 终于从内核到用户态了。一开始到用户态的是 ramdisk 的 init，后来会启动真正根文件系统上的 init，成为所有用户态进程的祖先。</p><p>为什么会有 ramdisk 这个东西呢？还记得上一节咱们内核启动的时候，配置过这个参数：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>initrd16 /boot/initramfs-3.10.0-862.el7.x86_64.img
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>就是这个东西，这是一个基于内存的文件系统。为啥会有这个呢？</p><p>是因为刚才那个 init 程序是在文件系统上的，文件系统一定是在一个存储设备上的，例如硬盘。Linux 访问存储设备，要有驱动才能访问。如果存储系统数目很有限，那驱动可以直接放到内核里面，反正前面我们加载过内核到内存里了，现在可以直接对存储系统进行访问。</p><p>但是存储系统越来越多了，如果所有市面上的存储系统的驱动都默认放进内核，内核就太大了。这该怎么办呢？</p><p>我们只好先弄一个基于内存的文件系统。内存访问是不需要驱动的，这个就是 ramdisk。这个时候，ramdisk 是根文件系统。</p><p>然后，我们开始运行 ramdisk 上的 /init。等它运行完了就已经在用户态了。/init 这个程序会先根据存储系统的类型加载驱动，有了驱动就可以设置真正的根文件系统了。有了真正的根文件系统，ramdisk 上的 /init 会启动文件系统上的 init。</p><p>接下来就是各种系统的初始化。启动系统的服务，启动控制台，用户就可以登录进来了。</p><p>先别忙着高兴，rest_init 的第一个大事情才完成。我们仅仅形成了用户态所有进程的祖先。</p><blockquote><p>ramdisk里面是不是也要提前放上存储设备的驱动，然后ramdisk里面的init起来之后，加载对应存储设备的驱动，为了适应各种存储设备，ramdisk里面需要放上市面上各种存储设备的驱动吗？如果是这样的话，那跟把这些驱动放到内核里有什么区别呢？反正也没有节省空间。</p><p>我的理解是这样的，ramdisk中只放要运行的电脑上的存储设备驱动，内核中不放存储设备驱动，这样的话如果每次存储设备不同，我们只需要做一个对应的ramdisk，每次更换存储设备只需要做ramdisk，而内核只需要编译一次就行了，这样效率会提高？如果驱动放到内核一起编译，每次换存储设备都要重新编译内核，效率低。编译内核比做一个新的ramdisk效率低。</p><p>不知道以上理解对不对，还请老师指点一二。<br> 作者回复: 是的</p><p>加载不同文件系统的驱动这件事本来是要放在内核里的，但这会导致内核很大，所以放到ramdisk的/init里去做，但ramdisk是基于内存的，应该是系统启动后才会有，所以/init程序应该还是从内核里来的，那这和内核直接加载文件系统驱动，到底有什么不同呢？<br> 作者回复: 后期加载就不会放到内核镜像里面了</p></blockquote><h2 id="创建-2-号进程" tabindex="-1"><a class="header-anchor" href="#创建-2-号进程" aria-hidden="true">#</a> <strong>创建 2 号进程</strong></h2><p>用户态的所有进程都有大师兄了，那内核态的进程有没有一个人统一管起来呢？有的，rest_init 第二大事情就是第三个进程，就是 2 号进程。</p><p>kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES) 又一次使用 kernel_thread 函数创建进程。这里需要指出一点，函数名 thread 可以翻译成“线程”，这也是操作系统很重要的一个概念。它和进程有什么区别呢？为什么这里创建的是进程，函数名却是线程呢？</p><p>从用户态来看，创建进程其实就是立项，也就是启动一个项目。这个项目包含很多资源，例如会议室、资料库等。这些东西都属于这个项目，但是这个项目需要人去执行。有多个人并行执行不同的部分，这就叫<strong>多线程</strong>（Multithreading）。如果只有一个人，那它就是这个项目的主线程。</p><p>但是从内核态来看，无论是进程，还是线程，我们都可以统称为任务（Task），都使用相同的数据结构，平放在同一个链表中。这些在进程的那一章节，我会更加详细地讲。</p><p>这里的函数 kthreadd，负责所有内核态的线程的调度和管理，是内核态所有线程运行的祖先。</p><p>这下好了，用户态和内核态都有人管了，可以开始接项目了。</p><h2 id="总结时刻" tabindex="-1"><a class="header-anchor" href="#总结时刻" aria-hidden="true">#</a> <strong>总结时刻</strong></h2><p>这一节，我们讲了内核的初始化过程，主要做了以下几件事情：</p><p>各个职能部门的创建；</p><p>用户态祖先进程的创建；</p><p>内核态祖先进程的创建。</p><p>咱们还是用一个图来总结一下这个过程。</p><img src="`+e+'" alt="img" style="zoom:25%;"><img src="'+_+'" alt="img" style="zoom:25%;"><blockquote><p>linux内核初始化，首先要初始化职能部门，init/main.c文件的start_kernel函数，相当于main函数，</p><ol><li>第一步 <code>INIT_TASK()</code> 初始化项目管理部，进程管理系统 - 对执行中的项目(进程)进行生命周期和资源管理<br> 【初始化进程列表，创建0号进程】<br><code>set_task_stack_end_magic(&amp;init_task)</code> and <code>struct task_struct init_task = INIT_TASK(init_task)</code></li><li>第二步 <code>trap_init()</code> 初始化统一办事厅，系统调用 - 可以区分用户态/内核态 - 项目(找老板元老)请求公司资源(系统内核)的统一入口。<br> 【初始化中断，设置系统调用的中断门】系统调用也是通过发送中断进行, 由 <code>set_system_intr_gate()</code> 完成</li><li>第三步 <code>mm_init()</code> 初始化会议室管理，内存管理系统 - 对执行中的项目(进程)使用的会议室(内存)进行管理分配回收隔离<br> 【初始化内存管理模块】</li><li>？<br> 第四步 <code>sched_init()</code> 初始化调度器，实现进程调度功能<br> ？</li><li>第五步 <code>vfs_caches_init()</code> 初始化资料档案库，文件管理系统 - 对公司所有项目(程序)使用的文档资料(文件)进行管理<br> 【初始化VFS（虚拟文件系统），将各种文件系统抽象成统一接口】<br> 初始化基于内存的管理系统 rootfs，register_filesystem，在 VFS虚拟文件系统 定义了一种类型，<br> 文件系统是资料库，抽象出数据结构和操作，形成抽象层，就是虚拟文件系统，</li></ol><ul><li><mark><strong>调用<code>rest_init() </code>完成其他初始化工作，</strong></mark></li></ul><ol start="6"><li><p>rest_init的一大作用初始化<code>1号进程</code>，第一个用户进程，是用户态进程的祖先，管理/创建用户态进程的进程。<br> 【初始化1号进程（用户态进程祖先），在内核态中准备好寄存器后恢复用户态】<br><code>rest_init()</code> 通过 <code>kernel_thread(kernel_init,...)</code> 创建 1号进程(工作在用户态).</p><ul><li>权限管理 <ul><li>x86 提供 4个 Ring 分层权限</li><li>操作系统利用: Ring0-内核态(访问核心资源); Ring3-用户态(普通程序)</li></ul></li><li>用户态调用系统调用: 用户态-系统调用-保存寄存器-内核态执行系统调用-恢复寄存器-返回用户态</li><li>新进程执行 kernel_init 函数, 先运行 ramdisk 的 /init 程序(位于内存中) <ul><li>首先加载 ELF 文件</li><li>设置用于保存用户态寄存器的结构体</li><li>返回进入用户态</li><li>/init 加载存储设备的驱动</li></ul></li><li>kernel_init 函数启动存储设备文件系统上的 init</li></ul><ol><li>1号进程启动的过程，kernal_thread函数有kernal_init函数，里面kernal_init_freeable函数，1号进程运行的是一些文件，</li><li>run_init_process函数，里面调用的do_execve，execve运行一个执行文件，do是系统内核的调用， <ol><li>一般会运行ramdisk/init，sbin/init，bin/init，etc/init和bib/sh，</li></ol></li><li>内核态执行系统调用，首先会执行项目执行计划书，即一个ELF格式的文件，然后start_thread，struct regs寄存器， <ol><li>系统调用的时候保存用户上下文，里面将代码段的CS设置为<code>_USER_CS</code>，将用户态的数据段的CS设置为<code>_USER_DS</code>，</li><li>iret函数用于恢复寄存器， <ol><li>从保存的寄存器里拿出，CS和IP指令指针寄存器恢复了，指向下一个要执行的语句，</li><li>DS和函数栈指针SP也恢复了，指向函数栈的栈顶。</li><li>ramdisk的作用，ramdisk是一个基于内存的文件系统，<br> linux访问存储设备需要驱动，如果市面上所有的系统都放进内核里面，会很大，<br> 所以有了ramdisk根文件系统，ramdisk的/init会启动文件系统的init，</li></ol></li></ol></li></ol></li><li><p>接下来是系统其他的初始化，<code>2号进程</code>是内核进程的大师兄，管理/创建内核态进程的进程。<br> 【初始化2号进程（内核态进程祖先）】<br><code>rest_init()</code> 通过 <code>kernel_thread(kthreadd,...)</code> 创建 2号进程(工作在内核态).</p><ol><li>kthreadd负责所有内核态线程的调度和管理，用户态有多线程的概念，可以并行执行，</li><li>内核态线程和进程数据结构一样，统称为Task，在内核里面所有都是task</li><li>是<code>任务</code>，任务<code>也有pid</code>，<strong>因此<code>内核</code>里面<code>不区分</code>进程和线程</strong></li></ol></li></ol></blockquote><h2 id="课堂练习" tabindex="-1"><a class="header-anchor" href="#课堂练习" aria-hidden="true">#</a> <strong>课堂练习</strong></h2><p>这一节，我们看到内核创建了一些进程，这些进程都是放在一个列表中的，请你研读内核代码，看看这个列表是如何实现的。</p><p>欢迎留言和我分享你的疑惑和见解，也欢迎你收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习、进步。</p><h2 id="课后讨论" tabindex="-1"><a class="header-anchor" href="#课后讨论" aria-hidden="true">#</a> 课后讨论</h2>',109),b={href:"https://j.youzan.com/BA2Fr9%EF%BC%89",target:"_blank",rel:"noopener noreferrer"},h={href:"https://github.com/mengning/mykernel",target:"_blank",rel:"noopener noreferrer"},g=n("br",null,null,-1),f={href:"https://elixir.bootlin.com/linux/latest/source",target:"_blank",rel:"noopener noreferrer"},y=n("p",null,"对于你我这种搞 java 的，对 c 基本上是小白，看源码连函数位置都找不到，强烈建议：使用 source insight4.0 打开 Linux 源码，然后重点来了，使用 project -> synchronize files -> force all files to be... 工具同步一下（找了好久才找到，说出来都是泪啊），基本上就可以到处跳转啦。",-1),x=n("p",null,"这样基本上都可以找到函数位置了，爽歪歪的，不过源码我也只是验证一下文中的内容，陷太深了也完蛋。",-1),S=n("p",null,"作者回复: 是的",-1),w=n("p",null,[s("需要自己去看源码，才能理解了。老师画的图是真的好"),n("br"),n("code",null,"作者回复: 鼓励看代码，但是别纠结")],-1);function E(L,q){const a=p("ExternalLinkIcon");return o(),c("div",null,[v,n("p",null,[s("推荐一本入门书配套本课程学习，《庖丁解牛Linux内核分析》（ "),n("a",b,[s("https://j.youzan.com/BA2Fr9）"),t(a)])]),n("p",null,[s("学习Linux内核，我建议看看myKernel("),n("a",h,[s("https://github.com/mengning/mykernel"),t(a)]),s(")")]),n("p",null,[s("有什么工具可以打开内核源码，在能直接跳转方法的？"),g,s(" 作者回复: sourceinsight "),n("a",f,[s("https://elixir.bootlin.com/linux/latest/source"),t(a)])]),y,x,S,w])}const I=i(m,[["render",E],["__file","G08-内核初始化.html.vue"]]);export{I as default};
