import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{r,o as i,c as s,a as e,b as a,e as o,d as c}from"./app-cdabc73c.js";const h="/assets/640-1691477191457-69-87dccf3c.png",d={},p=e("h1",{id:"_29-白泽带你读论文using-safety-properties-to-generate-vulnerabilitypatches",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_29-白泽带你读论文using-safety-properties-to-generate-vulnerabilitypatches","aria-hidden":"true"},"#"),a(" 29-白泽带你读论文Using Safety Properties to Generate VulnerabilityPatches")],-1),l=e("p",null,[e("strong",null,"Using Safety Properties to Generate Vulnerability Patches")],-1),_=e("p",null,"原文链接：",-1),f={href:"http://www.cse.psu.edu/~gxt29/papers/Senx-oakland19.pdf%E3%80%82",target:"_blank",rel:"noopener noreferrer"},u=c('<p>这篇文章收录在Oakland 2019。其一作是德保罗大学的助理教授，从事于研究软件安全、移动安全、程序分析等领域。</p><h2 id="_1-主要内容" tabindex="-1"><a class="header-anchor" href="#_1-主要内容" aria-hidden="true">#</a> <strong>1 主要内容</strong></h2><p>安全漏洞广泛存在于应用程序中，也一直受到研究者们的关注。一旦程序中的漏洞被发现，开发者需要尽快给程序打上补丁以防止漏洞被利用。由于人为发现并修补程序漏洞的周期较长，一部分研究致力于如何自动发现程序中的漏洞并给源代码打上补丁。</p><p>先前的做法通常基于大量的样例输入进行测试。补丁生成工具根据开发者给出的一系列输入来生成可能的补丁。如果补丁能够使得所有的样例输入符合预期结果，那么它就被认为是正确的。由于这种方法并不能反映程序中各个变量的关系，同时也不能覆盖所有可能的输入，其缺陷显而易见。作者因而提出了基于安全规则的补丁生成方法，它能够有效地解决先前工作的缺陷。</p><p>作者基于该方法实现了<mark>Senx工具</mark>，它能够识别3种类型的漏洞，并且给应用程序打上补丁。作者尝试对现实应用程序中的42个漏洞进行修复，最后成功修复了其中的32个。</p><h2 id="_2-设计与实现" tabindex="-1"><a class="header-anchor" href="#_2-设计与实现" aria-hidden="true">#</a> <strong>2 设计与实现</strong></h2><figure><img src="'+h+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>Senx工具的工作流程图如上，主要分为4个阶段：</p><h3 id="_1-vulnerability-identification" tabindex="-1"><a class="header-anchor" href="#_1-vulnerability-identification" aria-hidden="true">#</a> 1 Vulnerability Identification</h3><p>这一步中，作者基于符号执行引擎KLEE做了扩展，可以根据一个应用程序和一个可以触发其漏洞的输入，得到程序中的漏洞点，其漏洞类型，以及其他一些可以供后续分析的信息。</p><h3 id="_2-predicate-generation" tabindex="-1"><a class="header-anchor" href="#_2-predicate-generation" aria-hidden="true">#</a> 2 Predicate Generation</h3><p>这一步的目标是得到一个判断漏洞是否触发的判断逻辑。这一步的关键在于如何确定程序中循环结构中的内存访问范围。为此，作者提出了两种循环分析技术，Access Range Analysis和Loop Cloning。</p><p>Access Range Analysis技术用于分析可规范化循环结构中的内存访问范围。所谓可规范化的是指，控制循环次数的变量有着固定的起始值，跨度和结束条件，而每次循环中的内存跨度也是固定值。这样我们能够很方便地用变量表示出循环执行的次数。通过与每次循环的内存跨度相乘，我们能够很容易地表示出循环中的内存访问范围。</p><p>Loop Cloning技术用于分析不可规范化循环结构中的内存访问范围。其主要思想在于通过克隆循环结构中的代码，并且把有副作用的语句去掉，这样我们就能够在循环执行结束后得到循环内内存访问范围的表达式。</p><h3 id="_3-patch-placement" tabindex="-1"><a class="header-anchor" href="#_3-patch-placement" aria-hidden="true">#</a> 3 Patch Placement</h3><p>这一步的目标是在源代码中找到合适的位置放置补丁逻辑。之所以需要找到这个合适的位置，是因为第二步Predicate Generation生成的检测漏洞触发的逻辑需要用到源代码中的变量，而只有在这些变量的作用域范围内才能够使用这些变量。为了解决补丁的位置和其所需要用到的变量不在同一个作用域的问题，作者提出了Expression Translation技术。其核心想法在于，变量声明到与之相关的漏洞被触发之间通常存在着函数调用链，而变量信息通常会通过函数调用的方式传递。由于形参和实参信息的等价性，我们通过分析可以将实参和形参建立一定的关系，这样变量信息就能在函数调用的过程中传递下去。由此，我们就能够解决变量与补丁不在同一个作用域的问题。</p><h3 id="_4-patch-synthesis" tabindex="-1"><a class="header-anchor" href="#_4-patch-synthesis" aria-hidden="true">#</a> 4 Patch Synthesis</h3><p>这一步即根据前三步的分析结果和一定的语法规则，来生成最后的补丁。</p><h2 id="_3-实验评估" tabindex="-1"><a class="header-anchor" href="#_3-实验评估" aria-hidden="true">#</a> <strong>3 实验评估</strong></h2><p>作者基于现实应用中的42个漏洞进行了测试，其能够给其中的32个漏洞打上补丁。这些补丁经过人为检测也是能够使用的。而对于剩下的一些漏洞，补丁生成失败的主要原因是Senx第二步和第三步中的分析失败了。作者在这些步骤的过程中有一些比较强的假设，而一部分应用代码并不能满足这些假设。比如第三步中，对于内存信息在函数作用域间传递，如果函数只传递了内存起始地址而不传递内存结束地址，那么在被调用函数中就无法确定内存的实际范围。</p><p>作者将该工作的工具与先前工作的工具进行比较。该工作中的工具能够解决先前工作所不能解决的安全漏洞问题，这能够证明该工作优于先前的工作。</p><p>作者还对本文中提到的程序分析技术进行了测试，这些程序分析技术能够在作者用到的大部分测试用例下工作，这证明了这些技术的适用性比较普遍。</p><h2 id="_4-总结评价" tabindex="-1"><a class="header-anchor" href="#_4-总结评价" aria-hidden="true">#</a> <strong>4 总结评价</strong></h2><p>作者提出的基于安全属性来生成源代码中漏洞补丁的方法能够解决先前工作不精确、输入覆盖率不够的问题。由于其安全规则是可以扩展的，因此该工具可以应对更多类型的漏洞。但是其成功率依赖于工具中第二步和第三步的分析技术。由于这些分析技术在绝大多数情况下具有适用性，因此该工具生成漏洞补丁的质量与成功率都是可以接受的。未来的工作可以通过进一步改进过程中分析技术来提高补丁生成的成功率。</p>',24);function g(x,b){const t=r("ExternalLinkIcon");return i(),s("div",null,[p,l,_,e("p",null,[e("a",f,[a("http://www.cse.psu.edu/~gxt29/papers/Senx-oakland19.pdf。"),o(t)])]),u])}const P=n(d,[["render",g],["__file","29-白泽带你读论文Using Safety Properties to Generate VulnerabilityPatches.html.vue"]]);export{P as default};
