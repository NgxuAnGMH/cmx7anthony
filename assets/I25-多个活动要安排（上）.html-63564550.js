import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as a,d as t}from"./app-cdabc73c.js";const p="/assets/8b94e8daaf985262d6a83d38dbb07152-608025d2.jpg",e="/assets/a3ec5e2e1c0dc6acdb50095b20e2977a-663645e1.jpg",o="/assets/5181c38bfcb42c688076daaeb3452d49-4f6355fe.jpg",c="/assets/283efe1570a388902ae842acyyb299d0-ed58495a.jpg",l="/assets/2414600d584323034cbd383c756yybc4-6b308802.jpg",i={},u=t('<h1 id="_25-多个活动要安排-上-多进程如何调度" tabindex="-1"><a class="header-anchor" href="#_25-多个活动要安排-上-多进程如何调度" aria-hidden="true">#</a> 25 | 多个活动要安排（上）：多进程如何调度？</h1><p>你好，我是 LMOS。</p><p>上节课，我们了解了什么是进程，还一起写好了建立进程的代码。不知道你想过没有，如果在系统中只有一个进程，那我们提出进程相关的概念和实现与进程有关的功能，是不是就失去了意义呢？</p><p>显然，提出进程的目的之一，就是为了实现多个进程，使系统能运行多个应用程序。今天我们就在单进程的基础上扩展多进程，并在进程与进程之间进行调度。</p><p>“你存在，我深深的脑海里，我的梦里，我的心里，我的代码里”，我经常一边哼着歌，一边写着代码，这就是我们大脑中最典型“多进程”场景。</p><p>再来举一个例子：你在 Windows 上，边听音乐，边浏览网页，还能回复微信消息。Windows 之所以能同时运行多个应用程序，就是因为 Windows 内核支持多进程机制，这就是最典型的多进程场景了。</p><p>这节课配套代码，你可以点击这里下载。</p><h2 id="为什么需要多进程调度" tabindex="-1"><a class="header-anchor" href="#为什么需要多进程调度" aria-hidden="true">#</a> 为什么需要多进程调度</h2><p>我们先来搞清楚多进程调度的原因是什么，我来归纳一下。</p><p>第一，CPU 同一时刻只能运行一个进程，而 CPU 个数总是比进程个数少，这就需要让多进程共用一个 CPU，每个进程在这个 CPU 上运行一段时间。</p><p>第二点原因，当一个进程不能获取某种资源，导致它不能继续运行时，就应该让出 CPU。当然你也可以把第一点中的 CPU 时间，也归纳为一种资源，这样就合并为一点：**进程拿不到资源就要让出 CPU。**我来为你画幅图就明白了，如下所示。</p><img src="'+p+`" alt="img" style="zoom:15%;"><p>多进程调度示意图</p><p>上图中，有五个进程，其中浏览器进程和微信进程依赖于网络和键盘的数据资源，如果不能满足它们，就应该通过进程调度让出 CPU。</p><p>而两个科学计算进程，则更多的依赖于 CPU，但是如果它们中的一个用完了自己的 CPU 时间，也得借助进程调度让出 CPU，不然它就会长期霸占 CPU，导致其它进程无法运行。需要注意的是，每个进程都会依赖一种资源，那就是 CPU 时间，你可以把 CPU 时间理解为它就是 CPU，一个进程必须要有 CPU 才能运行。</p><p>这里我们只需要明白，多个进程为什么要进行调度，就可以了。</p><h2 id="管理进程" tabindex="-1"><a class="header-anchor" href="#管理进程" aria-hidden="true">#</a> 管理进程</h2><p>下面我们一起来看看怎么管理进程，我们的 Cosmos 操作系统也支持多个进程，有了多个进程就要把它们管理起来。说白了，就是弄清楚这些进程有哪些状态，是如何组织起来的，又要从哪找到它们。</p><h2 id="进程的生命周期" tabindex="-1"><a class="header-anchor" href="#进程的生命周期" aria-hidden="true">#</a> 进程的生命周期</h2><p>人有生老病死，对于一个进程来说也是一样。一个进程从建立开始，接着运行，然后因为资源问题不得不暂停运行，最后退出系统。这一过程，我们称为进程的生命周期。在系统实现中，通常用进程的状态表示进程的生命周期。进程的状态我们用几个宏来定义，如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TDSTUS_RUN</span> <span class="token expression"><span class="token number">0</span>        </span><span class="token comment">//进程运行状态</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TDSTUS_SLEEP</span> <span class="token expression"><span class="token number">3</span>      </span><span class="token comment">//进程睡眠状态</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TDSTUS_WAIT</span> <span class="token expression"><span class="token number">4</span>       </span><span class="token comment">//进程等待状态</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TDSTUS_NEW</span> <span class="token expression"><span class="token number">5</span>        </span><span class="token comment">//进程新建状态</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TDSTUS_ZOMB</span> <span class="token expression"><span class="token number">6</span>       </span><span class="token comment">//进程僵死状态</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以发现，我们的进程有 5 个状态。其中进程僵死状态，表示进程将要退出系统不再进行调度。那么进程状态之间是如何转换的，别急，我来给画一幅图解释，如下所示。</p><img src="`+e+`" alt="img" style="zoom:15%;"><p>进程状态切换示意图</p><p>上图中已经为你展示了，从建立进程到进程退出系统各状态之间的转换关系和需要满足的条件。</p><h2 id="如何组织进程" tabindex="-1"><a class="header-anchor" href="#如何组织进程" aria-hidden="true">#</a> 如何组织进程</h2><p>首先我们来研究如何组织进程。由于系统中会有许多个进程，在上节课中我们用 thread_t 结构表示一个进程，因此会有多个 thread_t 结构。而根据刚才我们对进程生命周期的解读，我们又知道了进程是随时可能建立或者退出的，所以系统中会随时分配或者删除 thread_t 结构。</p><p>要应对这样的情况，最简单的办法就是<strong>使用链表数据结构</strong>，而且我们的进程有优先级，所以我们可以设计成<strong>每个优先级对应一个链表头</strong>。</p><p>下面我们来把设计落地成数据结构，由于这是调度器模块，所以我们要建立几个文件 <code>krlsched.h</code>、<code>krlsched.c</code>，在其中写上代码，如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">s_THRDLST</span>
<span class="token punctuation">{</span>
    <span class="token class-name">list_h_t</span>    tdl_lsth<span class="token punctuation">;</span>                <span class="token comment">//挂载进程的链表头</span>
    <span class="token class-name">thread_t</span><span class="token operator">*</span>   tdl_curruntd<span class="token punctuation">;</span>            <span class="token comment">//该链表上正在运行的进程</span>
    <span class="token class-name">uint_t</span>      tdl_nr<span class="token punctuation">;</span>                  <span class="token comment">//该链表上进程个数</span>
<span class="token punctuation">}</span><span class="token class-name">thrdlst_t</span><span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">s_SCHDATA</span>
<span class="token punctuation">{</span>
    <span class="token class-name">spinlock_t</span>  sda_lock<span class="token punctuation">;</span>                <span class="token comment">//自旋锁</span>
    <span class="token class-name">uint_t</span>      sda_cpuid<span class="token punctuation">;</span>               <span class="token comment">//当前CPU id</span>
    <span class="token class-name">uint_t</span>      sda_schdflgs<span class="token punctuation">;</span>            <span class="token comment">//标志</span>
    <span class="token class-name">uint_t</span>      sda_premptidx<span class="token punctuation">;</span>           <span class="token comment">//进程抢占计数</span>
    <span class="token class-name">uint_t</span>      sda_threadnr<span class="token punctuation">;</span>            <span class="token comment">//进程数</span>
    <span class="token class-name">uint_t</span>      sda_prityidx<span class="token punctuation">;</span>            <span class="token comment">//当前优先级</span>
    <span class="token class-name">thread_t</span><span class="token operator">*</span>   sda_cpuidle<span class="token punctuation">;</span>             <span class="token comment">//当前CPU的空转进程</span>
    <span class="token class-name">thread_t</span><span class="token operator">*</span>   sda_currtd<span class="token punctuation">;</span>              <span class="token comment">//当前正在运行的进程</span>
    <span class="token class-name">thrdlst_t</span>   sda_thdlst<span class="token punctuation">[</span>PRITY_MAX<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">//进程链表数组</span>
<span class="token punctuation">}</span><span class="token class-name">schdata_t</span><span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">s_SCHEDCALSS</span>
<span class="token punctuation">{</span>
    <span class="token class-name">spinlock_t</span>  scls_lock<span class="token punctuation">;</span>                <span class="token comment">//自旋锁</span>
    <span class="token class-name">uint_t</span>      scls_cpunr<span class="token punctuation">;</span>               <span class="token comment">//CPU个数</span>
    <span class="token class-name">uint_t</span>      scls_threadnr<span class="token punctuation">;</span>            <span class="token comment">//系统中所有的进程数</span>
    <span class="token class-name">uint_t</span>      scls_threadid_inc<span class="token punctuation">;</span>        <span class="token comment">//分配进程id所用</span>
    <span class="token class-name">schdata_t</span>   scls_schda<span class="token punctuation">[</span>CPUCORE_MAX<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//每个CPU调度数据结构</span>
<span class="token punctuation">}</span><span class="token class-name">schedclass_t</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上述代码中，我们发现 schedclass_t 是个全局数据结构，这个结构里包含一个 schdata_t 结构数组，数组大小根据 CPU 的数量决定。在每个 schdata_t 结构中，又包含一个进程优先级大小的 thrdlst_t 结构数组。我画幅图，你就明白了。这幅图能让你彻底理清以上数据结构之间的关系。</p><img src="`+o+`" alt="img" style="zoom:15%;"><p>组织进程示意图</p><p>好，下面我们就去定义这个 schedclass_t 数据结构并初始化。</p><h2 id="管理进程的初始化" tabindex="-1"><a class="header-anchor" href="#管理进程的初始化" aria-hidden="true">#</a> 管理进程的初始化</h2><p>管理进程的初始化非常简单，就是对 schedclass_t 结构的变量的初始化。</p><p>通过前面的学习，你也许已经发现了，schedclass_t 结构的变量应该是个全局变量，所以先得在 cosmos/kernel/<code>krlglobal.c</code> 文件中定义一个 schedclass_t 结构的全局变量，如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token function">KRL_DEFGLOB_VARIABLE</span><span class="token punctuation">(</span><span class="token class-name">schedclass_t</span><span class="token punctuation">,</span>osschedcls<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>有了 schedclass_t 结构的全局变量 osschedcls，接着我们在 cosmos/kernel/<code>krlsched.c</code> 文件中写好初始化 osschedcls 变量的代码，如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">thrdlst_t_init</span><span class="token punctuation">(</span><span class="token class-name">thrdlst_t</span> <span class="token operator">*</span>initp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">list_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>initp<span class="token operator">-&gt;</span>tdl_lsth<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//初始化挂载进程的链表</span>
    initp<span class="token operator">-&gt;</span>tdl_curruntd <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//开始没有运行进程 </span>
    initp<span class="token operator">-&gt;</span>tdl_nr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">//开始没有进程</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">schdata_t_init</span><span class="token punctuation">(</span><span class="token class-name">schdata_t</span> <span class="token operator">*</span>initp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">krlspinlock_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>initp<span class="token operator">-&gt;</span>sda_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    initp<span class="token operator">-&gt;</span>sda_cpuid <span class="token operator">=</span> <span class="token function">hal_retn_cpuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取CPU id</span>
    initp<span class="token operator">-&gt;</span>sda_schdflgs <span class="token operator">=</span> NOTS_SCHED_FLGS<span class="token punctuation">;</span>
    initp<span class="token operator">-&gt;</span>sda_premptidx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    initp<span class="token operator">-&gt;</span>sda_threadnr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    initp<span class="token operator">-&gt;</span>sda_prityidx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    initp<span class="token operator">-&gt;</span>sda_cpuidle <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//开始没有空转进程和运行的进程</span>
    initp<span class="token operator">-&gt;</span>sda_currtd <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">uint_t</span> ti <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> ti <span class="token operator">&lt;</span> PRITY_MAX<span class="token punctuation">;</span> ti<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span><span class="token comment">//初始化schdata_t结构中的每个thrdlst_t结构</span>
        <span class="token function">thrdlst_t_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>initp<span class="token operator">-&gt;</span>sda_thdlst<span class="token punctuation">[</span>ti<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">schedclass_t_init</span><span class="token punctuation">(</span><span class="token class-name">schedclass_t</span> <span class="token operator">*</span>initp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">krlspinlock_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>initp<span class="token operator">-&gt;</span>scls_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    initp<span class="token operator">-&gt;</span>scls_cpunr <span class="token operator">=</span> CPUCORE_MAX<span class="token punctuation">;</span>  <span class="token comment">//CPU最大个数</span>
    initp<span class="token operator">-&gt;</span>scls_threadnr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">//开始没有进程</span>
    initp<span class="token operator">-&gt;</span>scls_threadid_inc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">uint_t</span> si <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> si <span class="token operator">&lt;</span> CPUCORE_MAX<span class="token punctuation">;</span> si<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span><span class="token comment">//初始化osschedcls变量中的每个schdata_t</span>
        <span class="token function">schdata_t_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>initp<span class="token operator">-&gt;</span>scls_schda<span class="token punctuation">[</span>si<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">init_krlsched</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>   <span class="token comment">//初始化osschedcls变量</span>
    <span class="token function">schedclass_t_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>osschedcls<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码非常简单，由 init_krlsched 函数调用 schedclass_t_init 函数，对 osschedcls 变量进行初始化工作，但是 init_krlsched 函数由谁调用呢？</p><p>还记得之前学的内核功能层的入口函数吗（可回看第 13 节课）？它就是 cosmos/kernel/<code>krlinit.c</code> 文件中的 <strong>init_krl 函数</strong>，我们在这个函数中来调用 init_krlsched 函数，代码如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">init_krl</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">init_krlsched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">die</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//控制不让init_krl函数返回</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>至此，管理进程的初始化就完成了，其实这也是我们进程调度器的初始化，就是这么简单吗？当然不是，还有重要的进程调度等我们搞定。</p><h2 id="设计实现进程调度器" tabindex="-1"><a class="header-anchor" href="#设计实现进程调度器" aria-hidden="true">#</a> 设计实现进程调度器</h2><p>管理进程的数据结构已经初始化好了，现在我们开始设计实现进程调度器。</p><p>进程调度器是为了在合适的时间点，合适的代码执行路径上进行进程调度。说白了，就是从当前运行进程切换到另一个进程上运行，让当前进程停止运行，由 CPU 开始执行另一个进程的代码。这个事情说来简单，但做起来并不容易，下面我将带领你一步步实现进程调度器。</p><h2 id="进程调度器入口" tabindex="-1"><a class="header-anchor" href="#进程调度器入口" aria-hidden="true">#</a> 进程调度器入口</h2><p>首先请你想象一下，进程调度器是什么样子的。其实，进程调度器不过是个函数，和其它函数并没有本质区别，你在其它很多代码执行路径上都可以调用它。只是它会从一个进程运行到下一个进程。</p><p>那这个函数的功能就能定下来了：**无非是确定当前正在运行的进程，然后选择下一个将要运行的进程，最后从当前运行的进程，切换到下一个将要运行的进程。**下面我们先来写好进程调度器的入口函数，如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">krlschedul</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">thread_t</span> <span class="token operator">*</span>prev <span class="token operator">=</span> <span class="token function">krlsched_retn_currthread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment">//返回当前运行进程</span>
             <span class="token operator">*</span>next <span class="token operator">=</span> <span class="token function">krlsched_select_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//选择下一个运行的进程</span>
    <span class="token function">save_to_new_context</span><span class="token punctuation">(</span>next<span class="token punctuation">,</span> prev<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//从当前进程切换到下一个进程</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们只要在任何需要调度进程的地方，调用上述代码中的函数就可以了。下面我们开始实现 krlschedul 函数中的其它功能逻辑。</p><h2 id="如何获取当前运行的进程" tabindex="-1"><a class="header-anchor" href="#如何获取当前运行的进程" aria-hidden="true">#</a> 如何获取当前运行的进程</h2><p>获取当前正在运行的进程，目的是为了保存当前进程的运行上下文，确保在下一次调度到当前运行的进程时能够恢复运行。后面你就会看到，每次切换到下一个进程运行时，我们就会将下一个运行的进程设置为当前运行的进程。</p><p>这个获取当前运行进程的函数，它的代码是这样的。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token class-name">thread_t</span> <span class="token operator">*</span><span class="token function">krlsched_retn_currthread</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">uint_t</span> cpuid <span class="token operator">=</span> <span class="token function">hal_retn_cpuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//通过cpuid获取当前cpu的调度数据结构</span>
    <span class="token class-name">schdata_t</span> <span class="token operator">*</span>schdap <span class="token operator">=</span> <span class="token operator">&amp;</span>osschedcls<span class="token punctuation">.</span>scls_schda<span class="token punctuation">[</span>cpuid<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>schdap<span class="token operator">-&gt;</span>sda_currtd <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span><span class="token comment">//若调度数据结构中当前运行进程的指针为空，就出错死机</span>
        <span class="token function">hal_sysdie</span><span class="token punctuation">(</span><span class="token string">&quot;schdap-&gt;sda_currtd NULL&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> schdap<span class="token operator">-&gt;</span>sda_currtd<span class="token punctuation">;</span><span class="token comment">//返回当前运行的进程</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码非常简单，如果你认真了解过前面组织进程的数据结构，就会发现，schdata_t 结构中的 <strong>sda_currtd 字段</strong>正是保存当前正在运行进程的地址。返回这个字段的值，就能取得当前正在运行的进程。</p><h2 id="选择下一个进程" tabindex="-1"><a class="header-anchor" href="#选择下一个进程" aria-hidden="true">#</a> 选择下一个进程</h2><p>根据调度器入口函数的设计，取得了当前正在运行的进程之后，下一步就是选择下个将要投入运行的进程。</p><p>在商业系统中，这个过程极为复杂。因为这个过程是<strong>进程调度算法的核心</strong>，它关乎到进程的吞吐量，能否及时响应请求，CPU 的利用率，各个进程之间运行获取资源的公平性，这些问题综合起来就会影响整个操作系统的性能、可靠性。</p><p>作为初学者，我们不必搞得如此复杂，可以使用一个简单的优先级调度算法，就是始终选择优先级最高的进程，作为下一个运行的进程。</p><p>完成这个功能的代码，如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token class-name">thread_t</span> <span class="token operator">*</span><span class="token function">krlsched_select_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">thread_t</span> <span class="token operator">*</span>retthd<span class="token punctuation">,</span> <span class="token operator">*</span>tdtmp<span class="token punctuation">;</span>
    <span class="token class-name">cpuflg_t</span> cufg<span class="token punctuation">;</span>
    <span class="token class-name">uint_t</span> cpuid <span class="token operator">=</span> <span class="token function">hal_retn_cpuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">schdata_t</span> <span class="token operator">*</span>schdap <span class="token operator">=</span> <span class="token operator">&amp;</span>osschedcls<span class="token punctuation">.</span>scls_schda<span class="token punctuation">[</span>cpuid<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">krlspinlock_cli</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>schdap<span class="token operator">-&gt;</span>sda_lock<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cufg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">uint_t</span> pity <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> pity <span class="token operator">&lt;</span> PRITY_MAX<span class="token punctuation">;</span> pity<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span><span class="token comment">//从最高优先级开始扫描</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>schdap<span class="token operator">-&gt;</span>sda_thdlst<span class="token punctuation">[</span>pity<span class="token punctuation">]</span><span class="token punctuation">.</span>tdl_nr <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span><span class="token comment">//若当前优先级的进程链表不为空</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">list_is_empty_careful</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>schdap<span class="token operator">-&gt;</span>sda_thdlst<span class="token punctuation">[</span>pity<span class="token punctuation">]</span><span class="token punctuation">.</span>tdl_lsth<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> FALSE<span class="token punctuation">)</span>
            <span class="token punctuation">{</span><span class="token comment">//取出当前优先级进程链表下的第一个进程</span>
                tdtmp <span class="token operator">=</span> <span class="token function">list_entry</span><span class="token punctuation">(</span>schdap<span class="token operator">-&gt;</span>sda_thdlst<span class="token punctuation">[</span>pity<span class="token punctuation">]</span><span class="token punctuation">.</span>tdl_lsth<span class="token punctuation">.</span>next<span class="token punctuation">,</span> <span class="token class-name">thread_t</span><span class="token punctuation">,</span> td_list<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">list_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tdtmp<span class="token operator">-&gt;</span>td_list<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//脱链</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>schdap<span class="token operator">-&gt;</span>sda_thdlst<span class="token punctuation">[</span>pity<span class="token punctuation">]</span><span class="token punctuation">.</span>tdl_curruntd <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
                <span class="token punctuation">{</span><span class="token comment">//将这sda_thdlst[pity].tdl_curruntd的进程挂入链表尾</span>
                    <span class="token function">list_add_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>schdap<span class="token operator">-&gt;</span>sda_thdlst<span class="token punctuation">[</span>pity<span class="token punctuation">]</span><span class="token punctuation">.</span>tdl_curruntd<span class="token operator">-&gt;</span>td_list<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>schdap<span class="token operator">-&gt;</span>sda_thdlst<span class="token punctuation">[</span>pity<span class="token punctuation">]</span><span class="token punctuation">.</span>tdl_lsth<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                schdap<span class="token operator">-&gt;</span>sda_thdlst<span class="token punctuation">[</span>pity<span class="token punctuation">]</span><span class="token punctuation">.</span>tdl_curruntd <span class="token operator">=</span> tdtmp<span class="token punctuation">;</span>
                retthd <span class="token operator">=</span> tdtmp<span class="token punctuation">;</span><span class="token comment">//将选择的进程放入sda_thdlst[pity].tdl_curruntd中，并返回</span>
                <span class="token keyword">goto</span> return_step<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>schdap<span class="token operator">-&gt;</span>sda_thdlst<span class="token punctuation">[</span>pity<span class="token punctuation">]</span><span class="token punctuation">.</span>tdl_curruntd <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span><span class="token comment">//若sda_thdlst[pity].tdl_curruntd不为空就直接返回它</span>
                retthd <span class="token operator">=</span> schdap<span class="token operator">-&gt;</span>sda_thdlst<span class="token punctuation">[</span>pity<span class="token punctuation">]</span><span class="token punctuation">.</span>tdl_curruntd<span class="token punctuation">;</span>
                <span class="token keyword">goto</span> return_step<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//如果最后也没有找到进程就返回默认的空转进程</span>
    schdap<span class="token operator">-&gt;</span>sda_prityidx <span class="token operator">=</span> PRITY_MIN<span class="token punctuation">;</span>
    retthd <span class="token operator">=</span> <span class="token function">krlsched_retn_idlethread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
return_step<span class="token operator">:</span>
    <span class="token comment">//解锁并返回进程</span>
    <span class="token function">krlspinunlock_sti</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>schdap<span class="token operator">-&gt;</span>sda_lock<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cufg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> retthd<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码的逻辑非常简单，我来给你梳理一下。</p><p>首先，从高到低扫描优先级进程链表，然后若当前优先级进程链表不为空，就取出该链表上的第一个进程，放入 thrdlst_t 结构中的 tdl_curruntd 字段中，并把之前 thrdlst_t 结构的 tdl_curruntd 字段中的进程挂入该链表的尾部，并返回。最后，当扫描到最低优先级时也没有找到进程，就返回默认的空转进程。</p><p>这个算法极其简单，但是对我们学习原理却足够了，也欢迎你举一反三，动手实现更高级的调度算法。</p><h2 id="获取空转进程" tabindex="-1"><a class="header-anchor" href="#获取空转进程" aria-hidden="true">#</a> 获取空转进程</h2><p>在选择下一个进程的函数中，如果没有找到合适的进程，就返回默认的空转进程。</p><p>你可以想一下，为什么要有一个空转进程，直接返回 NULL 不行吗？</p><p>还真不行，因为调度器的功能必须完成从一个进程到下一个进程的切换，如果没有下一个进程，而上一个进程又不能运行了，调度器将无处可去，整个系统也将停止运行，这当然不是我们要的结果，所以我们要给系统留下最后一条路。</p><p>下面我们先来实现获取空转进程的函数，如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token class-name">thread_t</span> <span class="token operator">*</span><span class="token function">krlsched_retn_idlethread</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">uint_t</span> cpuid <span class="token operator">=</span> <span class="token function">hal_retn_cpuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//通过cpuid获取当前cpu的调度数据结构</span>
    <span class="token class-name">schdata_t</span> <span class="token operator">*</span>schdap <span class="token operator">=</span> <span class="token operator">&amp;</span>osschedcls<span class="token punctuation">.</span>scls_schda<span class="token punctuation">[</span>cpuid<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>schdap<span class="token operator">-&gt;</span>sda_cpuidle <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span><span class="token comment">//若调度数据结构中空转进程的指针为空，就出错死机</span>
        <span class="token function">hal_sysdie</span><span class="token punctuation">(</span><span class="token string">&quot;schdap-&gt;sda_cpuidle NULL&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> schdap<span class="token operator">-&gt;</span>sda_cpuidle<span class="token punctuation">;</span><span class="token comment">//返回空转进程</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码非常简单，和我们之前实现的获取当前运行进程的函数如出一辙，只是使用 schdata_t 结构中的字段发生了改变。好，接下来我们要处理更重要的问题，那就是进程之间的切换。</p><h2 id="进程切换" tabindex="-1"><a class="header-anchor" href="#进程切换" aria-hidden="true">#</a> 进程切换</h2><p>经过前面的流程，我们已经找到了当前运行的进程 P1，和下一个将要运行的进程 P2，现在就进入最重要的进程切换流程。</p><p>在进程切换前，我们还要了解另一个重要的问题：<strong>进程在内核中函数调用路径，那什么是函数调用路径。</strong></p><p>举个例子，比如进程 P1 调用了函数 A，接着在函数 A 中调用函数 B，然后在函数 B 中调用了函数 C，最后在函数 C 中调用了调度器函数 S，这个函数 A 到函数 S 就是进程 P1 的函数调用路径。</p><p>再比如，进程 P2 开始调用了函数 D，接着在函数 D 中调用函数 E，然后在函数 E 中又调用了函数 F，最后在函数 F 中调用了调度器函数 S，函数 D、E、F 到函数 S 就是进程 P2 的函数调用路径。</p><p>函数调用路径是通过栈来保存的，对于运行在内核空间中的进程，就是保存在对应的内核栈中。我为你准备了一幅图帮助理解。</p><img src="`+c+`" alt="img" style="zoom:15%;"><p>内核栈状态</p><p>以上就是进程 P1，P2 的函数调用路径，也是它们调用函数时各自内核栈空间状态的变化结果。说个题外话，你有没有发现。<strong>C 语言栈才是最高效内存管理，而且变量的生命周期也是妥妥的，比很多高级语言的内存垃圾回收器都牛</strong>。</p><p>有了前面的基础，现在我们来动手实现进程切换的函数。在这个函数中，我们要干这几件事。</p><ol><li><p><strong>首先</strong>，我们把当前进程的通用寄存器保存到当前进程的内核栈中；</p></li><li><p><strong>然后</strong>，保存 CPU 的 RSP 寄存器到当前进程的机器上下文结构中，</p><p>并且读取保存在下一个进程机器上下文结构中的 RSP 的值，把它存到 CPU 的 RSP 寄存器中；</p></li><li><p><strong>接着</strong>，调用一个函数切换 MMU 页表；</p></li><li><p><strong>最后</strong>，从下一个进程的内核栈中恢复下一个进程的通用寄存器。</p></li></ol><p>这样下一个进程就开始运行了，代码如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">save_to_new_context</span><span class="token punctuation">(</span><span class="token class-name">thread_t</span> <span class="token operator">*</span>next<span class="token punctuation">,</span> <span class="token class-name">thread_t</span> <span class="token operator">*</span>prev<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    __asm__ <span class="token function">__volatile__</span><span class="token punctuation">(</span>
        <span class="token string">&quot;pushfq \\n\\t&quot;</span><span class="token comment">//保存当前进程的标志寄存器</span>
        <span class="token string">&quot;cli \\n\\t&quot;</span>  <span class="token comment">//关中断</span>
        <span class="token comment">//保存当前进程的通用寄存器</span>
        <span class="token string">&quot;pushq %%rax\\n\\t&quot;</span>
        <span class="token string">&quot;pushq %%rbx\\n\\t&quot;</span>
        <span class="token string">&quot;pushq %%rcx\\n\\t&quot;</span>
        <span class="token string">&quot;pushq %%rdx\\n\\t&quot;</span>
        <span class="token string">&quot;pushq %%rbp\\n\\t&quot;</span>
        <span class="token string">&quot;pushq %%rsi\\n\\t&quot;</span>
        <span class="token string">&quot;pushq %%rdi\\n\\t&quot;</span>
        <span class="token string">&quot;pushq %%r8\\n\\t&quot;</span>
        <span class="token string">&quot;pushq %%r9\\n\\t&quot;</span>
        <span class="token string">&quot;pushq %%r10\\n\\t&quot;</span>
        <span class="token string">&quot;pushq %%r11\\n\\t&quot;</span>
        <span class="token string">&quot;pushq %%r12\\n\\t&quot;</span>
        <span class="token string">&quot;pushq %%r13\\n\\t&quot;</span>
        <span class="token string">&quot;pushq %%r14\\n\\t&quot;</span>
        <span class="token string">&quot;pushq %%r15\\n\\t&quot;</span>
        <span class="token comment">//保存CPU的RSP寄存器到当前进程的机器上下文结构中</span>
        <span class="token string">&quot;movq %%rsp,%[PREV_RSP] \\n\\t&quot;</span>
        <span class="token comment">//把下一个进程的机器上下文结构中的RSP的值，写入CPU的RSP寄存器中</span>
        <span class="token string">&quot;movq %[NEXT_RSP],%%rsp \\n\\t&quot;</span><span class="token comment">//事实上这里已经切换到下一个进程了，因为切换进程的内核栈    </span>
        <span class="token comment">//调用__to_new_context函数切换MMU页表</span>
        <span class="token string">&quot;callq __to_new_context\\n\\t&quot;</span>
        <span class="token comment">//恢复下一个进程的通用寄存器</span>
        <span class="token string">&quot;popq %%r15\\n\\t&quot;</span>
        <span class="token string">&quot;popq %%r14\\n\\t&quot;</span>
        <span class="token string">&quot;popq %%r13\\n\\t&quot;</span>
        <span class="token string">&quot;popq %%r12\\n\\t&quot;</span>
        <span class="token string">&quot;popq %%r11\\n\\t&quot;</span>
        <span class="token string">&quot;popq %%r10\\n\\t&quot;</span>
        <span class="token string">&quot;popq %%r9\\n\\t&quot;</span>
        <span class="token string">&quot;popq %%r8\\n\\t&quot;</span>
        <span class="token string">&quot;popq %%rdi\\n\\t&quot;</span>
        <span class="token string">&quot;popq %%rsi\\n\\t&quot;</span>
        <span class="token string">&quot;popq %%rbp\\n\\t&quot;</span>
        <span class="token string">&quot;popq %%rdx\\n\\t&quot;</span>
        <span class="token string">&quot;popq %%rcx\\n\\t&quot;</span>
        <span class="token string">&quot;popq %%rbx\\n\\t&quot;</span>
        <span class="token string">&quot;popq %%rax\\n\\t&quot;</span>
        <span class="token string">&quot;popfq \\n\\t&quot;</span>      <span class="token comment">//恢复下一个进程的标志寄存器</span>
        <span class="token comment">//输出当前进程的内核栈地址</span>
        <span class="token operator">:</span> <span class="token punctuation">[</span> PREV_RSP <span class="token punctuation">]</span> <span class="token string">&quot;=m&quot;</span><span class="token punctuation">(</span>prev<span class="token operator">-&gt;</span>td_context<span class="token punctuation">.</span>ctx_nextrsp<span class="token punctuation">)</span>
        <span class="token comment">//读取下一个进程的内核栈地址</span>
        <span class="token operator">:</span> <span class="token punctuation">[</span> NEXT_RSP <span class="token punctuation">]</span> <span class="token string">&quot;m&quot;</span><span class="token punctuation">(</span>next<span class="token operator">-&gt;</span>td_context<span class="token punctuation">.</span>ctx_nextrsp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;D&quot;</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;S&quot;</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token comment">//为调用__to_new_context函数传递参数</span>
        <span class="token operator">:</span> <span class="token string">&quot;memory&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你看，代码中的 save_to_new_context 函数，是不是有点偷天换日的感觉？</p><p>通过切换进程的内核栈，导致切换进程，因为进程的函数调用路径就保存在对应的内核栈中，只要调用 krlschedul 函数，最后的函数调用路径一定会停在 save_to_new_context 函数中，当 save_to_new_context 函数一返回，就会导致回到调用 save_to_new_context 函数的下一行代码开始运行，在这里就是返回到 krlschedul 函数中，最后层层返回。</p><p>我知道你很难理解这一过程，所以准备了一幅图辅助说明。</p><figure><img src="`+l+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>进程切换示意图</p><p>结合上图，你就能理解这个进程切换的原理了。同时你也会发现一个问题，就是这个切换机制能够正常运行，必须保证下一个进程已经被调度过，也就是<strong>它调用执行过 krlschedul 函数。</strong></p><p>那么已知新建进程绝对没有调用过 krlschedul 函数，所以它得进行特殊处理。我们在 __to_new_context 函数中完成这个特殊处理，代码如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">__to_new_context</span><span class="token punctuation">(</span><span class="token class-name">thread_t</span> <span class="token operator">*</span>next<span class="token punctuation">,</span> <span class="token class-name">thread_t</span> <span class="token operator">*</span>prev<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">uint_t</span> cpuid <span class="token operator">=</span> <span class="token function">hal_retn_cpuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">schdata_t</span> <span class="token operator">*</span>schdap <span class="token operator">=</span> <span class="token operator">&amp;</span>osschedcls<span class="token punctuation">.</span>scls_schda<span class="token punctuation">[</span>cpuid<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">//设置当前运行进程为下一个运行的进程</span>
    schdap<span class="token operator">-&gt;</span>sda_currtd <span class="token operator">=</span> next<span class="token punctuation">;</span>
    <span class="token comment">//设置下一个运行进程的tss为当前CPU的tss</span>
    next<span class="token operator">-&gt;</span>td_context<span class="token punctuation">.</span>ctx_nexttss <span class="token operator">=</span> <span class="token operator">&amp;</span>x64tss<span class="token punctuation">[</span>cpuid<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">//设置当前CPU的tss中的R0栈为下一个运行进程的内核栈</span>
    next<span class="token operator">-&gt;</span>td_context<span class="token punctuation">.</span>ctx_nexttss<span class="token operator">-&gt;</span>rsp0 <span class="token operator">=</span> next<span class="token operator">-&gt;</span>td_krlstktop<span class="token punctuation">;</span>
    <span class="token comment">//装载下一个运行进程的MMU页表</span>
    <span class="token function">hal_mmu_load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>next<span class="token operator">-&gt;</span>td_mmdsc<span class="token operator">-&gt;</span>msd_mmu<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>next<span class="token operator">-&gt;</span>td_stus <span class="token operator">==</span> TDSTUS_NEW<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>   <span class="token comment">//如果是新建进程第一次运行就要进行处理</span>
        next<span class="token operator">-&gt;</span>td_stus <span class="token operator">=</span> TDSTUS_RUN<span class="token punctuation">;</span>
        <span class="token function">retnfrom_first_sched</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码的注释已经很清楚了，__to_new_context 负责设置当前运行的进程，处理 CPU 发生中断时需要切换栈的问题，又切换了一个进程的 MMU 页表（即使用新进程的地址空间），最后如果是新建进程第一次运行，就调用 retnfrom_first_sched 函数进行处理。下面我们来写好这个函数。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">retnfrom_first_sched</span><span class="token punctuation">(</span><span class="token class-name">thread_t</span> <span class="token operator">*</span>thrdp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    __asm__ <span class="token function">__volatile__</span><span class="token punctuation">(</span>
        <span class="token string">&quot;movq %[NEXT_RSP],%%rsp\\n\\t&quot;</span>  <span class="token comment">//设置CPU的RSP寄存器为该进程机器上下文结构中的RSP</span>
        <span class="token comment">//恢复进程保存在内核栈中的段寄存器</span>
        <span class="token string">&quot;popq %%r14\\n\\t&quot;</span>
        <span class="token string">&quot;movw %%r14w,%%gs\\n\\t&quot;</span>
        <span class="token string">&quot;popq %%r14\\n\\t&quot;</span>
        <span class="token string">&quot;movw %%r14w,%%fs\\n\\t&quot;</span>
        <span class="token string">&quot;popq %%r14\\n\\t&quot;</span>
        <span class="token string">&quot;movw %%r14w,%%es\\n\\t&quot;</span>
        <span class="token string">&quot;popq %%r14\\n\\t&quot;</span>
        <span class="token string">&quot;movw %%r14w,%%ds\\n\\t&quot;</span>
        <span class="token comment">//恢复进程保存在内核栈中的通用寄存器</span>
        <span class="token string">&quot;popq %%r15\\n\\t&quot;</span>
        <span class="token string">&quot;popq %%r14\\n\\t&quot;</span>
        <span class="token string">&quot;popq %%r13\\n\\t&quot;</span>
        <span class="token string">&quot;popq %%r12\\n\\t&quot;</span>
        <span class="token string">&quot;popq %%r11\\n\\t&quot;</span>
        <span class="token string">&quot;popq %%r10\\n\\t&quot;</span>
        <span class="token string">&quot;popq %%r9\\n\\t&quot;</span>
        <span class="token string">&quot;popq %%r8\\n\\t&quot;</span>
        <span class="token string">&quot;popq %%rdi\\n\\t&quot;</span>
        <span class="token string">&quot;popq %%rsi\\n\\t&quot;</span>
        <span class="token string">&quot;popq %%rbp\\n\\t&quot;</span>
        <span class="token string">&quot;popq %%rdx\\n\\t&quot;</span>
        <span class="token string">&quot;popq %%rcx\\n\\t&quot;</span>
        <span class="token string">&quot;popq %%rbx\\n\\t&quot;</span>
        <span class="token string">&quot;popq %%rax\\n\\t&quot;</span>
        <span class="token comment">//恢复进程保存在内核栈中的RIP、CS、RFLAGS，（有可能需要恢复进程应用程序的RSP、SS）寄存器</span>
        <span class="token string">&quot;iretq\\n\\t&quot;</span>
        <span class="token operator">:</span>
        <span class="token operator">:</span> <span class="token punctuation">[</span> NEXT_RSP <span class="token punctuation">]</span> <span class="token string">&quot;m&quot;</span><span class="token punctuation">(</span>thrdp<span class="token operator">-&gt;</span>td_context<span class="token punctuation">.</span>ctx_nextrsp<span class="token punctuation">)</span>
        <span class="token operator">:</span> <span class="token string">&quot;memory&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>retnfrom_first_sched 函数不会返回到调用它的 __to_new_context 函数中，而是直接运行新建进程的相关代码（如果你不理解这段代码的原理，可以回顾上一课，看看建立进程时，对进程内核栈进行的初始化工作）。</p><p>好，进行到这里，我们已经设计出了我们的 Cosmos 的进程调度器，但我们都知道，这样的调度器还不够，我们还没有解决进程的等待和唤醒问题，这些内容下节课我再跟你详细分享。</p><h2 id="重点回顾" tabindex="-1"><a class="header-anchor" href="#重点回顾" aria-hidden="true">#</a> 重点回顾</h2><p>这节课我们从了解为什么需要多进程调度开始，随后实现子调度管理多个进程，最终实现了进程调度器，这里面有很多重要的知识点，我来为你梳理一下。</p><p>1.**为什么需要多进程调度？**我们分析了系统中总有些资源不能满足每个进程的需求，所以一些进程必须要走走停停，这就需要不同的进程来回切换到 CPU 上运行，为了实现这个机制就需要多进程调度。</p><p>2.**组织多个进程。**为了实现进程管理，必须要组织多个进程。我们设计了调度器数据结构，在该结构中，我们使用优先级链表数组来组织多个进程，并且对这些数据结构的变量进行了初始化。</p><p>3.**进程调度。**有了多个进程就需要进程调度，我们的进程调度器是一个函数，在这个函数中选择了当前运行进程和下一个将要运行的进程，如果实在没有可运行的进程就选择空转进程，最后关键是进程间切换，我们是通过切换进程的内核栈来切换进程的函数调用路径，当调度器函数返回的时候已经是另一个进程了。</p><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题" aria-hidden="true">#</a> 思考题</h2><p>请问当调度器函数调度到一个新建进程时，为何要进入 retnfrom_first_sched 函数呢？</p><p>欢迎你在留言区积极分享，相信通过主动输出，你将更好地理解这节课的内容。也欢迎把这节课分享给你的朋友，和他交流探讨，</p><p>好，我是 LMOS，我们下节课见！</p>`,107),r=[u];function d(k,m){return s(),a("div",null,r)}const b=n(i,[["render",d],["__file","I25-多个活动要安排（上）.html.vue"]]);export{b as default};
