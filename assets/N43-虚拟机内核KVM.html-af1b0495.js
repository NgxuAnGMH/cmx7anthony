import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as a,d as p}from"./app-cdabc73c.js";const t="/assets/fcbfd4f9eda7193a0b5254ddc74a0d09-40f52f38.jpg",e="/assets/65be2a810204bba7ce73c723ff839df3-e2f95d0d.jpg",o="/assets/4fa89e9e4c81f31fc1603059644ab081-70c26662.png",c="/assets/4d939a7422a37dfe2ce0d4d3887d051e-88ccf885.jpg",i="/assets/0b768c2f3b8cd80539347f546f6b2397-d975db81.jpg",l={},u=p('<h1 id="_43-虚拟机内核-kvm是什么" tabindex="-1"><a class="header-anchor" href="#_43-虚拟机内核-kvm是什么" aria-hidden="true">#</a> 43 | 虚拟机内核：KVM是什么？</h1><p>你好，我是 LMOS。</p><p>上节课，我们理解了 Linux 里要如何实现系统 API。可是随着云计算、大数据和分布式技术的演进，我们需要在一台服务器上虚拟化出更多虚拟机，还要让这些虚拟机能够弹性伸缩，实现跨主机的迁移。</p><p>而虚拟化技术正是这些能力的基石。这一节课，就让我们一起探索一下，亚马逊、阿里、腾讯等知名公司用到的云虚拟主机，看看其中的核心技术——KVM 虚拟化技术。</p><h2 id="理解虚拟化的定义" tabindex="-1"><a class="header-anchor" href="#理解虚拟化的定义" aria-hidden="true">#</a> 理解虚拟化的定义</h2><p>什么是虚拟化？在我看来，虚拟化的本质是一种资源管理的技术，它可以通过各种技术手段把计算机的实体资源（如：CPU、RAM、存储、网络、I/O 等等）进行<strong>转换和抽象</strong>，让这些资源可以重新分割、排列与组合，实现<strong>最大化使用物理资源的目的</strong>。</p><h2 id="虚拟化的核心思想" tabindex="-1"><a class="header-anchor" href="#虚拟化的核心思想" aria-hidden="true">#</a> 虚拟化的核心思想</h2><p>学习了前面的课程我们发现，操作系统的设计很高明，已经帮我们实现了单机的资源配置需求，具体就是在一台物理机上把 CPU、内存资源抽象成进程，把磁盘等资源抽象出存储、文件、I/O 等特性，方便之后的资源调度和管理工作。</p><p>但随着时间的推移，我们做个统计就会发现，其实现在的 PC 机平常可能只有 50% 的时间处于工作状态，剩下的一半时间都是在闲置资源，甚至要被迫切换回低功耗状态。这显然是对资源的严重浪费，那么我们如何解决资源复用的问题呢？</p><p>这个问题确实很复杂，但根据我们的工程经验，但凡遇到不太好解决的问题，我们就可以考虑抽象出一个新的层次来解决。于是我们在已有的 OS 经验之上，进行了后面这样的设计。</p><h2 id="虚拟化架构简图-vmm-hypervisor" tabindex="-1"><a class="header-anchor" href="#虚拟化架构简图-vmm-hypervisor" aria-hidden="true">#</a> 虚拟化架构简图(VMM/Hypervisor)</h2><img src="'+t+'" alt="img" style="zoom:15%;"><p>虚拟化架构简图</p><p>结合图解，可以看出最大的区别就是后者额外引入了一个叫 <code>Hypervisor/Virtual Machine Monitor（VMM）</code>的层。在这个层里面我们就可以做一些“无中生有”的事情，<strong>向下</strong>统一管理和调度真实的物理资源，<strong>向上</strong>“骗”虚拟机，让每个虚拟机都以为自己都独享了独立的资源。</p><p>而在这个过程中，我们既然作为一个“两头骗的中间商”，显然要做一些瞒天过海的事情（<strong>访问资源的截获与重定向</strong>）。那么让我们先暂停两分钟，思考一下具体如何设计，才能实现这个“两头骗”的目标呢？</p><h2 id="用赵高矫诏谈理解虚拟化" tabindex="-1"><a class="header-anchor" href="#用赵高矫诏谈理解虚拟化" aria-hidden="true">#</a> 用赵高矫诏谈理解虚拟化</h2><p>说起欺上瞒下，有个历史人物很有代表性，他就是赵高。始皇三十七年（前 210 年），统一了天下的秦始皇（OS）在生平最后一次出巡路上去世了，管理诏书的赵高（<strong><code>Hypervisor/VMM</code></strong>）却趁机发动了阴谋，威胁丞相李斯，矫诏处死扶苏与蒙恬。</p><img src="'+e+'" alt="img" style="zoom:15%;"><p>赵高欺上瞒下</p><p>赵高隐瞒秦始皇死讯，还伪造了诏书，回到了咸阳最终一顿忽悠立了胡亥为为帝。这段故事后世称为沙丘之变。</p><p>作为一个成功瞒天过海，实现了偷梁换柱的中间人赵高，他成事的关键要点包括这些，首先要像咸阳方向伪造一切正常的假象（<strong><code>让被虚拟化的机器看起来和平常一样</code></strong>），其次还要把真正核心的权限获取到手（<strong><code>Hypervisor/VMM 要想办法调度真正的物理资源</code></strong>）。</p><p>所以以史为鉴。在具体实现的层面，我们会发现，这个瞒天过海的目标其实有几种实现方式。</p><ol><li>一种思路是赵高一个人全权代理，全部模拟和代理出所有的资源（<strong><code>软件虚拟化技术</code></strong>），</li><li>另一种思路是朝中有人（胡亥）配合赵高控制、调度各种资源的使用，真正执行的时候，再转发给胡亥去处理（<strong><code>硬件虚拟化技术</code></strong>）。</li></ol><p>我们发现如果如果是前者，显然赵高会消耗大量资源，并且还可能会遇到一些安全问题，所以他选择了后者。</p><p>历史总是惊人地相似，在软件虚拟化遇到了无法根治的性能瓶颈和安全等问题的时候，<strong>软件工程师就开始给硬件工程师提需求了</strong>，需求背后的核心想法是这样的：能不能让朝中有人，有问题交给他，<strong>软件中间层只管调度资源之类的轻量级工作呢</strong>？</p><h2 id="kvm-架构梳理" tabindex="-1"><a class="header-anchor" href="#kvm-架构梳理" aria-hidden="true">#</a> KVM 架构梳理</h2><p>答案显然是可以的，根据我们对计算机的了解就会发现，计算机最重要几种资源分别是：<mark>计算（CPU）</mark>、<mark>存储（RAM、ROM）</mark>，以及为了连接各种设备抽象出的 <mark>I/O 资源</mark>。</p><p>所以 Intel 分别设计出了 VT-x 指令集、VT-d 指令集、VT-c 指令集等技术来实现硬件虚拟化，让 CPU 配合我们来实现这个目标，了解了核心思想之后，让我们来看一看 KVM 的架构图。（图片出自论文《Residency-Aware Virtual Machine Communication Optimization: Design Choices and Techniques》）</p><img src="'+o+'" alt="img" style="zoom:80%;"><p>是不是看起来比较复杂？别担心，我用大白话帮你梳理一下。</p><p>首先，<strong>客户机</strong>（咸阳）看到的<mark>硬件资源</mark>基本都是由 <strong>Hypervisor</strong>（赵高）<mark>模拟出来的</mark>。当客户机对模拟设备进行操作时，<strong>命令就会被截获并转发给</strong> <mark>实际设备 / 内核模块</mark>（胡亥）去处理。</p><p>通过这种架构思想设计 <mark>Hypervisor 层</mark>，最终实现了把<mark>用户态的<strong>一个客户机</strong><mark>映射到</mark>宿主机 OS 系统的<strong>一个进程</strong></mark>，而<mark>一个客户机的 <strong>vCPU</strong></mark> 则映射到==这个进程下的<strong>独立的线程</strong><mark>中。同理，<mark>一个客户机的<strong>I/O</strong></mark> 也可以映射到</mark>同一个线程组内的<strong>独立线程</strong>==中。</p><blockquote><p>这样，我们就可以基于物理机 OS 的进程等资源调度能力，实现不同虚拟机的权限限定、优先级管理等功能了。</p></blockquote><h2 id="kvm-核心原理" tabindex="-1"><a class="header-anchor" href="#kvm-核心原理" aria-hidden="true">#</a> KVM 核心原理</h2><p>通过前面的知识，我们发现，要实现成功的虚拟化，核心是要对资源进行“欺上瞒下”。而对应到我们计算机内的最重要的资源，可以简单抽象成为三大类，分别是：CPU、内存、I/O。接下来，我们就来看看如何让这三大类资源做好虚拟化。</p><h3 id="_1-cpu-虚拟化原理" tabindex="-1"><a class="header-anchor" href="#_1-cpu-虚拟化原理" aria-hidden="true">#</a> 1) CPU 虚拟化原理</h3><p>众所周知，CPU 是我们计算机最重要的模块，让我们先看看 Intel CPU 是如何跟 Hypervisor/VMM“里应外合”的。</p><p>Intel 定义了 Virtual Machine Extension（VMX）这个处理器特性，也就是传说中的 VT-x 指令集，开启了这个特性之后，就会存在两种操作模式。它们分别是：根操作（VMX root operation）和非根操作（VMX non-root operation）。</p><p>我们之前说的 Hypervisor/VMM，其实就运行在根操作模式下，这种模式下的系统对处理器和平台硬件具有完全的控制权限。</p><p>而客户软件（Guest software）包括虚拟机内的操作系统和应用程序，则运行在非根操作模式下。当客户软件执行一些特殊的敏感指令或者一些异常（如 CPUID、INVD、INVEPT 指令，中断、故障、或者一些寄存器操作等）时，则会触发 VM-Exit 指令切换回根操作模式，从而让 Hypervisor/VMM 完全接管控制权限。</p><p>下面这张图画出了模式切换的过程，想在这两种模式之间切换，就要通过 VM-Entry 和 VM-Exit 实现进入和退出。而在这个切换过程中，你要留意一个非常关键的数据结构，它就是 VMCS（Virtual Machine Control Structure）数据结构控制（下文也会讲到）。</p><img src="'+c+`" alt="img" style="zoom:15%;"><p>VMM和Guest切换过程</p><h3 id="_2-内存虚拟化原理" tabindex="-1"><a class="header-anchor" href="#_2-内存虚拟化原理" aria-hidden="true">#</a> 2) 内存虚拟化原理</h3><p>内存虚拟化的核心目的是“骗”客户机，给每个虚拟客户机都提供一个从 0 开始的连续的物理内存空间的假象，同时又要保障各个虚拟机之间内存的隔离和调度能力。</p><p>可能有同学已经联想到，我们之前实现实现虚拟内存的时候，不也是在“骗”应用程序每个程序都有连续的物理内存，为此还设计了一大堆“转换表”的数据结构和转换、调度机制么？</p><p>没错，其实内存虚拟化也借鉴了相同的思想，只不过问题更复杂些，因为我们发现我们的内存从原先的虚拟地址、物理地址突然变成了后面这四种内存地址。</p><ul><li><p>\\1. 客户机虚拟地址 GVA（Guest Virtual Address）</p></li><li><p>\\2. 客户机物理地址 GPA（Guest Physical Address）</p></li><li><p>\\3. 宿主机虚拟地址 HVA（Host Virtual Address）</p></li><li><p>\\4. 宿主机物理地址 HPA（Host Physical Address）</p></li></ul><p>一看到有这么多种地址，又需要进行地址转换，想必转换时的<strong>映射关系表</strong>是少不掉的。</p><p>确实，早期我们主要是基于影子页表（Shadow Page Table）来进行转换的，缺点就是性能有不小的损耗。所以，后来 Intel 在硬件上就设计了 EPT（Extended Page Tables）机制，用来提升内存地址转换效率。</p><h3 id="_3-i-o-虚拟化原理" tabindex="-1"><a class="header-anchor" href="#_3-i-o-虚拟化原理" aria-hidden="true">#</a> 3) I/O 虚拟化原理</h3><p>I/O 虚拟化是基于 Intel 的 VT-d 指令集来实现的，这是一种基于 North Bridge 北桥芯片（或 MCH）的硬件辅助虚拟化技术。</p><p>运用 VT-d 技术，虚拟机得以使用基于直接 I/O 设备分配方式，或者用 I/O 设备共享方式来代替传统的设备模拟 / 额外设备接口方式，不需要硬件改动，还省去了中间通道和 VMM 的开销，从而大大提升了虚拟化的 I/O 性能，让虚拟机性能更接近于真实主机。</p><h2 id="kvm-关键代码走读" tabindex="-1"><a class="header-anchor" href="#kvm-关键代码走读" aria-hidden="true">#</a> KVM 关键代码走读</h2><p>前面我们已经明白了 CPU、内存、I/O 这三类重要的资源是如何做到虚拟化的。不过知其然, 也要知其所以然，对知识只流于原理是不够的。接下来让我们来看看，具体到代码层面，虚拟化技术是如何实现的。</p><h3 id="_1-创建虚拟机" tabindex="-1"><a class="header-anchor" href="#_1-创建虚拟机" aria-hidden="true">#</a> 1) 创建虚拟机</h3><p>这里我想提醒你的是，后续代码为了方便阅读和理解，只保留了与核心逻辑相关的代码，省略了部分代码。</p><p>首先，我们来看一下虚拟机初始化的入口部分，代码如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>virt<span class="token operator">/</span>kvm<span class="token operator">/</span>kvm_main<span class="token punctuation">.</span>c<span class="token operator">:</span> 
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">kvm_dev_ioctl_create_vm</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> fd<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">kvm</span> <span class="token operator">*</span>kvm<span class="token punctuation">;</span>

   kvm <span class="token operator">=</span> <span class="token function">kvm_create_vm</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>kvm<span class="token punctuation">)</span><span class="token punctuation">)</span>
           <span class="token keyword">return</span> <span class="token function">PTR_ERR</span><span class="token punctuation">(</span>kvm<span class="token punctuation">)</span><span class="token punctuation">;</span>

   r <span class="token operator">=</span> <span class="token function">kvm_coalesced_mmio_init</span><span class="token punctuation">(</span>kvm<span class="token punctuation">)</span><span class="token punctuation">;</span>

   r <span class="token operator">=</span> <span class="token function">get_unused_fd_flags</span><span class="token punctuation">(</span>O_CLOEXEC<span class="token punctuation">)</span><span class="token punctuation">;</span>

         <span class="token comment">/*生成kvm-vm控制文件*/</span>
   file <span class="token operator">=</span> <span class="token function">anon_inode_getfile</span><span class="token punctuation">(</span><span class="token string">&quot;kvm-vm&quot;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>kvm_vm_fops<span class="token punctuation">,</span> kvm<span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> fd<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来。我们要创建 KVM 中内存、I/O 等资源相关的数据结构并进行初始化。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>virt<span class="token operator">/</span>kvm<span class="token operator">/</span>kvm_main<span class="token punctuation">.</span>c<span class="token operator">:</span>
<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">kvm</span> <span class="token operator">*</span><span class="token function">kvm_create_vm</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> r<span class="token punctuation">,</span> i<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">kvm</span> <span class="token operator">*</span>kvm <span class="token operator">=</span> <span class="token function">kvm_arch_create_vm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*设置kvm的mm结构为当前进程的mm,然后引用计数为1*/</span>
    kvm<span class="token operator">-&gt;</span>mm <span class="token operator">=</span> current<span class="token operator">-&gt;</span>mm<span class="token punctuation">;</span>
    <span class="token function">kvm_eventfd_init</span><span class="token punctuation">(</span>kvm<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">mutex_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kvm<span class="token operator">-&gt;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">mutex_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kvm<span class="token operator">-&gt;</span>irq_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">mutex_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kvm<span class="token operator">-&gt;</span>slots_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">refcount_set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kvm<span class="token operator">-&gt;</span>users_count<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kvm<span class="token operator">-&gt;</span>devices<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">INIT_HLIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kvm<span class="token operator">-&gt;</span>irq_ack_notifier_list<span class="token punctuation">)</span><span class="token punctuation">;</span>

  r <span class="token operator">=</span> <span class="token function">kvm_arch_init_vm</span><span class="token punctuation">(</span>kvm<span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span>

  r <span class="token operator">=</span> <span class="token function">hardware_enable_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> KVM_NR_BUSES<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">rcu_assign_pointer</span><span class="token punctuation">(</span>kvm<span class="token operator">-&gt;</span>buses<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token function">kzalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kvm_io_bus</span><span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">kvm_init_mmu_notifier</span><span class="token punctuation">(</span>kvm<span class="token punctuation">)</span><span class="token punctuation">;</span> 

    <span class="token comment">/*把kvm链表加入总链表*/</span>
  <span class="token function">list_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kvm<span class="token operator">-&gt;</span>vm_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>vm_list<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> kvm<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结合代码我们看得出，初始化完毕后会将 KVM 加入到一个全局链表头。这样, 我们后面就可以通过这个链表头，遍历所有的 VM 虚拟机了。</p><h3 id="_2-创建-vcpu" tabindex="-1"><a class="header-anchor" href="#_2-创建-vcpu" aria-hidden="true">#</a> 2) 创建 vCPU</h3><p>创建 VM 之后，接下来就是创建我们虚拟机赖以生存的 vCPU 了，代码如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>virt<span class="token operator">/</span>kvm<span class="token operator">/</span>kvm_main<span class="token punctuation">.</span>c<span class="token operator">:</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">kvm_vm_ioctl_create_vcpu</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kvm</span> <span class="token operator">*</span>kvm<span class="token punctuation">,</span> u32 id<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> r<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">kvm_vcpu</span> <span class="token operator">*</span>vcpu<span class="token punctuation">,</span> <span class="token operator">*</span>v<span class="token punctuation">;</span>
    <span class="token comment">/*调用相关cpu的vcpu_create 通过arch/x86/x86.c 进入vmx.c*/</span>
    vcpu <span class="token operator">=</span> <span class="token function">kvm_arch_vcpu_create</span><span class="token punctuation">(</span>kvm<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*调用相关cpu的vcpu_setup*/</span>
  r <span class="token operator">=</span> <span class="token function">kvm_arch_vcpu_setup</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*判断是否达到最大cpu个数*/</span>
  <span class="token function">mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kvm<span class="token operator">-&gt;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">atomic_read</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kvm<span class="token operator">-&gt;</span>online_vcpus<span class="token punctuation">)</span> <span class="token operator">==</span> KVM_MAX_VCPUS<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    r <span class="token operator">=</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
    <span class="token keyword">goto</span> vcpu_destroy<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
    kvm<span class="token operator">-&gt;</span>created_vcpus<span class="token operator">++</span><span class="token punctuation">;</span>    
  <span class="token function">mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kvm<span class="token operator">-&gt;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*生成kvm-vcpu控制文件*/</span>
  <span class="token comment">/* Now it&#39;s all set up, let userspace reach it */</span>
    <span class="token function">kvm_get_kvm</span><span class="token punctuation">(</span>kvm<span class="token punctuation">)</span><span class="token punctuation">;</span>
  r <span class="token operator">=</span> <span class="token function">create_vcpu_fd</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">kvm_get_kvm</span><span class="token punctuation">(</span>kvm<span class="token punctuation">)</span><span class="token punctuation">;</span>
        r <span class="token operator">=</span> <span class="token function">create_vcpu_fd</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">kvm_put_kvm</span><span class="token punctuation">(</span>kvm<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">goto</span> unlock_vcpu_destroy<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        kvm<span class="token operator">-&gt;</span>vcpus<span class="token punctuation">[</span><span class="token function">atomic_read</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kvm<span class="token operator">-&gt;</span>online_vcpus<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> vcpu<span class="token punctuation">;</span>

        <span class="token comment">/*
         * Pairs with smp_rmb() in kvm_get_vcpu.  Write kvm-&gt;vcpus
         * before kvm-&gt;online_vcpu&#39;s incremented value.
         */</span>
        <span class="token function">smp_wmb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">atomic_inc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kvm<span class="token operator">-&gt;</span>online_vcpus<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kvm<span class="token operator">-&gt;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">kvm_arch_vcpu_postcreate</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接着，从这部分代码顺藤摸瓜。</p><p>我们首先在第 7 行的 kvm_arch_vcpu_create() 函数内进行 vcpu_vmx 结构的申请操作，然后还对 vcpu_vmx 进行了初始化。在这个函数的执行过程中，同时还会设置 CPU 模式寄存器（MSR 寄存器）。</p><p>接下来，我们会分别为 guest 和 host 申请页面，并在页面里保存 MSR 寄存器的信息。最后，我们还会申请一个 vmcs 结构，并调用 vmx_vcpu_setup 设置 vCPU 的工作模式，这里就是<strong>实模式</strong>。（一看到把 vCPU 切换回实模式，有没有一种轮回到我们第五节课的感觉？）</p><h3 id="_3-vcpu-运行" tabindex="-1"><a class="header-anchor" href="#_3-vcpu-运行" aria-hidden="true">#</a> 3) vCPU 运行</h3><p>不过只把 vCPU 创建出来是不够的，我们还要让它运行起来，所以我们来看一下 vcpu_run 函数。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>arch<span class="token operator">/</span>x86<span class="token operator">/</span>kvm<span class="token operator">/</span>x86<span class="token punctuation">.</span>c<span class="token operator">:</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">vcpu_run</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kvm_vcpu</span> <span class="token operator">*</span>vcpu<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">int</span> r<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">kvm</span> <span class="token operator">*</span>kvm <span class="token operator">=</span> vcpu<span class="token operator">-&gt;</span>kvm<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/*vcpu进入guest模式*/</span> 
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">kvm_vcpu_running</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                   r <span class="token operator">=</span> <span class="token function">vcpu_enter_guest</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                        r <span class="token operator">=</span> <span class="token function">vcpu_block</span><span class="token punctuation">(</span>kvm<span class="token punctuation">,</span> vcpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token function">kvm_clear_request</span><span class="token punctuation">(</span>KVM_REQ_PENDING_TIMER<span class="token punctuation">,</span> vcpu<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*检查是否有阻塞的时钟timer*/</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">kvm_cpu_has_pending_timer</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token function">kvm_inject_pending_timer_irqs</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*检查是否有用户空间的中断注入*/</span> 
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dm_request_for_irq_injection</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                        <span class="token function">kvm_vcpu_ready_for_interrupt_injection</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                        vcpu<span class="token operator">-&gt;</span>run<span class="token operator">-&gt;</span>exit_reason <span class="token operator">=</span> KVM_EXIT_IRQ_WINDOW_OPEN<span class="token punctuation">;</span>
                        <span class="token operator">++</span>vcpu<span class="token operator">-&gt;</span>stat<span class="token punctuation">.</span>request_irq_exits<span class="token punctuation">;</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token function">kvm_check_async_pf_completion</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*是否有阻塞的signal*/</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">signal_pending</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        r <span class="token operator">=</span> <span class="token operator">-</span>EINTR<span class="token punctuation">;</span>
                        vcpu<span class="token operator">-&gt;</span>run<span class="token operator">-&gt;</span>exit_reason <span class="token operator">=</span> KVM_EXIT_INTR<span class="token punctuation">;</span>
                        <span class="token operator">++</span>vcpu<span class="token operator">-&gt;</span>stat<span class="token punctuation">.</span>signal_exits<span class="token punctuation">;</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
    <span class="token comment">/*执行一个调度*/</span>
                 <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">need_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                         <span class="token function">cond_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                 <span class="token punctuation">}</span>
         <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看到这里，我们终于理解了上文说的 VM-Exit、VM-Entry 指令进入、退出的本质了。这其实是就是通过 vcpu_enter_guest 进入 / 退出 vCPU，在根模式之间来回切换、反复横跳的过程。</p><h3 id="_4-内存虚拟化" tabindex="-1"><a class="header-anchor" href="#_4-内存虚拟化" aria-hidden="true">#</a> 4) 内存虚拟化</h3><p>在 vcpu 初始化的时候，会调用 kvm_init_mmu 来设置虚拟内存初始化。在这里会有两种不同的模式，一种是基于 EPT 的方式，另一种是基于影子页表实现的 soft mmu 方式。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>arch<span class="token operator">/</span>x86<span class="token operator">/</span>kvm<span class="token operator">/</span>mmu<span class="token operator">/</span>mmu<span class="token punctuation">.</span>c
<span class="token keyword">void</span> <span class="token function">kvm_init_mmu</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kvm_vcpu</span> <span class="token operator">*</span>vcpu<span class="token punctuation">,</span> bool reset_roots<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token comment">/*嵌套虚拟化，我们暂不考虑了 */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">mmu_is_nested</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token function">init_kvm_nested_mmu</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>tdp_enabled<span class="token punctuation">)</span>
                <span class="token function">init_kvm_tdp_mmu</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
                <span class="token function">init_kvm_softmmu</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_5-i-o-虚拟化" tabindex="-1"><a class="header-anchor" href="#_5-i-o-虚拟化" aria-hidden="true">#</a> 5) I/O 虚拟化</h3><p>I/O 虚拟化其实也有两种方案，一种是全虚拟化方案，一种是半虚拟化方案。区别在于全虚拟化会在 VM-exit 退出之后把 IO 交给 QEMU 处理，而半虚拟化则是把 I/O 变成了消息处理，从客户机（guest）机器发消息出来，宿主机（由 host）机器来处理。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>arch<span class="token operator">/</span>x86<span class="token operator">/</span>kvm<span class="token operator">/</span>vmx<span class="token punctuation">.</span>c<span class="token operator">:</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">handle_io</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kvm_vcpu</span> <span class="token operator">*</span>vcpu<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> exit_qualification<span class="token punctuation">;</span>
        <span class="token keyword">int</span> size<span class="token punctuation">,</span> in<span class="token punctuation">,</span> string<span class="token punctuation">;</span>
        <span class="token keyword">unsigned</span> port<span class="token punctuation">;</span>

        exit_qualification <span class="token operator">=</span> <span class="token function">vmcs_readl</span><span class="token punctuation">(</span>EXIT_QUALIFICATION<span class="token punctuation">)</span><span class="token punctuation">;</span>
        string <span class="token operator">=</span> <span class="token punctuation">(</span>exit_qualification <span class="token operator">&amp;</span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token operator">++</span>vcpu<span class="token operator">-&gt;</span>stat<span class="token punctuation">.</span>io_exits<span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>string<span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token function">kvm_emulate_instruction</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> EMULATE_DONE<span class="token punctuation">;</span>

        port <span class="token operator">=</span> exit_qualification <span class="token operator">&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">;</span>
        size <span class="token operator">=</span> <span class="token punctuation">(</span>exit_qualification <span class="token operator">&amp;</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        in <span class="token operator">=</span> <span class="token punctuation">(</span>exit_qualification <span class="token operator">&amp;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> <span class="token function">kvm_fast_pio</span><span class="token punctuation">(</span>vcpu<span class="token punctuation">,</span> size<span class="token punctuation">,</span> port<span class="token punctuation">,</span> in<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="重点回顾" tabindex="-1"><a class="header-anchor" href="#重点回顾" aria-hidden="true">#</a> 重点回顾</h2><p>好，这节课的内容告一段落了，我来给你做个总结。历史总是惊人相似，今天我用一个历史故事带你理解了虚拟化的核心思想，引入一个专门的层，像赵高一样瞒天过海，向下统一管理和调度真实的物理资源，向上“骗”虚拟机。</p><p>而要想成功实现虚拟化，核心就是对资源进行“欺上瞒下”。我带你梳理分析了 KVM 的基本架构以及 CPU、RAM、I/O 三大件的虚拟化原理。其中，内存虚拟化虽然衍生出了四种内存，但你不妨以用当初物理内存与虚拟内存的思路做类比学习。</p><p>之后，我又带你进行了 KVM 核心逻辑相关的代码走读，如果你有兴趣阅读完整的 KVM 代码，可以到官方仓库搜索。</p><p>最后，为了帮你巩固今天的学习内容，我特意整理了导图。</p><img src="`+i+'" alt="img" style="zoom:25%;"><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题" aria-hidden="true">#</a> 思考题</h2><p>有了 KVM 作为虚拟化的基石之后，如果让你从零开始，设计一款像各大云厂商 IAAS 平台一样的虚拟化平台，还需要考虑哪些问题呢？</p><p>欢迎你在留言区跟我互动，也欢迎你把这节课转发给自己的朋友，跟他一起探讨 KVM 的相关问题。</p><p>我是 LMOS，我们下节课见！</p>',88),r=[u];function k(d,v){return s(),a("div",null,r)}const b=n(l,[["render",k],["__file","N43-虚拟机内核KVM.html.vue"]]);export{b as default};
