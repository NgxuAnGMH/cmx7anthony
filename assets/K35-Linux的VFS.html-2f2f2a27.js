import{_ as s}from"./plugin-vue_export-helper-c27b6911.js";import{o as n,c as a,d as p}from"./app-cdabc73c.js";const t="/assets/2d9b81aaf77f91958c8de723f95bfccb-acad901c.jpg",e="/assets/6bf465757535b4f874f1a9c61252ff1c-bf9bf065.jpg",o="/assets/cefb99c451223567d731527596c3b111-dce38b2e.jpg",c="/assets/a977d06a73a9c7f3e821b08b76f628c4-873e427c.jpg",l="/assets/1fdab587ed7a8b1598c924a300c82186-53aee720.jpg",i="/assets/10b031cce6daed19975289d3115f90ac-c84e3681.jpg",k={},u=p('<h1 id="_35-瞧一瞧linux-虚拟文件系统如何管理文件" tabindex="-1"><a class="header-anchor" href="#_35-瞧一瞧linux-虚拟文件系统如何管理文件" aria-hidden="true">#</a> 35 | 瞧一瞧Linux：虚拟文件系统如何管理文件？</h1><p>你好，我是 LMOS。</p><p>在前面的课程中，我们已经实现了 Cosmos 下的文件系统 rfs，相信你已经感受到了一个文件系统是如何管理文件的。今天我们一起来瞧一瞧 Linux 是如何管理文件，也验证一下 Linux 那句口号：一切皆为文件。</p><p>为此，我们需要首先搞清楚什么是 VFS，接着理清为了实现 VFS 所用到的数据结构，然后看看一个文件的打开、读写、关闭的过程，最后我们还要亲自动手实践，在 VFS 下实现一个“小”且“能跑”的文件系统。</p><p>下面让我们开始吧！这节课的配套代码，你可以从这里下载。</p><h2 id="什么是-vfs" tabindex="-1"><a class="header-anchor" href="#什么是-vfs" aria-hidden="true">#</a> 什么是 VFS</h2><p>VFS（Virtual Filesystem）就像伙伴系统、SLAB 内存管理算法一样，也是 SUN 公司最早在 Sloaris 上实现的虚拟文件系统，也可以理解为通用文件系统抽象层。Linux 又一次“白嫖”了 Sun 公司的技术。</p><p>在 Linux 中，支持 EXT、XFS、JFS、BTRFS、FAT、NTFS 等多达十几种不同的文件系统，但不管在什么储存设备上使用什么文件系统，也不管访问什么文件，都可以统一地使用一套 open(), read()、write()、close() 这样的接口。</p><p>这些接口看上去都很简单，但要基于不同的存储设备设计，还要适应不同的文件系统，这并不容易。这就得靠优秀的 VFS 了，它提供了一个抽象层，让不同的文件系统表现出一致的行为。</p><p>对于用户空间和内核空间的其他部分，这些文件系统看起来都是一样的：文件都有目录，都支持建立、打开，读写、关闭和删除操作，不用关注不同文件系统的细节。</p><p>我来给你画张图，你一看就明白了。</p><img src="'+t+`" alt="img" style="zoom:15%;"><p>VFS架构图</p><p>你有没有发现，在计算机科学领域的很多问题，都可以通过<strong>增加一个中间的抽象层</strong>来解决，上图中 Linux 的 VFS 层就是应用和许多文件系统之间的抽象层。VFS 向上对应用提供了操作文件的标准接口，向下规范了一个文件系统要接入 VFS 必需要实现的机制。</p><p>后面我们就会看到，VFS 提供一系列数据结构和具体文件系统应该实现的回调函数。这样，一个文件系统就可以被安装到 VFS 中了。操作具体文件时，VFS 会根据需要调用具体文件系统的函数。从此文件系统的细节就被 VFS 屏蔽了，应用程序只需要调用标准的接口就行了。</p><h2 id="vfs-数据结构" tabindex="-1"><a class="header-anchor" href="#vfs-数据结构" aria-hidden="true">#</a> VFS 数据结构</h2><p>VFS 为了屏蔽各个文件系统的差异，就必须要定义一组通用的数据结构，规范各个文件系统的实现，<strong>每种结构都对应一套回调函数集合</strong>，这是典型的<strong>面向对象的设计方法</strong>。</p><p>这些数据结构包含描述文件系统信息的超级块、表示文件名称的目录结构、描述文件自身信息的索引节点结构、表示打开一个文件的实例结构。下面我们依次探讨这些结构。</p><h3 id="_1-超级块结构" tabindex="-1"><a class="header-anchor" href="#_1-超级块结构" aria-hidden="true">#</a> 1 超级块结构</h3><p>首先我们来看一看超级块结构，这个结构用于一个具体文件系统的相关信息，其中包含了 VFS 规定的标准信息，也有具体文件系统的特有信息，Linux 系统中的超级块结构是一个文件系统安装在 VFS 中的标识。我们来看看代码，如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>    s_list<span class="token punctuation">;</span> <span class="token comment">//超级块链表</span>
    <span class="token class-name">dev_t</span>           s_dev<span class="token punctuation">;</span>     <span class="token comment">//设备标识</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span>       s_blocksize_bits<span class="token punctuation">;</span><span class="token comment">//以位为单位的块大小</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>       s_blocksize<span class="token punctuation">;</span><span class="token comment">//以字节为单位的块大小</span>
    <span class="token class-name">loff_t</span>          s_maxbytes<span class="token punctuation">;</span> <span class="token comment">//一个文件最大多少字节</span>
    <span class="token keyword">struct</span> <span class="token class-name">file_system_type</span> <span class="token operator">*</span>s_type<span class="token punctuation">;</span> <span class="token comment">//文件系统类型</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">super_operations</span>   <span class="token operator">*</span>s_op<span class="token punctuation">;</span><span class="token comment">//超级块函数集合</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">dquot_operations</span>   <span class="token operator">*</span>dq_op<span class="token punctuation">;</span><span class="token comment">//磁盘限额函数集合</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>       s_flags<span class="token punctuation">;</span><span class="token comment">//挂载标志</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>       s_magic<span class="token punctuation">;</span><span class="token comment">//文件系统魔数</span>
    <span class="token keyword">struct</span> <span class="token class-name">dentry</span>       <span class="token operator">*</span>s_root<span class="token punctuation">;</span><span class="token comment">//挂载目录</span>
    <span class="token keyword">struct</span> <span class="token class-name">rw_semaphore</span> s_umount<span class="token punctuation">;</span><span class="token comment">//卸载信号量</span>
    <span class="token keyword">int</span>         s_count<span class="token punctuation">;</span><span class="token comment">//引用计数</span>
    <span class="token class-name">atomic_t</span>        s_active<span class="token punctuation">;</span><span class="token comment">//活动计数</span>
    <span class="token keyword">struct</span> <span class="token class-name">block_device</span> <span class="token operator">*</span>s_bdev<span class="token punctuation">;</span><span class="token comment">//块设备</span>
    <span class="token keyword">void</span>            <span class="token operator">*</span>s_fs_info<span class="token punctuation">;</span><span class="token comment">//文件系统信息</span>
    <span class="token class-name">time64_t</span>           s_time_min<span class="token punctuation">;</span><span class="token comment">//最小时间限制</span>
    <span class="token class-name">time64_t</span>           s_time_max<span class="token punctuation">;</span><span class="token comment">//最大时间限制</span>
    <span class="token keyword">char</span>            s_id<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">//标识名称</span>
    <span class="token class-name">uuid_t</span>          s_uuid<span class="token punctuation">;</span>     <span class="token comment">//文件系统的UUID</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_lru</span>     s_dentry_lru<span class="token punctuation">;</span><span class="token comment">//LRU方式挂载的目录 </span>
    <span class="token keyword">struct</span> <span class="token class-name">list_lru</span>     s_inode_lru<span class="token punctuation">;</span><span class="token comment">//LRU方式挂载的索引结点</span>
    <span class="token keyword">struct</span> <span class="token class-name">mutex</span>        s_sync_lock<span class="token punctuation">;</span><span class="token comment">//同步锁  </span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>    s_inodes<span class="token punctuation">;</span>   <span class="token comment">//所有的索引节点</span>
    <span class="token class-name">spinlock_t</span>      s_inode_wblist_lock<span class="token punctuation">;</span><span class="token comment">//回写索引节点的锁</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>    s_inodes_wb<span class="token punctuation">;</span>    <span class="token comment">//挂载所有要回写的索引节点</span>
<span class="token punctuation">}</span> __randomize_layout<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中我删除了我们现在不用关注的代码，在文件系统被挂载到 VFS 的某个目录下时，VFS 会调用获取文件系统自己的超级块的函数，用具体文件系统的信息构造一个上述结构的实例，有了这个结构实例，VFS 就能感知到一个文件系统插入了。</p><p>下面我们来看看超级块函数集合。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">super_operations</span> <span class="token punctuation">{</span>
    <span class="token comment">//分配一个新的索引结点结构</span>
    <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>alloc_inode<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span>sb<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//销毁给定的索引节点</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>destroy_inode<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//释放给定的索引节点</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>free_inode<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//VFS在索引节点为脏(改变)时，会调用此函数</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>dirty_inode<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//该函数用于将给定的索引节点写入磁盘</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>write_inode<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">writeback_control</span> <span class="token operator">*</span>wbc<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//在最后一个指向索引节点的引用被释放后，VFS会调用该函数</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>drop_inode<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>evict_inode<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//减少超级块计数调用</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>put_super<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//同步文件系统调用</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>sync_fs<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span>sb<span class="token punctuation">,</span> <span class="token keyword">int</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//释放超级块调用</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>freeze_super<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//释放文件系统调用</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>freeze_fs<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>thaw_super<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>unfreeze_fs<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//VFS通过调用该函数，获取文件系统状态</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>statfs<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">kstatfs</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//当指定新的安装选项重新安装文件系统时，VFS会调用此函数</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>remount_fs<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//VFS调用该函数中断安装操作。该函数被网络文件系统使用，如NFS</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>umount_begin<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中 super_operations 结构中所有函数指针所指向的函数，都应该要由一个具体文件系统实现。</p><p>有了超级块和超级块函数集合结构，VFS 就能让一个文件系统的信息和表示变得规范了。也就是说，文件系统只要实现了 super_block 和 super_operations 两个结构，就可以插入到 VFS 中了。但是，这样的文件系统没有任何实质性的功能，我们接着往下看。</p><h3 id="_2-目录结构" tabindex="-1"><a class="header-anchor" href="#_2-目录结构" aria-hidden="true">#</a> 2 目录结构</h3><p>Linux 系统中所有文件都是用目录组织的，就连具体的文件系统也是挂载到某个目录下的。Linux 系统的目录结构逻辑示意图，如下所示。</p><img src="`+e+`" alt="img" style="zoom:15%;"><p>Linux目录结构</p><p>上图中显示了 Linux 文件目录情况，也显示了一个设备上的文件系统是如何挂载到某个目录下的。那么 VFS 用什么来表示一个目录呢？我们来看看代码，如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//快速字符串保存关于字符串的 &quot;元数据&quot;（即长度和哈希值）</span>
<span class="token keyword">struct</span> <span class="token class-name">qstr</span> <span class="token punctuation">{</span>
    <span class="token keyword">union</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token punctuation">{</span>
            HASH_LEN_DECLARE<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        u64 hash_len<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span><span class="token comment">//指向名称字符串</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> d_flags<span class="token punctuation">;</span>       <span class="token comment">//目录标志</span>
    <span class="token class-name">seqcount_spinlock_t</span> d_seq<span class="token punctuation">;</span>  <span class="token comment">//锁</span>
    <span class="token keyword">struct</span> <span class="token class-name">hlist_bl_node</span> d_hash<span class="token punctuation">;</span><span class="token comment">//目录的哈希链表    </span>
    <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span>d_parent<span class="token punctuation">;</span>    <span class="token comment">//指向父目录</span>
    <span class="token keyword">struct</span> <span class="token class-name">qstr</span> d_name<span class="token punctuation">;</span>         <span class="token comment">//目录名称</span>
    <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>d_inode<span class="token punctuation">;</span>      <span class="token comment">//指向目录文件的索引节点 </span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> d_iname<span class="token punctuation">[</span>DNAME_INLINE_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//短目录名</span>
    <span class="token keyword">struct</span> <span class="token class-name">lockref</span> d_lockref<span class="token punctuation">;</span>   <span class="token comment">//目录锁与计数</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">dentry_operations</span> <span class="token operator">*</span>d_op<span class="token punctuation">;</span><span class="token comment">//目录的函数集</span>
    <span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span>d_sb<span class="token punctuation">;</span>   <span class="token comment">//指向超级块</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> d_time<span class="token punctuation">;</span>       <span class="token comment">//时间</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>d_fsdata<span class="token punctuation">;</span>         <span class="token comment">//指向具体文件系统的数据</span>
    <span class="token keyword">union</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">list_head</span> d_lru<span class="token punctuation">;</span>     <span class="token comment">//LRU链表</span>
        <span class="token class-name">wait_queue_head_t</span> <span class="token operator">*</span>d_wait<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> d_child<span class="token punctuation">;</span>   <span class="token comment">//挂入父目录的链表节点 </span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> d_subdirs<span class="token punctuation">;</span> <span class="token comment">//挂载所有子目录的链表</span>
<span class="token punctuation">}</span> __randomize_layout<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以发现，dentry 结构中包含了目录的名字和挂载子目录的链表，同时也能指向父目录。但是需要注意的是，<strong>目录也是文件，需要用 inode 索引结构来管理目录文件数据</strong>。</p><p>这个目录文件数据，你可以把它想象成一个表，表有三列，它们分别是：名称、类型（文件或者目录）、inode 号。扫描这个表，就可以找出这个目录文件中包含的所有子目录或者文件。</p><p>接着我们来看看目录函数集, 如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">dentry_operations</span> <span class="token punctuation">{</span>
    <span class="token comment">//该函数判断目录对象是否有效</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>d_revalidate<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>d_weak_revalidate<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//该函数为目录项生成散列值，当目录项要加入散列表中时，VFS调用该函数</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>d_hash<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">qstr</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//VFS调用该函数来比较name1和name2两个文件名。多数文件系统使用VFS的默认操作，仅做字符串比较。对于有些文件系统，比如FAT，简单的字符串比较不能满足其需要，因为 FAT文件系统不区分大小写</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>d_compare<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span>
            <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">qstr</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//当目录项对象的计数值等于0时，VFS调用该函数</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>d_delete<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//当分配目录时调用 </span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>d_init<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//当目录项对象要被释放时，VFS调用该函数，默认情况下，它什么也不做</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>d_release<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>d_prune<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//当一个目录项对象丢失了相关索引节点时，VFS调用该函数。默认情况下VFS会调用iput()函数释放索引节点</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>d_iput<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//当需要生成一个dentry的路径名时被调用</span>
    <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>d_dname<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//当要遍历一个自动挂载时被调用（可选），这应该创建一个新的VFS挂载记录并将该记录返回给调用者</span>
    <span class="token keyword">struct</span> <span class="token class-name">vfsmount</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>d_automount<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">path</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//文件系统管理从dentry的过渡（可选）时，被调用</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>d_manage<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">path</span> <span class="token operator">*</span><span class="token punctuation">,</span> bool<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//叠加/联合类型的文件系统实现此方法</span>
    <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>d_real<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> ____cacheline_aligned<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>dentry_operations 结构中的函数，也需要具体文件系统实现，下层代码查找或者操作目录时 VFS 就会调用这些函数，让具体文件系统根据自己储存设备上的目录信息处理并设置 dentry 结构中的信息，这样文件系统中的目录就和 VFS 的目录对应了。</p><p>现在我们已经解决了目录，下面我们就去看看 VFS 怎么实现表示文件。</p><h3 id="_3-文件索引结点" tabindex="-1"><a class="header-anchor" href="#_3-文件索引结点" aria-hidden="true">#</a> 3 文件索引结点</h3><p>VFS 用 inode 结构表示一个文件索引结点，它里面包含文件权限、文件所属用户、文件访问和修改时间、文件数据块号等一个文件的全部信息，一个 inode 结构就对应一个文件，代码如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token punctuation">{</span>
    <span class="token class-name">umode_t</span>         i_mode<span class="token punctuation">;</span><span class="token comment">//文件访问权限</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">short</span>      i_opflags<span class="token punctuation">;</span><span class="token comment">//打开文件时的标志</span>
    <span class="token class-name">kuid_t</span>          i_uid<span class="token punctuation">;</span><span class="token comment">//文件所属的用户id</span>
    <span class="token class-name">kgid_t</span>          i_gid<span class="token punctuation">;</span><span class="token comment">//文件所属的用户组id</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>        i_flags<span class="token punctuation">;</span><span class="token comment">//标志</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">inode_operations</span>   <span class="token operator">*</span>i_op<span class="token punctuation">;</span><span class="token comment">//inode函数集</span>
    <span class="token keyword">struct</span> <span class="token class-name">super_block</span>  <span class="token operator">*</span>i_sb<span class="token punctuation">;</span><span class="token comment">//指向所属超级块</span>
    <span class="token keyword">struct</span> <span class="token class-name">address_space</span>    <span class="token operator">*</span>i_mapping<span class="token punctuation">;</span><span class="token comment">//文件数据在内存中的页缓存</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>       i_ino<span class="token punctuation">;</span><span class="token comment">//inode号</span>
    <span class="token class-name">dev_t</span>           i_rdev<span class="token punctuation">;</span><span class="token comment">//实际设备标志符</span>
    <span class="token class-name">loff_t</span>          i_size<span class="token punctuation">;</span><span class="token comment">//文件大小，以字节为单位</span>
    <span class="token keyword">struct</span> <span class="token class-name">timespec64</span>   i_atime<span class="token punctuation">;</span><span class="token comment">//文件访问时间</span>
    <span class="token keyword">struct</span> <span class="token class-name">timespec64</span>   i_mtime<span class="token punctuation">;</span><span class="token comment">//文件修改时间</span>
    <span class="token keyword">struct</span> <span class="token class-name">timespec64</span>   i_ctime<span class="token punctuation">;</span><span class="token comment">//最后修改时间</span>
    <span class="token class-name">spinlock_t</span>      i_lock<span class="token punctuation">;</span> <span class="token comment">//保护inode的自旋锁</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">short</span>          i_bytes<span class="token punctuation">;</span><span class="token comment">//使用的字节数</span>
    u8          i_blkbits<span class="token punctuation">;</span><span class="token comment">//以位为单位的块大小；</span>
    u8          i_write_hint<span class="token punctuation">;</span>
    <span class="token class-name">blkcnt_t</span>        i_blocks<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>    i_io_list<span class="token punctuation">;</span>  
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>    i_lru<span class="token punctuation">;</span>      <span class="token comment">//在缓存LRU中的链表节点</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>    i_sb_list<span class="token punctuation">;</span><span class="token comment">//在超级块中的链表节点</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>    i_wb_list<span class="token punctuation">;</span>
    <span class="token class-name">atomic64_t</span>      i_version<span class="token punctuation">;</span><span class="token comment">//版本号</span>
    <span class="token class-name">atomic64_t</span>      i_sequence<span class="token punctuation">;</span> 
    <span class="token class-name">atomic_t</span>        i_count<span class="token punctuation">;</span><span class="token comment">//计数</span>
    <span class="token class-name">atomic_t</span>        i_dio_count<span class="token punctuation">;</span><span class="token comment">//直接io进程计数</span>
    <span class="token class-name">atomic_t</span>        i_writecount<span class="token punctuation">;</span><span class="token comment">//写进程计数</span>
    <span class="token keyword">union</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span>    <span class="token operator">*</span>i_fop<span class="token punctuation">;</span><span class="token comment">//文件函数集合 </span>
        <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>free_inode<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">file_lock_context</span>    <span class="token operator">*</span>i_flctx<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">address_space</span>    i_data<span class="token punctuation">;</span>
    <span class="token keyword">void</span>            <span class="token operator">*</span>i_private<span class="token punctuation">;</span> <span class="token comment">//私有数据指针</span>
<span class="token punctuation">}</span> __randomize_layout<span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>inode 结构表示一个文件的全部信息，但这个 inode 结构是 VFS 使用的，跟某个具体文件系统上的“inode”结构并不是一一对应关系。</p><p>所以，inode 结构还有一套函数集合，用于具体文件系统根据自己特有的信息，构造出 VFS 使用的 inode 结构，这套函数集合如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">inode_operations</span> <span class="token punctuation">{</span>
    <span class="token comment">//VFS通过系统create()和open()接口来调用该函数，从而为dentry对象创建一个新的索引节点</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>create<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//该函数在特定目录中寻找索引节点，该索引节点要对应于dentry中给出的文件名</span>
    <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>lookup<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//被系统link()接口调用，用来创建硬连接。硬链接名称由dentry参数指定</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>link<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//被系统unlink()接口调用，删除由目录项dentry链接的索引节点对象</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>unlink<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//被系统symlik()接口调用，创建符号连接，该符号连接名称由symname指定，连接对象是dir目录中的dentry目录项</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>symlink<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//被mkdir()接口调用，创建一个新目录。</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>mkdir<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//被rmdir()接口调用，删除dentry目录项代表的文件</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>rmdir<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//被mknod()接口调用，创建特殊文件(设备文件、命名管道或套接字)。</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>mknod<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token class-name">dev_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//VFS调用该函数来移动文件。文件源路径在old_dir目录中，源文件由old_dentry目录项所指定，目标路径在new_dir目录中，目标文件由new_dentry指定</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>rename<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//被系统readlink()接口调用，拷贝数据到特定的缓冲buffer中。拷贝的数据来自dentry指定的符号链接</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>readlink<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//被VFS调用，从一个符号连接查找他指向的索引节点</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>follow_link<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">nameidata</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//在follow_link()调用之后，该函数由vfs调用进行清除工作</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>put_link<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">nameidata</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//被VFS调用，修改文件的大小，在调用之前，索引节点的i_size项必须被设置成预期的大小</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>truncate<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//该函数用来检查给定的inode所代表的文件是否允许特定的访问模式，如果允许特定的访问模式，返回0，否则返回负值的错误码</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>permission<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//被notify_change接口调用，在修改索引节点之后，通知发生了改变事件</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>setattr<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">iattr</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//在通知索引节点需要从磁盘中更新时，VFS会调用该函数</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>getattr<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">vfsmount</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">kstat</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//被VFS调用，向dentry指定的文件设置扩展属性</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>setxattr<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token class-name">size_t</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//被VFS调用，拷贝给定文件的扩展属性name对应的数值</span>
    <span class="token class-name">ssize_t</span> <span class="token punctuation">(</span><span class="token operator">*</span>getxattr<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//该函数将特定文件所有属性列表拷贝到一个缓冲列表中</span>
    <span class="token class-name">ssize_t</span> <span class="token punctuation">(</span><span class="token operator">*</span>listxattr<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//该函数从给定文件中删除指定的属性</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>removexattr<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中删除了一些我们不用关心的接口，VFS 通过定义 inode 结构和函数集合，并让具体文件系统实现这些函数，使得 VFS 及其上层只要关注 inode 结构，底层的具体文件系统根据自己的文件信息生成相应的 inode 结构，达到了 VFS 表示一个文件的目的。</p><p>下面我们再看一个实例，进一步理解 VFS 如何表示一个打开的文件。</p><h3 id="_4-打开的文件" tabindex="-1"><a class="header-anchor" href="#_4-打开的文件" aria-hidden="true">#</a> 4 打开的文件</h3><p>如何表示应用进程打开的不同文件呢？ VFS 设计了一个文件对象结构解决这个问题，文件对象结构表示进程已打开的文件。</p><p>如果我们站在应用程序的角度思考，文件对象结构会首先进入我们的视野。应用程序直接处理的就是文件，而不是超级块、索引节点或目录项。文件对象结构包含了我们非常熟悉的信息，如访问模式、当前读写偏移等。我们来看代码，如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token punctuation">{</span>
    <span class="token keyword">union</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">llist_node</span>   fu_llist<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">rcu_head</span>     fu_rcuhead<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> f_u<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">path</span>     f_path<span class="token punctuation">;</span> <span class="token comment">//文件路径</span>
    <span class="token keyword">struct</span> <span class="token class-name">inode</span>        <span class="token operator">*</span>f_inode<span class="token punctuation">;</span>  <span class="token comment">//文件对应的inode</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span>    <span class="token operator">*</span>f_op<span class="token punctuation">;</span><span class="token comment">//文件函数集合</span>
    <span class="token class-name">spinlock_t</span>      f_lock<span class="token punctuation">;</span>  <span class="token comment">//自旋锁</span>
    <span class="token keyword">enum</span> <span class="token class-name">rw_hint</span>        f_write_hint<span class="token punctuation">;</span>
    <span class="token class-name">atomic_long_t</span>       f_count<span class="token punctuation">;</span><span class="token comment">//文件对象计数据。</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>        f_flags<span class="token punctuation">;</span><span class="token comment">//文件标志</span>
    <span class="token class-name">fmode_t</span>         f_mode<span class="token punctuation">;</span><span class="token comment">//文件权限</span>
    <span class="token keyword">struct</span> <span class="token class-name">mutex</span>        f_pos_lock<span class="token punctuation">;</span><span class="token comment">//文件读写位置锁</span>
    <span class="token class-name">loff_t</span>          f_pos<span class="token punctuation">;</span><span class="token comment">//进程读写文件的当前位置</span>
    u64         f_version<span class="token punctuation">;</span><span class="token comment">//文件版本</span>
    <span class="token keyword">void</span>            <span class="token operator">*</span>private_data<span class="token punctuation">;</span><span class="token comment">//私有数据</span>
<span class="token punctuation">}</span> __randomize_layout
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在进程结构中有个文件表，那个表其实就是 <strong>file 结构的指针数组</strong>，进程每打开一个文件就会建立一个 file 结构实例，并将其地址放入数组中，最后返回对应的数组下标，就是我们调用 open 函数返回的那个整数。</p><p>对于 file 结构，也有对应的函数集合 file_operations 结构，下面我们再次看看它，如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">file_operations</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">module</span> <span class="token operator">*</span>owner<span class="token punctuation">;</span><span class="token comment">//所在的模块</span>
    <span class="token class-name">loff_t</span> <span class="token punctuation">(</span><span class="token operator">*</span>llseek<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token class-name">loff_t</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调整读写偏移</span>
    <span class="token class-name">ssize_t</span> <span class="token punctuation">(</span><span class="token operator">*</span>read<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token class-name">size_t</span><span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//读</span>
    <span class="token class-name">ssize_t</span> <span class="token punctuation">(</span><span class="token operator">*</span>write<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token class-name">size_t</span><span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//写</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>mmap<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//映射</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>open<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//打开</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>flush<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token class-name">fl_owner_t</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//刷新</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>release<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//关闭</span>
<span class="token punctuation">}</span> __randomize_layout<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>file_operations 结构中的函数指针有 31 个，这里我删除了我们不需要关注的函数指针，这些函数依然需要具体文件系统来实现，由 VFS 层来调用。</p><p>到此为止，有超级块、目录结构、文件索引节点，打开文件的实例，通过四大对象就可以描述抽象出一个文件系统了。而四大对象的对应的操作函数集合，又由具体的文件系统来实现，这两个一结合，一个文件系统的状态和行为都具备了。</p><p>这样一个具体的文件系统，我们就可以安装在 VFS 中运行了。</p><h3 id="四大对象结构的关系" tabindex="-1"><a class="header-anchor" href="#四大对象结构的关系" aria-hidden="true">#</a> # 四大对象结构的关系</h3><p>我们已经了解构成文件系统的四大对象结构，但是要想完全了解它们的工作机制，还必须要搞清楚，随着 VFS 代码的运行，这些对象结构在内存中的建立和销毁以及它们之间的组织关系。</p><p>一图胜千言，我来为你画一幅全景图，你就明白四大对象结构之间的关系了。</p><img src="`+o+'" alt="img" style="zoom:15%;"><p>VFS对象关系示意图</p><p>上图中展示了 spuer_block、dentry、inode、file 四大结构的关系，当然这只是打开一个文件的情况，如果打开了多个文件则相应的结构实例就会增加，不过底层逻辑还是前面图里梳理的这样，万变不离其宗。</p><p>搞清楚了四大结构的关系后，我们就可以探索文件相关的操作了。</p><h2 id="文件操作" tabindex="-1"><a class="header-anchor" href="#文件操作" aria-hidden="true">#</a> 文件操作</h2><p>Linux 下常规的文件操作就是打开、读、写、关闭，让我们分别讨论一下这几种文件操作的流程。</p><h3 id="打开文件" tabindex="-1"><a class="header-anchor" href="#打开文件" aria-hidden="true">#</a> 打开文件</h3><p>在对文件进行读写之前，需要先用 open 函数打开这个文件。应用程序使用标准库的 open 函数来打开一个文件。</p><p>在 x86_64 架构里，open 函数会执行 syscall 指令，从用户态转换到内核态，并且最终调用到 do_sys_open 函数，然进而调用 do_sys_openat2 函数。</p><p>我给你画一幅流程图，你一看就明白了。</p><img src="'+c+'" alt="img" style="zoom:25%;"><p>打开文件流程</p><p>上图中清楚了展示了从系统调用开始，打开文件的全部主要流程，<strong>file、dentry、inode 三个结构</strong>在这个流程中扮演了重要角色。在查找路径和检查权限后，进入了具体文件系统的打开流程。</p><h3 id="读写文件" tabindex="-1"><a class="header-anchor" href="#读写文件" aria-hidden="true">#</a> 读写文件</h3><p>只要打开了一个文件，就可以对文件进行进一步的读写操作了。其实读写本是两个操作，只数据流向不同：读操作是数据从文件经由内核流向进程，而写操作是数据从进程经由内核流向文件。</p><p>所以，下面我们以读操作为例，看看读操作的流程，我依然用画图的方式为你展示这一流程，如下所示。</p><img src="'+l+'" alt="img" style="zoom:15%;"><p>读文件流程示意图</p><p>上图中展示了读文件操作的函数调用流程，写文件操作的流程和读文件操作的流程一样，只是数据流向不同，我就不展开了，你可以自己想一下。</p><h3 id="关闭文件" tabindex="-1"><a class="header-anchor" href="#关闭文件" aria-hidden="true">#</a> 关闭文件</h3><p>我们打开了文件，也对文件进行了读写，然后就到了关闭文件的环节。为什么要关闭文件呢？因为打开文件时分配了很多资源，如 file、dentry、inode，内存缓冲区等，这些资源使用了都要还给系统，如若不然，就会导致资源泄漏。</p><p>下面我们就来看看关闭文件的操作流程，我同样用画图的方式为你展示这一流程，如下所示。</p><img src="'+i+`" alt="img" style="zoom:15%;"><p>关闭文件流程示意图</p><p>以上就是关闭一个文件的全部流程。它回收了 file 结构，其中最重要<strong>是调用了文件系统的 flush 函数</strong>，它给了文件系统一个刷新缓冲区，把数据写回储存设备的机会，这样就保证了储存设备数据的一致性。</p><h2 id="文件系统实例" tabindex="-1"><a class="header-anchor" href="#文件系统实例" aria-hidden="true">#</a> 文件系统实例</h2><p>为了进一步加深理解，我为你写了一个 400 行代码左右的最小文件系统，放在本课的目录中，**它就是 trfs，这是一个内存文件系统，支持文件的建立、打开、读写、关闭等操作，通过内存块存放数据。**下面仅对文件系统的注册和使用进行介绍。</p><h3 id="注册-trfs" tabindex="-1"><a class="header-anchor" href="#注册-trfs" aria-hidden="true">#</a> 注册 trfs</h3><p>我们先来看看如何注册 trfs 文件系统的。由于我们的文件系统是写在 Linux 内核模块中的，所以我们要在模块初始化函数中注册文件系统 ，Linux 注册文件系统需要一个参数，即文件系统类型结构，它里面放着文件系统名字、文件系统挂载、卸载的回调函数，代码如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">file_system_type</span> trfs_fs_type <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;trfs&quot;</span><span class="token punctuation">,</span><span class="token comment">//文件系统名字</span>
    <span class="token punctuation">.</span>mount <span class="token operator">=</span> trfs_mount<span class="token punctuation">,</span><span class="token comment">//文件系统挂载函数</span>
    <span class="token punctuation">.</span>kill_sb <span class="token operator">=</span> trfs_kill_superblock<span class="token punctuation">,</span><span class="token comment">//文件系统卸载函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">trfs_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
    <span class="token function">init_fileinfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始化trfs文件系统数据结构</span>
    ret <span class="token operator">=</span> <span class="token function">register_filesystem</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>trfs_fs_type<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//注册文件系统</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret<span class="token punctuation">)</span>
        <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG<span class="token string">&quot;register trfs failed\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG<span class="token string">&quot;trfs is ok\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">trfs_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">exit_fileinfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放trfs文件系统数据结构</span>
    <span class="token function">unregister_filesystem</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>trfs_fs_type<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//卸载文件系统</span>
<span class="token punctuation">}</span>
<span class="token function">module_init</span><span class="token punctuation">(</span>trfs_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>trfs_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码只展示了注册文件系统的代码，其它代码在课程相关代码目录下。支持文件打开、读写、关闭操作，能够在内存中保存文件数据。</p><h3 id="使用-trfs-文件系统" tabindex="-1"><a class="header-anchor" href="#使用-trfs-文件系统" aria-hidden="true">#</a> 使用 trfs 文件系统</h3><p>注册了 trfs 文件系统，这不等于可以使用这个文件系统存取文件了。那么如何使用 trfs 文件系统呢？当然首先是编译 trfs 内核模块代码，在终端中 cd 到对应的目录下执行 make，然后把编译好的内核模块插入到系统中，最后就是将这个文件系统挂载到一个具体的目录下。代码如下。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>make                           <span class="token comment">//编译内核模块 </span>
sudo insmod trfs<span class="token punctuation">.</span>ko            <span class="token comment">//把内核模块插入到内核</span>
sudo mount <span class="token operator">-</span>t trfs none <span class="token operator">/</span>mnt<span class="token operator">/</span>  <span class="token comment">// 挂载trfs文件系统到mnt目录下</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有了上述代码，挂载 trfs 到 /mnt 下，我们就可以用 touch 建立一个文件，然后用 cat 读取这个文件了。</p><p>好了，关于 trfs 我们就介绍到这里了，trfs 的代码我已经帮你写好了，你可以自己慢慢研究，有什么问题也可以和我交流。</p><h2 id="重点回顾" tabindex="-1"><a class="header-anchor" href="#重点回顾" aria-hidden="true">#</a> 重点回顾</h2><p>至此，Linux 的虚拟文件系统就告一段落了，同时也标志着我们整个文件系统章节结束了。那么本节课中学了什么呢？我来为你梳理一下。</p><p>\\1. <strong>什么是 VFS</strong>。VFS 是虚拟文件系统，是 Linux 中一个中间层，它抽象了文件系统共有数据结构和操作函数集合。一个具体的文件系统只要实现这些函数集合就可以插入 VFS 中了，也因为 VFS 的存在，使得 Linux 可以同时支持各种不同的文件系统。</p><p>\\2. VFS 的数据结构，为了搞清楚 VFS 的实现原理，我们研究了它的数据结构，分别是表示文件系统的超级块结构、表示文件路径的目录结构、表示文件自身的索引结点结构，还有进程打开的文件实例结构，最后还了解了它们之间的关系。</p><p>\\3. 为了进一步了解 <strong>VFS 和具体文件系统的工作机制</strong>，我们研究了文件的打开、读写、关闭等操作流程，在这些流程我们明白了 VFS 是如何和具体文件系统打通的。</p><p>\\4. 为了弄懂一个具体文件系统是如何安装到 VFS 中的，我们实现了一个小的 trfs 文件系统，trfs 将文件数据保存在内存中， 将 trfs 挂载到 Linux 中某个目录下就可以让一些标准应用进行文件操作了。</p><p>你或许还想知道 EXT4 文件系统是如何划分储存设备的，还想知道 EXT4 是如何管理目录和文件索引结点的。那请你以勤奋为舟，遨游在 LInux 代码的海洋中，寻找 EXT4 这座大岛吧。</p><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题" aria-hidden="true">#</a> 思考题</h2><p>请说一说 super_block，dentry，inode 这三个数据结构 ，一定要在储存设备上对应存在吗？</p><p>欢迎你在留言区跟我交流互动，也推荐你把这节课分享给朋友一起学习进步。</p><p>我是 LMOS，我们下节课见！</p>`,106),r=[u];function d(m,v){return n(),a("div",null,r)}const _=s(k,[["render",d],["__file","K35-Linux的VFS.html.vue"]]);export{_ as default};
