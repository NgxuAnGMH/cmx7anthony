import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o as n,c as p,a,b as e,e as s,d as h}from"./app-cdabc73c.js";const d="/assets/640-1691391271223-157-93b37f48.png",o="/assets/640-1691391271223-158-d35d5b09.png",c="/assets/640-1691391271223-159-dd3c536a.png",g="/assets/640-1691391271223-160-d3e0e8f0.png",_="/assets/640-1691391271223-161-e44cdb18.png",l="/assets/640-1691391271223-162-25d91aa9.png",C={},S=a("h1",{id:"_58-白泽带你读论文-mining-and-exploiting-payment-credential-leaks",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#_58-白泽带你读论文-mining-and-exploiting-payment-credential-leaks","aria-hidden":"true"},"#"),e(" 58-白泽带你读论文 | Mining and Exploiting Payment Credential Leaks")],-1),A={href:"https://i.blackhat.com/asia-21/Thursday-Handouts/as-21-Shi-Mining-And-Exploiting-Mobile-Payment-Credential-Leaks-In-The-Wild-wp.pdf",target:"_blank",rel:"noopener noreferrer"},f=h('<p><strong>Mining and Exploiting (Mobile) Payment</strong> <strong>Credential Leaks in the Wild</strong></p><p>本周由复旦系统与软件安全实验室吕海铭等同学负责论文精读与整理，论文选取自Black Hat Asia 2021的一篇研究移动支付及凭证泄露的的工作。本文通过对主流移动支付服务及四个顶级Cashier的研究，发现了支付凭证的新的泄漏源，并提出了4种利用泄漏的支付凭证发起攻击的方法。这些攻击可以导致其他用户或商家的直接经济损失。本文还构建了一个自动化挖掘泄漏凭证的工具，进行了大范围的实验测试，最终成功挖掘出了约20,000个泄漏的凭证。</p><h2 id="_1-研究背景" tabindex="-1"><a class="header-anchor" href="#_1-研究背景" aria-hidden="true">#</a> 1. 研究背景</h2><p>一般的在线支付服务涉及到三个主体：用户（User）、收款方（Cashier）以及商家（Merchant）。而在移动支付的场景下，Cashier和Merchant实际上对应着他们的后端服务器，即Cashier Server（CS）和Merchant Server（MS）；User对应着用户终端上的前端App，即Cashier App（CA）和Merchant App（MA）。</p><h3 id="_1-1-移动支付服务的工作流程" tabindex="-1"><a class="header-anchor" href="#_1-1-移动支付服务的工作流程" aria-hidden="true">#</a> <strong>1.1 移动支付服务的工作流程</strong></h3><p>通过对四个顶级Cashier的文档的分析（Cashier1-4），本文总结出了移动支付的一般流程：</p><figure><img src="'+d+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>1）用户登录MA（可能是通过第三方Cashier所提供的SSO服务登录）；</p><p>2）用户在MA上挑选好商品，而后选择一个Cashier来结账。然后MA会向MS发送一个包含了订单详情的请求；</p><p>3）MS生成一份付款单，并将其返回给MA；</p><p>4）MA将付款单传递给CA。CA收到付款单后会将交易总额和付款方等详细信息展示给用户，供用户检查；</p><p>5）用户同意支付后，CA会向CS发送支付请求；</p><p>6）CS处理支付请求。随后，casher会将用户的支付信息异步通知给MS（通过之前步骤三中付款单所包含的backURL），同步通知给CA；</p><p>7）CA将来自CS的同步通知传递给MA；</p><p>8）MA将收到的通知传回服务器MS，同时会查询订单的支付状态；</p><p>9）MS可以直接向CS发起特权操作的请求，诸如退款、转账等。</p><h3 id="_1-2-支付凭证" tabindex="-1"><a class="header-anchor" href="#_1-2-支付凭证" aria-hidden="true">#</a> <strong>1.2 支付凭证</strong></h3><h4 id="_1-2-1-payment-key" tabindex="-1"><a class="header-anchor" href="#_1-2-1-payment-key" aria-hidden="true">#</a> <strong>1.2.1 Payment Key</strong></h4><p>在Figure 1中用斜体字标出来的步骤都使用了HMAC或者数字签名来提供安全保障。下面的表格中总结了不同的Cashier所使用的Payment Key。</p><figure><img src="'+o+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>这些Payment Key可以被分成下面两种类型：</p><p>1）Secret Key。Cashier1-4都支持使用HMAC来对交易信息进行保护。采用这种方式，MS和CS都会使用相同的秘钥来作为生成HMAC的哈希函数的salt。</p><p>2）Signing Key。表格中的其他秘钥都是用来生成数字签名的秘钥。MS和CS需要拥有自己的一对公私钥，并将自己的公钥分享给对方。Cashier1 支持两种生成数字签名的方法，也定义了两种签名秘钥：RSA Key 和 RSA’ Key。这两种秘钥之间的不同之处在于：在RSA Key中，所有的App共享相同的Cashier1公钥；在RSA’ Key中，Cashier1和每个不同的App共享不同的公钥。Cashier3通过为MA签发PFX证书来保护支付信息的安全。其公钥包含在官方的后端SDK中，同时也是为所有的App所共享。</p><h4 id="_1-2-2-其他支付凭证" tabindex="-1"><a class="header-anchor" href="#_1-2-2-其他支付凭证" aria-hidden="true">#</a> <strong>1.2.2 其他支付凭证</strong></h4><p>一些Cashier通过定义其他的支付凭证来加强其支付服务的安全性：</p><p>1）Android Signing Key。Cashier2和Cashier4的CA会在接受到付款单时通过检查MA的安卓包签名来验证MA的完整性。</p><p>2）Client Certificate。Cashier2通过分别为每个App签发不同的证书来支持它所提供的服务。MS需要在调用关键的API（比如退款请求）之前向CS展示自己的证书来进行身份验证。</p><h2 id="_2-潜在支付凭证泄漏源" tabindex="-1"><a class="header-anchor" href="#_2-潜在支付凭证泄漏源" aria-hidden="true">#</a> 2. 潜在支付凭证泄漏源</h2><h3 id="_2-1-公开的git仓库" tabindex="-1"><a class="header-anchor" href="#_2-1-公开的git仓库" aria-hidden="true">#</a> <strong>2.1 公开的git仓库</strong></h3><p>一些开发者在上传开发代码到GitHub时，并没有将敏感的凭证移除。即使随后开发者意识到了凭证已泄漏，他们很有可能不会通过更新凭证的方法来替换已泄漏的凭证，而是会采用一些错误的弥补手段。这就导致攻击者从公开的git仓库中取得一些支付凭证。</p><p>此外，一些公司会在公开访问的IP上部署GitLab服务，并将自己的仓库设置为可以公开访问，其中是可能包含一些支付凭证的。借助于强大的网络爬虫技术，攻击者可以轻松访问这些公开的仓库并将支付凭证提取出来。</p><h3 id="_2-2-移动应用程序" tabindex="-1"><a class="header-anchor" href="#_2-2-移动应用程序" aria-hidden="true">#</a> <strong>2.2 移动应用程序</strong></h3><p>许多的开发者会在移动应用程序中部署一些服务端的操作，这样就会导致一些凭证被嵌入到MA中。攻击者可以通过反编译MA来获取到凭证。</p><h3 id="_2-3-商家服务器ms" tabindex="-1"><a class="header-anchor" href="#_2-3-商家服务器ms" aria-hidden="true">#</a> <strong>2.3 商家服务器MS</strong></h3><p>由于Cashier所提供的后端SDK设计不安全，同时MS对于与SDK相关的凭证文件没有足够的保护意识，导致MS成为一个支付凭证的泄漏源。</p><p>Cashier通过提供SDK来促进其支付服务的部署。图2中展示了一个日活3亿+的Cashier所提供的官方SDK结构。</p><figure><img src="'+c+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>在这个SDK中，“backURL.php”会处理来自于CS的异步通知，“PaymentConfig.php”中会包含Merchant的签名秘钥所在的具体位置，即“cred/privateKey.pem”，同时在这个位置下还会保存开发者的私钥。这样不安全的设计导致攻击者可以在自己控制的设备上通过backURL的值得知backURL.php的具体位置。然后基于SDK的结构可以进一步推测出私钥文件的位置。如果MS没有关闭对这个私钥文件访问权限，攻击者就可以直接获取到私钥文件。</p><h2 id="_3-支付凭证泄漏的利用" tabindex="-1"><a class="header-anchor" href="#_3-支付凭证泄漏的利用" aria-hidden="true">#</a> 3. 支付凭证泄漏的利用</h2><h3 id="_3-1-冒充商家攻击" tabindex="-1"><a class="header-anchor" href="#_3-1-冒充商家攻击" aria-hidden="true">#</a> <strong>3.1 冒充商家攻击</strong></h3><p>通过使用泄漏出来的支付凭证，攻击者可以伪装成正常的商家向Cashier发送伪造的请求来执行一些特权操作，比如退款和转账。</p><h3 id="_3-2-安卓包签名伪造" tabindex="-1"><a class="header-anchor" href="#_3-2-安卓包签名伪造" aria-hidden="true">#</a> <strong>3.2 安卓包签名伪造</strong></h3><p>Cashier2和Cashier4会在每次支付的时候对MA进行签名的校验。然而许多安卓签名秘钥也会在一些git仓库中被泄漏。因此攻击者可以在修改App的源代码后使用泄漏的签名秘钥进行重打包，构造一个具有合法签名的恶意App，执行任意自己想要的恶意操作。</p><h3 id="_3-3-backward-sso攻击" tabindex="-1"><a class="header-anchor" href="#_3-3-backward-sso攻击" aria-hidden="true">#</a> <strong>3.3 Backward SSO攻击</strong></h3><p>Cashier2提供SSO认证的服务。本文在其系统中发现了一些缺陷，即在支付服务和SSO服务中共用了相同的一套user_id。因此在其支付凭证泄漏后，攻击者可以很轻松的获取的这些用户id。尽管SSO协议在设计上是安全的，但是一些商家App在使用时没有遵循OAuth的标准流程，而是仅仅依赖于客户端CA返回的用户id来对用户进行认证，没有进一步向CS发起查询（如Figure3所示）。这就导致这些App无法抵御Profile Attack，攻击者可以通过替换其终端上的用户id来劫持其他受害者的账户。</p><figure><img src="'+g+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>此外本文还发现了一些开发者（2%）在SSO服务和支付服务中使用了相同的秘钥，进一步扩大了支付凭证泄漏对SSO的威胁。</p><h3 id="_3-4-跨应用通知伪造" tabindex="-1"><a class="header-anchor" href="#_3-4-跨应用通知伪造" aria-hidden="true">#</a> <strong>3.4 跨应用通知伪造</strong></h3><p>Cashier1和Cashier3的公钥是可以在不同的App之间共享的。因此，攻击者可以用泄漏的支付凭证精心伪造CS的一些支付通知，并将其注入另一个应用程序的会话。这些通知可以通过MS的密码学校验，但在逻辑上是不正确的。然而MS可能不会去检验通知中包含的App Identifier，也就意味着MS不会去检验这个通知是否是发送给自己的。最终这会导致攻击者可以实现免费购物攻击。</p><h2 id="_4-泄漏支付凭证自动化挖掘工具" tabindex="-1"><a class="header-anchor" href="#_4-泄漏支付凭证自动化挖掘工具" aria-hidden="true">#</a> 4. 泄漏支付凭证自动化挖掘工具</h2><p>本文所涉及的自动化凭证挖掘工具的整体框架如图4所示。</p><figure><img src="'+_+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>其主要包含三个模块：</p><p>1）<mark>Crawler</mark>：识别可能支持了支付功能的公开git仓库和安卓Apk</p><p>2）<mark>Scanner</mark>：识别仓库和Apk中潜在的支付凭证</p><p>3）<mark>Detector</mark>：对潜在的支付凭证进行处理，验证其是否是可用的凭证。</p><h2 id="_5-实验测试" tabindex="-1"><a class="header-anchor" href="#_5-实验测试" aria-hidden="true">#</a> 5. 实验测试</h2><figure><img src="'+l+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>测试的数据集包括139,206个Github仓库，943个GitLab仓库，233,550个安卓应用，一共有1,240,961个版本。Table 2 中展示了测试的结果，一共找出20,000个独特的支付凭证。实验结果表明，10.34%的Git仓库，3.21%的安卓Apk，7.11%的MS都出现了泄漏的情况。处理每个输入平均耗时约300秒。</p><h2 id="_6-应用程序身份解析" tabindex="-1"><a class="header-anchor" href="#_6-应用程序身份解析" aria-hidden="true">#</a> 6. 应用程序身份解析</h2><p>为了能够利用泄漏出的凭证，需要知道与其相关的MA。因此本文利用了三种方法来识别App的身份：</p><p>1）构造支付请求给CA，利用返回的消息来识别</p><p>2）分析Client Certificate中包含的App信息</p><p>3）Hook CA中关于应用身份验证的函数比如getAppInfo、verifyAppInfo</p><h2 id="_7-缓解措施" tabindex="-1"><a class="header-anchor" href="#_7-缓解措施" aria-hidden="true">#</a> 7. 缓解措施</h2><p>1）Cashier应该明确的警告开发者支付凭证泄漏的严重后果；</p><p>2）Cashier应该审查其提供的服务并即使修改不安全的设计，比如有缺陷的后端SDK等；</p><p>3）Cashier应该积极主动的监测和撤销已经泄漏的支付凭证；</p><p>4）商家应该定期更换他们的支付凭证。</p><h2 id="_8-总结" tabindex="-1"><a class="header-anchor" href="#_8-总结" aria-hidden="true">#</a> 8. 总结</h2><p>本文通过对四个顶级Cashier的研究，发现了支付凭证的新的泄漏源，并提出了4种利用泄漏的支付凭证发起攻击的方法。这些攻击可以导致其他用户或商家的直接经济损失。本文还构建了一个自动化挖掘泄漏凭证的工具，进行了大范围的实验测试，最终成功挖掘出了约20,000个泄漏的凭证。</p><h2 id="_9-思考与讨论" tabindex="-1"><a class="header-anchor" href="#_9-思考与讨论" aria-hidden="true">#</a> 9. 思考与讨论</h2><p>Q1：Payment Credential泄漏和普通的密码/凭证泄漏，有什么本质区别吗？</p><p>A1：Payment Credential主要关注在支付过程中的消息认证上，而密码凭证可能关注的是登陆时候的身份认证，如作者所说，Payment Credential可能会影响到更多的用户，而普通的密码/凭证可能影响到的当前的密码/用户对应的账户；</p><p>Q2：Cross-App Notification forgery的具体攻击方式？Payment Key到底是指什么？</p><p>A2：Payment Key是CS的Private Key。因为公钥是共享的，一旦CS的私钥泄漏，attacker利用CS的Private Key仿冒CS对其他App发出notification，如果MS刚好不对CS做其他额外认证方式，则可以攻击成功。</p><p>Q3：密钥的泄漏究竟是开发者使用不当，还是SDK本身存在问题？</p><p>A3：开发者获取密钥的时候都是需要经过验证，然后获取到密钥后SDK一般都会提醒，保护好自己的密钥不要泄漏，但比如可能开发者一不小心就将源码（包括密钥）上传到Github上。这种情况下开发者将SDK的密钥暴露出去了，偏向于开发者问题更多。</p><p>Q4：为什么如果SSO attack用的是Payment Key，影响更大？</p><p>A4：一个私钥多个用途，攻击面被扩大了。</p><p>Q5：在backward SSO attack中，attacker是如何获取到user_id的？理论上token和user_id并不是独立的，为什么仅替换user_id就可以发起profile attack？</p><p>A5：在SSO中使用的user id 和支付过程中使用的user id 是相同的一个集合。攻击者利用泄漏的凭证，可以很容易地在支付过程中获取到一些合法的user id。</p><p>一些App没有严格遵循OAuth的认证步骤，省略了第2步。第2步可能是用token验证与user_id是否匹配，省略了该步骤的话，其实并没有使用token。</p><p>Q6：文中提出的mitigation都比较简单，能不能对协议有什么安全性的优化？</p><p>A6：对于用户登录的验证，可以使用一次一密的token或者ticket；此外可以使用更安全的协议比如https；对于冒充商家的攻击，仅仅验证签名或者hash，可以补充对于商家身份的进一步验证；可以动态设置backurl，来取代backurl的固定值。</p><p>Q7：文章1.2.1节当中可以看到C2和C4都仅仅使用了HMAC来做消息验证，但是C1和C3除了消息验证码还采用了数字签名，能否说明安全性不同？</p><p>A7：确实会有一定的安全性的差距，比如最安全的应该是C1的RSA&#39; Key,为不同的Merchant App使用不同的密钥对，可以降低某一个秘钥泄漏后其他App受攻击的风险。</p><p>Q8：聚合平台的存在对安全性的影响？</p><p>A8：增加泄漏途径和攻击点。</p>',89);function u(m,b){const i=t("ExternalLinkIcon");return n(),p("div",null,[S,a("p",null,[a("a",A,[e("as-21-Shi-Mining-And-Exploiting-Mobile-Payment-Credential-Leaks-In-The-Wild-wp.pdf (blackhat.com)"),s(i)])]),f])}const y=r(C,[["render",u],["__file","58-白泽带你读论文  Mining and Exploiting Payment Credential Leaks.html.vue"]]);export{y as default};
