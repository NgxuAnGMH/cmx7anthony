import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o as s,c as o,a,b as e,e as i,d}from"./app-cdabc73c.js";const h="/assets/640-1691486010437-345-a2f85361.jpeg",c="/assets/640-1691486010438-346-3a03e8c2.jpeg",p={},l=a("h1",{id:"_08-白泽带你读论文丨pomp-postmortem-program-analysis-with-hardware-enhanced",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#_08-白泽带你读论文丨pomp-postmortem-program-analysis-with-hardware-enhanced","aria-hidden":"true"},"#"),e(" 08-白泽带你读论文丨POMP:Postmortem Program Analysis with Hardware-Enhanced")],-1),P=a("p",null,"POMP: Postmortem Program Analysis with Hardware-Enhanced Post-Crash Artifacts",-1),_={href:"https://github.com/junxzm1990/pomp.git",target:"_blank",rel:"noopener noreferrer"},g=d('<p>本文发表在<strong>USENIX Security 17</strong>，第一作者是来自宾夕法尼亚州立大学的徐军。本文的第四作者Xinyu Xing长期从事自动化漏洞分析、漏洞利用生成等安全领域的研究，发表过多篇顶会论文。</p><h2 id="主要内容" tabindex="-1"><a class="header-anchor" href="#主要内容" aria-hidden="true">#</a> 主要内容</h2><p><strong>程序崩溃分析</strong>是软件开发和测试中的一个重要步骤。一方面，程序中存在的崩溃行为会影响到程序的稳定性，造成软件质量的下降。另一方面，程序崩溃中的一部分甚至会形成安全漏洞，造成远程代码执行等严重后果。为了修复这些崩溃而进行的人工分析往往是代价巨大的。据统计，全世界每年平均花费在调试程序的支出就超过了3120亿美元。因此，<em>自动化地定位程序崩溃原因</em>的意义十分巨大。</p><p>根据使用到的技术，目前的自动化程序崩溃分析工具主要可以分为两类。</p><ul><li>第一类<strong>重量级的分析工具</strong>，主要使用了插桩的技术来对程序的运行流程进行跟踪，并通过跟踪获得的反馈信息对程序崩溃的流程进行分析。这种方法可以拿到程序运行的详细信息，因此准确度比较高，但动态插桩的代价比较大，也额外增加了工具的开销。</li><li>另一类<strong>轻量级的分析工具</strong>，主要通过静态的方法，对程序执行日志、stack trace、crash dump等进行分析，比上一类工具更为轻量，但由于获得的信息较少，往往较难精确地对程序崩溃进行定位。</li></ul><p>本文中作者提出了一个<strong>自动化工具POMP</strong>，使用了轻量级的分析方法，在程序崩溃时产生的核心转储文件（core dump）的基础上对Intel PT记录的信息进行了分析，在保证了工具的运行效率的同时提高了准确度。该工具首先通过<strong>PT 重构指令序列</strong>，再通过**逆向执行（Reverse execution）<strong>来恢复软件崩溃前的控制流，最后通过</strong>反向污点分析（Backward taint analysis）**的方法来定位到造成程序崩溃的一组指令，最终的定位成功率非常高，定位结果也比较精确。</p><h2 id="问题定义" tabindex="-1"><a class="header-anchor" href="#问题定义" aria-hidden="true">#</a> 问题定义</h2><p>程序崩溃分析的过程，简单来说，就是<strong>从程序崩溃的状态定位到崩溃原因点的过程</strong>。常见的程序崩溃原因主要有两种，分别是运行非法指令和解引用非法地址。以下图为例，崩溃发生在19行中对一个非法地址的赋值。为了追溯到引发这个崩溃的源头，我们通过回溯的方法，一行一行往回推进，一直到第8行，找到了这条对错误指针进行赋值的语句，从而理解了这次崩溃发生的原因，于是这次程序崩溃分析就已经完成了。</p><figure><img src="'+h+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>回溯方法</p><p>实际上，自动化的程序崩溃分析往往不能完全精确地定位到造成崩溃的最小指令集合，因此程序崩溃工具的目标是，工具得到的指令集合在完全覆盖最小指令集合的基础上尽量的小。</p><h2 id="设计与实现" tabindex="-1"><a class="header-anchor" href="#设计与实现" aria-hidden="true">#</a> 设计与实现</h2><p>POMP的实现流程主要分为三个步骤：重构指令序列、恢复数据流和逆向污点分析。</p><h3 id="_1-重构指令序列" tabindex="-1"><a class="header-anchor" href="#_1-重构指令序列" aria-hidden="true">#</a> <strong>1. 重构指令序列</strong></h3><p>POMP使用了Intel PT工具，在程序运行的过程中记录运行的指令。使用相关工具，POMP就可以从Trace中重构出从程序运行到崩溃这一过程的指令序列。</p><h3 id="_2-恢复数据流" tabindex="-1"><a class="header-anchor" href="#_2-恢复数据流" aria-hidden="true">#</a> <strong>2. 恢复数据流</strong></h3><p>为了追溯到程序崩溃的源头，POMP需要进行数据流分析。在上一步中，POMP已经拿到了指令序列，为了进一步恢复数据流，POMP需要进行逆向执行。</p><p>逆向执行的概念非常简单，即逆向地执行一条汇编指令，将其产生的影响完全回溯。对于一些简单的指令，例如add和sub等，可以非常容易地直接恢复。而对于mov一类破坏性的指令，POMP就需要进行后向数据流分析以确定被破坏的值的原值。在分析的过程中，如果出现内存别名，即两个内存指针可能指向同一个地址的时候，POMP会使用假设检验的方法来尝试进行解决，即对两个指针是别名和不是别名分别创建两个状态，再通过use-define chain来寻找条件约束，对两个假设分别进行约束求解，筛选掉不可能的状态。</p><p>但这个方法也存在着一些不足之处。首先，对于一些可以改变内存的syscall，如recv和write等，syscall前的内存使用和修改都有可能被覆盖，为了结果的准确性，这些约束条件都只能被去掉，从而减少了约束求解的可能性。另外一方面，内存别名检验的过程中还有可能遇到另一对别名，而这个过程可以无限地递归下去，使程序的复杂度变为指数级别。针对这个问题，作者限制了递归的深度为2，在测试中也取得了比较好的效果。</p><h3 id="_3-逆向污点分析" tabindex="-1"><a class="header-anchor" href="#_3-逆向污点分析" aria-hidden="true">#</a> <strong>3. 逆向污点分析</strong></h3><p>逆向污点分析是POMP的最后一步，最终污点分析的结果即为工具定位到的程序崩溃原因。</p><p>为了进行逆向污点分析，POMP首先需要指定一个sink。对于运行非法指令和解引用非法地址的情况，POMP分别指定了eip和含有非法地址的寄存器作为sink。在逆向污点分析的过程中还可能会遇到内存别名的问题，POMP依然使用了假设检验的方法进行解决。</p><h2 id="评价" tabindex="-1"><a class="header-anchor" href="#评价" aria-hidden="true">#</a> 评价</h2><figure><img src="'+c+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>测试结果</p><p>POMP对31个真实程序的崩溃进行了测试，这些崩溃包括堆、栈和整数溢出，UAF和空指针解引用：</p><p>首先作者人工分析了这些程序崩溃的原因（即造成崩溃的最小指令集合）作为Ground Truth。对于其中的29个例子，POMP生成的崩溃原因集合都能覆盖Ground Truth，且两者指令数目相差不大。对于剩下的两个没有成功的例子，一个是由于前面提到的syscall问题，造成了无法正常求解约束。另一个是由于Intel PT buffer size过小，没有完整的记录造成崩溃的Trace造成的。</p><p>总体而言，POMP在对core dump进行分析的基础上使用了PT Trace的信息，在对程序运行的效率损耗较小的前提下，能精确地定位到程序崩溃原因，大大减少了人工的代价。但该工具只能针对内存漏洞，对多线程和JIT的支持较差，还有一定的改进空间。</p>',28);function m(u,f){const r=n("ExternalLinkIcon");return s(),o("div",null,[l,P,a("p",null,[e("开源项目地址："),a("a",_,[e("https://github.com/junxzm1990/pomp.git"),i(r)])]),g])}const x=t(p,[["render",m],["__file","08-白泽带你读论文丨POMPPostmortem Program Analysis with Hardware-Enhanced.html.vue"]]);export{x as default};
