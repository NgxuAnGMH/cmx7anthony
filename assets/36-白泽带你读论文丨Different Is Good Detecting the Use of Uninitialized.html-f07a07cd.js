import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o as r,c as o,a as e,b as a,e as s,d as p}from"./app-cdabc73c.js";const d="/assets/640-1691474903736-270-658d0601.png",c="/assets/640-1691474903737-271-98ef88aa.png",h="/assets/640-1691474903737-272-019ec5d1.png",_="/assets/640-1691474903737-273-8aef6f84.png",f="/assets/640-1691474903737-274-8d933072.png",l={},g=e("h1",{id:"_36-白泽带你读论文丨different-is-good-detecting-the-use-of-uninitialized",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_36-白泽带你读论文丨different-is-good-detecting-the-use-of-uninitialized","aria-hidden":"true"},"#"),a(" 36-白泽带你读论文丨Different Is Good: Detecting the Use of Uninitialized")],-1),u=e("p",null,[e("strong",null,"Different Is Good: Detecting the Use of Uninitialized Variables Through Differential Replay")],-1),m=e("p",null,"论文链接：",-1),x={href:"https://dl.acm.org/doi/pdf/10.1145/3319535.3345654",target:"_blank",rel:"noopener noreferrer"},b=p('<p>本文发表在CCS 2019，第一作者是来自<u>阿里猎户座安全实验室的Mengchen Cao</u>。</p><h2 id="_1-主要内容" tabindex="-1"><a class="header-anchor" href="#_1-主要内容" aria-hidden="true">#</a> <strong>1. 主要内容</strong></h2><p>使用未初始化的变量是很常见的编程错误，它可能会造成内核信息泄漏，从而严重危害系统安全。目前针对闭源操作系统中未初始化变量的检查仍然是一个比较困难的问题，其原因包含两个方面：</p><p>一是静态分析往往需要源码，并不适合闭源操作系统；</p><p>二是动态分析一般需要一个触发点，而使用未初始化的变量这类内存泄漏问题通常并不会造成crash或者其它可以感知的到的影响。目前效果最好的动态分析工具<em>Bochspwn Reloaded</em>，虽然能够检测出大量的未初始化变量的漏洞，但是它的实现只是针对一些特定指令进行污点传播，这就导致该工具会有不少的漏报。</p><p>因此，本文提出了一种全新的检测是否使用未初始化变量的方法：采用差分重放技术在不使用源码的前提下定位在哪里使用了未初始化的变量，并利用符号污点分析快速找到未初始化变量的来源，通过这两种技术的结合实现对操作系统中未初始化变量bug进行有效检测。作者利用这种检测方法实现了一个原型工具<mark>Timeplayer</mark>，在Windows7和Windows10的最新版本上测试了7个月，共发现了34个漏洞，其中17个被微软确认为零日漏洞。</p><h2 id="_2-设计与实现" tabindex="-1"><a class="header-anchor" href="#_2-设计与实现" aria-hidden="true">#</a> <strong>2. 设计与实现</strong></h2><figure><img src="'+d+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>Timeplayer的整体架构如上图所示，它首先利用全系统模拟器记录内核态和用户态程序的运行，然后设置实验组进行重放并通过比较重放结果找到差异点，从而确定对未初始化变量的使用。之后会从差异点处回退部分指令并重新执行，在执行trace上进行符号污点分析从而确定未初始化变量声明的位置。整体来看，其实现过程就是差分重放和符号污点分析两种关键技术的组合：</p><p><strong>(1) 差分重放</strong>: 差分重放是本文的核心idea，它旨在找到未初始化变量的使用位置。</p><p>Timeplayer利用确定性重放功能，在重放时设置了对照实验，其中实验组不对原来程序的执行状态做任何修改，而对照组会在内存分配时在所有内存中填充一个特定的值，并在之后的重放过程中对内存读写指令进行检查。如果存在初始化操作，那么在程序运行中填充值就会被初始化的值覆盖掉，因此在变量使用时两次重放过程从该内存区域中读出的值相同，反之，如果没进行初始化，在使用时读出的值就会出现差异。作者便利用这个差异找到了使用未初始化变量的位置。</p><p>本文的差分重放是基于PANDA框架的确定性重放功能实现的，PANDA框架是基于Qemu的开源动态分析平台，它不仅可以在程序运行时记录下内存和寄存器的状态，也能记录下输入事件、硬件中断、DMA事件这些不确定事件，因此它可以在重放过程中确保程序的运行状态完全相同。</p><p>由于差分重放会带来较大的开销，所以作者还利用PANDA框架的剪刀插件将一次执行记录分成多个子记录进行并行重放从而提高重放效率。但是这样可能存在变量声明和使用在不同的子记录中而导致漏报。</p><p><strong>(2) 符号污点分析</strong>: 符号污点分析用于找到未初始化变量的来源。</p><p>现有的基于数据流的动态污点分析方法很难处理由位运算、逻辑操作以及算术操作所造成的污点标志消除，因此本文采用符号化污点分析来获取未初始化变量的来源。作者将在堆栈上分配内存的指令定义为source，将差分重放中发现的差异点指令作为sink，基于VEX IR来实现整个符号污点分析。</p><p>当差分重放找到差异点指令后，会回退部分指令重新执行并进行符号污点分析。具体来说，作者会在分配内存的指令处给该内存区域分配一个符号表达式，并在后续符号执行的过程中传递污染标识。当到达差异点指令的时候，根据目标内存区域的符号表达式就能很快定位到未初始化变量声明的位置。</p><p>同时，作者提出了两种提高符号污点分析效率的方案：</p><p>1）选择执行：即在符号执行的过程中跳过不涉及被污染内存或者寄存器的指令。</p><p>2）符号表达式包装：因为随着符号执行，符号表达式的长度也会增加，这会影响后续符号执行的性能，因此作者给符号表达式的长度和深度设置了一个门槛，当到达门槛时，会将符号表达式进行拆分。</p><h2 id="_3-实验评估" tabindex="-1"><a class="header-anchor" href="#_3-实验评估" aria-hidden="true">#</a> <strong>3. 实验评估</strong></h2><h3 id="_1-针对效果的评估" tabindex="-1"><a class="header-anchor" href="#_1-针对效果的评估" aria-hidden="true">#</a> (1) 针对效果的评估：</h3><p>1）工具本身的效果：</p><p>针对ReactOS测试套件、Firefox、Chrome、IE、优酷客户端、用户登录和远程登录共8个测试用例在32位和64位的Windows 7和Windows 10上共测试了7个月，共发现了34个内核信息泄漏的漏洞，其中17个已经被确认并分配了CVE编号。</p><p>2）与Bochspwn进行对比：</p><p>作者收集了52个Bochspwn之前发布的PoC作为测试用例，在旧版本的Windows上进行复现，并测试两个工具的检测效果，最终结果如下图所示：</p><figure><img src="'+c+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>Timeplayer在测试中共发现了85个漏洞，比Bochspwn多发现了18个。在Timeplayer发现的85个漏洞中，其中55个CVE编号，剩下30个经由人工确认确实是内核信息泄漏。</p><h3 id="_2-针对效率的评估" tabindex="-1"><a class="header-anchor" href="#_2-针对效率的评估" aria-hidden="true">#</a> (2) 针对效率的评估：</h3><p>作者自实现了一个基于数据流的动态分析工具来检测未初始化的漏洞，并将它与Timeplayer进行比较，最终结果如下图所示：</p><figure><img src="'+h+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>Timeplayer在47个小时内发现了34个漏洞，而动态污点分析工具花费了66个小时只发现了7个漏洞。从效率上看，Timeplayer远优于污点分析。</p><h3 id="_3-针对性能的评估" tabindex="-1"><a class="header-anchor" href="#_3-针对性能的评估" aria-hidden="true">#</a> (3) 针对性能的评估：</h3><p>1）差分重放</p><p>评估结果如下表所示，在ReactOS测试套件和Chrome的测试用例中，差分重放的耗时远高于原本的重放，大约慢22-24倍，而采用并行重放的方法可以有效降低时间开销。</p><figure><img src="'+_+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>2）符号污点分析</p><p>评估结果如下表所示，在5个真实测试用例中，在差分重放找到差异点后，符号污点分析基本都会在1分钟内找到未初始化变量的来源。</p><figure><img src="'+f+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h2 id="_4-总结" tabindex="-1"><a class="header-anchor" href="#_4-总结" aria-hidden="true">#</a> <strong>4. 总结</strong></h2><p>本文针对闭源操作系统的未初始化变量的检测提出了一套比较巧妙的方法，其整体流程并不复杂，首先采用了差分重放来发现漏洞，然后通过符号污点分析的方法来快速确定内存泄漏的位置。这种控制变量，对比状态从而发现比较隐蔽的漏洞的思想值得我们借鉴。另外针对于工具的使用而言，由于漏洞还是需要通过输入进行触发，其测试覆盖率一定程度上取决于输入的多少，因此感觉可以采用fuzz的方式来生成输入从而提高覆盖率。</p>',40);function y(z,D){const i=n("ExternalLinkIcon");return r(),o("div",null,[g,u,m,e("p",null,[e("a",x,[a("https://dl.acm.org/doi/pdf/10.1145/3319535.3345654"),s(i)])]),b])}const C=t(l,[["render",y],["__file","36-白泽带你读论文丨Different Is Good Detecting the Use of Uninitialized.html.vue"]]);export{C as default};
