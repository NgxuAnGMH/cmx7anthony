import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as e,o,c,a as s,b as n,e as l,d as a}from"./app-cdabc73c.js";const i="/assets/cb2c806532449f2c1edfe821990ac9ca-b3a514a5.png",u={},r=a(`<h1 id="_32-jni的运行机制" tabindex="-1"><a class="header-anchor" href="#_32-jni的运行机制" aria-hidden="true">#</a> 32 | JNI的运行机制</h1><p>我们经常会遇见 Java 语言较难表达，甚至是无法表达的应用场景。比如我们希望使用汇编语言（如 X86_64 的 SIMD 指令）来提升关键代码的性能；再比如，我们希望调用 Java 核心类库无法提供的，某个体系架构或者操作系统特有的功能。</p><p>在这种情况下，我们往往会牺牲可移植性，在 Java 代码中调用 C/C++ 代码（下面简述为 C 代码），并在其中实现所需功能。这种跨语言的调用，便需要借助 Java 虚拟机的 Java Native Interface（JNI）机制。</p><p>关于 JNI 的例子，你应该特别熟悉 Java 中标记为native的、没有方法体的方法（下面统称为 native 方法）。当在 Java 代码中调用这些 native 方法时，Java 虚拟机将通过 JNI，调用至对应的 C 函数（下面将 native 方法对应的 C 实现统称为 C 函数）中。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Object</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>举个例子，Object.hashCode方法便是一个 native 方法。它对应的 C 函数将计算对象的哈希值，并缓存在对象头、栈上锁记录（轻型锁）或对象监视锁（重型锁所使用的 monitor）中，以确保该值在对象的生命周期之内不会变更。</p><p><strong>native 方法的链接</strong></p><p>在调用 native 方法前，Java 虚拟机需要将该 native 方法链接至对应的 C 函数上。</p><p>链接方式主要有两种。第一种是让 Java 虚拟机自动查找符合默认命名规范的 C 函数，并且链接起来。</p><p>事实上，我们并不需要记住所谓的命名规范，而是采用javac -h命令，便可以根据 Java 程序中的 native 方法声明，自动生成包含符合命名规范的 C 函数的头文件。</p><p>举个例子，在下面这段代码中，Foo类有三个 native 方法，分别为静态方法foo以及两个重载的实例方法bar。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">org<span class="token punctuation">.</span>example</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">long</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token class-name">Object</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过执行javac -h . org/example/Foo.java命令，我们将在当前文件夹（对应-h后面跟着的.）生成名为org_example_Foo.h的头文件。其内容如下所示：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span>
#include <span class="token generics"><span class="token punctuation">&lt;</span>jni<span class="token punctuation">.</span>h<span class="token punctuation">&gt;</span></span>
<span class="token comment">/* Header for class org_example_Foo */</span>

#ifndef _Included_org_example_Foo
#define _Included_org_example_Foo
#ifdef __cplusplus
extern <span class="token string">&quot;C&quot;</span> <span class="token punctuation">{</span>
#endif
<span class="token comment">/*
 * Class:     org_example_Foo
 * Method:    foo
 * Signature: ()V
 */</span>
<span class="token constant">JNIEXPORT</span> <span class="token keyword">void</span> <span class="token constant">JNICALL</span> <span class="token class-name">Java_org_example_Foo_foo</span>
  <span class="token punctuation">(</span><span class="token class-name">JNIEnv</span> <span class="token operator">*</span><span class="token punctuation">,</span> jclass<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
 * Class:     org_example_Foo
 * Method:    bar
 * Signature: (IJ)V
 */</span>
<span class="token constant">JNIEXPORT</span> <span class="token keyword">void</span> <span class="token constant">JNICALL</span> <span class="token class-name">Java_org_example_Foo_bar__IJ</span>
  <span class="token punctuation">(</span><span class="token class-name">JNIEnv</span> <span class="token operator">*</span><span class="token punctuation">,</span> jobject<span class="token punctuation">,</span> jint<span class="token punctuation">,</span> jlong<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
 * Class:     org_example_Foo
 * Method:    bar
 * Signature: (Ljava/lang/String;Ljava/lang/Object;)V
 */</span>
<span class="token constant">JNIEXPORT</span> <span class="token keyword">void</span> <span class="token constant">JNICALL</span> <span class="token class-name">Java_org_example_Foo_bar__Ljava_lang_String_2Ljava_lang_Object_2</span>
  <span class="token punctuation">(</span><span class="token class-name">JNIEnv</span> <span class="token operator">*</span><span class="token punctuation">,</span> jobject<span class="token punctuation">,</span> jstring<span class="token punctuation">,</span> jobject<span class="token punctuation">)</span><span class="token punctuation">;</span>

#ifdef __cplusplus
<span class="token punctuation">}</span>
#endif
#endif
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我简单讲解一下该命名规范。</p><p>首先，native 方法对应的 C 函数都需要以Java_为前缀，之后跟着完整的包名和方法名。由于 C 函数名不支持/字符，因此我们需要将/转换为_，而原本方法名中的_符号，则需要转换为_1。</p><p>举个例子，org.example包下Foo类的foo方法，Java 虚拟机会将其自动链接至名为Java_org_example_Foo_foo的 C 函数中。</p><p>当某个类出现重载的 native 方法时，Java 虚拟机还会将参数类型纳入自动链接对象的考虑范围之中。具体的做法便是在前面 C 函数名的基础上，追加__以及方法描述符作为后缀。</p><p>方法描述符的特殊符号同样会被替换掉，如引用类型所使用的;会被替换为_2，数组类型所使用的[会被替换为_3。</p><p>基于此命名规范，你可以手动拼凑上述代码中，Foo类的两个bar方法所能自动链接的 C 函数名，并用javac -h命令所生成的结果来验证一下。</p><p>第二种链接方式则是在 C 代码中主动链接。</p><p>这种链接方式对 C 函数名没有要求。通常我们会使用一个名为registerNatives的 native 方法，并按照第一种链接方式定义所能自动链接的 C 函数。在该 C 函数中，我们将手动链接该类的其他 native 方法。</p><p>举个例子，Object类便拥有一个registerNatives方法，所对应的 C 代码如下所示：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 注：Object类的registerNatives方法的实现位于java.base模块里的C代码中</span>
<span class="token keyword">static</span> <span class="token class-name">JNINativeMethod</span> methods<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">{</span><span class="token string">&quot;hashCode&quot;</span><span class="token punctuation">,</span>    <span class="token string">&quot;()I&quot;</span><span class="token punctuation">,</span>                    <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token class-name">JVM_IHashCode</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token string">&quot;wait&quot;</span><span class="token punctuation">,</span>        <span class="token string">&quot;(J)V&quot;</span><span class="token punctuation">,</span>                   <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token class-name">JVM_MonitorWait</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token string">&quot;notify&quot;</span><span class="token punctuation">,</span>      <span class="token string">&quot;()V&quot;</span><span class="token punctuation">,</span>                    <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token class-name">JVM_MonitorNotify</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token string">&quot;notifyAll&quot;</span><span class="token punctuation">,</span>   <span class="token string">&quot;()V&quot;</span><span class="token punctuation">,</span>                    <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token class-name">JVM_MonitorNotifyAll</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token string">&quot;clone&quot;</span><span class="token punctuation">,</span>       <span class="token string">&quot;()Ljava/lang/Object;&quot;</span><span class="token punctuation">,</span>   <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token class-name">JVM_Clone</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token constant">JNIEXPORT</span> <span class="token keyword">void</span> <span class="token constant">JNICALL</span>
<span class="token class-name">Java_java_lang_Object_registerNatives</span><span class="token punctuation">(</span><span class="token class-name">JNIEnv</span> <span class="token operator">*</span>env<span class="token punctuation">,</span> jclass cls<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">(</span><span class="token operator">*</span>env<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token class-name">RegisterNatives</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> cls<span class="token punctuation">,</span>
                            methods<span class="token punctuation">,</span> <span class="token function">sizeof</span><span class="token punctuation">(</span>methods<span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">sizeof</span><span class="token punctuation">(</span>methods<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以看到，上面这段代码中的 C 函数将调用RegisterNatives API，注册Object类中其他 native 方法所要链接的 C 函数。并且，这些 C 函数的名字并不符合默认命名规则。</p><p>当使用第二种方式进行链接时，我们需要在其他 native 方法被调用之前完成链接工作。因此，我们往往会在类的初始化方法里调用该registerNatives方法。具体示例如下所示：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Object</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">registerNatives</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token function">registerNatives</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面我们采用第一种链接方式，并且实现其中的bar(String, Object)方法。如下所示：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// foo.c</span>
#include <span class="token generics"><span class="token punctuation">&lt;</span>stdio<span class="token punctuation">.</span>h<span class="token punctuation">&gt;</span></span>
#include <span class="token string">&quot;org_example_Foo.h&quot;</span>

<span class="token constant">JNIEXPORT</span> <span class="token keyword">void</span> <span class="token constant">JNICALL</span> <span class="token class-name">Java_org_example_Foo_bar__Ljava_lang_String_2Ljava_lang_Object_2</span>
  <span class="token punctuation">(</span><span class="token class-name">JNIEnv</span> <span class="token operator">*</span>env<span class="token punctuation">,</span> jobject thisObject<span class="token punctuation">,</span> jstring str<span class="token punctuation">,</span> jobject obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Hello, World\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，我们可以通过 gcc 命令将其编译成为动态链接库：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code># 该命令仅适用于macOS
$ gcc <span class="token operator">-</span><span class="token class-name">I</span>$<span class="token constant">JAVA_HOME</span><span class="token operator">/</span>include <span class="token operator">-</span><span class="token class-name">I</span>$<span class="token constant">JAVA_HOME</span><span class="token operator">/</span>include<span class="token operator">/</span>darwin <span class="token operator">-</span>o libfoo<span class="token punctuation">.</span>dylib <span class="token operator">-</span>shared foo<span class="token punctuation">.</span>c
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>`,31),k={href:"http://xn--fhqs00h.so",target:"_blank",rel:"noopener noreferrer"},d=a(`<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">org<span class="token punctuation">.</span>example</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">long</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token class-name">Object</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0xDEADBEEF</span><span class="token punctuation">;</span>

  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">loadLibrary</span><span class="token punctuation">(</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">UnsatisfiedLinkError</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果libfoo.dylib不在当前路径下，我们可以在启动 Java 虚拟机时配置java.library.path参数，使其指向包含libfoo.dylib的文件夹。具体命令如下所示：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>$ java <span class="token operator">-</span><span class="token class-name">Djava</span><span class="token punctuation">.</span>library<span class="token punctuation">.</span>path<span class="token operator">=</span><span class="token operator">/</span><span class="token constant">PATH</span><span class="token operator">/</span><span class="token constant">TO</span><span class="token operator">/</span><span class="token constant">DIR</span><span class="token operator">/</span><span class="token constant">CONTAINING</span><span class="token operator">/</span>libfoo<span class="token punctuation">.</span>dylib <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>example<span class="token punctuation">.</span></span>Foo</span>
<span class="token class-name">Hello</span><span class="token punctuation">,</span> <span class="token class-name">World</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>JNI 的 API</strong></p><p>在 C 代码中，我们也可以使用 Java 的语言特性，如 instanceof 测试等。这些功能都是通过特殊的 JNI 函数（JNI Functions）来实现的。</p><p>Java 虚拟机会将所有 JNI 函数的函数指针聚合到一个名为JNIEnv的数据结构之中。</p><p>这是一个线程私有的数据结构。Java 虚拟机会为每个线程创建一个JNIEnv，并规定 C 代码不能将当前线程的JNIEnv共享给其他线程，否则 JNI 函数的正确性将无法保证。</p><p>这么设计的原因主要有两个。一是给 JNI 函数提供一个单独命名空间。二是允许 Java 虚拟机通过更改函数指针替换 JNI 函数的具体实现，例如从附带参数类型检测的慢速版本，切换至不做参数类型检测的快速版本。</p><p>在 HotSpot 虚拟机中，JNIEnv被内嵌至 Java 线程的数据结构之中。部分虚拟机代码甚至会从JNIEnv的地址倒推出 Java 线程的地址。因此，如果在其他线程中使用当前线程的JNIEnv，会使这部分代码错误识别当前线程。</p><p>JNI 会将 Java 层面的基本类型以及引用类型映射为另一套可供 C 代码使用的数据结构。其中，基本类型的对应关系如下表所示：</p><figure><img src="`+i+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>引用类型对应的数据结构之间也存在着继承关系，具体如下所示：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>jobject
<span class="token operator">|</span><span class="token operator">-</span> jclass <span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>Class</span> objects<span class="token punctuation">)</span>
<span class="token operator">|</span><span class="token operator">-</span> jstring <span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>String</span> objects<span class="token punctuation">)</span>
<span class="token operator">|</span><span class="token operator">-</span> jthrowable <span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>Throwable</span> objects<span class="token punctuation">)</span>
<span class="token operator">|</span><span class="token operator">-</span> jarray <span class="token punctuation">(</span>arrays<span class="token punctuation">)</span>
   <span class="token operator">|</span><span class="token operator">-</span> jobjectArray <span class="token punctuation">(</span>object arrays<span class="token punctuation">)</span>
   <span class="token operator">|</span><span class="token operator">-</span> jbooleanArray <span class="token punctuation">(</span><span class="token keyword">boolean</span> arrays<span class="token punctuation">)</span>
   <span class="token operator">|</span><span class="token operator">-</span> jbyteArray <span class="token punctuation">(</span><span class="token keyword">byte</span> arrays<span class="token punctuation">)</span>
   <span class="token operator">|</span><span class="token operator">-</span> jcharArray <span class="token punctuation">(</span><span class="token keyword">char</span> arrays<span class="token punctuation">)</span>
   <span class="token operator">|</span><span class="token operator">-</span> jshortArray <span class="token punctuation">(</span><span class="token keyword">short</span> arrays<span class="token punctuation">)</span>
   <span class="token operator">|</span><span class="token operator">-</span> jintArray <span class="token punctuation">(</span><span class="token keyword">int</span> arrays<span class="token punctuation">)</span>
   <span class="token operator">|</span><span class="token operator">-</span> jlongArray <span class="token punctuation">(</span><span class="token keyword">long</span> arrays<span class="token punctuation">)</span>
   <span class="token operator">|</span><span class="token operator">-</span> jfloatArray <span class="token punctuation">(</span><span class="token keyword">float</span> arrays<span class="token punctuation">)</span>
   <span class="token operator">|</span><span class="token operator">-</span> jdoubleArray <span class="token punctuation">(</span><span class="token keyword">double</span> arrays<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们回头看看Foo类 3 个 native 方法对应的 C 函数的参数。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token constant">JNIEXPORT</span> <span class="token keyword">void</span> <span class="token constant">JNICALL</span> <span class="token class-name">Java_org_example_Foo_foo</span>
  <span class="token punctuation">(</span><span class="token class-name">JNIEnv</span> <span class="token operator">*</span><span class="token punctuation">,</span> jclass<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token constant">JNIEXPORT</span> <span class="token keyword">void</span> <span class="token constant">JNICALL</span> <span class="token class-name">Java_org_example_Foo_bar__IJ</span>
  <span class="token punctuation">(</span><span class="token class-name">JNIEnv</span> <span class="token operator">*</span><span class="token punctuation">,</span> jobject<span class="token punctuation">,</span> jint<span class="token punctuation">,</span> jlong<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token constant">JNIEXPORT</span> <span class="token keyword">void</span> <span class="token constant">JNICALL</span> <span class="token class-name">Java_org_example_Foo_bar__Ljava_lang_String_2Ljava_lang_Object_2</span>  <span class="token punctuation">(</span><span class="token class-name">JNIEnv</span> <span class="token operator">*</span><span class="token punctuation">,</span> jobject<span class="token punctuation">,</span> jstring<span class="token punctuation">,</span> jobject<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>静态 native 方法foo将接收两个参数，分别为存放 JNI 函数的JNIEnv指针，以及一个jclass参数，用来指代定义该 native 方法的类，即Foo类。</p><p>两个实例 native 方法bar的第二个参数则是jobject类型的，用来指代该 native 方法的调用者，也就是Foo类的实例。</p><p>如果 native 方法声明了参数，那么对应的 C 函数将接收这些参数。在我们的例子中，第一个bar方法声明了 int 型和 long 型的参数，对应的 C 函数则接收 jint 和 jlong 类型的参数；第二个bar方法声明了 String 类型和 Object 类型的参数，对应的 C 函数则接收 jstring 和 jobject 类型的参数。</p><p>下面，我们继续修改上一小节中的foo.c，并在 C 代码中获取Foo类实例的i字段。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// foo.c</span>
#include <span class="token generics"><span class="token punctuation">&lt;</span>stdio<span class="token punctuation">.</span>h<span class="token punctuation">&gt;</span></span>
#include <span class="token string">&quot;org_example_Foo.h&quot;</span>

<span class="token constant">JNIEXPORT</span> <span class="token keyword">void</span> <span class="token constant">JNICALL</span> <span class="token class-name">Java_org_example_Foo_bar__Ljava_lang_String_2Ljava_lang_Object_2</span>
  <span class="token punctuation">(</span><span class="token class-name">JNIEnv</span> <span class="token operator">*</span>env<span class="token punctuation">,</span> jobject thisObject<span class="token punctuation">,</span> jstring str<span class="token punctuation">,</span> jobject obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  jclass cls <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>env<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token class-name">GetObjectClass</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> thisObject<span class="token punctuation">)</span><span class="token punctuation">;</span>
  jfieldID fieldID <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>env<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token class-name">GetFieldID</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> cls<span class="token punctuation">,</span> <span class="token string">&quot;i&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;I&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  jint value <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>env<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token class-name">GetIntField</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> thisObject<span class="token punctuation">,</span> fieldID<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Hello, World 0x%x\\n&quot;</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以看到，在 JNI 中访问字段类似于反射 API：我们首先需要通过类实例获得FieldID，然后再通过FieldID获得某个实例中该字段的值。不过，与 Java 代码相比，上述代码貌似不用处理异常。事实果真如此吗？</p><p>下面我就尝试获取了不存在的字段j，运行结果如下所示：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>$ java <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>example<span class="token punctuation">.</span></span>Foo</span>
<span class="token class-name">Hello</span><span class="token punctuation">,</span> <span class="token class-name">World</span> <span class="token number">0x5</span>
<span class="token class-name">Exception</span> in thread <span class="token string">&quot;main&quot;</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>NoSuchFieldError</span><span class="token operator">:</span> j
 at <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>example<span class="token punctuation">.</span></span>Foo</span><span class="token punctuation">.</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token class-name">Native</span> <span class="token class-name">Method</span><span class="token punctuation">)</span>
 at <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>example<span class="token punctuation">.</span></span>Foo</span><span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">Foo</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">20</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以看到，printf语句照常执行并打印出Hello, World 0x5，但这个数值明显是错误的。当从 C 函数返回至 main 方法时，Java 虚拟机又会抛出NoSuchFieldError异常。</p><p>实际上，当调用 JNI 函数时，Java 虚拟机便已生成异常实例，并缓存在内存中的某个位置。与 Java 编程不一样的是，它并不会显式地跳转至异常处理器或者调用者中，而是继续执行接下来的 C 代码。</p><p>因此，当从可能触发异常的 JNI 函数返回时，我们需要通过 JNI 函数ExceptionOccurred检查是否发生了异常，并且作出相应的处理。如果无须抛出该异常，那么我们需要通过 JNI 函数ExceptionClear显式地清空已缓存的异常。</p><p>具体示例如下所示（为了控制代码篇幅，我仅在第一个GetFieldID后检查异常以及清空异常）：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// foo.c</span>
#include <span class="token generics"><span class="token punctuation">&lt;</span>stdio<span class="token punctuation">.</span>h<span class="token punctuation">&gt;</span></span>
#include <span class="token string">&quot;org_example_Foo.h&quot;</span>

<span class="token constant">JNIEXPORT</span> <span class="token keyword">void</span> <span class="token constant">JNICALL</span> <span class="token class-name">Java_org_example_Foo_bar__Ljava_lang_String_2Ljava_lang_Object_2</span>
  <span class="token punctuation">(</span><span class="token class-name">JNIEnv</span> <span class="token operator">*</span>env<span class="token punctuation">,</span> jobject thisObject<span class="token punctuation">,</span> jstring str<span class="token punctuation">,</span> jobject obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  jclass cls <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>env<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token class-name">GetObjectClass</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> thisObject<span class="token punctuation">)</span><span class="token punctuation">;</span>
  jfieldID fieldID <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>env<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token class-name">GetFieldID</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> cls<span class="token punctuation">,</span> <span class="token string">&quot;j&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;I&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>env<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token class-name">ExceptionOccurred</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Exception!\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">(</span><span class="token operator">*</span>env<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token class-name">ExceptionClear</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  fieldID <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>env<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token class-name">GetFieldID</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> cls<span class="token punctuation">,</span> <span class="token string">&quot;i&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;I&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  jint value <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>env<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token class-name">GetIntField</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> thisObject<span class="token punctuation">,</span> fieldID<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// we should put an exception guard here as well.</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Hello, World 0x%x\\n&quot;</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>局部引用与全局引用</strong></p><p>在 C 代码中，我们可以访问所传入的引用类型参数，也可以通过 JNI 函数创建新的 Java 对象。</p><p>这些 Java 对象显然也会受到垃圾回收器的影响。因此，Java 虚拟机需要一种机制，来告知垃圾回收算法，不要回收这些 C 代码中可能引用到的 Java 对象。</p><p>这种机制便是 JNI 的局部引用（Local Reference）和全局引用（Global Reference）。垃圾回收算法会将被这两种引用指向的对象标记为不可回收。</p><p>事实上，无论是传入的引用类型参数，还是通过 JNI 函数（除NewGlobalRef及NewWeakGlobalRef之外）返回的引用类型对象，都属于局部引用。</p><p>不过，一旦从 C 函数中返回至 Java 方法之中，那么局部引用将失效。也就是说，垃圾回收器在标记垃圾时不再考虑这些局部引用。</p><p>这就意味着，我们不能缓存局部引用，以供另一 C 线程或下一次 native 方法调用时使用。</p><p>对于这种应用场景，我们需要借助 JNI 函数NewGlobalRef，将该局部引用转换为全局引用，以确保其指向的 Java 对象不会被垃圾回收。</p><p>相应的，我们还可以通过 JNI 函数DeleteGlobalRef来消除全局引用，以便回收被全局引用指向的 Java 对象。</p><p>此外，当 C 函数运行时间极其长时，我们也应该考虑通过 JNI 函数DeleteLocalRef，消除不再使用的局部引用，以便回收被引用的 Java 对象。</p><p>另一方面，由于垃圾回收器可能会移动对象在内存中的位置，因此 Java 虚拟机需要另一种机制，来保证局部引用或者全局引用将正确地指向移动过后的对象。</p><p>HotSpot 虚拟机是通过句柄（handle）来完成上述需求的。这里句柄指的是内存中 Java 对象的指针的指针。当发生垃圾回收时，如果 Java 对象被移动了，那么句柄指向的指针值也将发生变动，但句柄本身保持不变。</p><p>实际上，无论是局部引用还是全局引用，都是句柄。其中，局部引用所对应的句柄有两种存储方式，一是在本地方法栈帧中，主要用于存放 C 函数所接收的来自 Java 层面的引用类型参数；另一种则是线程私有的句柄块，主要用于存放 C 函数运行过程中创建的局部引用。</p><p>当从 C 函数返回至 Java 方法时，本地方法栈帧中的句柄将会被自动清除。而线程私有句柄块则需要由 Java 虚拟机显式清理。</p><p>进入 C 函数时对引用类型参数的句柄化，和调整参数位置（C 调用和 Java 调用传参的方式不一样），以及从 C 函数返回时清理线程私有句柄块，共同造就了 JNI 调用的额外性能开销（具体可参考该 stackoverflow 上的回答）。</p><p><strong>总结与实践</strong></p><p>今天我介绍了 JNI 的运行机制。</p><p>Java 中的 native 方法的链接方式主要有两种。一是按照 JNI 的默认规范命名所要链接的 C 函数，并依赖于 Java 虚拟机自动链接。另一种则是在 C 代码中主动链接。</p><p>JNI 提供了一系列 API 来允许 C 代码使用 Java 语言特性。这些 API 不仅使用了特殊的数据结构来表示 Java 类，还拥有特殊的异常处理模式。</p><p>JNI 中的引用可分为局部引用和全局引用。这两者都可以阻止垃圾回收器回收被引用的 Java 对象。不同的是，局部引用在 native 方法调用返回之后便会失效。传入参数以及大部分 JNI API 函数的返回值都属于局部引用。</p><p>今天的实践环节，请阅读该文档中的 Performance pitfalls 以及 Correctness pitfalls 两节。</p>`,49);function v(m,b){const p=e("ExternalLinkIcon");return o(),c("div",null,[r,s("p",null,[n("这里需要注意的是，动态链接库的名字须以lib为前缀，以.dylib(或 Linux "),s("a",k,[n("上的.so"),l(p)]),n('）为扩展名。在 Java 程序中，我们可以通过System.loadLibrary("foo")方法来加载libfoo.dylib，如下述代码所示：')]),d])}const _=t(u,[["render",v],["__file","S32-JNI运行机制.html.vue"]]);export{_ as default};
