import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as a,d as t}from"./app-cdabc73c.js";const p="/assets/051a8aa336a0d8a547a610cb0d296e55-135ce853.jpg",e="/assets/ea47e5ba68cbf0f30a44286b7b401cff-ad48939e.jpg",c={},o=t('<h1 id="_41-服务接口-如何搭建沟通桥梁" tabindex="-1"><a class="header-anchor" href="#_41-服务接口-如何搭建沟通桥梁" aria-hidden="true">#</a> 41 | 服务接口：如何搭建沟通桥梁？</h1><p>你好，我是 LMOS。</p><p>一路走来，咱们的 Cosmos 系统已经有内存管理，进程、文件、I/O 了，这些重要的组件已经建立了，也就是说它们可以向应用程序提供服务了。</p><p>但就好像你去各政府部门办理业务证件一样，首先是前台工作人员接待你，对你的业务需求进行初级预判，然后后台人员进行审核并进行业务办理，最后由前台人员回复，并且给你开好相关业务证件。</p><p>今天，我们就来实现 Cosmos 下的“前台工作人员”，我们称之为<mark>服务接口</mark>，也可以说是 Cosmos 的 API。代码你可以从这里下载。</p><h2 id="服务接口的结构" tabindex="-1"><a class="header-anchor" href="#服务接口的结构" aria-hidden="true">#</a> 服务接口的结构</h2><p>我们先来设计一下服务接口的整体结构，即 Cosmos 的 API 结构。因为 Cosmos 的 <mark>API</mark> 数量很多，所以我们先来分个类，它们分别是<mark>进程类</mark>、<mark>内存类</mark>、<mark>文件类</mark>和<mark>时间类</mark>的 API。这些 API 还会被<mark>上层 C 库</mark>封装，方便应用程序调用。</p><p>为了帮你理解它们之间的关系，我为你准备了一幅图，如下所示。</p><img src="'+p+`" alt="img" style="zoom:15%;"><p>API框架</p><p>结合上图可以看到，我们的应用程序库分为时间库、进程库、内存库、文件库这几种类型。</p><p>通常情况下，应用程序中调用的是一些<mark>库函数</mark>。库函数是对<mark>系统服务</mark>的封装，</p><ol><li>有的库函数是直接调用相应的系统服务；</li><li>而有的库函数为了完成特定的功能，则调用了几个相应的系统服务；</li><li>还有一些库函数完成的功能不需要调用相应的系统调用，这时前台接待人员也就是“库函数”，可以自行处理。</li></ol><h2 id="如何进入内核" tabindex="-1"><a class="header-anchor" href="#如何进入内核" aria-hidden="true">#</a> 如何进入内核</h2><p>由上图我们还可以看出，应用程序和库函数都在<strong>用户空间</strong>中，而系统服务却在<strong>内核空间</strong>中，想要让代码控制流从用户空间进入到内核空间中，如何穿过 CPU 保护模式的“铜墙铁壁”才是关键。下面我们就一起来探索这个问题。</p><h3 id="_1-软中断指令" tabindex="-1"><a class="header-anchor" href="#_1-软中断指令" aria-hidden="true">#</a> 1）软中断指令</h3><p>请你回忆下，CPU 长模式下如何处理中断的（不熟悉的可以回看第 5 课和第 13 课）？</p><p>设备向 CPU 发送一个<mark>中断信号</mark>，CPU 接受到这个电子信号后，在允许响应中断的情况下，就会中断当前正在运行的程序，自动切换到<mark>相应的 CPU R0 特权级</mark>，并跳转到<mark>中断门描述符</mark>中相应的地址上运行<mark>中断处理代码</mark>。</p><p>当然，这里的中断处理代码就是<mark>操作系统内核的代码</mark>，这样 CPU 的控制权就转到操作系统内核的手中了。</p><p>其实，应用软件也可以给 CPU 发送中断。现代 CPU 设计时都会设计这样一条指令，<strong>一旦执行该指令</strong>，CPU 就要中断当前正在运行的程序，自动跳转到相应的固定地址上运行代码。当然这里的代码也就是操作系统内核的代码，就这样 CPU 的控制权同样会回到操作系统内核的手中。</p><p>因为这条指令模拟了中断的电子信号，所以称为==<strong>软中断指令</strong><mark>。在 x86 CPU 上这条指令是 int 指令。例如 int255。int 指令后面需要跟一个常数，这个常数表示 CPU 从中断表描述符表中取得</mark><strong>第几个中断描述符</strong>==进入内核。</p><h4 id="传递参数-寄存器-用户栈" tabindex="-1"><a class="header-anchor" href="#传递参数-寄存器-用户栈" aria-hidden="true">#</a> 传递参数(寄存器/用户栈)</h4><p>虽然 int 指令提供了应用程序进入操作系统内核函数的底层机制，但是我们还需要解决参数传递的问题。</p><p>因为你必须要告诉操作系统你要干什么，系统才能做出相应的反馈。比如你要分配内存，分配多大的内存，这些信息<strong>必须要以参数的形式</strong>传递给操作系统内核。</p><p>因为应用程序运行在用户空间时，用的是用户栈，当它切换到内核空间时，用的是内核栈。所以参数的传递，就需要硬性地规定一下，要么所有的参数都用<mark>寄存器</mark>传递，要么所有的参数都保存在<mark>用户栈</mark>中。</p><p>显然，第一种用寄存器传递所有参数的方法要简单得多，事实上有很多操作系统就是用寄存器传递参数的。</p><p>我们使用 RBX、RCX、RDX、RDI、RSI 这 5 个寄存器来传递参数，事实上一个系统服务接口函数不会超过 5 个参数，所以这是足够的。而 RAX 寄存器中保存着一个整数，称为**<mark>系统服务号</mark><strong>。在系统服务分发器中，会根据这个系统服务号</strong>调用相应的函数**。</p><p>因为 C 编译器不能处理这种参数传递形式，另外 C 编译器也不支持 int 指令，所以要用汇编代码来处理这种问题。</p><p>下面我们来建立一个 cosmos/include/libinc/<code>lapinrentry.h</code> 文件，在这里写上后面的代码。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//传递一个参数所用的宏</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">API_ENTRY_PARE1</span><span class="token expression"><span class="token punctuation">(</span>intnr<span class="token punctuation">,</span>rets<span class="token punctuation">,</span>pval1<span class="token punctuation">)</span> </span><span class="token punctuation">\\</span>
<span class="token expression">__asm__ <span class="token function">__volatile__</span><span class="token punctuation">(</span></span><span class="token punctuation">\\</span>
         <span class="token string">&quot;movq %[inr],%%rax\\n\\t&quot;</span><span class="token expression">\\</span><span class="token comment">//系统服务号</span></span>
         <span class="token string">&quot;movq %[prv1],%%rbx\\n\\t&quot;</span>\\<span class="token comment">//第一个参数</span>
         <span class="token string">&quot;int $255 \\n\\t&quot;</span>\\<span class="token comment">//触发中断</span>
         <span class="token string">&quot;movq %%rax,%[retval] \\n\\t&quot;</span>\\<span class="token comment">//处理返回结果</span>
         <span class="token operator">:</span><span class="token punctuation">[</span>retval<span class="token punctuation">]</span> <span class="token string">&quot;=r&quot;</span> <span class="token punctuation">(</span>rets<span class="token punctuation">)</span>\\
         <span class="token operator">:</span><span class="token punctuation">[</span>inr<span class="token punctuation">]</span> <span class="token string">&quot;r&quot;</span> <span class="token punctuation">(</span>intnr<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">[</span>prv1<span class="token punctuation">]</span><span class="token string">&quot;r&quot;</span> <span class="token punctuation">(</span>pval1<span class="token punctuation">)</span>\\
         <span class="token operator">:</span><span class="token string">&quot;rax&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;rbx&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;cc&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;memory&quot;</span>\\
    <span class="token punctuation">)</span>
<span class="token comment">//传递四个参数所用的宏    </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">API_ENTRY_PARE4</span><span class="token expression"><span class="token punctuation">(</span>intnr<span class="token punctuation">,</span>rets<span class="token punctuation">,</span>pval1<span class="token punctuation">,</span>pval2<span class="token punctuation">,</span>pval3<span class="token punctuation">,</span>pval4<span class="token punctuation">)</span> </span><span class="token punctuation">\\</span>
<span class="token expression">__asm__ <span class="token function">__volatile__</span><span class="token punctuation">(</span></span><span class="token punctuation">\\</span>
         <span class="token string">&quot;movq %[inr],%%rax \\n\\t&quot;</span><span class="token expression">\\</span><span class="token comment">//系统服务号</span></span>
         <span class="token string">&quot;movq %[prv1],%%rbx \\n\\t&quot;</span>\\<span class="token comment">//第一个参数</span>
         <span class="token string">&quot;movq %[prv2],%%rcx \\n\\t&quot;</span>\\<span class="token comment">//第二个参数</span>
         <span class="token string">&quot;movq %[prv3],%%rdx \\n\\t&quot;</span>\\<span class="token comment">//第三个参数</span>
         <span class="token string">&quot;movq %[prv4],%%rsi \\n\\t&quot;</span>\\<span class="token comment">//第四个参数</span>
         <span class="token string">&quot;int $255 \\n\\t&quot;</span>\\<span class="token comment">//触发中断</span>
         <span class="token string">&quot;movq %%rax,%[retval] \\n\\t&quot;</span>\\<span class="token comment">//处理返回结果</span>
         <span class="token operator">:</span><span class="token punctuation">[</span>retval<span class="token punctuation">]</span> <span class="token string">&quot;=r&quot;</span> <span class="token punctuation">(</span>rets<span class="token punctuation">)</span>\\
         <span class="token operator">:</span><span class="token punctuation">[</span>inr<span class="token punctuation">]</span> <span class="token string">&quot;r&quot;</span> <span class="token punctuation">(</span>intnr<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">[</span>prv1<span class="token punctuation">]</span><span class="token string">&quot;g&quot;</span> <span class="token punctuation">(</span>pval1<span class="token punctuation">)</span><span class="token punctuation">,</span>\\
         <span class="token punctuation">[</span>prv2<span class="token punctuation">]</span> <span class="token string">&quot;g&quot;</span> <span class="token punctuation">(</span>pval2<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">[</span>prv3<span class="token punctuation">]</span><span class="token string">&quot;g&quot;</span> <span class="token punctuation">(</span>pval3<span class="token punctuation">)</span><span class="token punctuation">,</span>\\
         <span class="token punctuation">[</span>prv4<span class="token punctuation">]</span> <span class="token string">&quot;g&quot;</span> <span class="token punctuation">(</span>pval4<span class="token punctuation">)</span>\\
         <span class="token operator">:</span><span class="token string">&quot;rax&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;rbx&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;rcx&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;rdx&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;rsi&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;cc&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;memory&quot;</span>\\
    <span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中只展示了两个宏。其实是有四个，在代码文件中我已经帮你写好了，主要功能是用来解决传递参数和触发中断问题，并且还需要处理系统返回的结果。这些都是用 C 语言中嵌入汇编代码的方式来实现的。</p><p>下面我们用它来写一个系统服务接口，代码如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//请求分配内存服务</span>
<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">api_mallocblk</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> blksz<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">void</span><span class="token operator">*</span> retadr<span class="token punctuation">;</span>
    <span class="token comment">//把系统服务号，返回变量和请求分配的内存大小</span>
    <span class="token function">API_ENTRY_PARE1</span><span class="token punctuation">(</span>INR_MM_ALLOC<span class="token punctuation">,</span>retadr<span class="token punctuation">,</span>blksz<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> retadr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="内存管理模块" tabindex="-1"><a class="header-anchor" href="#内存管理模块" aria-hidden="true">#</a> 内存管理模块</h4><p>上述代码可以被库函数调用，也可以由应用程序直接调用，它用 API_ENTRY_PARE1 宏传递参数和触发中断进入 Cosmos 内核，<strong>最终将由<mark>内存管理模块</mark>相应分配内存服务的请求</strong>。</p><p>到这里，我们已经解决了如何进入内核和传递参数的问题了，下面我们看看进入内核之后要做些什么。</p><h3 id="_2-系统服务分发器" tabindex="-1"><a class="header-anchor" href="#_2-系统服务分发器" aria-hidden="true">#</a> 2）系统服务分发器</h3><p>由于执行了 int 指令后，CPU 会停止当前代码执行，转而执行对应的中断处理代码。再加上随着系统功能的增加，系统服务也会增加，但是中断的数量却是有限的，所以我们不能每个系统服务都占用一个中断描述符。</p><p>那这个问题怎么解决呢？其实我们可以只使用一个中断描述符，然后通过系统服务号来区分是哪个服务。这其实就是**<mark>系统服务器分发器</mark>**完成的工作。</p><h4 id="实现系统服务分发器" tabindex="-1"><a class="header-anchor" href="#实现系统服务分发器" aria-hidden="true">#</a> 实现系统服务分发器</h4><p>其实系统服务分发器就是一个函数，它由中断处理代码调用，在它的内部根据系统服务号来调用相应的服务。下面我们一起在 cosmos/kernel/<code>krlservice.c</code> 文件中写好这个函数，代码如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token class-name">sysstus_t</span> <span class="token function">krlservice</span><span class="token punctuation">(</span><span class="token class-name">uint_t</span> inr<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> sframe<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>INR_MAX <span class="token operator">&lt;=</span> inr<span class="token punctuation">)</span><span class="token comment">//判断服务号是否大于最大服务号</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> SYSSTUSERR<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> osservicetab<span class="token punctuation">[</span>inr<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//判断是否有服务接口函数</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> SYSSTUSERR<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> osservicetab<span class="token punctuation">[</span>inr<span class="token punctuation">]</span><span class="token punctuation">(</span>inr<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">stkparame_t</span><span class="token operator">*</span><span class="token punctuation">)</span>sframe<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用对应的服务接口函数</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的系统服务分发器函数现在就写好了。其实逻辑非常简单，就是先对服务号进行判断，如果大于系统中最大的服务号，就返回一个错误状态表示服务失败。然后判断是否有服务接口函数。最后这两个检查通过之后，就可以调用相应的服务接口了。</p><h4 id="中断处理框架函数" tabindex="-1"><a class="header-anchor" href="#中断处理框架函数" aria-hidden="true">#</a> 中断处理框架函数</h4><p>那么 krlservice 函数是谁调用的呢？答案是<mark>中断处理的框架函数</mark>，如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token class-name">sysstus_t</span> <span class="token function">hal_syscl_allocator</span><span class="token punctuation">(</span><span class="token class-name">uint_t</span> inr<span class="token punctuation">,</span><span class="token keyword">void</span><span class="token operator">*</span> krnlsframp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">krlservice</span><span class="token punctuation">(</span>inr<span class="token punctuation">,</span>krnlsframp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>hal_syscl_allocator 函数则是由我们系统中断处理的第一层汇编代码调用的，这个汇编代码主要是将进程的用户态 CPU 寄存器保存在内核栈中，代码如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//cosmos/include/halinc/kernel.inc</span>
<span class="token operator">%</span>macro  EXI_SCALL  <span class="token number">0</span>
  push rbx<span class="token comment">//保存通用寄存器到内核栈</span>
  push rcx
  push rdx
  push rbp
  push rsi
  push rdi
    <span class="token comment">//删除了一些代码</span>
  mov  rdi<span class="token punctuation">,</span> rax <span class="token comment">//处理hal_syscl_allocator函数第一个参数inr</span>
  mov rsi<span class="token punctuation">,</span> rsp <span class="token comment">//处理hal_syscl_allocator函数第二个参数krnlsframp</span>
  call hal_syscl_allocator <span class="token comment">//调用hal_syscl_allocator函数</span>
  <span class="token comment">//删除了一些代码</span>
  pop rdi
  pop rsi
  pop rbp
  pop rdx
  pop rcx
  pop rbx<span class="token comment">//从内核栈中恢复通用寄存器</span>
  iretq <span class="token comment">//中断返回</span>
<span class="token operator">%</span>endmacro
<span class="token comment">//cosmos/hal/x86/kernel.asm</span>
exi_sys_call<span class="token operator">:</span>
  EXI_SCALL
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中的 exi_sys_call 标号的地址保存在第 255 个中断门描述符中。这样执行了 int $255 之后，CPU 就会自动跳转到 exi_sys_call 标号处运行，从而进入内核开始运行，最终调用 krlservice 函数，开始执行系统服务。</p><h3 id="_3-系统服务表" tabindex="-1"><a class="header-anchor" href="#_3-系统服务表" aria-hidden="true">#</a> 3）系统服务表</h3><p>从上面的代码可以看出，我们不可能<mark>每个系统服务</mark>都占用<mark>一个中断描述符</mark>，所以要设计一个叫做<mark>系统服务<strong>表</strong><mark>的东西，用来存放</mark>各种系统服务的<strong>入口函数</strong></mark>，它能在 krlservice 函数中根据服务号，调用相应系统服务表中相应的服务入口函数。怎么实现系统服务表呢？如果你想到函数指针数组，这说明你和我想到一块了。</p><p>下面我们一起来定义这个函数指针数组，它是全局的，我们放在 cosmos/kernel/<code>krlglobal.c</code> 中，代码如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">s_STKPARAME</span>
<span class="token punctuation">{</span>
    <span class="token class-name">u64_t</span> gs<span class="token punctuation">;</span>
    <span class="token class-name">u64_t</span> fs<span class="token punctuation">;</span>
    <span class="token class-name">u64_t</span> es<span class="token punctuation">;</span>
    <span class="token class-name">u64_t</span> ds<span class="token punctuation">;</span>
    <span class="token class-name">u64_t</span> r15<span class="token punctuation">;</span>
    <span class="token class-name">u64_t</span> r14<span class="token punctuation">;</span>
    <span class="token class-name">u64_t</span> r13<span class="token punctuation">;</span>
    <span class="token class-name">u64_t</span> r12<span class="token punctuation">;</span>
    <span class="token class-name">u64_t</span> r11<span class="token punctuation">;</span>
    <span class="token class-name">u64_t</span> r10<span class="token punctuation">;</span>
    <span class="token class-name">u64_t</span> r9<span class="token punctuation">;</span>
    <span class="token class-name">u64_t</span> r8<span class="token punctuation">;</span>
    <span class="token class-name">u64_t</span> parmv5<span class="token punctuation">;</span><span class="token comment">//rdi;</span>
    <span class="token class-name">u64_t</span> parmv4<span class="token punctuation">;</span><span class="token comment">//rsi;</span>
    <span class="token class-name">u64_t</span> rbp<span class="token punctuation">;</span>
    <span class="token class-name">u64_t</span> parmv3<span class="token punctuation">;</span><span class="token comment">//rdx;</span>
    <span class="token class-name">u64_t</span> parmv2<span class="token punctuation">;</span><span class="token comment">//rcx;</span>
    <span class="token class-name">u64_t</span> parmv1<span class="token punctuation">;</span><span class="token comment">//rbx;</span>
    <span class="token class-name">u64_t</span> rvsrip<span class="token punctuation">;</span>    
    <span class="token class-name">u64_t</span> rvscs<span class="token punctuation">;</span>
    <span class="token class-name">u64_t</span> rvsrflags<span class="token punctuation">;</span>
    <span class="token class-name">u64_t</span> rvsrsp<span class="token punctuation">;</span>
    <span class="token class-name">u64_t</span> rvsss<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token class-name">stkparame_t</span><span class="token punctuation">;</span>
<span class="token comment">//服务函数类型</span>
<span class="token keyword">typedef</span> <span class="token class-name">sysstus_t</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token class-name">syscall_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token class-name">uint_t</span> inr<span class="token punctuation">,</span><span class="token class-name">stkparame_t</span><span class="token operator">*</span> stkparm<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//cosmos/kernel/krlglobal.c</span>
<span class="token function">KRL_DEFGLOB_VARIABLE</span><span class="token punctuation">(</span><span class="token class-name">syscall_t</span><span class="token punctuation">,</span>osservicetab<span class="token punctuation">)</span><span class="token punctuation">[</span>INR_MAX<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们知道，执行 int 指令后会 CPU 会进入中断处理流程。</p><ol><li><p>中断处理流程的第一步就是把 CPU 的一寄存器压入内核栈中，前面系统传递参数正是通过寄存器传递的，而寄存器就保存在内核栈中。</p><p>所以我们需要定义一个 stkparame_t 结构，用来提取内核栈中的参数。</p></li><li><p>接着是第二步，我们可以查看一下 hal_syscl_allocator 函数的第二个参数，正是传递的 RSP 寄存器的值，</p><p>只要把这个值转换成 stkparame_t 结构的地址，就能提取内核栈中的参数了。</p></li></ol><p>但是目前 osservicetab 数组中为空，什么也没有，这是因为我们还没有实现相应<mark>服务接口函数</mark>。下面我们就来实现它。</p><h3 id="_4-系统服务接口函数-实例" tabindex="-1"><a class="header-anchor" href="#_4-系统服务接口函数-实例" aria-hidden="true">#</a> 4）系统服务接口函数 [实例]</h3><p>现在我们已经搞清楚了实现系统服务的所有机制，下面我们就要去实现 Cosmos 的系统服务了。</p><p>其实我已经帮你实现了大多数系统服务了，我没有介绍所有系统服务的实现过程 ，但是每个系统服务的实现原理是相同的。如果每个系统服务都写一遍将非常浪费，所以我选择一个系统服务做为例子，来带你了解实现过程。相信以你的智慧和能力，一定能够举一反三。</p><p>我们下面就来实现系统时间系统服务，应用程序也是经常要获取时间数据的。</p><h4 id="时间库-libtime-c" tabindex="-1"><a class="header-anchor" href="#时间库-libtime-c" aria-hidden="true">#</a> 时间库: libtime.c</h4><p>根据前面所讲，应用程序开发者往往不是直接调用系统 API（应用程序编程接口，我们称为服务接口），而是经常调用某个库来达到目的。</p><p>所以，我们要先来实现一个时间的库函数。首先，我们需要建立一个 cosmos/lib/<code>libtime.c</code> 文件，在里面写上后面这段代码。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//时间库函数</span>
<span class="token class-name">sysstus_t</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token class-name">times_t</span> <span class="token operator">*</span>ttime<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">sysstus_t</span> rets <span class="token operator">=</span> <span class="token function">api_time</span><span class="token punctuation">(</span>ttime<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用时间API</span>
    <span class="token keyword">return</span> rets<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>time 库函数非常简单，就是对系统 API 的封装、应用程序需要传递一个 times_t 结构的地址，这是这个系统 API 的要求， 这个结构也是由系统定义的，如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">s_TIME</span>
<span class="token punctuation">{</span>
    <span class="token class-name">uint_t</span>      year<span class="token punctuation">;</span>
    <span class="token class-name">uint_t</span>      mon<span class="token punctuation">;</span>
    <span class="token class-name">uint_t</span>      day<span class="token punctuation">;</span>
    <span class="token class-name">uint_t</span>      date<span class="token punctuation">;</span>
    <span class="token class-name">uint_t</span>      hour<span class="token punctuation">;</span>
    <span class="token class-name">uint_t</span>      min<span class="token punctuation">;</span>
    <span class="token class-name">uint_t</span>      sec<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token class-name">times_t</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以看到，上述结构中定义了年、月、日、时、分、秒。系统内核会将时间信息填入这个结构中，然后返回，这样一来，时间数据就可以返回给应用程序了。</p><h4 id="时间-api-接口-lapitime-c" tabindex="-1"><a class="header-anchor" href="#时间-api-接口-lapitime-c" aria-hidden="true">#</a> 时间 API 接口: lapitime.c</h4><p>时间库函数已经写好了，在库中需要调用时间 API 接口，因为库和 API 接口函数不同层次的，有时应用程序也会直接调用 API 接口函数，所以我们要分为不同模块。</p><p>下面我们建立一个 cosmos/lib/<code>lapitime.c</code> 文件，并在里面实现 api_time 函数，如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token class-name">sysstus_t</span> <span class="token function">api_time</span><span class="token punctuation">(</span><span class="token class-name">buf_t</span> ttime<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">sysstus_t</span> rets<span class="token punctuation">;</span>
    <span class="token function">API_ENTRY_PARE1</span><span class="token punctuation">(</span>INR_TIME<span class="token punctuation">,</span>rets<span class="token punctuation">,</span>ttime<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//处理参数，执行int指令 </span>
    <span class="token keyword">return</span> rets<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>INR_TIME 是系统服务号，它经过 API_ENTRY_PARE1 宏处理，把 INR_TIME 和 ttime、rets 关联到相应的寄存器，如果不明白可以参考前面的参数传递中使用寄存器的情况。最后就是执行 int 指令进入内核，开始运行时间服务代码。</p><h3 id="_5-内核态时间服务接口-krltime-c" tabindex="-1"><a class="header-anchor" href="#_5-内核态时间服务接口-krltime-c" aria-hidden="true">#</a> 5）内核态时间服务接口: krltime.c</h3><p>当执行 int 指令后，就进入了内核模式下开始执行内核代码了。系统服务分发器会根据服务号从系统服务表中取出相应的函数并调用。因为我们这里要响应的是时间服务，所以取用的自然就是时间服务的接口函数。</p><p>下面我们来建立一个 cosmos/kernel/<code>krltime.c</code> 文件，写出这个时间服务的接口函数，代码如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token class-name">sysstus_t</span> <span class="token function">krlsvetabl_time</span><span class="token punctuation">(</span><span class="token class-name">uint_t</span> inr<span class="token punctuation">,</span> <span class="token class-name">stkparame_t</span> <span class="token operator">*</span>stkparv<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>inr <span class="token operator">!=</span> INR_TIME<span class="token punctuation">)</span><span class="token comment">//判断是否时间服务号</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> SYSSTUSERR<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//调用真正时间服务函数 </span>
    <span class="token keyword">return</span> <span class="token function">krlsve_time</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">time_t</span> <span class="token operator">*</span><span class="token punctuation">)</span>stkparv<span class="token operator">-&gt;</span>parmv1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每个服务接口函数的参数形式都是固定的，我们在前面已经讲过了，但是这个 krlsvetabl_time 函数一定要放在系统服务表中才可以，系统服务表其实是个函数指针数组。虽然前面已经提过了，但是那时 osservicetab 数组是空的，现在我们要把 krlsvetabl_time 函数放进去，如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token function">KRL_DEFGLOB_VARIABLE</span><span class="token punctuation">(</span><span class="token class-name">syscall_t</span><span class="token punctuation">,</span> osservicetab<span class="token punctuation">)</span><span class="token punctuation">[</span>INR_MAX<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token constant">NULL</span><span class="token punctuation">,</span> krlsvetabl_mallocblk<span class="token punctuation">,</span><span class="token comment">//内存分配服务接口</span>
    krlsvetabl_mfreeblk<span class="token punctuation">,</span> <span class="token comment">//内存释放服务接口</span>
    krlsvetabl_exel_thread<span class="token punctuation">,</span><span class="token comment">//进程服务接口</span>
    krlsvetabl_exit_thread<span class="token punctuation">,</span><span class="token comment">//进程退出服务接口</span>
    krlsvetabl_retn_threadhand<span class="token punctuation">,</span><span class="token comment">//获取进程id服务接口</span>
    krlsvetabl_retn_threadstats<span class="token punctuation">,</span><span class="token comment">//获取进程状态服务接口</span>
    krlsvetabl_set_threadstats<span class="token punctuation">,</span><span class="token comment">//设置进程状态服务接口</span>
    krlsvetabl_open<span class="token punctuation">,</span> krlsvetabl_close<span class="token punctuation">,</span><span class="token comment">//文件打开、关闭服务接口</span>
    krlsvetabl_read<span class="token punctuation">,</span> krlsvetabl_write<span class="token punctuation">,</span><span class="token comment">//文件读、写服务接口</span>
    krlsvetabl_ioctrl<span class="token punctuation">,</span> krlsvetabl_lseek<span class="token punctuation">,</span><span class="token comment">//文件随机读写和控制服务接口</span>
    krlsvetabl_time<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//获取时间服务接口</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们的获取时间服务接口占最后一个，第 0 个要保留，其它的服务接口函数我已经帮你实现好了，可以自己查看代码。这样就能调用到 krlsvetabl_time 函数完成服务功能了。</p><h3 id="_6-内核实现时间服务" tabindex="-1"><a class="header-anchor" href="#_6-内核实现时间服务" aria-hidden="true">#</a> 6）内核实现时间服务</h3><p>上面我们只实现了时间服务的接口函数，这个函数还需要调用真正完成功能的函数，下面我们来实现它。想在该函数中完成获取时间数据的功能，我们依然要在 cosmos/kernel/<code>krltime.c</code> 文件中来实现，如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token class-name">sysstus_t</span> <span class="token function">krlsve_time</span><span class="token punctuation">(</span><span class="token class-name">time_t</span> <span class="token operator">*</span>time<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token comment">//对参数进行判断</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> SYSSTUSERR<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">ktime_t</span> <span class="token operator">*</span>initp <span class="token operator">=</span> <span class="token operator">&amp;</span>osktime<span class="token punctuation">;</span><span class="token comment">//操作系统保存时间的结构</span>
    <span class="token class-name">cpuflg_t</span> cpufg<span class="token punctuation">;</span>
    <span class="token function">krlspinlock_cli</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>initp<span class="token operator">-&gt;</span>kt_lock<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cpufg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//加锁</span>
    time<span class="token operator">-&gt;</span>year <span class="token operator">=</span> initp<span class="token operator">-&gt;</span>kt_year<span class="token punctuation">;</span>
    time<span class="token operator">-&gt;</span>mon <span class="token operator">=</span> initp<span class="token operator">-&gt;</span>kt_mon<span class="token punctuation">;</span>
    time<span class="token operator">-&gt;</span>day <span class="token operator">=</span> initp<span class="token operator">-&gt;</span>kt_day<span class="token punctuation">;</span>
    time<span class="token operator">-&gt;</span>date <span class="token operator">=</span> initp<span class="token operator">-&gt;</span>kt_date<span class="token punctuation">;</span>
    time<span class="token operator">-&gt;</span>hour <span class="token operator">=</span> initp<span class="token operator">-&gt;</span>kt_hour<span class="token punctuation">;</span>
    time<span class="token operator">-&gt;</span>min <span class="token operator">=</span> initp<span class="token operator">-&gt;</span>kt_min<span class="token punctuation">;</span>
    time<span class="token operator">-&gt;</span>sec <span class="token operator">=</span> initp<span class="token operator">-&gt;</span>kt_sec<span class="token punctuation">;</span><span class="token comment">//把时间数据写入到参数指向的内存</span>
    <span class="token function">krlspinunlock_sti</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>initp<span class="token operator">-&gt;</span>kt_lock<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cpufg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//解锁</span>
    <span class="token keyword">return</span> SYSSTUSOK<span class="token punctuation">;</span><span class="token comment">//返回正确的状态</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>krlsve_time 函数，只是把系统的时间数据读取出来，写入用户应用程序传入缓冲区中，由于 osktime 这个结构实例会由其它代码自动更新，所以要加锁访问。好了，这样一个简单的系统服务函数就实现了。</p><h2 id="系统服务函数的执行过程" tabindex="-1"><a class="header-anchor" href="#系统服务函数的执行过程" aria-hidden="true">#</a> 系统服务函数的执行过程</h2><p>我们已经实现了一个获取时间的系统服务函数，我想你应该能自己实现其它更多的系统服务函数了。下面我来帮你梳理一下，从库函数到进入中断再到系统服务分发器，最后到系统服务函数的全过程，我给你准备了一幅图，如下所示。</p><img src="`+e+'" alt="img" style="zoom:15%;"><p>系统服务流程示意图</p><p>上图中应用程序在用户空间中运行，调用库函数，库函数调用 API 函数执行 INT 指令，进入中断门，从而运行内核代码。最后内核代码一步步执行了相关服务功能，返回到用户空间继续运行应用程序。这就是应用程序调用一个系统服务的全部过程。</p><h2 id="重点回顾" tabindex="-1"><a class="header-anchor" href="#重点回顾" aria-hidden="true">#</a> 重点回顾</h2><p>这节课程又到了尾声，今天我们以获取时间的系统服务为例，一起学习了如何建立一个系统服务接口和具体服务函数实现细节。下面我梳理一下本节课的重点。</p><ul><li><p>\\1. 首先，我们从全局了解了 Cosmos 服务接口的结构，它是分层封装的，由库、API 接口、系统服务分发器、系统服务接口、系统服务组成的。</p></li><li><p>\\2. 接着，我们学习了如何使用 int 指令触发中断，使应用程序通过中断进入内核开始执行相关的服务，同时解决了如何给内核传递参数的问题。</p></li><li><p>\\3. 然后，我们一起实现了系统分发器和系统服务表，这是实现系统服务的重要机制。</p></li><li><p>\\4. 最后，我们从库函数开始一步步实现了获取时间的系统服务，了解了实现一个系统的全部过程和细节。</p></li></ul><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题" aria-hidden="true">#</a> 思考题</h2><p>请问 int 指令后面的常数能不能大于 255，为什么？</p><p>欢迎你在留言区跟我交流互动，也推荐你把这节课分享给自己的朋友，跟他一起动手做做这节课的实验。</p><p>我是 LMOS，我们下节课见！</p>',95),l=[o];function i(u,r){return s(),a("div",null,l)}const m=n(c,[["render",i],["__file","M41-用户态与内核态之间的接口.html.vue"]]);export{m as default};
