import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as a,d as p}from"./app-cdabc73c.js";const t="/assets/efcf95c11732273ace5329152c782924-e78b43fe.jpg",e="/assets/f986251428c419f5b2000308236466b1-8a243736.jpg",c={},o=p(`<h1 id="_26-多个活动要安排-下-如何实现进程的等待与唤醒机制" tabindex="-1"><a class="header-anchor" href="#_26-多个活动要安排-下-如何实现进程的等待与唤醒机制" aria-hidden="true">#</a> 26 | 多个活动要安排（下）：如何实现进程的等待与唤醒机制？</h1><p>你好，我是 LMOS。</p><p>上节课，我带你一起设计了我们 Cosmos 的进程调度器，但有了进程调度器还不够，因为调度器它始终只是让一个进程让出 CPU，切换到它选择的下一个进程上去运行。</p><p>结合前面我们对进程生命周期的讲解，估计你已经反应过来了。没错，多进程调度方面，我们还要实现进程的等待与唤醒机制，今天我们就来搞定它。</p><p>这节课的配套代码，你可以从这里下载。</p><h2 id="进程的等待与唤醒" tabindex="-1"><a class="header-anchor" href="#进程的等待与唤醒" aria-hidden="true">#</a> 进程的等待与唤醒</h2><p>我们已经知道，进程得不到所需的某个资源时就会进入等待状态，直到这种资源可用时，才会被唤醒。那么进程的等待与唤醒机制到底应该这样设计呢，请听我慢慢为你梳理。</p><h2 id="进程等待结构" tabindex="-1"><a class="header-anchor" href="#进程等待结构" aria-hidden="true">#</a> 进程等待结构</h2><p>很显然，在实现进程的等待与唤醒的机制之前，我们需要设计一种数据结构，用于挂载等待的进程，在唤醒的时候才可以找到那些等待的进程 ，这段代码如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">s_KWLST</span>
<span class="token punctuation">{</span>   
    <span class="token class-name">spinlock_t</span> wl_lock<span class="token punctuation">;</span>  <span class="token comment">//自旋锁</span>
    <span class="token class-name">uint_t</span>   wl_tdnr<span class="token punctuation">;</span>    <span class="token comment">//等待进程的个数</span>
    <span class="token class-name">list_h_t</span> wl_list<span class="token punctuation">;</span>    <span class="token comment">//挂载等待进程的链表头</span>
<span class="token punctuation">}</span><span class="token class-name">kwlst_t</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其实，这个结构在前面讲信号量的时候，我们已经见过了。这是因为它经常被包含在信号量等上层数据结构中，而信号量结构，通常用于保护访问受限的共享资源。这个结构非常简单，我们不用多说。</p><h2 id="进程等待" tabindex="-1"><a class="header-anchor" href="#进程等待" aria-hidden="true">#</a> 进程等待</h2><p>现在我们来实现让进程进入等待状态的机制，它也是一个函数。这个函数会设置进程状态为等待状态，让进程从调度系统数据结构中脱离，最后让进程加入到 kwlst_t 等待结构中，代码如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">krlsched_wait</span><span class="token punctuation">(</span><span class="token class-name">kwlst_t</span> <span class="token operator">*</span>wlst<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">cpuflg_t</span> cufg<span class="token punctuation">,</span> tcufg<span class="token punctuation">;</span>
    <span class="token class-name">uint_t</span> cpuid <span class="token operator">=</span> <span class="token function">hal_retn_cpuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">schdata_t</span> <span class="token operator">*</span>schdap <span class="token operator">=</span> <span class="token operator">&amp;</span>osschedcls<span class="token punctuation">.</span>scls_schda<span class="token punctuation">[</span>cpuid<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">//获取当前正在运行的进程</span>
    <span class="token class-name">thread_t</span> <span class="token operator">*</span>tdp <span class="token operator">=</span> <span class="token function">krlsched_retn_currthread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">uint_t</span> pity <span class="token operator">=</span> tdp<span class="token operator">-&gt;</span>td_priority<span class="token punctuation">;</span>
    <span class="token function">krlspinlock_cli</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>schdap<span class="token operator">-&gt;</span>sda_lock<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cufg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">krlspinlock_cli</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tdp<span class="token operator">-&gt;</span>td_lock<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tcufg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    tdp<span class="token operator">-&gt;</span>td_stus <span class="token operator">=</span> TDSTUS_WAIT<span class="token punctuation">;</span><span class="token comment">//设置进程状态为等待状态</span>
    <span class="token function">list_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tdp<span class="token operator">-&gt;</span>td_list<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//脱链</span>
    <span class="token function">krlspinunlock_sti</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tdp<span class="token operator">-&gt;</span>td_lock<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tcufg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>schdap<span class="token operator">-&gt;</span>sda_thdlst<span class="token punctuation">[</span>pity<span class="token punctuation">]</span><span class="token punctuation">.</span>tdl_curruntd <span class="token operator">==</span> tdp<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        schdap<span class="token operator">-&gt;</span>sda_thdlst<span class="token punctuation">[</span>pity<span class="token punctuation">]</span><span class="token punctuation">.</span>tdl_curruntd <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    schdap<span class="token operator">-&gt;</span>sda_thdlst<span class="token punctuation">[</span>pity<span class="token punctuation">]</span><span class="token punctuation">.</span>tdl_nr<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token function">krlspinunlock_sti</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>schdap<span class="token operator">-&gt;</span>sda_lock<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cufg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">krlwlst_add_thread</span><span class="token punctuation">(</span>wlst<span class="token punctuation">,</span> tdp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将进程加入等待结构中</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码也不难，你结合注释就能理解。有一点需要注意，这个函数使进程进入等待状态，而这个<strong>进程是当前正在运行的进程，而当前正在运行的进程正是调用这个函数的进程</strong>，所以一个进程想要进入等待状态，只要调用这个函数就好了。</p><h2 id="进程唤醒" tabindex="-1"><a class="header-anchor" href="#进程唤醒" aria-hidden="true">#</a> 进程唤醒</h2><p>进程的唤醒则是进程等待的反向操作行为，即从等待数据结构中获取进程，然后设置进程的状态为运行状态，最后将这个进程加入到进程调度系统数据结构中。这个函数的代码如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">krlsched_up</span><span class="token punctuation">(</span><span class="token class-name">kwlst_t</span> <span class="token operator">*</span>wlst<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">cpuflg_t</span> cufg<span class="token punctuation">,</span> tcufg<span class="token punctuation">;</span>
    <span class="token class-name">uint_t</span> cpuid <span class="token operator">=</span> <span class="token function">hal_retn_cpuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">schdata_t</span> <span class="token operator">*</span>schdap <span class="token operator">=</span> <span class="token operator">&amp;</span>osschedcls<span class="token punctuation">.</span>scls_schda<span class="token punctuation">[</span>cpuid<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token class-name">thread_t</span> <span class="token operator">*</span>tdp<span class="token punctuation">;</span>
    <span class="token class-name">uint_t</span> pity<span class="token punctuation">;</span>
    <span class="token comment">//取出等待数据结构第一个进程并从等待数据结构中删除</span>
    tdp <span class="token operator">=</span> <span class="token function">krlwlst_del_thread</span><span class="token punctuation">(</span>wlst<span class="token punctuation">)</span><span class="token punctuation">;</span>
    pity <span class="token operator">=</span> tdp<span class="token operator">-&gt;</span>td_priority<span class="token punctuation">;</span><span class="token comment">//获取进程的优先级</span>
    <span class="token function">krlspinlock_cli</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>schdap<span class="token operator">-&gt;</span>sda_lock<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cufg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">krlspinlock_cli</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tdp<span class="token operator">-&gt;</span>td_lock<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tcufg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    tdp<span class="token operator">-&gt;</span>td_stus <span class="token operator">=</span> TDSTUS_RUN<span class="token punctuation">;</span><span class="token comment">//设置进程的状态为运行状态</span>
    <span class="token function">krlspinunlock_sti</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tdp<span class="token operator">-&gt;</span>td_lock<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tcufg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">list_add_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tdp<span class="token operator">-&gt;</span>td_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>schdap<span class="token operator">-&gt;</span>sda_thdlst<span class="token punctuation">[</span>pity<span class="token punctuation">]</span><span class="token punctuation">.</span>tdl_lsth<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//加入进程优先级链表</span>
    schdap<span class="token operator">-&gt;</span>sda_thdlst<span class="token punctuation">[</span>pity<span class="token punctuation">]</span><span class="token punctuation">.</span>tdl_nr<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token function">krlspinunlock_sti</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>schdap<span class="token operator">-&gt;</span>sda_lock<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cufg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码相对简单，我想以你的能力，还能写出比以上更好的代码。好了，到这里，我们进程的等待与唤醒的机制已经实现了。</p><h2 id="空转进程" tabindex="-1"><a class="header-anchor" href="#空转进程" aria-hidden="true">#</a> 空转进程</h2><p>下面我们一起来建立空转进程 ，它也是我们系统下的第一个进程。空转进程是操作系统在没任何进程可以调度运行的时候，就选择调度空转进程来运行，可以说<strong>空转进程是进程调度器最后的选择。</strong></p><p>请注意，这个最后的选择一定要有，现在几乎所有的操作系统，都有一个或者几个空转进程（多 CPU 的情况下，每个 CPU 一个空转进程）。我们的 Cosmos 虽然是简单了些，但也必须要有空转进程，而且这是我们 Cosmos 上的第一个进程。</p><h2 id="建立空转进程" tabindex="-1"><a class="header-anchor" href="#建立空转进程" aria-hidden="true">#</a> 建立空转进程</h2><p>我们 Cosmos 的空转进程是个内核进程，按照常理，我们只要调用上节课实现的建立进程的接口，创建一个内核进程就好了。</p><p>但是我们的空转进程有点特殊，它是内核进程没错，但它不加入调度系统，而是一个专用的指针指向它的。</p><p>下面我们来建立一个空转进程。由于空转进程是个独立的模块，我们建立一个新的 C 语言文件 Cosmos/kernel/krlcpuidle.c，代码如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token class-name">thread_t</span> <span class="token operator">*</span><span class="token function">new_cpuidle_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>

    <span class="token class-name">thread_t</span> <span class="token operator">*</span>ret_td <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token class-name">bool_t</span> acs <span class="token operator">=</span> FALSE<span class="token punctuation">;</span>
    <span class="token class-name">adr_t</span> krlstkadr <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token class-name">uint_t</span> cpuid <span class="token operator">=</span> <span class="token function">hal_retn_cpuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">schdata_t</span> <span class="token operator">*</span>schdap <span class="token operator">=</span> <span class="token operator">&amp;</span>osschedcls<span class="token punctuation">.</span>scls_schda<span class="token punctuation">[</span>cpuid<span class="token punctuation">]</span><span class="token punctuation">;</span>
    krlstkadr <span class="token operator">=</span> <span class="token function">krlnew</span><span class="token punctuation">(</span>DAFT_TDKRLSTKSZ<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//分配进程的内核栈</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>krlstkadr <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//分配thread_t结构体变量</span>
    ret_td <span class="token operator">=</span> <span class="token function">krlnew_thread_dsc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret_td <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        acs <span class="token operator">=</span> <span class="token function">krldelete</span><span class="token punctuation">(</span>krlstkadr<span class="token punctuation">,</span> DAFT_TDKRLSTKSZ<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>acs <span class="token operator">==</span> FALSE<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//设置进程具有系统权限</span>
    ret_td<span class="token operator">-&gt;</span>td_privilege <span class="token operator">=</span> PRILG_SYS<span class="token punctuation">;</span>
    ret_td<span class="token operator">-&gt;</span>td_priority <span class="token operator">=</span> PRITY_MIN<span class="token punctuation">;</span>
    <span class="token comment">//设置进程的内核栈顶和内核栈开始地址</span>
    ret_td<span class="token operator">-&gt;</span>td_krlstktop <span class="token operator">=</span> krlstkadr <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token class-name">adr_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DAFT_TDKRLSTKSZ <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ret_td<span class="token operator">-&gt;</span>td_krlstkstart <span class="token operator">=</span> krlstkadr<span class="token punctuation">;</span>
    <span class="token comment">//初始化进程的内核栈</span>
    <span class="token function">krlthread_kernstack_init</span><span class="token punctuation">(</span>ret_td<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>krlcpuidle_main<span class="token punctuation">,</span> KMOD_EFLAGS<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//设置调度系统数据结构的空转进程和当前进程为ret_td</span>
    schdap<span class="token operator">-&gt;</span>sda_cpuidle <span class="token operator">=</span> ret_td<span class="token punctuation">;</span>
    schdap<span class="token operator">-&gt;</span>sda_currtd <span class="token operator">=</span> ret_td<span class="token punctuation">;</span>
    <span class="token keyword">return</span> ret_td<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//新建空转进程</span>
<span class="token keyword">void</span> <span class="token function">new_cpuidle</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">thread_t</span> <span class="token operator">*</span>thp <span class="token operator">=</span> <span class="token function">new_cpuidle_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//建立空转进程</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>thp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span><span class="token comment">//失败则主动死机</span>
        <span class="token function">hal_sysdie</span><span class="token punctuation">(</span><span class="token string">&quot;newcpuilde err&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">kprint</span><span class="token punctuation">(</span><span class="token string">&quot;CPUIDLETASK: %x\\n&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">uint_t</span><span class="token punctuation">)</span>thp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中，建立空转进程由 new_cpuidle 函数调用 new_cpuidle_thread 函数完成，new_cpuidle_thread 函数的操作和前面建立内核进程差不多，只不过在函数的最后，让调度系统数据结构的空转进程和当前进程的指针，指向了刚刚建立的进程。</p><p>但是你要注意，上述代码中调用初始内核栈函数时，将 krlcpuidle_main 函数传了进去，这就是空转进程的主函数，下面我们来写好。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">krlcpuidle_main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">uint_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">kprint</span><span class="token punctuation">(</span><span class="token string">&quot;空转进程运行:%x\\n&quot;</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//打印</span>
        <span class="token function">krlschedul</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调度进程</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我给你解释一下，空转进程的主函数本质就是个死循环，在死循环中打印一行信息，然后进行进程调度，这个函数就是永无休止地执行这两个步骤。</p><h2 id="空转进程运行" tabindex="-1"><a class="header-anchor" href="#空转进程运行" aria-hidden="true">#</a> 空转进程运行</h2><p>我们已经建立了空转进程，下面就要去运行它了。</p><p>由于是第一进程，所以没法用调度器来调度它，我们得手动启动它，才可以运行。其实上节课我们已经写了启动一个新建进程运行的函数，我们现在只要调用它就好了，代码如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">krlcpuidle_start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">uint_t</span> cpuid <span class="token operator">=</span> <span class="token function">hal_retn_cpuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">schdata_t</span> <span class="token operator">*</span>schdap <span class="token operator">=</span> <span class="token operator">&amp;</span>osschedcls<span class="token punctuation">.</span>scls_schda<span class="token punctuation">[</span>cpuid<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">//取得空转进程</span>
    <span class="token class-name">thread_t</span> <span class="token operator">*</span>tdp <span class="token operator">=</span> schdap<span class="token operator">-&gt;</span>sda_cpuidle<span class="token punctuation">;</span>
    <span class="token comment">//设置空转进程的tss和R0特权级的栈</span>
    tdp<span class="token operator">-&gt;</span>td_context<span class="token punctuation">.</span>ctx_nexttss <span class="token operator">=</span> <span class="token operator">&amp;</span>x64tss<span class="token punctuation">[</span>cpuid<span class="token punctuation">]</span><span class="token punctuation">;</span>
    tdp<span class="token operator">-&gt;</span>td_context<span class="token punctuation">.</span>ctx_nexttss<span class="token operator">-&gt;</span>rsp0 <span class="token operator">=</span> tdp<span class="token operator">-&gt;</span>td_krlstktop<span class="token punctuation">;</span>
    <span class="token comment">//设置空转进程的状态为运行状态</span>
    tdp<span class="token operator">-&gt;</span>td_stus <span class="token operator">=</span> TDSTUS_RUN<span class="token punctuation">;</span>
    <span class="token comment">//启动进程运行</span>
    <span class="token function">retnfrom_first_sched</span><span class="token punctuation">(</span>tdp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码的逻辑也很容易理解，我为你梳理一下。首先就是取出空转进程，然后设置一下机器上下文结构和运行状态，最后调用 retnfrom_first_sched 函数，恢复进程内核栈中的内容，让进程启动运行。</p><p>不过这还没完，我们应该把建立空转进程和启动空转进程运行函数封装起来，放在一个初始化空转进程的函数中，并在内核层初始化 init_krl 函数的最后调用，代码如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">init_krl</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">init_krlsched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始化进程调度器</span>
    <span class="token function">init_krlcpuidle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始化空转进程</span>
    <span class="token function">die</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//防止init_krl函数返回</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//初始化空转进程</span>
<span class="token keyword">void</span> <span class="token function">init_krlcpuidle</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">new_cpuidle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//建立空转进程</span>
    <span class="token function">krlcpuidle_start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//启动空转进程运行</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>好了，所有的代码都已备好，终于到我们检验学习成果的时候了，我切换到这节课程的 cosmos 目录下执行 make vboxtest 命令，就会出现如下图的结果，如下图所示。</p><img src="`+t+`" alt="img" style="zoom:25%;"><p>空转进程运行</p><p>可以看到，现在空转进程和调度器输出的信息在屏幕上交替滚动出现，这说明我们的空转进程和进程调度器都已经正常工作了。</p><h2 id="多进程运行" tabindex="-1"><a class="header-anchor" href="#多进程运行" aria-hidden="true">#</a> 多进程运行</h2><p>虽然我们的空转进程和调度器已经正常工作了，但你可能心里会有疑问，我们系统中就一个空转进程，那怎么证明我们进程调度器是正常工作的呢？</p><p>其实我们在空转进程中调用了调度器函数，然后进程调度器会发现系统中没有进程，又不得不调度空转进程，所以最后结果就是：空转进程调用进程调度器，而调度器又选择了空转进程，导致形成了一个闭环。</p><p>但是我们现在想要看看多个进程会是什么情况，就需要建立多个进程。下面我们马上就来实现这个想法，代码如下。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">thread_a_main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//进程A主函数</span>
<span class="token punctuation">{</span>
    <span class="token class-name">uint_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">kprint</span><span class="token punctuation">(</span><span class="token string">&quot;进程A运行:%x\\n&quot;</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">krlschedul</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">thread_b_main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//进程B主函数</span>
<span class="token punctuation">{</span>
    <span class="token class-name">uint_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">kprint</span><span class="token punctuation">(</span><span class="token string">&quot;进程B运行:%x\\n&quot;</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">krlschedul</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">init_ab_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">krlnew_thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>thread_a_main<span class="token punctuation">,</span> KERNTHREAD_FLG<span class="token punctuation">,</span> 
                PRILG_SYS<span class="token punctuation">,</span> PRITY_MIN<span class="token punctuation">,</span> DAFT_TDUSRSTKSZ<span class="token punctuation">,</span> DAFT_TDKRLSTKSZ<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//建立进程A</span>
    <span class="token function">krlnew_thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>thread_b_main<span class="token punctuation">,</span> KERNTHREAD_FLG<span class="token punctuation">,</span> 
                PRILG_SYS<span class="token punctuation">,</span> PRITY_MIN<span class="token punctuation">,</span> DAFT_TDUSRSTKSZ<span class="token punctuation">,</span> DAFT_TDKRLSTKSZ<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//建立进程B</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">init_krlcpuidle</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">new_cpuidle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//建立空转进程</span>
    <span class="token function">init_ab_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始化建立A、B进程</span>
    <span class="token function">krlcpuidle_start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//开始运行空转进程</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中，我们在 init_ab_thread 函数中建立两个内核进程，分别运行两个函数，这两个函数会打印信息，init_ab_thread 函数由 init_krlcpuidle 函数调用。这样在初始化空转进程的时候，就建立了进程 A 和进程 B。</p><p>好了，现在我们在 Linux 终端下进入 cosmos 目录，在目录下输入 make vboxtest 运行一下，结果如下图所示。</p><img src="`+e+'" alt="img" style="zoom:25%;"><p>两个进程结果截图</p><p>上图中，进程 A 和进程 B 在调度器的调度下交替运行，而空转进程不再运行，这表明我们的多进程机制完全正确。</p><h2 id="重点回顾" tabindex="-1"><a class="header-anchor" href="#重点回顾" aria-hidden="true">#</a> 重点回顾</h2><p>这节课我们接着上一节课，实现了进程的等待与唤醒机制，然后建立了空转进程，最后对进程调度进行了测试。下面我来为你梳理一下要点。</p><p>1.**等待和唤醒机制。**为了让进程能进入等待状态随后又能在其它条件满足的情况下被唤醒，我们实现了进程等待和唤醒机制。</p><p>2.**空转进程。**是我们 Cosmos 系统下的第一个进程，它只干一件事情就是调用调度器函数调度进程，在系统中没有其它可以运行进程时，调度器又会调度空转进程，形成了一个闭环。</p><p>3.**测试。**为了验证我们的进程调度器是否是正常工作的，我们建立了两个进程，让它们运行，结果在屏幕上出现了它们交替输出的信息。这证明了我们的进程调度器是功能正常的。</p><p>你也许发现了，我们的进程中都调用了 krlschedul 函数，不调用它就是始终只有一个进程运行了，你在开发应用程序中，需要调用调度器主动让出 CPU 吗？</p><p>这是什么原因呢？这是因为我们的 Cosmos 没有定时器驱动，系统的 TICK 机制无法工作，一旦我们系统 TICK 机开始工作，就能控制进程运行了多长时间，然后强制调度进程。系统 TICK 设备我们等到驱动与设备相关的模块，再给你展开讲解。</p><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题" aria-hidden="true">#</a> 思考题</h2><p>请问，我们让进程进入等待状态后，这进程会立马停止运行吗？</p><p>欢迎你在留言区和我交流，相信通过积极参与，你将更好地理解这节课的内容。</p><p>好，我是 LMOS，我们下节课见！</p>',63),l=[o];function i(u,k){return s(),a("div",null,l)}const v=n(c,[["render",i],["__file","I26-多个活动要安排（下）.html.vue"]]);export{v as default};
