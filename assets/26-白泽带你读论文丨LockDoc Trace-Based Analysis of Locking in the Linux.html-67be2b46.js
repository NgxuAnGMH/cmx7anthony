import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as s,c as t,a as e,b as a,e as i,d as c}from"./app-cdabc73c.js";const l="/assets/640-1691478793390-93-29c5807f.png",p="/assets/640-1691478793391-94-c4eb7943.png",d="/assets/640-1691478793391-95-ee317d0d.png",h="/assets/640-1691478793391-96-20b339cb.png",_={},u=e("h1",{id:"_26-白泽带你读论文丨lockdoc-trace-based-analysis-of-locking-in-the-linux",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_26-白泽带你读论文丨lockdoc-trace-based-analysis-of-locking-in-the-linux","aria-hidden":"true"},"#"),a(" 26-白泽带你读论文丨LockDoc: Trace-Based Analysis of Locking in the Linux")],-1),g=e("p",null,[e("strong",null,"LockDoc: Trace-Based Analysis of Locking in the Linux Kernel")],-1),m=e("p",null,"文章选自EuroSys - 2019。",-1),f={href:"https://dl.acm.org/doi/pdf/10.1145/3302424.3303948%EF%BC%8C%E6%9C%AC%E6%96%87%E4%BA%8C%E4%BD%9C%E6%98%AF%E5%A5%A5%E6%96%AF%E7%BA%B3%E5%B8%83%E5%90%95%E8%82%AF%E5%A4%A7%E5%AD%A6%E7%9A%84",target:"_blank",rel:"noopener noreferrer"},k={href:"https://ess.cs.uni-osnabrueck.de/~os/publications.html.en",target:"_blank",rel:"noopener noreferrer"},b=c('<h2 id="_1-主要内容" tabindex="-1"><a class="header-anchor" href="#_1-主要内容" aria-hidden="true">#</a> <strong>1 主要内容</strong></h2><p>对内核开发者来说，锁的使用是一件非常烦琐而且复杂的工作，需要针对代码的上下文、特定的成员对象综合考虑锁的使用，更糟糕的一件事情是，开发文档上关于锁的使用的介绍是不全面的，甚至是出错的。在这样的条件下，开发者很难不写出错误代码，错误的使用锁可能造成死锁、条件竞争，或者是并行的性能下降等危害。</p><p>相较之前的工作倾向于帮助开发者找到内核中的 bug，本文采用了另一种思路来降低开发者写出含有 bug 代码的概率：<em>即通过更完善的文档、更详细的介绍来帮助开发者编写正确的代码</em>。那么如何得到正确的加锁规则和完善的文档？作者在这里基于以下出发点：一般而言，Linux 等操作系统绝大多数情况下处于正常运行状态，<em>因此可以通过分析正常情况下Linux 内核的 trace 来推断什么是合理的加锁规则</em>。</p><p>为此，本文提出了<u>一种基于 trace 的自动加锁规则推断工具</u>，通过在一个插桩的 Linux 内核上记录对内核的数据结构和对锁的获取释放的记录，<u>可以分析并推断锁的合理加锁规则</u>，通过这些规则可以验证现有文档的缺陷以及定位可能的bug。</p><p>最终，作者在实验中找到了 52,452 个违反推导出的加锁规则的例子，并由开发者确认了其中一个是真实存在的 bug。</p><h2 id="_2-设计与实现" tabindex="-1"><a class="header-anchor" href="#_2-设计与实现" aria-hidden="true">#</a> <strong>2 设计与实现</strong></h2><figure><img src="'+l+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>LockDoc 的整体工作流程如上图所示，具体来说可以分成以下三个阶段：</p><h3 id="a-monitoring-tracing-phase" tabindex="-1"><a class="header-anchor" href="#a-monitoring-tracing-phase" aria-hidden="true">#</a> a. monitoring/tracing phase</h3><p>通过在一个 VM 里运行插桩后的 Linux kernel，记录相关数据结构的分配以及锁的加锁和释放，生成相应的trace ，在处理完成后插入到数据库中。需要同时记录这二者的原因是，锁的使用根本目的还是保证数据的同步，所以锁不会单独脱离其需要保护的数据而独立存在的。这里对数据结构的选取，主要基于后文的实验的需要，比如作者在之后选取了inode及其相关的加锁规则进行实验，这里则需要记录inode以及其结构内相关的变量i_hash、i_state等。</p><h3 id="b-locking-rule-derivation-phase" tabindex="-1"><a class="header-anchor" href="#b-locking-rule-derivation-phase" aria-hidden="true">#</a> b. locking-rule derivation phase</h3><p>利用上阶段得到的数据，在该阶段可以枚举出所有的加锁规则，并通过判断假设的可能性，进而得到合理的规则。</p><p>关于如何从所有枚举出的加锁规则中选择最可能是正确的加锁规则，作者提出了“次优选择”的策略。首先通过第一阶段的数据计算每一个加锁规则的匹配情况sr，然后选择一个合理的阈值 tac，在所有sr 高于阈值 tac 的所有情况中，选择值 sr 最小的一个。如果有多种可能，选择其中加锁规则最复杂的一个。这种选择的理由是，在所有高于阈值的选择都具有可能性的情况下，错误的加锁使用反而会有更高的匹配程度，因此sr反而会比正确的加锁规则高；同理，在可选情况较多时，选择更复杂的加锁规则比简单的加锁规则具有合理性。</p><figure><img src="'+p+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>以上图代码为例，变量 seconds 和minutes分别由锁sec_lock 和 min_lock 保护，由此可以枚举出5种加锁规则，以及通过第一阶段能计算得到不同规则的 sr：<img src="'+d+'" alt="图片" loading="lazy"></p><p>按照规则，我们选取阈值tac =90%，根据次优选择策略，我们可选的加锁规则有两种：1. 只使用min_lock；2. 先使用 sec_lock，再使用 min_lock，再根据有相同 sr则选取较复杂的那个的策略，我们最终选取sec_lock-&gt;min_lock作为该阶段生成的规则。</p><h3 id="c-analysis-phase" tabindex="-1"><a class="header-anchor" href="#c-analysis-phase" aria-hidden="true">#</a> c. analysis phase</h3><p>这一阶段主要是利用上阶段生成的结果，来完成以下三个工作：</p><p>1)通过生成的加锁规则和官方文档提供的加锁规则进行对比，比较二者的合理性</p><p>2)利用生成的加锁规则，生成用户可读的文档</p><p>3)通过生成规则的和记录的内存访问，验证代码中是否存在违背加锁规则的现象</p><h2 id="_3-实验评估" tabindex="-1"><a class="header-anchor" href="#_3-实验评估" aria-hidden="true">#</a> <strong>3</strong> <strong>实验评估</strong></h2><p>前置条件</p><p>• vanilla Linux 4.10</p><p>• lock：spinlock_t， rw_lock_t， semaphore， rw_semaphore， mutex， rcu</p><p>• Fail*-based experiment environment</p><p>测试代码的覆盖率：</p><figure><img src="'+h+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>本文实验验证的问题主要在于没有一个 Ground Truth 可以提供对照，因此作者只能对实验结果进行简单的讨论，比如通过实验结果发现关于数据结构transaction_t ，其执行结果推导出的加锁规则和加锁文档中定义的重合度最高，可以看出，transaction_t 的文档质量相对较好。</p><p>作者在实验中最终找到了 52,452 个违反推导出的规则的例子，但这同样由于没有 Ground Truth 而无法进行验证，不过作者强调了其中有一个已经被开发人员证实为 bug了。</p><p>关于 FP，作者总结了以下几点原因：</p><ol><li>Linux kernel 的代码中，可能会因为性能的原因，主动选择不使用锁</li><li>和情况1类似，当开发者知道某些情况下其实不会出现并发访问的话，会主动不使用锁</li><li>次优选择的策略，可能推断出错误的加锁规则，同样会引起 FP</li></ol><h2 id="_4-总结评价" tabindex="-1"><a class="header-anchor" href="#_4-总结评价" aria-hidden="true">#</a> <strong>4 总结评价</strong></h2><p>减少 bug 其实有两个维度，第一个就是找到bug，修复bug；<em>第二个则是在开发之初就减少bug</em>，现有的工作大多集中在第一个维度，而忽略了第二个维度的重要性。为了降低在开发之初就带来的bug，特别是开发 Linux kernel 等复杂工程，需要一个详尽且正确的文档，但残酷的现实是——<em>已有文档往往是缺损甚至错误的</em>。</p><p>本文巧妙地从这一个问题切入，讨论了如何通过生成正确的加锁规则进而指导开发者写出正确的代码。作者巧妙地基于“一般情况下 Linux 等操作系统是正常运行的，正常运行说明此时的逻辑是正确的，锁的使用也是合理的”这一前提，通过大量系统运行时的数据来推导合理的加锁规则。当然本文也有不足的地方，其实验验证部分由于缺少Ground Truth因此没有很强的说服力。</p><p>不过我们可以借鉴作者的这种假设，不仅仅是Linux kernel，这种基于大数据的合理性推断完全可以推广到其他大型应用的开发过程、系统漏洞的定位中来。</p>',36);function x(L,E){const n=o("ExternalLinkIcon");return s(),t("div",null,[u,g,m,e("p",null,[a("原文链接："),e("a",f,[a("https://dl.acm.org/doi/pdf/10.1145/3302424.3303948，本文二作是奥斯纳布吕肯大学的"),i(n)]),a(" Olaf Spinczyk 教授，其从事计算机领域已超过20年，著作丰富，可见其个人主页 "),e("a",k,[a("https://ess.cs.uni-osnabrueck.de/~os/publications.html.en"),i(n)])]),b])}const B=r(_,[["render",x],["__file","26-白泽带你读论文丨LockDoc Trace-Based Analysis of Locking in the Linux.html.vue"]]);export{B as default};
