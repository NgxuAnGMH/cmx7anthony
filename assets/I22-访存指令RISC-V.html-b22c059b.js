import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o as d,c as r,a as e,b as i,e as t,d as l}from"./app-cdabc73c.js";const c="/assets/ee3b74d78ce8bbf597f9e9d1998dd216-1e8be536.jpg",p="/assets/8ab29e03646a8b7824e515aa6980b07c-b8db7cdf.jpg",m="/assets/ca2946638e7a271e917d95037bb3be3e-f358cb11.jpg",o="/assets/691291f67fa032aebe3eb45a84e043d3-e54c20fc.jpg",b="/assets/b2d982461bbbe87685e54a2cec3b8e01-7b585288.jpg",g="/assets/7f261940269dd4edce593c91d3211f9c-89377409.jpg",u="/assets/45f7c8f9cf9558fb6143318bd89c0abc-8fa96cf4.jpg",v="/assets/4641362093d8794fc2f400d66ce3ec68-fd27ba90.jpg",f="/assets/14a4aa40d4bc9691394d02460bec0f82-e49cfdb9.jpg",h="/assets/3e11da000389d18458e20039ae4c46d0-2d6dcaa6.jpg",_={},x=e("h1",{id:"_22-risc-v指令精讲-七-访存指令实现与调试",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_22-risc-v指令精讲-七-访存指令实现与调试","aria-hidden":"true"},"#"),i(" 22｜RISC-V指令精讲（七）：访存指令实现与调试")],-1),w=e("p",null,"你好，我是 LMOS。",-1),j=e("p",null,"上节课我们说了 RISC-V 是加载储存体系结构的典型，只有加载指令和储存指令才有资格访问内存。",-1),C=e("p",null,"计算机运算完成的结果，一开始会放在寄存器中，但最终归宿还是内存，此时就需要存储指令发挥作用了。这节课我们就来看看 RISC-V 提供的存储指令，一共有三条，分别是储存字节指令、储存双字节指令和储存字指令。",-1),S={href:"https://gitee.com/lmos/Geek-time-computer-foundation/tree/master/lesson21~22",target:"_blank",rel:"noopener noreferrer"},y=l(`<h2 id="储存字节指令-sb-指令" tabindex="-1"><a class="header-anchor" href="#储存字节指令-sb-指令" aria-hidden="true">#</a> 储存字节指令：sb 指令</h2><p>我们先从储存字节指令，即 sb 指令学起。</p><p>这个指令存储的字节单位是一个字节，也就是 8 位数据。说得再具体一些，这个指令会把一个通用寄存器里的低[7:0]位，储存到特定地址的内存单元里。而这个特定地址，要由另一个通用寄存器和一个立即数之和来决定。</p><p>储存字节指令的汇编代码，书写形式如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>sb rs2,imm(rs1)
#sb 储存字节指令
#rs2 源寄存器2
#rs1 源寄存器1
#imm 立即数（-2048~2047）
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>**上述代码中 rs1 和 rs2 可以是任何通用寄存器。立即数 imm 为 12 位二进制数据，其范围是 -2048~2047。**因为 rs1、rs2 以及立即数 imm 的规定，对后面的 sh 指令和 sw 指令同样适用，后面我就不重复说了。</p><p>sb 指令完成的操作用伪代码描述是这样的：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>（[rs1+imm]）= rs2[7:0]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>我来为你解释一下伪代码执行的操作。首先取得 rs2 寄存器第 0 位到第 7 位这 8 位数据，即一个字节。然后，把这个字节数据储存到 rs1+imm 为地址的内存单元中。</p><p>接着是代码验证环节，为了方便调试，我们在工程目录下新建一个 store.S 文件，并在其中用汇编写上 sb_ins 函数。代码如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>.text
.globl sb_ins
#a0内存地址
#a1储存的值
sb_ins:
    sb a1, 0(a0)       #储存a1低8位到a0+0地址处
    jr ra              #返回
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>sb_ins 函数我已经帮你写好了，只有两条指令，第一条指令把 a1 寄存器的低 8 位数据，储存到 a0+0 地址处的内存单元中，第二条指令就返回了。</p><p>现在，我们一起用 VSCode 打开工程目录，把断点打在“sb a1, 0(a0) ”指令处，按下“F5”键调试一下，效果如下图：</p><figure><img src="`+c+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>图片里对应的是刚刚执行完 sb a1，0(a0) 指令之后，执行 jr ra 指令之前的状态。这时候 a0 寄存器中的值是 0x20a80，这是 byte 变量的地址，a1 是 0x80，正是十进制数据 128。</p><p>我们继续单步调试，返回到 main 函数中执行 printf 函数，打印一下 byte 变量的值，如下图所示：</p><figure><img src="'+p+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>从图中可以看到，byte 变量的初始值为 -5。调用 sb_ins 函数时，我们把 byte 的地址强制为无符号整数传给 sb_ins 函数第一个参数，把整数 128 传给 sb_ins 函数第二个参数。</p><p>C 语言调用规范告诉我们，sb_ins 函数会通过 a0、a1 寄存器传递第一个、第二个参数，之后 printf 函数输出 byte 变量的值为 128，这证明了 sb 指令是正常工作的。</p><h2 id="储存双字节指令-sh-指令" tabindex="-1"><a class="header-anchor" href="#储存双字节指令-sh-指令" aria-hidden="true">#</a> 储存双字节指令：sh 指令</h2><p>接下来要说的是储存半字指令，也是储存双字节指令。它可以把一个通用寄存器中的低[15:0]位，一共 16 位的数据（即两个字节），储存到特定地址的内存单元中，这个地址由另一个通用寄存器与一个立即数之和决定。</p><p>储存半字指令的汇编代码，书写形式是这样的：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>sh rs2,imm(rs1)
#sh 储存半字指令
#rs2 源寄存器2
#rs1 源寄存器1
#imm 立即数（-2048~2047）
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>sh 指令完成的操作用伪代码描述如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>（[rs1+imm]）= rs2[15:0]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>我来为你解释一下，上面的伪代码执行了怎样的操作。首先取得 rs2 的第 0 位到第 15 位的数据。然后把这两个字节（16 位数据）的数据，储存到 rs1+imm 这个地址的内存单元中。</p><p>好，咱们写个代码来验证一下。在 store.S 文件中，用汇编写上 sh_ins 函数。代码如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>.globl sh_ins
#a0内存地址
#a1储存的值
sh_ins:
    sh a1, 0(a0)       #储存a1低16位到a0+0地址处
    jr ra              #返回
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>与 sb_ins 函数一样，sh_ins 函数只有两条指令，但第一条指令是把 a1 寄存器的低 16 位数据，储存到 a0+0 地址处的内存单元中，第二条指令同样是返回指令。</p><p>现在我们一起用 VSCode 打开工程目录，在“sh a1, 0(a0) ”指令处打上断点，按“F5”键调试的截图如下所示：</p><figure><img src="`+m+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>图片对应的是刚刚执行完 sh a1,0(a0) 指令之后，执行 jr ra 指令之前的状态，a0 寄存器中的值是 half 变量的地址，a1 寄存器中的值是 0xa5a5。</p><p>我们继续进行单步调试，返回到 main 函数中执行 printf 函数，打印一下 half 变量的值。</p><figure><img src="'+o+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>如上图所示，half 变量的初始值为 -1。随后调用 sh_ins 函数，我们把 half 的地址强制为无符号整数传给 sh_ins 函数第一个参数，再把整数 0xa5a5 传给 sh_ins 函数第二个参数，之后 printf 函数输出 half 变量的值为 0xa5a5。这证明了 sh 指令工作正常。</p><h2 id="储存字指令-sw-指令" tabindex="-1"><a class="header-anchor" href="#储存字指令-sw-指令" aria-hidden="true">#</a> 储存字指令：sw 指令</h2><p>最后，我们来学习一下储存字指令，就是储存 32 位四字节指令，也是最常用的储存指令，它是把一个 32 位的通用寄存器，储存到特定地址的内存单元中，这个地址由另一个通用寄存器与一个立即数之和决定。</p><p>储存字指令的汇编代码书写形式如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>sw rs2,imm(rs1)
#sw 储存字指令
#rs2 源寄存器2
#rs1 源寄存器1
#imm 立即数（-2048~2047）
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中 rs1 和 rs2 可以是任何通用寄存器。立即数 imm 为 12 位二进制数据，其范围是 -2048~2047。</p><p>然后我们看看 sw 指令完成的操作，对应的伪代码描述如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>（[rs1+imm]）= rs2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这段伪代码执行的操作就是把 rs2 的 32 位数据，即四个字节数据，储存到 rs1+imm 为地址的内存单元中。</p><p>下面我们一起写代码验证一下，在 store.S 文件中，用汇编写上 sw_ins 函数。代码如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>.globl sw_ins
#a0内存地址
#a1储存的值
sw_ins:
    sw a1, 0(a0)       #储存a1到a0+0地址处
    jr ra              #返回
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>sw_ins 函数只有两条指令，第一条指令是把 a1 寄存器储存到 a0+0 地址处的内存单元中，第二条指令同样是返回指令。</p><p>毕竟眼见为实，咱们调试观察一下。用 VSCode 打开工程目录，在“sw a1, 0(a0) ”指令处打上断点，按下“F5”键调试，如下所示：</p><figure><img src="`+b+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>上图是刚刚执行完 sw a1,0(a0) 指令之后，执行 jr ra 指令之前的状态。a0 寄存器中的值是 word 变量的地址，a1 寄存器中的值是 0，执行完这个 sw_ins 函数后，word 变量的值应该变为 0 了。</p><p>我们继续单步调试，执行返回到 main 函数中执行 printf 函数，打印一下 word 变量的值，如下图所示：</p><figure><img src="'+g+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>可以看到图中 word 变量的初始值为 0xfffffffff，随后调用 sw_ins 函数，我们把 word 变量的地址强制为无符号整数传给 sw_ins 函数第一个参数，把整数 0 传给 sw_ins 函数第二个参数，之后 printf 函数输出 word 变量的值确实为 0。这证明了 sw 指令工作正常。</p><p>我们已经对 sb、sh、sw 指令进行了调试，了解了它们的功能，现在我们继续一起看看 sb_ins、sh_ins、sw_ins 函数的二进制数据。</p><p>打开终端，切换到该工程目录下，输入命令：riscv64-unknown-elf-objdump -d ./main.elf &gt; ./main.ins，就会得到 main.elf 的反汇编数据文件 main.ins，我们打开这个文件，就会看到上述这些函数的二进制数据，如下所示：</p><figure><img src="'+u+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>可以看到，在图片里的反汇编代码中不但有伪指令，还有两个字节的压缩指令。编译器为了节约内存，所以会把指令压缩。比如说 ret 的机器码是 0x8082，sw a1,0(a0) 机器码是 0xc10c，它们只占用 16 位编码，即二字节。</p><p>截图里五条加载指令的机器码与指令的对应关系，你可以参考后面这张表格。</p><figure><img src="'+v+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>我画了示意图，帮你拆分一下 sb、sh、sw 指令各位段的数据，这样更容易看清楚它们是如何编码的。如下所示：</p><figure><img src="'+f+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>对照上图可以看到，sb、sh、sw 指令的功能码都不一样，借此就能区分它们。而这些储存指令的操作码都相同，立即数也相同（都是 0），这和我们编写的代码有关。</p><p>我还想提示你注意一下 sw 指令，图片里的情况跟反汇编出来的数据可能不一致，原因是编译器使用了压缩指令。图片里我还原的是 sw a1,0(a0) 正常的编码。</p><p>你可以手动在 sw_ins 函数中，插入 0x00b52023 这个数据进行验证。怎么插入这个数据使之变成一条指令呢？参考上节课还原 lw 指令的讲解，我相信你这次自己也能搞定它。</p><p>关于 RISC-V 的三条储存指令已经介绍完了，它们可以将字节、双字节、四字节储存到内存中去。实现了保存运算指令运算结果的功能，给高级语言实现各种类型的变量，提供了基础。</p><h2 id="重点回顾" tabindex="-1"><a class="header-anchor" href="#重点回顾" aria-hidden="true">#</a> 重点回顾</h2><p>今天我们一口气学完了三条储存指令。有了三条储存指令，加上我们上节课学过的五条加载指令，就构成了 RISC-V 的访存指令。</p><p>RISC-V 提供的储存字节指令、储存半字指令和储存字指令。储存指令可以把寄存器的运算结果，或者其他数据储存到特定的内存空间中。储存单位可以是一个字节、两个字节，或者四个字节。有了这些指令，不同大小、位宽的数据处理起来都很方便。</p><p>运算指令的运算结果，要通过储存指令保存到内存中，这也给高级语言实现各种类型的变量，打下了基础。</p><p>我照例用导图梳理了这节课的要点，你可以做个参考。</p><figure><img src="'+h+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题" aria-hidden="true">#</a> 思考题</h2><p>为什么三条储存指令，不需要处理数据符号问题呢？</p><p>期待你在留言区跟我互动，也可以记录一下自己的收获。如果觉得课程还不错，也别忘了分享给更多朋友。</p><blockquote><p>好像上一节问过，储存字节指令，双字节指令，字指令。数据符号可以通过指令翻译来实现，没必要在储存环节特意把有符号和无符号数据分开储存的啊<br> 作者回复: 改了 重复了</p><hr><p>加载指令，CPU无法预测该怎么补高位，于是需要编译器/程序员通过不同指令来区分。而存储指令，CPU只需要截取不需要的高位，简单粗暴，截多少是编译器/程序员的事情，截错了也是编译器/程序员的锅，不是CPU的执行问题。</p><hr><p>既然加载指令已经解决了符号数的问题，存储就不用管这个问题，就存储二进制数据就可以啦<br> 作者回复: 嗯 嗯 是的</p></blockquote>',74);function V(I,z){const s=n("ExternalLinkIcon");return d(),r("div",null,[x,w,j,C,e("p",null,[e("a",S,[i("课程的代码你可以从这里下载"),t(s)]),i("。话不多说，咱们进入正题。")]),y])}const N=a(_,[["render",V],["__file","I22-访存指令RISC-V.html.vue"]]);export{N as default};
