import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o as i,c as t,a as e,b as a,e as c,d as p}from"./app-cdabc73c.js";const s="/assets/640-1689488170609-45-166455bb.png",g="/assets/640-1689488170609-46-0576b6f1.png",l="/assets/640-1689488170609-47-d9580008.png",m="/assets/640-1689488170609-48-3b1be341.png",A="/assets/640-1689488170609-49-f1a6103d.png",_="/assets/640-1689488170609-50-715b131f.png",d={},h=e("h1",{id:"_89-白泽带你读论文-manta",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_89-白泽带你读论文-manta","aria-hidden":"true"},"#"),a(" 89-白泽带你读论文｜MANTA")],-1),u={href:"https://dl.acm.org/doi/abs/10.1145/3564625.3564634",target:"_blank",rel:"noopener noreferrer"},N=p('<p>如需转载请注明出处，侵权必究。</p><p><strong>论文题目：Making Memory Account Accountable: Analyzing and Detecting Memory Missing-account bugs for Container Platforms</strong></p><p><strong>发表会议：ACSAC 2022</strong></p><p>本文的第一作者是杨昱天，浙江大学网络空间安全学院博士生，导师是申文博老师，研究方向是操作系统保护，程序分析及云原生系统安全等。</p><h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><p>通过内存控制组实现的内存记录存在内存漏记漏洞（即内存分配但并未记录）。本文首次对内存漏记进行了系统的研究，深入分析了其在容器平台上的可利用性和安全性影响。在此基础上，作者开发了工具MANTA（Memory AccouNTing Analyzer），利用<em>基于页计数器的接口识别、内存申请-记录映射分析以及记录标志位分析</em>等技术，实现对内存漏记漏洞的自动检测和验证。作者使用该工具检测并向Linux内核社区提交了53个漏洞：其中37个已经被接收，并获得了两个CVE编号CVE-2021-3759和CVE-2022-0480。</p><h2 id="背景" tabindex="-1"><a class="header-anchor" href="#背景" aria-hidden="true">#</a> 背景</h2><p>Linux内核引入了<mark>内存控制组（memory control groups, 简称memcg）</mark>，可以在<strong>进程级</strong><u>实现内存记录</u>和<u>限制内存使用</u>。与基于虚拟机（VM）的内存分区技术相比，memcg更加细粒度和轻量级，因此memcg广泛应用于Docker等容器引擎以及基于容器的CaaS和FaaS平台。</p><p>尽管 memcg 被广泛使用，但其内部实现是非常复杂而易错的。</p><ol><li>其一，Linux内核通过在内存分配/释放路径中插入内存记录接口来实现内存记录，但由于内存分配/释放函数使用量大、用法多样，memcg在插入内存记录接口时难以覆盖到所有的执行路径，从而出现内存漏记漏洞。</li><li>其二，即使接口处于正确的位置，内存记录行为是否发生也进一步取决于记录标志，作者分析发现这些标志经常没有被正确使用，这种情况也会导致内存漏记错误。</li></ol><p>然而关于内存漏记的研究存在两个问题：</p><ul><li>1）memcg内存漏记从未被系统地分析过，所以人们不清楚内存漏记漏洞会造成什么样的安全问题；</li><li>2）目前缺少自动检测内存漏记漏洞的工具，而开发人员几乎不可能人工验证所有内存记录的正确性。</li></ul><p>针对上述的两个问题，本文致力于研究内存漏记漏洞的可利用性以及自动检测工具实现。</p><h2 id="漏洞可利用分析" tabindex="-1"><a class="header-anchor" href="#漏洞可利用分析" aria-hidden="true">#</a> 漏洞可利用分析</h2><p>下面我们介绍两个案例来说明内存漏记漏洞的安全影响。</p><p><strong>案例 1</strong></p><figure><img src="'+s+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图一 CVE-2021-3759漏洞，内核<mark>信号量对象</mark>在申请时并未被正确记录</p><p>漏洞细节如图1，内核在调用sem_alloc()进行信号量对象申请时，在第8行调用kvzalloc()函数时传入的是GFP_KERNEL标志而非GFP_KERNEL_ACCOUNT，<mark>GFP_KERNEL</mark>是内核内存分配时使用的，但是<strong>从用户空间触发的不受信任的分配</strong>必须设置<mark>GFP_KERNEL_ACCOUNT</mark>，因此用户态程序申请的所有信号量对象所占用的内存都<em>不会被memcg记录，从而导致内存漏记</em>。攻击者通过反复申请信号量对象占用大量内存并导致内存耗尽，<u>而这一过程只需要攻击者拥有普通用户权限</u>。</p><p><strong>案例 2</strong></p><figure><img src="'+g+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图二 CVE-2022-0480漏洞，攻击者可以重复申请文件锁，触发宿主机内核的内存漏记漏洞</p><p>内存漏记能穿透Kata Containers这样基于虚拟机的安全容器：Kata Containers的每个容器实例都运行在一个轻量虚拟机中以实现强隔离，然而Kata 运行时会将虚拟机内的文件操作转发给宿主机，使得宿主机面临内存漏记攻击的风险。如图2所示，攻击者是容器内的普通用户，并通过<mark>fcntl系统调用</mark>在一组文件上分配大量 POSIX 锁，此时虚拟机内核会将请求转发给宿主机机上运行的 <mark>virtio-fsd 守护进程</mark>，守护进程则会在宿主机内核中分配相应的POSIX 锁，占用大量宿主机内存。虽然守护进程的内存使用量受到宿主机 memcg 的限制，<em>但锁对象所使用的内存却因为内存漏记而未被记录</em>，导致恶意容器可以耗尽主机上的所有物理内存。</p><h2 id="漏洞检测工具-manta" tabindex="-1"><a class="header-anchor" href="#漏洞检测工具-manta" aria-hidden="true">#</a> 漏洞检测工具 MANTA</h2><p><strong>内存漏记漏洞自动检测的挑战</strong></p><p>1、没有文档或现有的研究定义memcg使用的内存记录接口。现有的工作采用自然语言处理来识别内存分配接口。然而，这些技术的启发式规则由于识别精度问题不能直接应用到内存记录接口。</p><p>2、基于识别出的内存记录接口，MANTA需要分析内存申请调用和内存记录调用间的映射关系。然而这种分析由于执行路径的深度和嵌套会变得复杂。同时内存记录是否确实发生进一步取决于传入内存申请接口的标志位。</p><p><strong>工具架构和工作流程</strong></p><figure><img src="'+l+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图三 MANTA的主要架构</p><p>MANTA的体系结构如图三所示：</p><ol><li>MANTA首先以整个内核IR作为输入，生成内核调用图。</li><li>然后使用基于页计数器的方法来识别所有记录接口 (§4.1)。</li><li>基于记录接口，MANTA建立内存申请/释放和内存记录之间的映射(§4.2)。</li><li>之后，MANTA使用记录标志分析来进一步分析内核内存记录(§4.3)。</li><li>随着检测到的内存记录错误，MANTA会评估每个错误的动态触发性 (§4.4)。</li><li>最后MANTA会生成缺陷报告。</li></ol><p><strong>1. 基于页计数器的接口识别</strong></p><p>内核没有关于内存记录接口的文档，MANTA创新性地通过<em>定位内存页计数器</em>的方法来实现内存记录接口识别。作者观察到所有内存记录接口都会维护<mark>usage counter</mark>（如 page_counter页计数器）。</p><ol><li>基于此观察，MANTA 遍历找出所有增加/减少页计数器的指令，并且将直接包含这些指令的函数标记为基本函数。</li><li>随后根据基本函数使用深度优先搜索沿着调用链向上遍历，同时标记所有访问到的函数。</li><li>遍历过程会在到达 memcg 子系统外的函数时停止。</li><li>对于被标记函数，如果它被memcg子系统外部的任意处调用，则将其标记为内存记录接口。</li></ol><figure><img src="'+m+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图四 基于页计数器的接口识别</p><p>图四为内存记录接口识别的示例：在<code>__memcg_kmem_charge</code>中，MANTA发现了对page_counter进行增加/减少的接口page_counter_try_charge(第6行)并且二次确认其第一个参数来自memcg。然后MANTA进入该函数发现其包含了增加page_counter的指令。因此MANTA认为<code>__memcg_kmem_charge</code>是一个基本函数。</p><p>从基本函数开始，MANTA沿着调用链逐步识别所有的wrapper：如果一个接口调用基本函数并且页数量来自于它的参数，MANTA把它标记为一个wrapper。<code>__memcg_kmem_charge_page</code>调用基本函数<code>__memcg_kmem_charge</code>(第29行)，而数量由<code>__memcg_kmem_charge_page</code>的参数order控制。因此，MANTA认为<code>__memcg_kmem_charge_page</code>是一个wrapper并标记。</p><p><strong>2. 内存申请-记录映射分析</strong></p><p>基于识别出的内存记录接口，MANTA需要更进一步分析内存申请和内存记录的映射关系。在正常情况下这种映射应该是一对一的，即申请一次内存只需要记录一次。<em>然而内核中的调用关系异常复杂，从内存申请到内存记录的执行路径数量可能极多</em>，</p><ol><li>因此MANTA通过提前算好每个函数是否对某个内存页有申请或记录的操作，并保存到函数摘要中（<mark>图五左①</mark>）。</li><li>接下来，对于一个函数𝑓，通过收集其callee的函数摘要并分析内存申请的位置（IsAlloc），</li><li>MANTA可以为所有non-escaped objects（对象指针未从当前函数中泄漏）构建申请-记录映射（第4-9行）。</li><li>然后MANTA调用CheckPage（<mark>图五左③</mark>）分析𝑓内部的申请-记录映射，在CheckPage中，MANTA首先报告non-escaped objects的内存漏记错误（第19行）。</li><li>对于𝑓中的escaped objects（第14-18行），它们最终将在某个函数（例如𝑓的调用者）中处理，因为内核中的所有函数都会被遍历（第3-10行）。</li></ol><figure><img src="'+A+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图五 MANTA的内存申请-记录映射分析算法（左）和示例（右）</p><p>图五右侧为该算法的具体示例：MANTA为底层内存分配函数<code>__alloc_pages_nodemask</code>生成摘要（图五右①），标记page在第6行被记录。在分析do_anonymous_page时（图五右②），MANTA获取alloc_zeroed_user_highpage_movable的函数摘要（由于alloc_zeroed_user_highpage_movable是<code>__alloc_pages_nodemask</code>的wrapper，它们具有相同的函数摘要）并且标记do_anonymous_page中的page已经（第14行）记录。然后分析do_anonymous_page内的申请-记录映射时，MANTA发现第18行处的内存已经在第14行处记录，并且page在第18行处再次记录（图五右③）。在这种情况下，MANTA会报告一个冗余警告。相反，如果page在当前函数中没有记录，MANTA会报告一个漏记警告。</p><p><strong>3. 内存记录标志位分析</strong></p><p>MANTA使用过程间的数据流追踪技术来分析记录标志位。这个过程中，MANTA会递归地追踪标志位的use-def链，且进行跨函数调用追踪。如果MANTA发现该标志位中没有GFP_ACCOUNT，就会报告一个内存漏记警告。</p><p><strong>4. 动态验证</strong></p><p>对于所有静态分析生成的警告案例，MANTA进一步通过动态触发的分析方法验证这些警告是否是可触发的漏洞。作者利用 Linux Test Project （LTP）对所有 syscall 进行测试：1）提前对存在漏洞的内核代码进行插桩，验证漏洞触发；2）对LTP没有成功执行的 syscall 手动构建测试用例。最后将发现的内存漏记漏洞转换为PoC，在云服务平台（Amazon Fargate–CaaS）上进一步测试。</p><h2 id="实验评估" tabindex="-1"><a class="header-anchor" href="#实验评估" aria-hidden="true">#</a> 实验评估</h2><p>MANTA共检测到242个内存漏记警告，其中162个能被动态触发（包括134个LTP触发、23个现有工具触发、5个手动触发），其余80个无法动态触发（72个调用链过长触发失败、8 个漏洞的 syscall 文档标记为内部使用）。由于测试用例只覆盖了一部分执行路径，72个非动态触发的bug并不都是误报，可以保守地说，MANTA的准确率大于66.9%（162/242）。</p><p>作者通过人工删除记录标志位来评估召回率：如表一，评估显示MANTA可以检测到所有19个内存漏记漏洞。虽然评估的数量有限，但仍然表明MANTA具有较高的召回率。此外，MANTA没有发现任何冗余记录错误。</p><figure><img src="'+_+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>表一 召回率评估总结</p><p>作者向Linux社区报告了53个高危漏洞，并开发了17个PoC验证这些漏洞能被重复触发导致占用大量未记录的内存。Linux社区已确认其中37个漏洞并接收了论文提交的其中18个补丁。</p><h2 id="limitations和未来工作" tabindex="-1"><a class="header-anchor" href="#limitations和未来工作" aria-hidden="true">#</a> Limitations和未来工作</h2><p><strong>静态分析局限性</strong></p><p>由于函数摘要是路径不敏感的，MANTA的分析可能会错过内存漏记漏洞。函数可以在执行路径之外对该页进行记录。在这种情况下，MANTA仍然将该页标记为已记录，导致在后续的分析中遗漏了漏记错误。相反，如果MANTA将该页标记为未记录，则会遗漏冗余错误。在未来，作者计划采用像SATURN框架这样的路径敏感函数摘要来提高可靠性。</p><p><strong>动态可触发性测试局限性</strong></p><p>目前，MANTA使用LTP测试用例来测试是否可以触发静态检测错误。然而LTP测试用例是有限的，这些测试用例不可能覆盖内核中所有可能的执行路径。因此，未来的工作之一是开发更多的测试用例，并采用模糊技术来增加代码覆盖率。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>本文首次对Linux内存漏记漏洞进行了系统的分析检测以了解容器平台上内存漏记的可利用性和安全影响。作者分析表明包括普通和安全运行时都容易遭受内存漏记导致的内存耗尽攻击。此外，内存漏记可以被利用来攻击Docker，CaaS和FaaS平台导致节点甚至整个集群崩溃。作者提出了自动检测内存漏记的工具MANTA，检测报告了53个可利用的内存漏记漏洞，其中37个已被内核开发人员确认，包括两个新的CVE。</p>',62);function T(M,f){const o=n("ExternalLinkIcon");return i(),t("div",null,[h,e("p",null,[e("a",u,[a("Making Memory Account Accountable: Analyzing and Detecting Memory Missing-account bugs for Container Platforms | Proceedings of the 38th Annual Computer Security Applications Conference (acm.org)"),c(o)]),a("。")]),N])}const C=r(d,[["render",T],["__file","89-白泽带你读论文｜MANTA.html.vue"]]);export{C as default};
