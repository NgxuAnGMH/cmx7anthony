import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as a,d as e}from"./app-cdabc73c.js";const p="/assets/fa6c2b6166d02ac37637d7da4e4b579b-58bfaf4e.jpeg",t="/assets/8f158f58dda94ec04b26200073e15449-6e73cfde.jpeg",o="/assets/2738c0c98d2ed31cbbe1fdcba01142cf-257965de.jpeg",c="/assets/3fa8123990e5ae2c86859f70a8351f4f-ad5b6b04.jpeg",l="/assets/image-20220707143313628-964c741b.png",i={},u=e('<h1 id="_23-物理内存管理-上-会议室管理员如何分配会议室" tabindex="-1"><a class="header-anchor" href="#_23-物理内存管理-上-会议室管理员如何分配会议室" aria-hidden="true">#</a> 23 | 物理内存管理（上）：会议室管理员如何分配会议室？</h1><p>前一节，我们讲了如何从项目经理的角度看内存，看到的是虚拟地址空间，这些虚拟的地址，总是要映射到物理的页面。这一节，我们来看，物理的页面是如何管理的。</p><h2 id="物理内存的组织方式" tabindex="-1"><a class="header-anchor" href="#物理内存的组织方式" aria-hidden="true">#</a> 物理内存的组织方式</h2><p>前面咱们讲虚拟内存，涉及物理内存的映射的时候，我们总是把内存想象成它是由连续的一页一页的块组成的。</p><h3 id="_1-平坦内存模型" tabindex="-1"><a class="header-anchor" href="#_1-平坦内存模型" aria-hidden="true">#</a> 1 平坦内存模型</h3><p>我们可以从 0 开始对物理页编号，这样每个物理页都会有个页号。</p><p>由于物理地址是连续的，页也是连续的，每个页大小也是一样的。<strong>因而对于任何一个(物理)地址，只要直接除一下每页的大小，很容易直接算出在哪一页</strong>。每个页有一个结构 <code>struct page</code> 表示，这个结构也是放在一个数组里面，这样根据<mark>页号</mark>，很容易通过<mark>下标</mark>找到<mark>相应的 struct page 结构</mark>。</p><p>如果是这样，整个物理内存的布局就非常简单、易管理，这就是最经典的**<code>平坦内存模型</code>**（Flat Memory Model）。</p><p>我们讲 x86 的工作模式的时候，讲过 CPU 是通过总线去访问内存的，这就是最经典的内存使用方式。</p><img src="'+p+'" alt="img" style="zoom:25%;"><h3 id="_2-对称多处理器" tabindex="-1"><a class="header-anchor" href="#_2-对称多处理器" aria-hidden="true">#</a> 2 对称多处理器</h3><p>在这种模式下，CPU 也会有多个，在总线的一侧。所有的内存条组成一大片内存，在总线的另一侧，所有的 CPU 访问内存都要过总线，而且距离都是一样的，这种模式称为 <strong>SMP</strong>（Symmetric multiprocessing），即**<code>对称多处理器</code><strong>。当然，它也有一个</strong>显著的缺点，就是总线会成为瓶颈，因为数据都要走它**。</p><img src="'+t+`" alt="img" style="zoom:25%;"><h3 id="_3-非连续内存模型-稀疏内存模型" tabindex="-1"><a class="header-anchor" href="#_3-非连续内存模型-稀疏内存模型" aria-hidden="true">#</a> 3 非连续内存模型 / 稀疏内存模型</h3><p>为了提高性能和可扩展性，后来有了一种更高级的模式，<strong>NUMA</strong>（Non-uniform memory access），<strong><code>非一致内存访问</code></strong>。</p><ol><li>在这种模式下，<strong>内存不是一整块</strong>。</li><li><strong>每个 CPU 都有自己的本地内存</strong>，CPU 访问本地内存不用过总线，因而速度要快很多，</li><li>每个 CPU 和内存在一起，称为<strong>一个 NUMA 节点</strong>。</li><li>但是，<strong>在本地内存不足的情况下</strong>，每个 CPU 都可以去另外的 NUMA 节点申请内存，这个时候访问延时就会比较长。</li></ol><p>这样，<strong>内存被分成了多个节点，每个节点再被分成一个一个的页面</strong>。由于页需要全局唯一定位，页还是需要有全局唯一的页号的。但是由于物理内存不是连起来的了，<strong>页号也就不再连续了</strong>。于是内存模型就变成了**<code>非连续内存模型</code>**，管理起来就复杂一些。</p><p>这里需要指出的是，NUMA 往往是非连续内存模型。而非连续内存模型不一定就是 NUMA，有时候一大片内存的情况下，也会有物理内存地址不连续的情况。</p><p>后来内存技术牛了，可以支持**<code>热插拔</code><strong>了。这个时候，不连续成为常态，于是就有了</strong><code>稀疏内存模型</code>**。</p><h2 id="节点-pglist-data-pg-data-t" tabindex="-1"><a class="header-anchor" href="#节点-pglist-data-pg-data-t" aria-hidden="true">#</a> 节点: pglist_data / pg_data_t</h2><p>我们主要解析当前的主流场景，NUMA 方式。我们首先要能够表示 NUMA 节点的概念，于是有了下面这个结构 typedef struct pglist_data pg_data_t，它里面有以下的成员变量：</p><ul><li>每一个节点都有自己的 ID：<code>node_id</code>；(节点有自己本地内存)</li><li><code>node_mem_map</code> 就是这个节点的 struct page 数组，用于描述这个节点里面的所有的页；</li><li><code>node_start_pfn</code> 是这个节点的起始页号；</li><li><code>node_spanned_pages</code> 是这个节点中包含不连续的物理内存地址的页面数；</li><li><code>node_present_pages</code> 是真正可用的物理页面的数目。</li></ul><blockquote><p>例如，64M 物理内存隔着一个 4M 的空洞，然后是另外的 64M 物理内存。这样换算成页面数目就是，16K 个页面隔着 1K 个页面，然后是另外 16K 个页面。这种情况下，node_spanned_pages 就是 33K 个页面，node_present_pages 就是 32K 个页面。</p></blockquote><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">pglist_data</span> <span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">zone</span> node_zones<span class="token punctuation">[</span>MAX_NR_ZONES<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">zonelist</span> node_zonelists<span class="token punctuation">[</span>MAX_ZONELISTS<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> nr_zones<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>node_mem_map<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> node_start_pfn<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> node_present_pages<span class="token punctuation">;</span> <span class="token comment">/* total number of physical pages */</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> node_spanned_pages<span class="token punctuation">;</span> <span class="token comment">/* total size of physical page range, including holes */</span>
  <span class="token keyword">int</span> node_id<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span> <span class="token class-name">pg_data_t</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="节点-多个区域" tabindex="-1"><a class="header-anchor" href="#节点-多个区域" aria-hidden="true">#</a> 节点 -&gt; 多个区域</h3><p><strong>每一个节点分成一个个区域 zone</strong>，放在数组 node_zones 里面。这个数组的大小为 MAX_NR_ZONES。我们来看区域的定义。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">enum</span> <span class="token class-name">zone_type</span> <span class="token punctuation">{</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_ZONE_DMA</span></span>
  ZONE_DMA<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_ZONE_DMA32</span></span>
  ZONE_DMA32<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
  ZONE_NORMAL<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_HIGHMEM</span></span>
  ZONE_HIGHMEM<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
  ZONE_MOVABLE<span class="token punctuation">,</span>
  __MAX_NR_ZONES
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="dma-直接内存存取" tabindex="-1"><a class="header-anchor" href="#dma-直接内存存取" aria-hidden="true">#</a> DMA 直接内存存取</h3><p>ZONE_DMA 是指可用于作 **DMA（Direct Memory Access，直接内存存取）**的内存。</p><p>DMA 是这样一种机制：要把外设的数据读入内存或把内存的数据传送到外设，原来都要通过 CPU 控制完成，但是这会占用 CPU，影响 CPU 处理其他事情，所以有了 DMA 模式。CPU 只需向 <mark>DMA 控制器</mark>下达指令，让 DMA 控制器来处理数据的传送，数据传送完毕再把信息反馈给 CPU，这样就可以解放 CPU。</p><p>对于 64 位系统，有两个 DMA 区域。除了上面说的 <code>ZONE_DMA</code>，还有 <code>ZONE_DMA32</code>。在这里你大概理解 DMA 的原理就可以，不必纠结，我们后面会讲 DMA 的机制。</p><ul><li><code>ZONE_NORMAL</code> 是<strong>直接映射区</strong>，就是上一节讲的，从物理内存到虚拟内存的内核区域，<code>通过加上一个常量直接映射</code>。<br> 其实就是又一个普通的可映射的物理内存区域，只不过连续且简单的映射关系。</li><li><code>ZONE_HIGHMEM</code> 是<strong>高端内存区</strong>，就是上一节讲的，<code>对于 32 位</code>系统来说超过 896M 的地方，<code>对于 64 位</code>没必要有的一段区域。</li><li><code>ZONE_MOVABLE</code> 是<strong>可移动区域</strong>，通过将物理内存划分为可移动分配区域和不可移动分配区域来<code>避免内存碎片</code>。</li></ul><p>这里你需要注意一下，我们刚才对于区域的划分，都是针对<mark>物理内存</mark>的。</p><p><code>nr_zones</code> 表示当前节点的区域的数量。<code>node_zonelists</code> 是备用节点和它的内存区域的情况。前面讲 NUMA 的时候，我们讲了 CPU 访问内存，本节点速度最快，但是如果本节点内存不够怎么办，还是需要去其他节点进行分配。毕竟，就算在备用节点里面选择，<strong>慢了点也比没有强</strong>。</p><p><strong>既然整个内存被分成了多个节点</strong>，那 pglist_data 应该放在一个数组里面。每个节点一项，就像下面代码里面一样：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">pglist_data</span> <span class="token operator">*</span>node_data<span class="token punctuation">[</span>MAX_NUMNODES<span class="token punctuation">]</span> __read_mostly<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="区域" tabindex="-1"><a class="header-anchor" href="#区域" aria-hidden="true">#</a> 区域</h2><p>到这里，我们<strong>把内存分成了<code>节点</code>，把节点分成了<code>区域</code></strong>。接下来我们来看，一个区域里面是如何组织的。</p><p>表示区域的数据结构 zone 的定义如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">zone</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">struct</span> <span class="token class-name">pglist_data</span>  <span class="token operator">*</span>zone_pgdat<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">per_cpu_pageset</span> __percpu <span class="token operator">*</span>pageset<span class="token punctuation">;</span>


  <span class="token keyword">unsigned</span> <span class="token keyword">long</span>    zone_start_pfn<span class="token punctuation">;</span>


  <span class="token comment">/*
   * spanned_pages is the total pages spanned by the zone, including
   * holes, which is calculated as:
   *   spanned_pages = zone_end_pfn - zone_start_pfn;
   *
   * present_pages is physical pages existing within the zone, which
   * is calculated as:
   *  present_pages = spanned_pages - absent_pages(pages in holes);
   *
   * managed_pages is present pages managed by the buddy system, which
   * is calculated as (reserved_pages includes pages allocated by the
   * bootmem allocator):
   *  managed_pages = present_pages - reserved_pages;
   *
   */</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span>    managed_pages<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span>    spanned_pages<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span>    present_pages<span class="token punctuation">;</span>


  <span class="token keyword">const</span> <span class="token keyword">char</span>    <span class="token operator">*</span>name<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token comment">/* free areas of different sizes */</span>
  <span class="token keyword">struct</span> <span class="token class-name">free_area</span>  free_area<span class="token punctuation">[</span>MAX_ORDER<span class="token punctuation">]</span><span class="token punctuation">;</span>


  <span class="token comment">/* zone flags, see below */</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span>    flags<span class="token punctuation">;</span>


  <span class="token comment">/* Primarily protects free_area */</span>
  <span class="token class-name">spinlock_t</span>    lock<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span> ____cacheline_internodealigned_in_
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在一个 zone 里面，<code>zone_start_pfn</code> 表示属于这个 zone 的第一个页。</p><p>如果我们仔细看代码的注释，可以看到，spanned_pages = zone_end_pfn - zone_start_pfn，也即 spanned_pages 指的是不管中间有没有物理内存空洞，反正就是<strong>最后的页号减去起始的页号</strong>。</p><p>present_pages = spanned_pages - absent_pages(pages in holes)，也即 present_pages 是这个 zone 在物理内存中真实存在的所有 page 数目。</p><p>managed_pages = present_pages - reserved_pages，也即 managed_pages 是这个 zone 被<mark>伙伴系统</mark>管理的所有的 page 数目，伙伴系统的工作机制我们后面会讲。</p><h3 id="冷热页-cpu高速缓存" tabindex="-1"><a class="header-anchor" href="#冷热页-cpu高速缓存" aria-hidden="true">#</a> 冷热页/CPU高速缓存</h3><p><code>per_cpu_pageset</code> 用于区分<strong>冷热页</strong>。什么叫冷热页呢？咱们讲 x86 体系结构的时候讲过，为了让 CPU 快速访问段描述符，在 CPU 里面有段描述符缓存。CPU 访问这个缓存的速度比内存快得多。同样对于页面来讲，也是这样的。</p><ol><li>如果一个页被加载到 CPU 高速缓存里面，这就是一个热页（Hot Page），CPU 读起来速度会快很多，</li><li>如果没有就是冷页（Cold Page）。</li></ol><p>由于每个 CPU 都有自己的高速缓存，因而 per_cpu_pageset 也是每个 CPU 一个。</p><h2 id="页-struct-page" tabindex="-1"><a class="header-anchor" href="#页-struct-page" aria-hidden="true">#</a> 页: struct page</h2><p>了解了区域 zone，接下来我们就到了组成物理内存的基本单位，<code>页的数据结构 struct page</code>。这是一个特别复杂的结构，里面有很多的 union，union 结构是在 C 语言中被用于<strong>同一块内存<code>根据情况保存</code>不同类型数据</strong>的一种方式。这里之所以用了 union，是因为一个物理页面使用模式有多种。</p><h3 id="_1-整-匿名页-匿名映射文件-伙伴系统" tabindex="-1"><a class="header-anchor" href="#_1-整-匿名页-匿名映射文件-伙伴系统" aria-hidden="true">#</a> 1 [整] 匿名页/匿名映射文件 伙伴系统</h3><p><strong><code>第一种模式</code></strong>，要用就用一整页。这一整页的内存，或者直接和虚拟地址空间建立映射关系，我们把这种称为匿名页（Anonymous Page）。或者用于关联一个文件，然后再和虚拟地址空间建立映射关系，这样的文件，我们称为内存映射文件（Memory-mapped File）。</p><p>如果某一页是这种使用模式，则会使用 union 中的以下变量：</p><ul><li>struct address_space *mapping 就是用于内存映射，如果是匿名页，最低位为 1；如果是映射文件，最低位为 0；</li><li>pgoff_t index 是在映射区的偏移量；</li><li>atomic_t _mapcount，每个进程都有自己的页表，这里指有多少个页表项指向了这个页；</li><li>struct list_head lru 表示这一页应该在一个链表上，例如这个页面被换出，就在换出页的链表中；</li><li>compound 相关的变量用于复合页（Compound Page），就是将物理上连续的两个或多个页看成一个独立的大页。</li></ul><h3 id="_2-碎-内存对象-slab分配器" tabindex="-1"><a class="header-anchor" href="#_2-碎-内存对象-slab分配器" aria-hidden="true">#</a> 2 [碎] 内存对象? SLAB分配器</h3><p><strong><code>第二种模式</code></strong>，仅需分配小块内存。有时候，我们不需要一下子分配这么多的内存，例如分配一个 task_struct 结构，只需要分配小块的内存，去存储这个进程描述结构的对象。为了满足对这种小内存块的需要，Linux 系统采用了一种被称为 <strong>slab allocator</strong> 的技术，用于分配称为 slab 的一小块内存。它的基本原理是从内存管理模块申请一整块页，然后划分成多个小块的存储池，用复杂的队列来维护这些小块的状态（状态包括：被分配了 / 被放回池子 / 应该被回收）。</p><p>也正是因为 slab allocator 对于队列的维护过于复杂，后来就有了一种不使用队列的分配器 slub allocator，后面我们会解析这个分配器。但是你会发现，它里面还是用了很多 slab 的字眼，因为它保留了 slab 的用户接口，可以看成 slab allocator 的另一种实现。</p><p>还有一种小块内存的分配器称为 <strong>slob</strong>，非常简单，主要使用在小型的嵌入式系统。</p><p>如果某一页是用于分割成一小块一小块的内存进行分配的使用模式，则会使用 union 中的以下变量：</p><ul><li>s_mem 是已经分配了正在使用的 slab 的第一个对象；</li><li>freelist 是池子中的空闲对象；</li><li>rcu_head 是需要释放的列表。</li></ul><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token punctuation">{</span>
      <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>
      <span class="token keyword">union</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">address_space</span> <span class="token operator">*</span>mapping<span class="token punctuation">;</span>  
        <span class="token keyword">void</span> <span class="token operator">*</span>s_mem<span class="token punctuation">;</span>      <span class="token comment">/* slab first object */</span>
        <span class="token class-name">atomic_t</span> compound_mapcount<span class="token punctuation">;</span>  <span class="token comment">/* first tail page */</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
      <span class="token keyword">union</span> <span class="token punctuation">{</span>
        <span class="token class-name">pgoff_t</span> index<span class="token punctuation">;</span>    <span class="token comment">/* Our offset within mapping. */</span>
        <span class="token keyword">void</span> <span class="token operator">*</span>freelist<span class="token punctuation">;</span>    <span class="token comment">/* sl[aou]b first free object */</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
      <span class="token keyword">union</span> <span class="token punctuation">{</span>
        <span class="token keyword">unsigned</span> counters<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token punctuation">{</span>
          <span class="token keyword">union</span> <span class="token punctuation">{</span>
            <span class="token class-name">atomic_t</span> _mapcount<span class="token punctuation">;</span>
            <span class="token keyword">unsigned</span> <span class="token keyword">int</span> active<span class="token punctuation">;</span>    <span class="token comment">/* SLAB */</span>
            <span class="token keyword">struct</span> <span class="token punctuation">{</span>      <span class="token comment">/* SLUB */</span>
              <span class="token keyword">unsigned</span> inuse<span class="token operator">:</span><span class="token number">16</span><span class="token punctuation">;</span>
              <span class="token keyword">unsigned</span> objects<span class="token operator">:</span><span class="token number">15</span><span class="token punctuation">;</span>
              <span class="token keyword">unsigned</span> frozen<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> units<span class="token punctuation">;</span>      <span class="token comment">/* SLOB */</span>
          <span class="token punctuation">}</span><span class="token punctuation">;</span>
          <span class="token class-name">atomic_t</span> _refcount<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
      <span class="token keyword">union</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">list_head</span> lru<span class="token punctuation">;</span>  <span class="token comment">/* Pageout list   */</span>
        <span class="token keyword">struct</span> <span class="token class-name">dev_pagemap</span> <span class="token operator">*</span>pgmap<span class="token punctuation">;</span> 
        <span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token comment">/* slub per cpu partial pages */</span>
          <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>  <span class="token comment">/* Next partial slab */</span>
          <span class="token keyword">int</span> pages<span class="token punctuation">;</span>  <span class="token comment">/* Nr of partial slabs left */</span>
          <span class="token keyword">int</span> pobjects<span class="token punctuation">;</span>  <span class="token comment">/* Approximate # of objects */</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">rcu_head</span> rcu_head<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token punctuation">{</span>
          <span class="token keyword">unsigned</span> <span class="token keyword">long</span> compound_head<span class="token punctuation">;</span> <span class="token comment">/* If bit zero is set */</span>
          <span class="token keyword">unsigned</span> <span class="token keyword">int</span> compound_dtor<span class="token punctuation">;</span>
          <span class="token keyword">unsigned</span> <span class="token keyword">int</span> compound_order<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
      <span class="token keyword">union</span> <span class="token punctuation">{</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> private<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>slab_cache<span class="token punctuation">;</span>  <span class="token comment">/* SL[AU]B: Pointer to slab */</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="页的分配-伙伴系统" tabindex="-1"><a class="header-anchor" href="#页的分配-伙伴系统" aria-hidden="true">#</a> 页的分配: 伙伴系统</h2><p>好了，前面我们讲了物理内存的组织，从节点到区域到页到小块。接下来，我们来看物理内存的分配。</p><p>对于要分配比较大的内存，例如到分配页级别的，可以使用<strong>伙伴系统</strong>（Buddy System）。</p><p>Linux 中的内存管理的“页”大小为 4KB。把所有的空闲页分组为 11 个<mark>页块链表</mark>，每个块链表分别包含很多个大小的页块，<mark>有 1、2、4、8、16、32、64、128、256、512 和 1024 个连续页的页块</mark>。最大可以申请 1024 个连续页，对应 4MB 大小的连续内存。每个页块的第一个页的物理地址是该页块大小的整数倍。</p><img src="`+o+`" alt="img" style="zoom:25%;"><p>第 i 个页块链表中，页块中页的数目为 2^i。</p><p>在 struct zone 里面有以下的定义：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">free_area</span>  free_area<span class="token punctuation">[</span>MAX_ORDER<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>MAX_ORDER 就是指数。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_ORDER</span> <span class="token expression"><span class="token number">11</span></span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当向内核请求分配 (2<sup>(i-1)，2</sup>i]数目的页块时，按照 2^i 页块请求处理。如果对应的页块链表中没有空闲页块，那我们就在更大的页块链表中去找。当分配的页块中有多余的页时，伙伴系统会根据多余的页块大小插入到对应的空闲页块链表中。</p><p>例如，要请求一个 128 个页的页块时，先检查 128 个页的页块链表是否有空闲块。如果没有，则查 256 个页的页块链表；如果有空闲块的话，则将 256 个页的页块分成两份，一份使用，一份插入 128 个页的页块链表中。如果还是没有，就查 512 个页的页块链表；如果有的话，就分裂为 128、128、256 三个页块，一个 128 的使用，剩余两个插入对应页块链表。</p><p>上面这个过程，我们可以在分配页的函数 alloc_pages 中看到。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>
<span class="token function">alloc_pages</span><span class="token punctuation">(</span><span class="token class-name">gfp_t</span> gfp_mask<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> order<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">alloc_pages_current</span><span class="token punctuation">(</span>gfp_mask<span class="token punctuation">,</span> order<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token comment">/**
 *   alloc_pages_current - Allocate pages.
 *
 *  @gfp:
 *    %GFP_USER   user allocation,
 *        %GFP_KERNEL kernel allocation,
 *        %GFP_HIGHMEM highmem allocation,
 *        %GFP_FS     don&#39;t call back into a file system.
 *        %GFP_ATOMIC don&#39;t sleep.
 *  @order: Power of two of allocation size in pages. 0 is a single page.
 *
 *  Allocate a page from the kernel page pool.  When not in
 *  interrupt context and apply the current process NUMA policy.
 *  Returns NULL when no page can be allocated.
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span><span class="token function">alloc_pages_current</span><span class="token punctuation">(</span><span class="token class-name">gfp_t</span> gfp<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> order<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">mempolicy</span> <span class="token operator">*</span>pol <span class="token operator">=</span> <span class="token operator">&amp;</span>default_policy<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  page <span class="token operator">=</span> <span class="token function">__alloc_pages_nodemask</span><span class="token punctuation">(</span>gfp<span class="token punctuation">,</span> order<span class="token punctuation">,</span>
        <span class="token function">policy_node</span><span class="token punctuation">(</span>gfp<span class="token punctuation">,</span> pol<span class="token punctuation">,</span> <span class="token function">numa_node_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token function">policy_nodemask</span><span class="token punctuation">(</span>gfp<span class="token punctuation">,</span> pol<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">return</span> page<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>alloc_pages 会调用 alloc_pages_current，这里面的注释比较容易看懂了，gfp 表示希望在哪个区域中分配这个内存：</p><ul><li>GFP_USER 用于分配一个页映射到用户进程的虚拟地址空间，并且希望直接被内核或者硬件访问，主要用于一个用户进程希望通过内存映射的方式，访问某些硬件的缓存，例如显卡缓存；</li><li>GFP_KERNEL 用于内核中分配页，主要分配 ZONE_NORMAL 区域，也即直接映射区；</li><li>GFP_HIGHMEM，顾名思义就是主要分配高端区域的内存。</li></ul><p>另一个参数 order，就是表示分配 2 的 order 次方个页。</p><p>接下来调用 __alloc_pages_nodemask。这是伙伴系统的核心方法。它会调用 get_page_from_freelist。这里面的逻辑也很容易理解，就是在一个循环中先看当前节点的 zone。如果找不到空闲页，则再看备用节点的 zone。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>
<span class="token function">get_page_from_freelist</span><span class="token punctuation">(</span><span class="token class-name">gfp_t</span> gfp_mask<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> order<span class="token punctuation">,</span> <span class="token keyword">int</span> alloc_flags<span class="token punctuation">,</span>
            <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">alloc_context</span> <span class="token operator">*</span>ac<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token function">for_next_zone_zonelist_nodemask</span><span class="token punctuation">(</span>zone<span class="token punctuation">,</span> z<span class="token punctuation">,</span> ac<span class="token operator">-&gt;</span>zonelist<span class="token punctuation">,</span> ac<span class="token operator">-&gt;</span>high_zoneidx<span class="token punctuation">,</span> ac<span class="token operator">-&gt;</span>nodemask<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    page <span class="token operator">=</span> <span class="token function">rmqueue</span><span class="token punctuation">(</span>ac<span class="token operator">-&gt;</span>preferred_zoneref<span class="token operator">-&gt;</span>zone<span class="token punctuation">,</span> zone<span class="token punctuation">,</span> order<span class="token punctuation">,</span>
        gfp_mask<span class="token punctuation">,</span> alloc_flags<span class="token punctuation">,</span> ac<span class="token operator">-&gt;</span>migratetype<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每一个 zone，都有伙伴系统维护的各种大小的队列，就像上面伙伴系统原理里讲的那样。这里调用 rmqueue 就很好理解了，就是找到合适大小的那个队列，把页面取下来。</p><p>接下来的调用链是 <code>rmqueue</code>-&gt;<code>__rmqueue</code>-&gt;<code>__rmqueue_smallest</code>。在这里，我们能清楚看到伙伴系统的逻辑。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">inline</span>
<span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span><span class="token function">__rmqueue_smallest</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">zone</span> <span class="token operator">*</span>zone<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> order<span class="token punctuation">,</span>
            <span class="token keyword">int</span> migratetype<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> current_order<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">free_area</span> <span class="token operator">*</span>area<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">;</span>


  <span class="token comment">/* Find a page of the appropriate size in the preferred list */</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>current_order <span class="token operator">=</span> order<span class="token punctuation">;</span> current_order <span class="token operator">&lt;</span> MAX_ORDER<span class="token punctuation">;</span> <span class="token operator">++</span>current_order<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    area <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>zone<span class="token operator">-&gt;</span>free_area<span class="token punctuation">[</span>current_order<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    page <span class="token operator">=</span> <span class="token function">list_first_entry_or_null</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>area<span class="token operator">-&gt;</span>free_list<span class="token punctuation">[</span>migratetype<span class="token punctuation">]</span><span class="token punctuation">,</span>
              <span class="token keyword">struct</span> <span class="token class-name">page</span><span class="token punctuation">,</span> lru<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>page<span class="token punctuation">)</span>
      <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token function">list_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>page<span class="token operator">-&gt;</span>lru<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">rmv_page_order</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span>
    area<span class="token operator">-&gt;</span>nr_free<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token function">expand</span><span class="token punctuation">(</span>zone<span class="token punctuation">,</span> page<span class="token punctuation">,</span> order<span class="token punctuation">,</span> current_order<span class="token punctuation">,</span> area<span class="token punctuation">,</span> migratetype<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">set_pcppage_migratetype</span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> migratetype<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> page<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>


  <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从当前的 order，也即指数开始，在伙伴系统的 free_area 找 2^order 大小的页块。如果链表的第一个不为空，就找到了；如果为空，就到更大的 order 的页块链表里面去找。找到以后，除了将页块从链表中取下来，我们还要把多余部分放到其他页块链表里面。expand 就是干这个事情的。area–就是伙伴系统那个表里面的前一项，前一项里面的页块大小是当前项的页块大小除以 2，size 右移一位也就是除以 2，list_add 就是加到链表上，nr_free++ 就是计数加 1。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">expand</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">zone</span> <span class="token operator">*</span>zone<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">,</span>
  <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">free_area</span> <span class="token operator">*</span>area<span class="token punctuation">,</span>
  <span class="token keyword">int</span> migratetype<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> size <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> high<span class="token punctuation">;</span>


  <span class="token keyword">while</span> <span class="token punctuation">(</span>high <span class="token operator">&gt;</span> low<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    area<span class="token operator">--</span><span class="token punctuation">;</span>
    high<span class="token operator">--</span><span class="token punctuation">;</span>
    size <span class="token operator">&gt;&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">list_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>page<span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">.</span>lru<span class="token punctuation">,</span> <span class="token operator">&amp;</span>area<span class="token operator">-&gt;</span>free_list<span class="token punctuation">[</span>migratetype<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    area<span class="token operator">-&gt;</span>nr_free<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token function">set_page_order</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>page<span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="总结时刻" tabindex="-1"><a class="header-anchor" href="#总结时刻" aria-hidden="true">#</a> 总结时刻</h2><p>对于物理内存的管理的讲解，到这里要告一段落了。这一节我们主要讲了物理内存的组织形式，就像下面图中展示的一样。</p><ul><li><p>如果有多个 CPU，那就有多个节点。每个节点用 struct pglist_data 表示，放在一个数组里面。</p></li><li><p>每个节点分为多个区域，每个区域用 struct zone 表示，也放在一个数组里面。</p></li><li><p>每个区域分为多个页。为了方便分配，空闲页放在 struct free_area 里面，使用伙伴系统进行管理和分配，每一页用 struct page 表示。</p></li></ul><img src="`+c+'" alt="img" style="zoom:25%;"><img src="'+l+`" alt="image-20220707143313628" style="zoom:33%;"><blockquote><ul><li>物理内存组织方式</li><li>每个物理页由 struct page 表示 <ul><li>物理页连续, page 放入一个数组中, 称为平坦内存模型</li><li>多个 CPU 通过总线访问内存, 称为 SMP 对称多处理器(采用平坦内存模型, 总线成为瓶颈)</li><li>每个 CPU 都有本地内存, 访问内存不用总线, 称为 NUMA 非一致内存访问</li><li>本地内存称为 NUMA 节点, 本地内存不足可以向其他节点申请</li><li>NUMA 采用非连续内存模型，页号不连续</li><li>另外若内存支持热插拔，则采用稀疏内存模型</li></ul></li><li>节点</li><li>用 pglist_data 表示 NUMA 节点，多个节点信息保存在 node_data 数组中 <ul><li>pglist_data 包括 id，page 数组,起始页号, 总页数, 可用页数</li><li>节点分为多个区域 zone, 包括 DMA; 直接映射区; 高端内存区; 可移动区(避免内存碎片)</li></ul></li><li>区域 zone</li><li>用 zone 表示; 包含第一个页页号; 区域总页数; 区域实际页数; 被伙伴系统管理的页数; 用 per_cpu_pageset 区分冷热页(热页, 被 CPU 缓存的页)</li><li>页</li><li>用 struct page 表示, 有多种使用模式, 因此 page 结构体多由 union 组成 <ul><li>使用一整个页: 1) 直接和虚拟地址映射(匿名页); 2) 与文件关联再与虚拟地址映射(内存映射文件)</li><li>page 记录: 标记用于内存映射; 指向该页的页表数; 换出页的链表; 复合页, 用于合成大页;</li><li>分配小块内存:</li><li>Linux 采用 slab allocator 技术; 申请一整页, 分为多个小块存储池, 用队列维护其状态(较复杂) <ul><li>slub allocator 更简单</li><li>slob allocator 用于嵌入式</li><li>page 记录: 第一个 slab 对象; 空闲列表; 待释放列表</li></ul></li></ul></li><li>页分配</li><li>分配较大内存(页级别), 使用伙伴系统 <ul><li>Linux 把空闲页分组为 11 个页块链表, 链表管理大小不同的页块(页大小 2^i * 4KB)</li><li>分配大页剩下的内存, 插入对应空闲链表</li><li>alloc_pages-&gt;alloc_pages_current 用 gfp 指定在哪个 zone 分配</li></ul></li></ul></blockquote><h2 id="课堂练习" tabindex="-1"><a class="header-anchor" href="#课堂练习" aria-hidden="true">#</a> 课堂练习</h2><p>伙伴系统是一种非常精妙的实现方式，无论你使用什么语言，请自己实现一个这样的分配系统，说不定哪天你在做某个系统的时候，就用到了。</p><p>欢迎留言和我分享你的疑惑和见解，也欢迎你收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习、进步。</p><h2 id="课后讨论" tabindex="-1"><a class="header-anchor" href="#课后讨论" aria-hidden="true">#</a> 课后讨论</h2><p>还是没理解那个“伙伴系统”为何会命名为伙伴系统，没感觉到有“伙伴”的感觉<br> 作者回复: 一整个会议室，划分为两个1/2，再划分为四个1/4，两个1/4就是伙伴呀</p><hr><p>来来来，经过一段时间的学习，我有明确的答案了。它为什么叫伙伴系统，伙伴体现在哪。<br><strong>一个page block它的buddy是唯一的，它只能和它的唯一buddy组合成大一级的page block</strong>。</p><p>Two blocks are buddies if:<br> –They have the same size, e.g. b,<br> –They are adjacent to each other,<br> –the physical address of the first page of the first block is a multiple of 2 x b x PAGE_SIZE.<br> 这里考虑的是两个buddy合成的新block的首地址要是这个新block的size的整数倍。</p><p>A split block can only be merged with its unique buddy block：<br> 为什么呢？因为每个page block的首页的起始物理地址一定要是page block size的整数倍。<br> 比如一个page block是16个页，那么这个page block的起始物理地址一定是16*PAGE_SIZE的整数倍。<br> 比如 order 为0的 page 0,1,2,3。0和1是buddy，1和2就不能是buddy。因为1和2不能merge成 order 为1的 page block，因为起始地址1不是block size 2的整数倍。</p><p>下面给出如何找到一个page block的唯一buddy<br> To find the buddy block of a page block __find_buddy_pfn(page_pfn, order) (mm/internal.h)</p><div class="language-txt line-numbers-mode" data-ext="txt"><pre class="language-txt"><code> * 1) Any buddy B1 will have an order O twin B2 which satisfies
 * the following equation:
 *     B2 = B1 ^ (1 &lt;&lt; O)
 * For example, if the starting buddy (buddy2) is #8 its order
 * 1 buddy is #10:
 *     B2 = 8 ^ (1 &lt;&lt; 1) = 8 ^ 2 = 10
 * 同样的若是B1是10,它的order 1 buddy B2就是8.
 *     B2 = 10 ^ (1 &lt;&lt; 1) = 10 ^ 2 = 8
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><p>我理解到的是，要128页，128页的area没空闲了，<strong>就找256页要一个128页。这样就多了个128页。这个多出来的128页，正好加入到128页的area里</strong>。你看是不是“伙伴”，我不够找你要，多出来的我来帮你管。</p><p><strong>在分配的过程中 如果两个128相邻可以凑成256就是伙伴了，放到256的list中</strong></p><p>老师，对于32bit的系统，如果物理内存大小小于896M，那物理内存区域还有ZONE_HIGHMEM吗？您的第26节课讲到内核处理匿名页的缺页中断处理时，会调用alloc_zeroed_user_highpage_movable去高端内存区域分配物理页，对于32bit系统，物理内存小于896M的情况，这时候伙伴系统去哪里分配物理页呢？对于64bit系统，没有高端内存区域，那上述函数去哪里分配高端内存的物理页呢？<br> 作者回复: 小于就没有了。如果小于没有ZONE_HIGHMEM的话，就会退而求其次，在直接映射区分配，如果分配不到，就说明没有内存了。64位就是直接映射区分配。</p><p>关键词：物理内存的组织+分配机制。回忆文中的图</p><p>老师，我这里有一个疑惑，内存的最大连续页是1024个页，也就是4MB的大小，我们知道在一般的应用程序中，数组都是一连串的内存，那我如果要申请一个大于4MB的数组呢，操作系统会怎么样来分配呢，期待老师解惑。<br> 作者回复: <strong>这是物理内存呀。应用程序操作的是虚拟内存呀，虚拟内存大了去了</strong>。</p><p>通过本篇文章，主要学习到的知识点：在当前的<strong>主流非连续内存模型 NUMA 中，将内存分成了三层（节点 -&gt; 区域 -&gt; 页）</strong>，方便了对内存的管理；Linux 中的一页大小是 4 KB，<strong>其将空闲的页分组成了 11 个链表，当有分配内存的需求时，会从链表（大于等于分配需求，持有快最小的链表）中找出一个空闲的页块进行分配，如果没有找到空闲页块，会去更大页块的链表中进行查找，找到后进行分割等后续处理</strong>。</p><p>每个页块的第一个页的物理地址是该页块大小的整数倍。怎么理解<br> 作者回复: 大小为16个页框的块,其起始地址是16*2^12的倍数.</p><p>老师，<strong>好多数据安装时都建议关闭numa</strong>，主要是觉得numa哪里不好呢<br> 作者回复: <strong>跨节点速度慢</strong></p><p>您好，之前看过一篇文章讲解Linux内存物理模型，里面说到了三种物理模型:平坦型、非连续型、稀疏性，看完本节后，发现基于zone的buddy系统和上面讲解的几种模型的关系，理不清了。不知道，三种物理模型是不是也是基于zone的伙伴系统呢？<br> 作者回复: <strong>这三种模型的区别是page不是连续的，对于zone没有影响</strong></p><p>有些应用会要求<strong>关闭numa</strong>那么这里numanode就为1吗？这时候是所有CPU共用一个pglist?<br> 作者回复: <strong>关闭就smp了</strong></p><p>从隔壁操作系统45讲来的，更加理解了！谢谢老师，我一个java的学生也来搞搞内核让自己硬核！</p><p>&quot;ZONE_NORMAL 是直接映射区，就是上一节讲的，从物理内存到虚拟内存的内核区域，通过加上一个常量直接映射。&quot; 这里讲的有问题，ZONE_NORMAL就是一个<strong>普通的可映射的物理内存区域</strong>，而不是直接映射区</p><p>学了进程管理和内存管理，在看前面内核初始化的内容，感觉理解又深刻了点。<br> 作者回复: 赞，常复习常新</p><p>老师, 从这节课我看到 slab slob 和 slub... 这...是同一个吗?<br> 作者回复: 不是同一个</p><p>感觉伙伴系统的命名是说，每次请求内存时，要么是请求到别的伙伴分剩下的内存，要么是自己切好拿走一块，剩下的给将来的伙伴。<br> 作者回复: <strong>伙伴系统是对半分割空间</strong></p><p>Linux可以理解为每页能存4KB吗？<br> 作者回复: 是的</p>`,119),r=[u];function d(k,m){return s(),a("div",null,r)}const b=n(i,[["render",d],["__file","I23-物理内存管理（上）.html.vue"]]);export{b as default};
