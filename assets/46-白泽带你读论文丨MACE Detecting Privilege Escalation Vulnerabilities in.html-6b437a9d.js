import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o as r,c as o,a as i,b as t,e as s,d as c}from"./app-cdabc73c.js";const p="/assets/640-1691464349332-87-4d0af2b3.png",d="/assets/640-1691464349332-88-5d19907b.png",g="/assets/640-1691464349333-89-89ec4016.png",l="/assets/640-1691464349333-90-4d55c879.png",h="/assets/640-1691464349333-91-0286dc74.png",_="/assets/640-1691464349333-92-95170d5f.png",u="/assets/640-1691464349333-93-7c4f2655.png",f="/assets/640-1691464349333-94-99e6efc4.png",m={},E=i("h1",{id:"_46-白泽带你读论文丨mace-detecting-privilege-escalation-vulnerabilities-in",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#_46-白泽带你读论文丨mace-detecting-privilege-escalation-vulnerabilities-in","aria-hidden":"true"},"#"),t(" 46-白泽带你读论文丨MACE: Detecting Privilege Escalation Vulnerabilities in")],-1),b=i("p",null,[i("strong",null,"MACE: Detecting Privilege Escalation Vulnerabilities in Web Applications")],-1),C={href:"https://dl.acm.org/doi/pdf/10.1145/2660267.2660337",target:"_blank",rel:"noopener noreferrer"},x=c('<p>本文发表在CCS 2014，第一作者是来自伊利诺伊大学芝加哥分校Maliheh Monshizadeh</p><h2 id="_1-主要内容" tabindex="-1"><a class="header-anchor" href="#_1-主要内容" aria-hidden="true">#</a> <strong>1 主要内容</strong></h2><p>在Web应用中，越权漏洞主要分为两类：一种是垂直越权漏洞，另外一种是水平越权漏洞。垂直越权指的是一个低级别用户尝试访问高级别用户的资源，例如普通用户尝试获得管理员用户权限；水平越权指的是攻击者尝试访问或操作与他拥有相同权限的用户的资源，例如普通用户A尝试删除普通用户B的私人文章。</p><p>作者在文中指出，实现了一个名为MACE的<mark>自动化越权漏洞发现工具</mark>，MACE基于图的静态分析方法，通过构造资源授权点和资源使用点的授权上下文内容，经过比较授权上下文的内容冲突，判定项目代码中是否存在潜在的越权漏洞点。</p><p>同时需要指出的是，由于本文发布于2014年的CCS会议，时间跨度上较为久远，到目前为止也有一些研究人员在本文工作的基础上进行了一些延伸和拓展。在SACMAT 2016中，有研究员基于本文从SQL操作语句处寻找sink点的方法，扩展了一种同时考虑全局执行变量和SQL语句的sink点搜索方法，可以在更大的资源定义范围内搜索到潜在的越权sink点，为后续静态分析过程提供更多的可行入口。在ICICN 2019上有研究人员基于本文提出的资源四元组方式，重定义了一个“Can-Do-Object”组概念，阐述了一种新的越权漏洞挖掘思路。</p><h2 id="_2-设计与实现" tabindex="-1"><a class="header-anchor" href="#_2-设计与实现" aria-hidden="true">#</a> <strong>2 设计与实现</strong></h2><p>MACE的整体工作流程可以分为以下三个阶段：</p><h3 id="a-authorization-state" tabindex="-1"><a class="header-anchor" href="#a-authorization-state" aria-hidden="true">#</a> a) Authorization State</h3><p>Authorization State是由作者提出的一种用于定义资源分配规则的四元组&lt;U,R,S,P&gt;，其中U代表的是授权的用户类型；R是指在定义在U基础上的，用户是否又有不同的角色划分，例如admin和非admin；S指的是保存在SESSION中的用于资源校验的可用变量集；P指的某个资源点限制的权限，例如WRITE或者READ。针对如下的代码段</p><figure><img src="'+p+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>一个完全没有用户校验和授权资源检验的漏洞代码，该代码段的资源四元组即为&lt;-,-,-,-&gt;。针对代码段7</p><figure><img src="'+d+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>首先根据uerifyUser函数判定用户登录身份，在uerifyUser函数中使用user作为身份识别参数，即四元组第一个参数为user；在user身份的基础上，没有对用户身份进行管理员和非管理员身份划分，第二个参数即为no_admin；此外没有在资源点使用涉及SESSION的资源变量，第三个参数为空；最后此处限定访问权限为canwrite，最终生成代码段7中的四元组参数为&lt;user,non_admin,- ,canWrite&gt;。</p><h3 id="b-authorization-context" tabindex="-1"><a class="header-anchor" href="#b-authorization-context" aria-hidden="true">#</a> b) Authorization Context</h3><p>Authorization Context是指作者提出的一个叫授权上下文的概念，根据如上的四元组以及静态的图分析方法，确定了关于授权资源访问点的一些变量约束条件，根据项目提供的源码来分析出设计者在一个资源授权定义点上所预计设计的授权规则，把这个授权规则表达为授权上下文的概念，将这个概念用于后文的资源冲突比较。</p><figure><img src="'+g+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>上表是一些关于处理出来的一些代码中形成的授权上下文的例子，粉红色标记部分是清单7中针对资源定义形成的授权上下文，清单7中的代码逻辑是首先利用verifyUser来检验用户登录身份，紧接着通过判定canwrite来执行删除的SQL语句，基于Authorization State四元组的值给定清单7中资源点的授权上下文。</p><h3 id="c-authorization-context-consistency" tabindex="-1"><a class="header-anchor" href="#c-authorization-context-consistency" aria-hidden="true">#</a> c) Authorization Context Consistency</h3><p>Authorization Context Consistency指的是对授权上下文和授权资源的一致性判定，资源定义点的授权内容和资源使用点的的定义内容是否存在矛盾冲突，如果存在冲突的话就判定存在潜在越权漏洞。例如在Web应用当中会将访问资源作为信息储存在数据库中，所以资源定义点通常就会与INSERT语句紧密联系在一起，此处在插入一个文章内容时，与文章资源相关的授权资源信息是userid，特定userid的用户在他的资源范围内可以添加了一篇属于他的文章，如下图所示：</p><figure><img src="'+l+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>此处的四元组值为&lt;$_SESSION[’userID’], -,- ,- &gt;。但在文章删除时，使用如下逻辑</p><figure><img src="'+h+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>资源四元组为&lt;-,-,-,-&gt; ，在文章被删除时没有对删除资源的判定和限制，仅单纯地根据postid来删除文章，此时就存在资源定义点的授权上下文和资源使用点的授权上下文的矛盾冲突，这个冲突就可能会成为潜在的越权漏洞点，正确的写法应该是：</p><figure><img src="'+_+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>在删除文章时也应该同时判定用户userid，保持和资源定义点的定义一致性。在冲突比较算法中，通过将四元组中的U、S作为约束条件可以确定是否存在水平越权漏洞；比较R参数可用于判定是否存在垂直越权漏洞。</p><h2 id="_3-实验评估" tabindex="-1"><a class="header-anchor" href="#_3-实验评估" aria-hidden="true">#</a> <strong>3 实验评估</strong></h2><p>MACE是一款针对PHP 应用的越权漏洞检测工具，作者介绍MACE使用Java编写完成，代码量大概在10k左右，同时MACE部署到一台4GB的Mac pro电脑上进行实验评估。</p><figure><img src="'+u+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>上图是MACE针对7个主流的PHP应用进行了分析，第二列是指项目代码量，作者指出选择的PHP应用代码量跨度范围从1K到90K，其中涉及各种规模的PHP应用；第三列是项目文件中包含的PHP文件数；第四列是项目中涉及到INSERT、UPDATE和DELETE语句的代码位置点；第五列中是数据库中表的数目；最后一列是分析时间，同时作者也指出分析时间的大部分开销是在构建依赖图和枚举路径上。</p><figure><img src="'+f+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>上图是利用MACE发现的漏洞情况报告，TP表示MACE发现的漏洞数，FP表示经过人工校验以后，是否存在误报的情况，VPE指的是水平越权漏洞，HPE是垂直越权，最后一列的know和unknow是指这些漏洞是否被发现，例如phpns中，共发现7个越权漏洞，且经过人工核验以后没有出现误报的情况，7个漏洞中包括了VPE和HPE两种漏洞，且这7个漏洞均是此前还未被发现的漏洞。</p><h2 id="_4-总体评价" tabindex="-1"><a class="header-anchor" href="#_4-总体评价" aria-hidden="true">#</a> <strong>4 总体评价</strong></h2><p>本文的贡献点主要有以下几点：</p><p>1.实现了MACE这个软件，可用静态分析的方法来寻找PHP WEB应用中的<mark>越权漏洞</mark>。</p><p>2.一种根据从资源声明点和资源利用点的授权上下文比较方法，利用两者存在的冲突来寻找存在的越权漏洞，这种思路在当时还是很独特新颖的。</p><p>3.利用MACD发现了一些应用中还没有被挖掘到的越权漏洞，并将漏洞上报给相关厂商和机构。</p><p>同时本文的工作存在的一些有待提高的地方，一是和以往的PHP静态分析工具相类似的，MACE还不支持PHP语言中的一些动态调用和面向对象特性，以及在构建依赖图时对路径上的一些过滤函数的处理方法还有待改进。</p>',37);function A(P,S){const a=n("ExternalLinkIcon");return r(),o("div",null,[E,b,i("p",null,[t("原文链接："),i("a",C,[t("https://dl.acm.org/doi/pdf/10.1145/2660267.2660337"),s(a)])]),x])}const k=e(m,[["render",A],["__file","46-白泽带你读论文丨MACE Detecting Privilege Escalation Vulnerabilities in.html.vue"]]);export{k as default};
