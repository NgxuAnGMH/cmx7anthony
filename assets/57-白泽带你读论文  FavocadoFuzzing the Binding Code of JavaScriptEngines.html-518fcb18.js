import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as t,c as r,a as e,b as a,e as s,d as c}from"./app-cdabc73c.js";const d="/assets/640-1691391837358-177-27c232a5.png",g="/assets/640-1691391837358-178-a203608f.png",p="/assets/640-1691391837358-179-bbccbea8.png",f="/assets/640-1691391837358-180-c6e78578.png",u="/assets/640-1691391837358-181-929e75e5.png",l={},h=e("h1",{id:"_57-白泽带你读论文-favocado-fuzzing-the-binding-code-of-javascriptengines",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_57-白泽带你读论文-favocado-fuzzing-the-binding-code-of-javascriptengines","aria-hidden":"true"},"#"),a(" 57-白泽带你读论文 | Favocado:Fuzzing the Binding Code of JavaScriptEngines")],-1),m={href:"https://sefcom.asu.edu/publications/favocado-ndss21.pdf",target:"_blank",rel:"noopener noreferrer"},z=c('<p>Favocado: Fuzzing the Binding Code of JavaScript Engines Using Semantically Correct Test Cases</p><p>本周由复旦系统与软件安全实验室张寒歌等同学负责论文精读与整理，论文选取自NDSS 2021的一篇研究对JS引擎进行模糊测试的文章。作者来自亚利桑那州立大学，提出了一种对JS语言中绑定层代码进行fuzzing的工具Favocado，首先通过解析IDL文件或API引用提取绑定对象的语义信息，再根据绑定对象间的关系选择绑定对象，并基于提取的语义信息和动态上下文信息生成并执行测试用例，效果优于最新的绑定代码fuzz工具。作者在对在4个不同的JavaScript运行时系统fuzz时，发现了61个新的bug，其中33个是安全漏洞，13个已经被CVE收录。</p><h2 id="_1-引言" tabindex="-1"><a class="header-anchor" href="#_1-引言" aria-hidden="true">#</a> 1. 引言</h2><p>JavaScript是由JS引擎解释的动态高级编程语言。作为经常被用作交互式网页、浏览器以及其他许多软件的通用编程语言，JS有很多低级功能不能直接实现（如内存管理和文件访问）。因此为了实现这些功能，JS运行时系统包括一些专门的编程接口，称为<mark>绑定层</mark>（binding layers），绑定层通过在不同类型之间转换数据，在JS和不安全的低级语言(如C和C++)之间转换数据表示。发现<em>在绑定层中的bug</em>也是至关重要的，作者认为现有的fuzz工具都不能适用于非浏览器环境中的绑定代码（binding code）fuzzing，也不能很好的处理绑定代码，于是提出了Facocado，针对JS运行时系统的绑定层fuzzing。</p><figure><img src="'+d+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>​</p><h2 id="_2-关键挑战" tabindex="-1"><a class="header-anchor" href="#_2-关键挑战" aria-hidden="true">#</a> 2. 关键挑战</h2><p>作者认为目前面临的挑战主要有两点：</p><ol><li>生成语法和语义正确的测试用例。语法错误的测试用例在处理之前就会被发现不能运行，语法正确而语义错误的测试用例会在运行时引发系统错误。</li><li>减少fuzz时的输入空间。在Chromium中有大于1000个DOM对象，每个对象可能有许多方法和属性难以填入，这也会增加生成测试用例的时间，阻碍fuzz的能力。</li></ol><h2 id="_3-整体设计" tabindex="-1"><a class="header-anchor" href="#_3-整体设计" aria-hidden="true">#</a> 3. 整体设计</h2><figure><img src="'+g+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>JS引擎为了执行JS代码会首先通过语法分析器解析源代码，生成<mark>抽象语法树(AST)</mark>。如果代码的语法不正确，它将不会生成AST或执行源代码。然后，JS引擎开始在控制代码范围并包含有关当前程序状态的最新信息的执行上下文中执行代码。</p><figure><img src="'+p+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>​ 如上图所示，Favocado首先解析来自接口定义语言（Interface Definition Language, IDL）的文件或是API引用的语义信息。为了构造目标绑定代码的完整语义信息，Favocado在有源代码时会解析IDL文件。如果没有源代码，Favocado会使用API参考手册。通过解析IDL文件或API引用，Favocado能获得绑定对象的语义信息（方法、参数、属性等），其中包括确切的类型和可能的值。提取的语义信息可以直接用于生成测试用例。</p><figure><img src="'+f+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>然后，Favocado使用绑定代码的语义信息生成一个JS文件（测试用例生成器），并通过在目标JS运行时系统上执行刚刚生成的JS文件进行Fuzzing。测试用例生成器会在预定义的语句格式中随机选择JS语句格式，这些预定义语句格式包括定义对象、调用方法、为属性赋值等，如下图。然后，它使用绑定代码的语义信息和fuzzing过程的上下文信息（例如，测试用例的运行时语义，如前面定义的变量及其类型的列表）来完成语句，防止意外的运行时错误。例如，当Favocado构造诸如car.drive(man)这样的语句时，Favocado会检查是否正确定义了man对象。此外，即使Favocado知道该对象已经被预先定义，它也会检查该对象是否仍然是活动的和可访问的。例如，当语句在调用释放对象（如removecchild）的方法后访问对象时，可能会发生运行时错误。如果该对象被这些方法释放，Favocado将再次创建该对象并执行所构造的语句，从而避免运行时错误。它还记得指向新定义的对象的变量名，以便以后使用。这些措施有效的解决了挑战一。</p><figure><img src="'+u+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>为了解决挑战二，也就是减少输入空间，作者将整个输入空间划分为多个等价类。作者举出了例子，Favocado定义两个对象（object）之间的关系为，一个绑定对象把另一个绑定对象当作属性或者方法参数时成立的关系，利用不同DOM对象之间的相对隔离关系（除非存在对象关系，不然在测试逻辑上是无关的，比如spell.check()和Net.http.request，拼写模块和网络模块之间是独立的，二者测试的顺序和上下文联系很可能不会影响到找到bug）将输入空间划分为不同等价类，在同一等价类中进行fuzzing，减少输入空间。</p><h2 id="_4-实验与结果" tabindex="-1"><a class="header-anchor" href="#_4-实验与结果" aria-hidden="true">#</a> 4. 实验与结果</h2><p>​ 作者使用Favocado对四个不同的JS运行系统进行fuzzing（Adobe Acrobat Reader、Foxit PDF Reader、Chromium、WebKit），发现Favocado的效果和范围都比现有的工具更好（CodeAlchemist和Domato），并发现了61个新的bug，其中33个是安全漏洞，13个已经被授予CVE ID。</p><h2 id="_5-总结" tabindex="-1"><a class="header-anchor" href="#_5-总结" aria-hidden="true">#</a> 5. 总结</h2><p>作者提出了一种对JS语言中绑定层代码进行fuzzing的工具Favocado，通过解析<em>IDL文件</em>或<em>API引用</em>提取绑定对象的语义信息，根据绑定对象的关系选择绑定对象，并基于提取的语义信息和动态上下文信息生成并执行测试用例，效果优于最新的绑定代码fuzz工具。在对在4个不同的JavaScript运行时系统fuzz时，发现了61个新的bug，其中33个是安全漏洞，13个已经被设为CVE。</p><h2 id="_6-思考与讨论" tabindex="-1"><a class="header-anchor" href="#_6-思考与讨论" aria-hidden="true">#</a> 6. 思考与讨论</h2><p><strong>Q1:</strong> 作者为什么要fuzz binding code？binding code有什么特殊的么，是不是非常重要的部分，如果出问题了会怎么样，如果不重要的话fuzz binding code意义不也不重大了么?</p><p><strong>A1:</strong> binding code的特殊之处:1.从论文的表述来说，JS fuzz中binding code的fuzz没有被广泛研究 2.对于binding code组件，可以通过IDL文件获取全面详细的语义信息，其他组件未必可以获得如此完备的语义信息。</p><p>重要性：binding code是负责在具有底层函数功能的原生代码和JS之间创建必要的数据类型映射。binding code必须以严格的安全原则执行翻译过程，以避免原生代码存在的问题被引入到JS中。</p><p><strong>Q2:</strong> 一些现有工作会从PoC中学习生成test case，为什么favocado生成test case不这样做？</p><p><strong>A2:</strong> favocado为了fuzz binding code，更多是需要测试一系列各种 JavaScript 语句设置属性和调用具有正确语义的 API，这不需要从测试套件中学习复杂的语法或代码模式。</p><p><strong>Q3:</strong> 为什么已有的JS FUZZER不能够用在FUZZ JS BINDING CODE 这个领域？</p><p><strong>A3:</strong> 前人的工作有很多，比如：</p><p>Skyfire通过probabilistic context sensitive grammar和已有的samples来生成test cases；CodeAlchemist通过数据集中的代码基本块来生成语义-aware JS；DIE通过structure preserving mutation和type preservingmutation来减少input space规模，此外，还利用已知的PoC(Proof of concept) exploits或者现有的test cases；Montage: 用了神经网络语言模型CodeAlchemist ：the latest semantics-aware generative JS engine fuzzer</p><p>但是，前人的工作生成的test case语义不正确。在Evaluation中看到CodeAlchemist只能生成28.24%语义正确的CASE，Domato:（ 1 use-after-freevulnerability, 34% of test cases caused runtime errors）,这也证明了语义正确性的重要性。</p><p><strong>Q4:</strong> 文章依据什么来判断两个对象相关的？</p><p><strong>A4:</strong> 根据API文档或者IDL文件中对象的参数，返回值和属性来判断，如果一个对象被用在另一个对象的函数参数、返回值或属性类型的话，就记录为相关对象，便于后续一起进行fuzz。</p><p><strong>Q5:</strong> 文章为了避免runtime errors做了哪些工作，这些工作能避免所有的runtime error吗？(文章有提到not wasting anytest case)</p><p><strong>A5:</strong> 当执行car.drivr(man)语句时，会去检查man变量是否被正确定义；如果变量之前已经被定义，还会去检查对象是否alive或者accessible。如果变量已经被deallocate，还会去重新创建这个变量。同时维护了一个已经allocate的数据结构，用于防止意外的runtime error。</p><p>这些略有些牵强，作者没有做evaluation，可以增加一个评估runtime error的实验，去掉故意生成的runtime error的test case，再评估导致runtime error的比例和效果。以及再增加一个实验评估runtime error的减少与发现漏洞数量之间的关系，以证明runtime error的减少。</p><p><strong>Q6:</strong> 在本文的基础上，还能再做什么工作？</p><p><strong>A6:</strong> 本文针对的是JS binding code，这个层面关注的比较少，由于binding layer是JS与底层代码之间的中间层，是对底层的封装，可以再关注很容易出错的binding code与native code之间的封装一致性，做进一步的工作。</p>',39);function _(v,b){const i=o("ExternalLinkIcon");return t(),r("div",null,[h,e("p",null,[e("a",m,[a("favocado-ndss21.pdf (asu.edu)"),s(i)]),a("。")]),z])}const F=n(l,[["render",_],["__file","57-白泽带你读论文  FavocadoFuzzing the Binding Code of JavaScriptEngines.html.vue"]]);export{F as default};
