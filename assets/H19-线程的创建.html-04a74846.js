import{_ as p}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as c,c as l,a as s,b as n,e,d as t}from"./app-cdabc73c.js";const i="/assets/14635b1613d04df9f217c3508ae8524b-e0101fdd.jpeg",r={},u=t(`<h1 id="_19-线程的创建-如何执行一个新子项目" tabindex="-1"><a class="header-anchor" href="#_19-线程的创建-如何执行一个新子项目" aria-hidden="true">#</a> 19 | 线程的创建：如何执行一个新子项目？</h1><p>上一节，我们了解了进程创建的整个过程，今天我们来看线程创建的过程。</p><p>我们前面已经写过多线程编程的程序了，你应该都知道创建一个线程调用的是 <code>pthread_create</code>，可你知道它背后的机制吗？</p><h2 id="用户态创建线程-pthread-create" tabindex="-1"><a class="header-anchor" href="#用户态创建线程-pthread-create" aria-hidden="true">#</a> <strong>用户态创建线程 <code>pthread_create</code></strong></h2><p>你可能会问，咱们之前不是讲过了吗？无论是进程还是线程，在内核里面都是任务，管起来不是都一样吗？但是问题来了，如果两个完全一样，那为什么咱们前两节写的程序差别那么大？如果不一样，那怎么在内核里面加以区分呢？</p><p>其实，线程不是一个完全由内核实现的机制，它是由内核态和用户态合作完成的。pthread_create 不是一个系统调用，是 Glibc 库的一个函数，所以我们还要去 Glibc 里面去找线索。</p><p>果然，我们在 nptl/pthread_create.c 里面找到了这个函数。这里的参数我们应该比较熟悉了。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">__pthread_create_2_1</span> <span class="token punctuation">(</span><span class="token class-name">pthread_t</span> <span class="token operator">*</span>newthread<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token class-name">pthread_attr_t</span> <span class="token operator">*</span>attr<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>start_routine<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
<span class="token function">versioned_symbol</span> <span class="token punctuation">(</span>libpthread<span class="token punctuation">,</span> __pthread_create_2_1<span class="token punctuation">,</span> pthread_create<span class="token punctuation">,</span> GLIBC_2_1<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面我们依次来看这个函数做了些啥。</p><h3 id="_1-线程的属性-pthread-attr" tabindex="-1"><a class="header-anchor" href="#_1-线程的属性-pthread-attr" aria-hidden="true">#</a> 1. 线程的属性 <code>pthread_attr</code></h3><p>首先处理的是<mark>线程的属性</mark>参数。例如前面写程序的时候，我们设置的线程栈大小。如果没有传入线程属性，就取默认值。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">pthread_attr</span> <span class="token operator">*</span>iattr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pthread_attr</span> <span class="token operator">*</span><span class="token punctuation">)</span> attr<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">pthread_attr</span> default_attr<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>iattr <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  iattr <span class="token operator">=</span> <span class="token operator">&amp;</span>default_attr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-用户态维护线程-pthread" tabindex="-1"><a class="header-anchor" href="#_2-用户态维护线程-pthread" aria-hidden="true">#</a> 2. 用户态维护线程 <code>pthread</code></h3><p>接下来，<code>就像在内核里一样</code>，每一个进程或者线程都有一个 task_struct 结构，在用户态也有一个用于维护线程的结构，就是这个 <mark>pthread 结构</mark>。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">pthread</span> <span class="token operator">*</span>pd <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_3-线程栈-处理函数调用-allocate-stack" tabindex="-1"><a class="header-anchor" href="#_3-线程栈-处理函数调用-allocate-stack" aria-hidden="true">#</a> 3. 线程栈(处理函数调用)<code>allocate_stack</code></h3><p>凡是涉及函数的调用，都要使用到栈。每个线程也有自己的栈。那接下来就是创建<mark>线程栈</mark>了。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> err <span class="token operator">=</span> <span class="token function">ALLOCATE_STACK</span> <span class="token punctuation">(</span>iattr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pd<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>所以，线程局部变量其实是存储在每个线程自己的用户态线程栈里咯？<br> 作者回复: 是的</p><p>老师、同学们，不知道如下认识是否正确呢：<br> 1.原来线程存在的价值是复用进程的部分内存（引用五大结构），又是一个享元模式（Flyweight Design Pattern）的体现<br> 2.<code>线程函数局部变量</code>在<mark>用户态的线程栈</mark>中（是在<mark>进程的堆</mark>里面创建的），独立的内存块，<code>所以在这里多线程之间还无需考虑共享数据问题</code>；<br> 然而对于<code>进程的全局变量</code>，由于多线程是共享了进程数据，再加上<code>各个线程</code>在内核中是<code>独立的task</code>被调度系统调度，<br> 随时可能会被抢占并且访问同一个全局变量，所以多线程之间需要做<code>共享数据保护</code><br> 作者回复: 是的</p></blockquote><p>ALLOCATE_STACK 是一个宏，我们找到它的定义之后，发现它其实就是一个函数。只是，这个函数有些复杂，所以我这里把主要的代码列一下。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">define</span> <span class="token macro-name function">ALLOCATE_STACK</span><span class="token expression"><span class="token punctuation">(</span>attr<span class="token punctuation">,</span> pd<span class="token punctuation">)</span> <span class="token function">allocate_stack</span> <span class="token punctuation">(</span>attr<span class="token punctuation">,</span> pd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>stackaddr<span class="token punctuation">)</span></span></span>


<span class="token keyword">static</span> <span class="token keyword">int</span>
<span class="token function">allocate_stack</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">pthread_attr</span> <span class="token operator">*</span>attr<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">pthread</span> <span class="token operator">*</span><span class="token operator">*</span>pdp<span class="token punctuation">,</span>
                ALLOCATE_STACK_PARMS<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">pthread</span> <span class="token operator">*</span>pd<span class="token punctuation">;</span>
  <span class="token class-name">size_t</span> size<span class="token punctuation">;</span>
  <span class="token class-name">size_t</span> pagesize_m1 <span class="token operator">=</span> <span class="token function">__getpagesize</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  size <span class="token operator">=</span> attr<span class="token operator">-&gt;</span>stacksize<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token comment">/* Allocate some anonymous memory.  If possible use the cache.  */</span>
  <span class="token class-name">size_t</span> guardsize<span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token operator">*</span>mem<span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">int</span> prot <span class="token operator">=</span> <span class="token punctuation">(</span>PROT_READ <span class="token operator">|</span> PROT_WRITE
                   <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">GL</span><span class="token punctuation">(</span>dl_stack_flags<span class="token punctuation">)</span> <span class="token operator">&amp;</span> PF_X<span class="token punctuation">)</span> <span class="token operator">?</span> PROT_EXEC <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* Adjust the stack size for alignment.  */</span>
  size <span class="token operator">&amp;=</span> <span class="token operator">~</span>__static_tls_align_m1<span class="token punctuation">;</span>
  <span class="token comment">/* Make sure the size of the stack is enough for the guard and
  eventually the thread descriptor.  */</span>
  guardsize <span class="token operator">=</span> <span class="token punctuation">(</span>attr<span class="token operator">-&gt;</span>guardsize <span class="token operator">+</span> pagesize_m1<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span>pagesize_m1<span class="token punctuation">;</span>
  size <span class="token operator">+=</span> guardsize<span class="token punctuation">;</span>
  pd <span class="token operator">=</span> <span class="token function">get_cached_stack</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>size<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mem<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>pd <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token comment">/* If a guard page is required, avoid committing memory by first
    allocate with PROT_NONE and then reserve with required permission
    excluding the guard page.  */</span>
  mem <span class="token operator">=</span> <span class="token function">__mmap</span> <span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> size<span class="token punctuation">,</span> <span class="token punctuation">(</span>guardsize <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> prot <span class="token operator">:</span> PROT_NONE<span class="token punctuation">,</span>
      MAP_PRIVATE <span class="token operator">|</span> MAP_ANONYMOUS <span class="token operator">|</span> MAP_STACK<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* Place the thread descriptor at the end of the stack.  */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">TLS_TCB_AT_TP</span></span>
    pd <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pthread</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> mem <span class="token operator">+</span> size<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">elif</span> <span class="token expression">TLS_DTV_AT_TP</span></span>
    pd <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pthread</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uintptr_t</span><span class="token punctuation">)</span> mem <span class="token operator">+</span> size <span class="token operator">-</span> __static_tls_size<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span>__static_tls_align_m1<span class="token punctuation">)</span> <span class="token operator">-</span> TLS_PRE_TCB_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    <span class="token comment">/* Now mprotect the required region excluding the guard area. */</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>guard <span class="token operator">=</span> <span class="token function">guard_position</span> <span class="token punctuation">(</span>mem<span class="token punctuation">,</span> size<span class="token punctuation">,</span> guardsize<span class="token punctuation">,</span> pd<span class="token punctuation">,</span> pagesize_m1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setup_stack_prot</span> <span class="token punctuation">(</span>mem<span class="token punctuation">,</span> size<span class="token punctuation">,</span> guard<span class="token punctuation">,</span> guardsize<span class="token punctuation">,</span> prot<span class="token punctuation">)</span><span class="token punctuation">;</span>
    pd<span class="token operator">-&gt;</span>stackblock <span class="token operator">=</span> mem<span class="token punctuation">;</span>
    pd<span class="token operator">-&gt;</span>stackblock_size <span class="token operator">=</span> size<span class="token punctuation">;</span>
    pd<span class="token operator">-&gt;</span>guardsize <span class="token operator">=</span> guardsize<span class="token punctuation">;</span>
    pd<span class="token operator">-&gt;</span>specific<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> pd<span class="token operator">-&gt;</span>specific_1stblock<span class="token punctuation">;</span>
    <span class="token comment">/* And add to the list of stacks in use.  */</span>
    <span class="token function">stack_list_add</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>pd<span class="token operator">-&gt;</span>list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>stack_used<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token operator">*</span>pdp <span class="token operator">=</span> pd<span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token operator">*</span>stacktop<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">if</span> <span class="token expression">TLS_TCB_AT_TP</span></span>
  <span class="token comment">/* The stack begins before the TCB and the static TLS block.  */</span>
  stacktop <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>pd <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> __static_tls_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">elif</span> <span class="token expression">TLS_DTV_AT_TP</span></span>
  stacktop <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>pd <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">endif</span></span>
  <span class="token operator">*</span>stack <span class="token operator">=</span> stacktop<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="线程栈的细节" tabindex="-1"><a class="header-anchor" href="#线程栈的细节" aria-hidden="true">#</a> ## 线程栈的细节</h3><p>我们来看一下，allocate_stack 主要做了以下这些事情：</p><ul><li><p>如果你在线程属性里面设置过栈的大小，需要你把设置的值拿出来；</p></li><li><p>为了防止栈的访问越界，在栈的末尾会有一块空间 guardsize，一旦访问到这里就错误了；</p></li><li><p><strong>其实<mark>线程栈</mark>是在<mark>进程的堆</mark>里面创建的。</strong></p><ul><li>如果一个进程不断地创建和删除线程，我们<code>不可能</code>不断地去申请和清除<code>线程栈使用的内存块</code>，这样就需要有一个缓存(先开辟)。</li><li>get_cached_stack 就是根据计算出来的 size 大小，看一看已经有的缓存中，有没有已经能够满足条件的； <ul><li>如果缓存里面没有，就需要调用 <code>__mmap</code> 创建一块新的，系统调用那一节我们讲过，</li><li>即如果要在堆里面 malloc 一块内存，比较大的话，用 <code>__mmap</code>；</li></ul></li></ul></li><li><p>线程栈也是自顶向下生长的，还记得<code>每个线程</code>要有<mark>一个 pthread 结构</mark>，这个结构也是放在栈的空间里面的。在栈底的位置，其实是地址最高位；</p><ul><li>计算出 guard 内存的位置，调用 setup_stack_prot 设置这块内存的是受保护的；</li><li>接下来，开始填充 pthread 这个结构里面的<code>成员变量 stackblock、stackblock_size、guardsize、specific</code>。</li><li>这里的 <code>specific</code> 是用于存放 Thread Specific Data 的，也即属于<code>线程的全局变量</code>；</li></ul></li><li><p>将这个线程栈放到 stack_used 链表中，其实管理线程栈总共有<mark>两个链表</mark>，</p><ul><li>一个是 stack_used，也就是这个栈正被使用；</li><li>另一个是 stack_cache，就是上面说的，一旦线程结束，先缓存起来，不释放，等有其他的线程创建的时候，给其他的线程用。</li></ul></li></ul><blockquote><p>搞定了用户态栈的问题，其实用户态的事情基本搞定了一半。</p></blockquote><h2 id="内核态创建任务" tabindex="-1"><a class="header-anchor" href="#内核态创建任务" aria-hidden="true">#</a> <strong>内核态创建任务</strong></h2><h3 id="用户态-start-routine" tabindex="-1"><a class="header-anchor" href="#用户态-start-routine" aria-hidden="true">#</a> 用户态 <code>start_routine</code></h3><p>接下来，我们接着 pthread_create 看。其实有了用户态的栈，接着需要解决的就是用户态的程序<code>从哪里开始运行</code>的问题。(<code>start_routine</code>)</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>pd<span class="token operator">-&gt;</span>start_routine <span class="token operator">=</span> start_routine<span class="token punctuation">;</span>
pd<span class="token operator">-&gt;</span>arg <span class="token operator">=</span> arg<span class="token punctuation">;</span>
pd<span class="token operator">-&gt;</span>schedpolicy <span class="token operator">=</span> self<span class="token operator">-&gt;</span>schedpolicy<span class="token punctuation">;</span>
pd<span class="token operator">-&gt;</span>schedparam <span class="token operator">=</span> self<span class="token operator">-&gt;</span>schedparam<span class="token punctuation">;</span>
<span class="token comment">/* Pass the descriptor to the caller.  */</span>
<span class="token operator">*</span>newthread <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">pthread_t</span><span class="token punctuation">)</span> pd<span class="token punctuation">;</span>
<span class="token function">atomic_increment</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>__nptl_nthreads<span class="token punctuation">)</span><span class="token punctuation">;</span>
retval <span class="token operator">=</span> <span class="token function">create_thread</span> <span class="token punctuation">(</span>pd<span class="token punctuation">,</span> iattr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>stopped_start<span class="token punctuation">,</span> STACK_VARIABLES_ARGS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>thread_ran<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>start_routine 就是咱们给线程的函数，<br><mark>start_routine(函数)</mark>，<mark>start_routine 的参数 arg</mark>，以及<mark>调度策略</mark>都要赋值给 <code>pthread(用户态维护线程)</code>。</li><li>接下来 <code>__nptl_nthreads</code> 加一，说明又多了一个线程。</li><li>真正创建线程的是调用 <code>create_thread 函数</code>，这个函数定义如下：</li></ol><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">create_thread</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pthread</span> <span class="token operator">*</span>pd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">pthread_attr</span> <span class="token operator">*</span>attr<span class="token punctuation">,</span>
bool <span class="token operator">*</span>stopped_start<span class="token punctuation">,</span> STACK_VARIABLES_PARMS<span class="token punctuation">,</span> bool <span class="token operator">*</span>thread_ran<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token keyword">int</span> clone_flags <span class="token operator">=</span> <span class="token punctuation">(</span>CLONE_VM <span class="token operator">|</span> CLONE_FS <span class="token operator">|</span> CLONE_FILES <span class="token operator">|</span> CLONE_SYSVSEM <span class="token operator">|</span> CLONE_SIGHAND <span class="token operator">|</span> CLONE_THREAD <span class="token operator">|</span> CLONE_SETTLS <span class="token operator">|</span> CLONE_PARENT_SETTID <span class="token operator">|</span> CLONE_CHILD_CLEARTID <span class="token operator">|</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">ARCH_CLONE</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>start_thread<span class="token punctuation">,</span> STACK_VARIABLES_ARGS<span class="token punctuation">,</span> clone_flags<span class="token punctuation">,</span> pd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pd<span class="token operator">-&gt;</span>tid<span class="token punctuation">,</span> tp<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pd<span class="token operator">-&gt;</span>tid<span class="token punctuation">)</span>；
  <span class="token comment">/* It&#39;s started now, so if we fail below, we&#39;ll have to cancel it
and let it clean itself up.  */</span>
  <span class="token operator">*</span>thread_ran <span class="token operator">=</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里面有很长的 clone_flags，这些咱们原来一直没注意，不过接下来的过程，我们要特别的关注一下这些标志位。</p><p>然后就是 ARCH_CLONE，其实调用的是 __clone。看到这里，你应该就有感觉了，马上就要到系统调用了。</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code># define ARCH_CLONE __clone


/* The userland implementation is:
   int clone (int (*fn)(void *arg), void *child_stack, int flags, void *arg),
   the kernel entry is:
   int clone (long flags, void *child_stack).


   The parameters are passed in register and on the stack from userland:
   rdi: fn
   rsi: child_stack
   rdx: flags
   rcx: arg
   r8d: TID field in parent
   r9d: thread pointer
%esp+8: TID field in child


   The kernel expects:
   rax: system call number
   rdi: flags
   rsi: child_stack
   rdx: TID field in parent
   r10: TID field in child
   r8:  thread pointer  */
 
        .text
ENTRY (__clone)
        movq    $-EINVAL,%rax
......
        /* Insert the argument onto the new stack.  */
        subq    $16,%rsi
        movq    %rcx,8(%rsi)


        /* Save the function pointer.  It will be popped off in the
           child in the ebx frobbing below.  */
        movq    %rdi,0(%rsi)


        /* Do the system call.  */
        movq    %rdx, %rdi
        movq    %r8, %rdx
        movq    %r9, %r8
        mov     8(%rsp), %R10_LP
        movl    $SYS_ify(clone),%eax
......
        syscall
......
PSEUDO_END (__clone)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="创建线程的sys-clone-创建进程的sys-fork" tabindex="-1"><a class="header-anchor" href="#创建线程的sys-clone-创建进程的sys-fork" aria-hidden="true">#</a> 创建线程的sys_clone/创建进程的sys_fork</h3><p>如果对于汇编不太熟悉也没关系，你可以重点看上面的注释。</p><p>我们能看到最后调用了 syscall，这一点 clone 和我们原来熟悉的其他系统调用几乎是一致的。但是，也有少许不一样的地方。</p><ul><li>如果<code>在 进程的主线程 里面</code>调用其他系统调用， <ul><li>当前用户态的栈是指向<code>整个进程</code>的栈，栈顶指针也是指向进程的栈，指令指针也是指向<code>进程的主线程</code>的代码。</li><li>此时此刻执行到这里，调用 clone 的时候，用户态的栈、栈顶指针、指令指针和其他系统调用一样，都是指向<code>主线程</code>的。</li></ul></li><li><code>但是对于线程来说</code>，这些都要变。 <ul><li>因为我们希望当 clone 这个系统调用成功的时候，除了内核里面有这个线程对应的 task_struct，</li><li>当系统调用返回到用户态的时候，用户态的栈应该是<code>线程的栈</code>，栈顶指针应该指向<code>线程的栈</code>，指令指针应该指向<code>线程将要执行的那个函数</code>。 <ul><li><strong>所以这些都需要我们自己做</strong>，将线程要执行的函数的参数和指令的位置都压到栈里面，<br> 当从内核返回，从栈里弹出来的时候，就从这个函数开始，带着这些参数执行下去。</li></ul></li></ul></li></ul><h3 id="create-thread系统调用内核态sys-clone" tabindex="-1"><a class="header-anchor" href="#create-thread系统调用内核态sys-clone" aria-hidden="true">#</a> <code>create_thread</code>系统调用内核态<code>sys_clone</code></h3><p>接下来我们就要进入内核了。内核里面对于 clone 系统调用的定义是这样的：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token function">SYSCALL_DEFINE5</span><span class="token punctuation">(</span>clone<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> clone_flags<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> newsp<span class="token punctuation">,</span>
     <span class="token keyword">int</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> parent_tidptr<span class="token punctuation">,</span>
     <span class="token keyword">int</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> child_tidptr<span class="token punctuation">,</span>
     <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> tls<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">_do_fork</span><span class="token punctuation">(</span>clone_flags<span class="token punctuation">,</span> newsp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> parent_tidptr<span class="token punctuation">,</span> child_tidptr<span class="token punctuation">,</span> tls<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看到这里，发现了熟悉的面孔 <code>_do_fork</code>，是不是轻松了一些？上一节我们已经沿着它的逻辑过了一遍了。这里我们重点关注几个区别。</p><blockquote><p>线程要进行上下文切换应该有各自的内核栈吧，那内核栈在哪里创建的？<br> 作者回复: fork的时候</p></blockquote><h3 id="a-通过-指针-直接共享-进程的五大结构" tabindex="-1"><a class="header-anchor" href="#a-通过-指针-直接共享-进程的五大结构" aria-hidden="true">#</a> A 通过[指针]直接共享[进程的五大结构]</h3><h4 id="_1-文件相关-files" tabindex="-1"><a class="header-anchor" href="#_1-文件相关-files" aria-hidden="true">#</a> 1. 文件相关 files</h4><p>第一个是上面<strong>复杂的标志位设定</strong>，我们来看都影响了什么。</p><p>对于 copy_files，原来是调用 dup_fd 复制一个 files_struct 的，现在因为 CLONE_FILES 标识位变成将原来的 files_struct 引用计数加一。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">copy_files</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> clone_flags<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">files_struct</span> <span class="token operator">*</span>oldf<span class="token punctuation">,</span> <span class="token operator">*</span>newf<span class="token punctuation">;</span>
  oldf <span class="token operator">=</span> current<span class="token operator">-&gt;</span>files<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CLONE_FILES<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">atomic_inc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>oldf<span class="token operator">-&gt;</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">goto</span> out<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  newf <span class="token operator">=</span> <span class="token function">dup_fd</span><span class="token punctuation">(</span>oldf<span class="token punctuation">,</span> <span class="token operator">&amp;</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
  tsk<span class="token operator">-&gt;</span>files <span class="token operator">=</span> newf<span class="token punctuation">;</span>
out<span class="token operator">:</span>
  <span class="token keyword">return</span> error<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-文件系统相关-fs" tabindex="-1"><a class="header-anchor" href="#_2-文件系统相关-fs" aria-hidden="true">#</a> 2. 文件系统相关 fs</h4><p>对于 copy_fs，原来是调用 copy_fs_struct 复制一个 fs_struct，现在因为 CLONE_FS 标识位变成将原来的 fs_struct 的用户数加一。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">copy_fs</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> clone_flags<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">fs_struct</span> <span class="token operator">*</span>fs <span class="token operator">=</span> current<span class="token operator">-&gt;</span>fs<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CLONE_FS<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    fs<span class="token operator">-&gt;</span>users<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  tsk<span class="token operator">-&gt;</span>fs <span class="token operator">=</span> <span class="token function">copy_fs_struct</span><span class="token punctuation">(</span>fs<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_3-信号相关-sighand" tabindex="-1"><a class="header-anchor" href="#_3-信号相关-sighand" aria-hidden="true">#</a> 3. 信号相关 sighand</h4><p>对于 copy_sighand，原来是创建一个新的 sighand_struct，现在因为 CLONE_SIGHAND 标识位变成将原来的 sighand_struct 引用计数加一。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">copy_sighand</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> clone_flags<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">sighand_struct</span> <span class="token operator">*</span>sig<span class="token punctuation">;</span>


  <span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CLONE_SIGHAND<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">atomic_inc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>current<span class="token operator">-&gt;</span>sighand<span class="token operator">-&gt;</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  sig <span class="token operator">=</span> <span class="token function">kmem_cache_alloc</span><span class="token punctuation">(</span>sighand_cachep<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">atomic_set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sig<span class="token operator">-&gt;</span>count<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">memcpy</span><span class="token punctuation">(</span>sig<span class="token operator">-&gt;</span>action<span class="token punctuation">,</span> current<span class="token operator">-&gt;</span>sighand<span class="token operator">-&gt;</span>action<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sig<span class="token operator">-&gt;</span>action<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_4-信号相关-signal" tabindex="-1"><a class="header-anchor" href="#_4-信号相关-signal" aria-hidden="true">#</a> 4. 信号相关 signal</h4><p>对于 copy_signal，原来是创建一个新的 signal_struct，现在因为 CLONE_THREAD 直接返回了。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">copy_signal</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> clone_flags<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">signal_struct</span> <span class="token operator">*</span>sig<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CLONE_THREAD<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  sig <span class="token operator">=</span> <span class="token function">kmem_cache_zalloc</span><span class="token punctuation">(</span>signal_cachep<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
  tsk<span class="token operator">-&gt;</span>signal <span class="token operator">=</span> sig<span class="token punctuation">;</span>
    <span class="token function">init_sigpending</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sig<span class="token operator">-&gt;</span>shared_pending<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_5-内存相关-mm-struct" tabindex="-1"><a class="header-anchor" href="#_5-内存相关-mm-struct" aria-hidden="true">#</a> 5. 内存相关 mm_struct</h4><p>对于 copy_mm，原来是调用 dup_mm 复制一个 mm_struct，现在因为 CLONE_VM 标识位而直接指向了原来的 mm_struct。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">copy_mm</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> clone_flags<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>mm<span class="token punctuation">,</span> <span class="token operator">*</span>oldmm<span class="token punctuation">;</span>
  oldmm <span class="token operator">=</span> current<span class="token operator">-&gt;</span>mm<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CLONE_VM<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">mmget</span><span class="token punctuation">(</span>oldmm<span class="token punctuation">)</span><span class="token punctuation">;</span>
    mm <span class="token operator">=</span> oldmm<span class="token punctuation">;</span>
    <span class="token keyword">goto</span> good_mm<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  mm <span class="token operator">=</span> <span class="token function">dup_mm</span><span class="token punctuation">(</span>tsk<span class="token punctuation">)</span><span class="token punctuation">;</span>
good_mm<span class="token operator">:</span>
  tsk<span class="token operator">-&gt;</span>mm <span class="token operator">=</span> mm<span class="token punctuation">;</span>
  tsk<span class="token operator">-&gt;</span>active_mm <span class="token operator">=</span> mm<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="b-处理亲缘关系-识别是否属于同进程" tabindex="-1"><a class="header-anchor" href="#b-处理亲缘关系-识别是否属于同进程" aria-hidden="true">#</a> B 处理亲缘关系/识别是否属于同进程</h3><p>第二个就是<strong>对于亲缘关系的影响</strong>，毕竟我们要识别多个线程是不是属于一个进程。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>p<span class="token operator">-&gt;</span>pid <span class="token operator">=</span> <span class="token function">pid_nr</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CLONE_THREAD<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  p<span class="token operator">-&gt;</span>exit_signal <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  p<span class="token operator">-&gt;</span>group_leader <span class="token operator">=</span> current<span class="token operator">-&gt;</span>group_leader<span class="token punctuation">;</span>
  p<span class="token operator">-&gt;</span>tgid <span class="token operator">=</span> current<span class="token operator">-&gt;</span>tgid<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CLONE_PARENT<span class="token punctuation">)</span>
    p<span class="token operator">-&gt;</span>exit_signal <span class="token operator">=</span> current<span class="token operator">-&gt;</span>group_leader<span class="token operator">-&gt;</span>exit_signal<span class="token punctuation">;</span>
  <span class="token keyword">else</span>
    p<span class="token operator">-&gt;</span>exit_signal <span class="token operator">=</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CSIGNAL<span class="token punctuation">)</span><span class="token punctuation">;</span>
  p<span class="token operator">-&gt;</span>group_leader <span class="token operator">=</span> p<span class="token punctuation">;</span>
  p<span class="token operator">-&gt;</span>tgid <span class="token operator">=</span> p<span class="token operator">-&gt;</span>pid<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
  <span class="token comment">/* CLONE_PARENT re-uses the old parent */</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> <span class="token punctuation">(</span>CLONE_PARENT<span class="token operator">|</span>CLONE_THREAD<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  p<span class="token operator">-&gt;</span>real_parent <span class="token operator">=</span> current<span class="token operator">-&gt;</span>real_parent<span class="token punctuation">;</span>
  p<span class="token operator">-&gt;</span>parent_exec_id <span class="token operator">=</span> current<span class="token operator">-&gt;</span>parent_exec_id<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  p<span class="token operator">-&gt;</span>real_parent <span class="token operator">=</span> current<span class="token punctuation">;</span>
  p<span class="token operator">-&gt;</span>parent_exec_id <span class="token operator">=</span> current<span class="token operator">-&gt;</span>self_exec_id<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="pid-tgid-group-leader" tabindex="-1"><a class="header-anchor" href="#pid-tgid-group-leader" aria-hidden="true">#</a> <code>pid/tgid/group_leader</code></h4><p>从上面的代码可以看出，使用了 CLONE_THREAD 标识位之后，使得亲缘关系有了一定的变化。</p><ul><li>如果是新进程，那这个进程的 group_leader 就是它自己，tgid 是它自己的 pid，这就完全重打锣鼓另开张了，自己是线程组的头。如果是新线程，group_leader 是当前进程的，group_leader，tgid 是当前进程的 tgid，也就是当前进程的 pid，这个时候还是拜原来进程为老大。</li><li>如果是新进程，新进程的 real_parent 是当前的进程，在进程树里面又见一辈人；如果是新线程，线程的 real_parent 是当前的进程的 real_parent，其实是平辈的。</li></ul><h3 id="c-对于信号的处理" tabindex="-1"><a class="header-anchor" href="#c-对于信号的处理" aria-hidden="true">#</a> C 对于信号的处理</h3><p>第三，<strong>对于信号的处理</strong>，如何保证发给进程的信号虽然可以被一个线程处理，但是影响范围应该是整个进程的。例如，kill 一个进程，则所有线程都要被干掉。如果一个信号是发给一个线程的 pthread_kill，则应该只有线程能够收到。</p><h4 id="_1-私有的信号处理-sigpending" tabindex="-1"><a class="header-anchor" href="#_1-私有的信号处理-sigpending" aria-hidden="true">#</a> 1. 私有的信号处理 <code>sigpending</code></h4><p>在 copy_process 的主流程里面，无论是创建进程还是线程，都会初始化 struct sigpending pending，</p><blockquote><p>也就是每个 task_struct(不论进程线程)，都会有这样一个 sigpending 私有的成员变量。这就是一个信号列表。</p><ul><li>如果这个 task_struct 是一个线程，这里面的信号就是发给这个线程的；</li><li>如果这个 task_struct 是一个进程，这里面的信号是发给主线程的。</li></ul></blockquote><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token function">init_sigpending</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-&gt;</span>pending<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="_2-共享的信号处理-signal-sighand-shared-pending" tabindex="-1"><a class="header-anchor" href="#_2-共享的信号处理-signal-sighand-shared-pending" aria-hidden="true">#</a> 2. 共享的信号处理 signal &amp; sighand -&gt; <code>shared_pending</code></h4><p>另外，上面 copy_signal 的时候，我们可以看到，在创建进程的过程中，会初始化 signal_struct 里面的 struct sigpending shared_pending。但是，在创建线程的过程中，连 <code>signal_struct</code> 都共享了。也就是说，整个进程里的所有线程共享一个 <code>shared_pending</code>，这也是一个信号列表，是发给整个进程的，哪个线程处理都一样。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token function">init_sigpending</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sig<span class="token operator">-&gt;</span>shared_pending<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>至此，clone 在内核的调用完毕，要返回系统调用，回到用户态。</p></blockquote><h2 id="用户态执行线程" tabindex="-1"><a class="header-anchor" href="#用户态执行线程" aria-hidden="true">#</a> <strong>用户态执行线程</strong></h2><p>根据 __clone 的第一个参数，回到用户态也不是直接运行我们指定的那个函数，而是一个通用的 <code>start_thread，这是所有线程在用户态的统一入口。</code></p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">START_THREAD_DEFN</span> <span class="token punctuation">\\</span>
  <span class="token expression"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>noreturn<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">start_thread</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span></span></span>


START_THREAD_DEFN
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">pthread</span> <span class="token operator">*</span>pd <span class="token operator">=</span> START_THREAD_SELF<span class="token punctuation">;</span>
    <span class="token comment">/* Run the code the user provided.  */</span>
    <span class="token function">THREAD_SETMEM</span> <span class="token punctuation">(</span>pd<span class="token punctuation">,</span> result<span class="token punctuation">,</span> pd<span class="token operator">-&gt;</span><span class="token function">start_routine</span> <span class="token punctuation">(</span>pd<span class="token operator">-&gt;</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* Call destructors for the thread_local TLS variables.  */</span>
    <span class="token comment">/* Run the destructor for the thread-local data.  */</span>
    <span class="token function">__nptl_deallocate_tsd</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__glibc_unlikely</span> <span class="token punctuation">(</span><span class="token function">atomic_decrement_and_test</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>__nptl_nthreads<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment">/* This was the last thread.  */</span>
        <span class="token function">exit</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">__free_tcb</span> <span class="token punctuation">(</span>pd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">__exit_thread</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 start_thread 入口函数中，才真正的调用用户提供的函数，在用户的函数执行完毕之后，会释放这个线程相关的数据。例如，线程本地数据 thread_local variables，线程数目也减一。如果这是最后一个线程了，就直接退出进程，另外 __free_tcb 用于释放 pthread。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> internal_function
<span class="token function">__free_tcb</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pthread</span> <span class="token operator">*</span>pd<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token function">__deallocate_stack</span> <span class="token punctuation">(</span>pd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">void</span> internal_function
<span class="token function">__deallocate_stack</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pthread</span> <span class="token operator">*</span>pd<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token comment">/* Remove the thread from the list of threads with user defined
     stacks.  */</span>
  <span class="token function">stack_list_del</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>pd<span class="token operator">-&gt;</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* Not much to do.  Just free the mmap()ed memory.  Note that we do
     not reset the &#39;used&#39; flag in the &#39;tid&#39; field.  This is done by
     the kernel.  If no thread has been created yet this field is
     still zero.  */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__glibc_likely</span> <span class="token punctuation">(</span><span class="token operator">!</span> pd<span class="token operator">-&gt;</span>user_stack<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token function">queue_stack</span> <span class="token punctuation">(</span>pd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>__free_tcb</code> 会调用 <code>__deallocate_stack</code> 来释放整个线程栈，这个线程栈要从当前使用线程栈的列表 stack_used 中拿下来，放到缓存的线程栈列表 stack_cache 中。</p><p>好了，整个线程的生命周期到这里就结束了。</p><h2 id="总结时刻" tabindex="-1"><a class="header-anchor" href="#总结时刻" aria-hidden="true">#</a> <strong>总结时刻</strong></h2><p>线程的调用过程解析完毕了，我画了一个图总结一下。这个图对比了<code>创建进程</code>和<code>创建线程</code>在<mark>用户态</mark>和<mark>内核态</mark>的不同。</p><ul><li>创建进程的话，调用的系统调用是 fork，在 copy_process 函数里面，<br> 会将五大结构 files_struct、fs_struct、sighand_struct、signal_struct、mm_struct 都复制一遍，<br> 从此父进程和子进程各用各的数据结构。</li><li>而创建线程的话，调用的是系统调用 clone，在 copy_process 函数里面，<br> 五大结构仅仅是引用计数加一，<br> 也即线程共享进程的数据结构。</li></ul><figure><img src="`+i+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><blockquote><ul><li>线程的创建</li><li>线程是由内核态和用户态合作完成的, pthread_create 是 Glibc 库的一个函数</li><li>pthread_create 中</li></ul><ol><li><p>设置线程属性参数, 如线程栈大小</p></li><li><p>创建用户态维护线程的结构, pthread</p></li><li><p>创建线程栈 allocate_stack</p><ul><li>取栈的大小, 在栈末尾加 guardsize</li><li>在进程堆中创建线程栈(先尝试调用 get_cached_stack 从缓存回收的线程栈中取用)</li><li>若无缓存线程栈, 调用 <code>__mmap</code> 创建</li><li>将 pthread 指向栈空间中</li><li>计算 guard 内存位置, 并设置保护</li><li>填充 pthread 内容, 其中 specific 存放属于线程的全局变量</li><li>线程栈放入 stack_used 链表中(另外 stack_cache 链表记录回收缓存的线程栈)</li></ul></li><li><p>设置运行函数, 参数到 pthread 中</p></li><li><p>调用 create_thread 创建线程</p><ul><li>设置 clone_flags 标志位, 调用 <code>__clone</code></li><li>clone 系统调用返回时, 应该要返回到新线程上下文中, 因此 <code>__clone</code> 将参数和指令位置压入栈中, 返回时从该函数开始执行</li></ul></li><li><p>内核调用 <code>__do_fork</code></p><ul><li>在 copy_process 复制 task_struct 过程中, 五大数据结构不复制, 直接引用进程的</li><li>亲缘关系设置: group_leader 和 tgid 是当前进程; real_parent 与当前进程一样</li><li>信号处理: 数据结构共享, 处理一样</li></ul></li><li><p>返回用户态, 先运行 start_thread 同样函数</p><ul><li>在 start_thread 中调用用户的函数, 运行完释放相关数据</li><li>如果是最后一个线程直接退出</li><li>或调用 <code>__free_tcb</code> 释放 pthread 以及线程栈, 从 stack_used 移到 stack_cache 中</li></ul></li></ol></blockquote><h2 id="课堂练习" tabindex="-1"><a class="header-anchor" href="#课堂练习" aria-hidden="true">#</a> <strong>课堂练习</strong></h2><p>你知道如果查看一个进程的线程以及线程栈的使用情况吗？请找一下相关的命令和 API，尝试一下。</p><p>欢迎留言和我分享你的疑惑和见解，也欢迎你收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习、进步。</p><h2 id="课后讨论" tabindex="-1"><a class="header-anchor" href="#课后讨论" aria-hidden="true">#</a> 课后讨论</h2><p>总结以下进程和线程的异同点：</p><ol><li><p>进程有独立的内存空间，比如代码段，数据段。</p><p><code>线程 则是共享 进程的内存空间VAS</code>。</p></li><li><p>在创建新进程的时候，会将父进程的所有五大数据结构复制新的，形成自己新的内存空间数据，</p><p>而在创建新线程的时候，则是引用进程的五大数据结构数据，但是线程会有自己的私有（局部）数据，执行栈空间。</p></li><li><p>进程和线程其实在cpu看来都是task_struct结构的一个封装，执行不同task即可，</p><p>而且在cpu看来就是在执行这些task时候遵循对应的调度策略以及上下文资源切换定义，<br> 包括寄存器地址切换，内核栈切换，指令指针寄存器的地址切换。<br> 所以对于cpu而言，进程和线程是没有区别的。</p></li><li><p>进程创建的时候直接使用系统调用fork，进行系统调用的链路走，从而进入到<code>_do_fork</code>去创建task，</p><p>而线程创建在调用<code>_do_fork</code>之前，还需要维护<mark>pthread</mark>这个数据结构的信息，初始化<mark>用户态线程栈</mark>的相关信息。</p></li></ol><p>pstree apl pid看进程树<br> pstack pid 看栈<br> ulimit -a<br> 作者回复: 赞</p><p>老师, 多线程的内核栈是共享的吗, 会不会出现问题?<br> 作者回复: <code>不共享</code>，进了内核都是单独的任务了</p><p>老师之前说过进程默认会有一个主线程，意思是在创建进程的时候也会同时创建一个线程吗？<br> 作者回复: 不会，这个进程的task_struct就代表这个线程</p><p>&quot;将这个线程栈放到 stack_used 链表中，其实管理线程栈总共有两个链表，一个是 stack_used，也就是这个栈正被使用；另一个是 stack_cache，就是上面说的，一旦线程结束，先缓存起来，不释放，等有其他的线程创建的时候，给其他的线程用。&quot; 这一段是线程池的意思么 如果是的话 既然内部已经有这个设计 我们有时候还要在程序中自己去设计一个呢？<br> 作者回复: <code>内核没有线程池的概念</code>，把线程弄一个池子，是业务层做的。这里只是<code>内核栈的复用</code>。</p>',98),d={href:"http://man7.org/linux/manpages/man2/clone.2.html",target:"_blank",rel:"noopener noreferrer"},k=s("br",null,null,-1),v=s("br",null,null,-1),m=s("br",null,null,-1),_=s("br",null,null,-1),b=s("p",null,[n("请问一下老师为什么栈的结构是栈底是高地址栈顶是低地址呢，为什么不是反过来的呢？"),s("br"),n(" 作者回复: 约定")],-1),h=s("br",null,null,-1),g=s("br",null,null,-1),f=s("br",null,null,-1),y=s("br",null,null,-1),w=s("br",null,null,-1),E=s("br",null,null,-1),T=s("br",null,null,-1),x=s("br",null,null,-1),A=s("br",null,null,-1),L=s("br",null,null,-1),N=s("br",null,null,-1),C=s("br",null,null,-1),S=s("br",null,null,-1),R=s("br",null,null,-1),O=s("br",null,null,-1),z=s("br",null,null,-1),I=s("br",null,null,-1),D=s("br",null,null,-1),P=s("br",null,null,-1),q=s("br",null,null,-1),H=s("br",null,null,-1),G={href:"https://garlicspace.com/?p=1678&preview=true",target:"_blank",rel:"noopener noreferrer"},V=t("<p>1、<code>pthread_create</code> 不是一个系统调用，<code>是 Glibc 库的一个函数</code><br> 2、在内核里一样，每一个进程或者线程都有一个 task_struct 结构，线程在用户态也有一个用于维护线程的结构，就是这个 pthread 结构<br> 3、创建线程栈<br> 用户态int err = ALLOCATE_STACK (iattr, &amp;pd);<br> 程属性里面设置过栈的大小，需要你把设置的值拿出来<br> 为了防止栈的访问越界，在栈的末尾会有一块空间 guardsize<br> 其实线程栈是在进程的堆里面创建的get_cached_stack<br> 如果缓存里面没有，就需要调用 <code>__mmap</code> 创建一块新的<br> 线程栈也是自顶向下生长的，还记得每个线程要有一个 pthread 结构，这个结构也是放在栈的空间里面的。在栈底的位置，其实是地址最高位。<br> 计算出 guard 内存的位置，调用 setup_stack_prot 设置这块内存的是受保护的<br> 开始填充 pthread 这个结构里面的成员变量 stackblock、stackblock_size、guardsize、specific。<br> 将这个线程栈放到 stack_used 链表中，使用完之后放到stack_cache中<br> 其实有了用户态的栈，接着需要解决的就是用户态的程序从哪里开始运行的问题<br> pd&gt;start_routine = start_routine;<br> pd&gt;arg = arg;<br> pd&gt;schedpolicy = self&gt;schedpolicy;<br> pd&gt;schedparam = self&gt;schedparam;<br> /* Pass the descriptor to the caller. */<br> *newthread = (pthread_t) pd;<br> atomic_increment (&amp;__nptl_nthreads);<br> retval = create_thread (pd, iattr, &amp;stopped_start, STACK_VARIABLES_ARGS, &amp;thread_ran);<br> start_routine 就是咱们给线程的函数，start_routine，start_routine 的参数 arg，以及调度策略都要赋值给 pthread</p><p>内核态<br> 系统调用__clone<br> 将线程要执行的函数的参数和指令的位置都压到栈里面，当从内核返回，从栈里弹出来的时候，就从这个函数开始<br> 在 copy_process 复制 task_struct 过程中, files、fs、sighand、mm、五大数据结构不复制, 直接引用进程的<br> 亲缘关系：新进程group_leader就是自己，tgid就是他的pid，real_parent 是当前的进程。新线程group_leader是当前进程的，tgid是当前进程的tgid，real_parent 是当前集成的real_parent；<br> 信号处理：共享信号</p><p>4、用户态执行线程<br> 所有的线程统一的入口start_thread<br> 用户的函数执行完毕之后，会释放这个线程相关的数据<br> a、线程数目也减一，如果这是最后一个线程了，就直接退出进程<br> b、_free_tcb 用于释放 pthread，<code>__free_tcb</code> 会调用 <code>__deallocate_stack</code> 来释放整个线程栈，放到缓存的线程栈列表 stack_cache 中；</p><p>之前总是认为线程和进程都占用了内核的 taskstruct 认为实际上线程进程没啥区别，这篇文章真是醍醐灌顶啊，谢谢老师。<br> 作者回复: 赞，加油</p><p>老师, 我最近在看k8s专栏, docker的原理是使用clone的namespace参数, 所以容器的创建, 实际上是线程的创建吗<br> 作者回复: 在容器那一节会讲的，clone有个特殊的参数操作namespace。其实clone和fork底层调用的是差不多的</p><p>问一下，如果一个信号是进程共享，比如说kill，那么是主线程会收到这个信号还是这个进程的任意一个线程都有可能收到？麻烦老师解答下<br> 作者回复: 后面会讲信号的，信号会挂在一个数据结构上，所有的线程都能访问到的</p>",6);function B(F,M){const a=o("ExternalLinkIcon");return c(),l("div",null,[u,s("p",null,[n("关于clone_flags标志位的含义，可以参考一下这里"),s("a",d,[n("http://man7.org/linux/manpages/man2/clone.2.html"),e(a)]),k,n(" If CLONE_THREAD is set, the child is placed in the same thread group as the calling process."),v,n(" When a clone call is made without specifying CLONE_THREAD, then the resulting thread is placed in a new thread group whose TGID is the same as the thread's TID. This thread is the leader of the new thread group."),m,n(" If CLONE_PARENT is set, then the parent of the new child (as returned by getppid(2)) will be the same as that of the calling process."),_,n(" If CLONE_PARENT is not set, then (as with fork(2)) the child's parent is the calling process.")]),b,s("p",null,[n("进程线程查看命令：ps，top，pidstat，pstree"),h,n(" 函数栈查看打印命令："),g,n(" pstack"),f,n(" jstack (java)"),y,n(" gdb (C/C++/go)"),w,n(" kill SIGQUIT [pid] (go)"),E,n(" 相关API:"),T,n(" C:"),x,n(" glibc backtrace"),A,n(" Boost stacktrace"),L,n(" libunwind"),N,n(" Java:"),C,n(" getStackTrace;"),S,n(" go:"),R,n(" panic"),O,n(" debug.PrintStack"),z,n(' pprof.Lookup("goroutine").WriteTo'),I,n(" runtime.Stack"),D,n(" python:"),P,n(" traceback objects"),q,n(" StackSummary Objects"),H,n(" 笔记链接 "),s("a",G,[n("https://garlicspace.com/?p=1678&preview=true"),e(a)])]),V])}const j=p(r,[["render",B],["__file","H19-线程的创建.html.vue"]]);export{j as default};
