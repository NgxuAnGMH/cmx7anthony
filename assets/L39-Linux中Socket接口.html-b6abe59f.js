import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o,c,a as n,b as s,e as p,d as i}from"./app-cdabc73c.js";const r="/assets/3ef6855cddf1dd6b623747769dc20423-dce2c176.jpg",l={},u=i('<h1 id="_39-瞧一瞧linux-详解socket实现与网络编程接口" tabindex="-1"><a class="header-anchor" href="#_39-瞧一瞧linux-详解socket实现与网络编程接口" aria-hidden="true">#</a> 39 | 瞧一瞧Linux：详解socket实现与网络编程接口</h1><p>你好，我是 LMOS。</p><p>前面我们了解了网络的宏观架构，建立了网络模块知识的大局观，也进行了实际的组网实践。现在我们来瞧一瞧 Linux 的网络程序，不过想要入门 Linux 的网络编程，套接字也是一个绕不开的重要知识点，正是有了套接字，Linux 系统才拥有了网络通信的能力。而且网络协议的最底层也是套接字，有了这个基础，你再去看相关的网络协议的时候也会更加轻松。</p><p>我会通过两节课的内容带你了解套接字的原理和具体实现。这节课，我们先来了解套接字的作用、工作原理和关键数据结构。下一节课，我们再一起研究它在 Linux 内核中的设计与实现。</p><p>好，让我们开始今天的学习吧。</p><h2 id="如何理解套接字" tabindex="-1"><a class="header-anchor" href="#如何理解套接字" aria-hidden="true">#</a> 如何理解套接字</h2><p>根据底层网络机制的差异，计算机网络世界中定义了<strong>不同协议族的套接字（socket）</strong>，比如</p><ul><li>DARPA Internet 地址（Internet 套接字）、</li><li>本地节点的路径名（Unix 套接字）、</li><li>CCITT X.25 地址（X.25 套接字）等。</li></ul><p>我们会重点讲解跟<mark>网络子系统</mark>和 <mark>TCP/IP 协议栈</mark>息息相关的一种套接字——<mark>Internet 套接字</mark>。如果你对其他类型的套接字有兴趣，可以自行阅读这里的资料。</p><blockquote><p>Internet 套接字是 TCP/IP 协议栈中传输层协议的接口，也是传输层以上所有协议的实现。</p></blockquote><p>同时，套接字接口在网络程序功能中是<strong>内核</strong>与<strong>应用层</strong>之间的接口。TCP/IP 协议栈的所有数据和控制功能都来自于套接字接口，与 OSI 网络分层模型相比，TCP/IP 协议栈本身在传输层以上<strong>就不包含任何其他协议</strong>。</p><p>在 Linux 操作系统中，替代传输层以上协议实体的标准接口，称为<mark>套接字</mark>，它负责实现传输层以上所有的功能，可以说套接字<strong>是 TCP/IP 协议栈对外的窗口</strong>。</p><p>Linux 套接字 API 适合所有的应用标准，现在的应用层协议也全部移植到了 Linux 系统中。但请你注意，在套接字层下的基础体系结构实现却是 Linux 系统独有的，Linux 内核支持的套接字结构如图所示。</p><img src="'+r+`" alt="img" style="zoom:15%;"><p>socket</p><p>我们创建套接字时，可以通过参数选择协议族，为应用程序指定<strong>不同的网络机制</strong>。如果指定为 <code>PF_INET 协议族</code>，这里的套接字就叫做 <code>INET 套接字</code>，它的套接字接口函数提供了 <code>TCP/IP 网络服务功能</code>。现在我先带你了解一下套接字的数据结构。</p><h2 id="套接字的数据结构" tabindex="-1"><a class="header-anchor" href="#套接字的数据结构" aria-hidden="true">#</a> 套接字的数据结构</h2><p>在 Linux 操作系统下，对套接字、套接字的属性、套接字传输的数据格式还有管理套接字连接状态的数据结构分别做了一系列抽象定义。</p><p><mark>每个程序使用的套接字</mark>都有一个 <strong>struct <code>socket</code></strong> 数据结构与 <strong>struct <code>sock</code></strong> 数据结构的实例。</p><p>Linux 内核在套接字层定义了包含套接字<strong>通用属性的数据结构</strong>，分别是 struct socket 与 struct sock，<strong>它们独立于具体协议</strong>；而具体的协议族与协议实例继承了通用套接字的属性，<strong>加入协议相关属性</strong>，就形成了管理协议本身套接字的结构。</p><h3 id="_1-struct-socket-数据结构" tabindex="-1"><a class="header-anchor" href="#_1-struct-socket-数据结构" aria-hidden="true">#</a> 1) struct socket 数据结构</h3><p>struct socket 是套接字结构类型，每个套接字在内核中都对应唯一的 struct socket 结构（用户程序通过<mark>唯一的套接字描述符</mark>来表示套接字，且描述符与 struct socket 结构一一对应）。</p><p>我们来看看 struct socket 数据结构是什么样，代码如下，我相信配合注释你有能力理解它。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token punctuation">{</span> 
    socket_state            state<span class="token punctuation">;</span>  <span class="token comment">// 套接字的状态</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>           flags<span class="token punctuation">;</span>  <span class="token comment">// 套接字的设置标志。存放套接字等待缓冲区的状态信息，其值的形式如SOCK_ASYNC_NOSPACE等</span>
    <span class="token keyword">struct</span> <span class="token class-name">fasync_struct</span>    <span class="token operator">*</span>fasync_list<span class="token punctuation">;</span>  <span class="token comment">// 等待被唤醒的套接字列表，该链表用于异步文件调用</span>
    <span class="token keyword">struct</span> <span class="token class-name">file</span>             <span class="token operator">*</span>file<span class="token punctuation">;</span>  <span class="token comment">// 套接字所属的文件描述符</span>
    <span class="token keyword">struct</span> <span class="token class-name">sock</span>             <span class="token operator">*</span>sk<span class="token punctuation">;</span>  <span class="token comment">// 指向存放套接字属性的结构指针</span>
    <span class="token class-name">wait_queue_head_t</span>       wait<span class="token punctuation">;</span>  <span class="token comment">//套接字的等待队列</span>
    <span class="token keyword">short</span>                   type<span class="token punctuation">;</span>  <span class="token comment">// 套接字的类型。其取值为SOCK_XXXX形式</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">proto_ops</span> <span class="token operator">*</span>ops<span class="token punctuation">;</span>  <span class="token comment">// 套接字层的操作函数块</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-struct-sock-数据结构" tabindex="-1"><a class="header-anchor" href="#_2-struct-sock-数据结构" aria-hidden="true">#</a> 2) struct sock 数据结构</h3><p>在 Linux 内核的早期版本中，struct sock 数据结构非常复杂。从 Linux2.6 版本以后，从两个方面对该数据结构做了优化。</p><p>其一是将 struct sock 数据结构划分成了两个部分。</p><ol><li>一部分为描述<strong>套接字的共有属性</strong>，所有协议族的这些属性都一样；</li><li>另一部分属性定义在了 <strong>struct sock_common</strong> 数据结构中。</li></ol><p>其二是为新套接字创建 struct sock 数据结构实例时，会从<mark>协议特有的缓冲槽</mark>中分配内存，不再从<mark>通用缓冲槽</mark>中分配内存。</p><p>struct sock 数据结构包含了大量的**<code>内核管理套接字</code>的信息**，内核把最重要的成员存放在 struct sock_common 数据结构中，struct sock_common 数据结构嵌入在 struct sock 结构中，它是 struct sock 数据结构的第一个成员。</p><p><strong>struct sock_common</strong> 数据结构是套接字在网络中的最小描述，它包含了<strong>内核管理套接字<code>最重要信息的集合</code></strong>。而 struct sock 数据结构中包含了套接字的全部信息与特点，有的特性很少用到，甚至根本就没有用到。我们这里就看一下 struct sock_common 的数据结构，代码如下。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>    <span class="token keyword">struct</span> <span class="token class-name">sock_common</span> <span class="token punctuation">{</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">short</span>      skc_family<span class="token punctuation">;</span>         <span class="token comment">/*地址族*/</span>
        <span class="token keyword">volatile</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span>  skc_state<span class="token punctuation">;</span>      <span class="token comment">/*连接状态*/</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">char</span>       skc_reuse<span class="token punctuation">;</span>          <span class="token comment">/*SO_REUSEADDR设置*/</span>
        <span class="token keyword">int</span>         skc_bound_dev_if<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">hlist_node</span>   skc_node<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">hlist_node</span>   skc_bind_node<span class="token punctuation">;</span>      <span class="token comment">/*哈希表相关*/</span>
        <span class="token class-name">atomic_t</span>        skc_refcnt<span class="token punctuation">;</span>             <span class="token comment">/*引用计数*/</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结合代码可以看到，系统中 struct sock 数据结构组织在特定协议的哈希链表中，skc_node 是连接哈希链表中成员的哈希节点，skc_hash 是引用的哈希值。接收和发送数据放在数据 struct sock 数据结构的两个等待队列中：sk_receive_queue 和 sk_write_queue。这两个队列中包含的都是 Socket Buffer（后面我会展开讲）。</p><p>内核使用 struct sock 数据结构实例中的回调函数，获取套接字上某些事件发生的消息或套接字状态发生变化。其中，使用最频繁的回调函数是 <strong>sk_data_ready</strong>，用户进程等待数据到达时，就会调用该回调函数。</p><h2 id="套接字与文件" tabindex="-1"><a class="header-anchor" href="#套接字与文件" aria-hidden="true">#</a> 套接字与文件</h2><p>套接字的连接建立起来后，用户进程就可以使用<mark>常规文件操作</mark>访问<mark>套接字</mark>了。</p><p>这种方式在内核中如何实现，这要取决于 ==Linux 虚拟文件系统层（VFS）==的实现。在 VFS 中，每个文件都有一个 VFS inode 结构，每个套接字都分配了一个该类型的 inode，套接字中的 inode 指针连接管理常规文件的其他结构。操作文件的函数存放在一个独立的指针表中，代码如下。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">inode</span><span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">file_operation</span> <span class="token operator">*</span>i_fop <span class="token comment">// 指向默认文件操作函数块</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>套接字的文件描述符的文件访问的重定向，对网络协议栈各层是透明的。而 inode 和 socket 的链接是通过直接分配一个辅助数据结构来实现的，这个数据结构的代码如下。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">socket_slloc</span> <span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">socket</span> socket<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">inode</span> vfs_inode<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="套接字缓存-socket-buffer" tabindex="-1"><a class="header-anchor" href="#套接字缓存-socket-buffer" aria-hidden="true">#</a> 套接字缓存: Socket Buffer</h2><p>前面我们提到了一个 <code>Socket Buffer</code>，也就是套接字缓存，它代表了一个要发送或者处理的报文。在 Linux 网络子系统中，Socket Buffer 是一个关键的数据结构，因为它贯穿于整个 TCP/IP 协议栈的各层。Linux 内核对网络数据打包处理的全过程中，始终伴随着这个 Socket Buffer。</p><p>你可以这样理解，<strong>Socket Buffer 就是<mark>网络数据包</mark>在内核中的对象实例。</strong></p><p>Socket Buffer 主要由两部分组成。</p><ul><li><p>\\1. 数据包：存放了在网络中实际流通的数据。</p></li><li><p>\\2. 管理数据结构（struct sk_buff）：当在内核中对数据包进行时，内核还需要一些其他的数据来管理数据包和操作数据包，</p><p>例如协议之间的交换信息，数据的状态，时间等。</p></li></ul><p>Socket Buffer 有什么作用呢？struct sk_buff 数据结构中存放了套接字接收 / 发送的数据。在发送数据时，在套接字层创建了 Socket Buffer 缓冲区与管理数据结构，<strong>存放来自<code>应用程序</code>的数据</strong>。在接收数据包时，Socket Buffer 则在网络设备的驱动程序中创建，<strong>存放来自<code>网络</code>的数据</strong>。</p><p>在发送和接受数据的过程中，各层协议的头信息会不断从数据包中插入和去掉，sk_buff 结构中描述协议头信息的地址指针也会被不断地赋值和复位。</p><h2 id="套接字的初始化" tabindex="-1"><a class="header-anchor" href="#套接字的初始化" aria-hidden="true">#</a> 套接字的初始化</h2><p>Linux 的网络体系结构可以支持多个协议栈和网络地址类型。内核支持的每一个协议栈都会在套接字层注册<mark>一个地址族</mark>。这就解释了为什么在<mark>套接字层</mark>可以有一个通用的 API，供完全不同的协议栈使用。</p><p>Linux 内核支持的地址族非常多，<mark>TCP/IP 协议栈</mark>在套接字层注册的地址族是 AF_INET，<code>AF_INET 地址族</code>是在内核启动时注册到内核中的。TCP/IP 协议栈与 AF_INET 地址族相连的处理函数，既可以在套接字初始化时与 AF_INET 地址连接起来，也可以在套接字中动态地注册新的协议栈。</p><p>套接字层的初始化要为以后各协议初始化 struct sock 数据结构对象、套接字缓冲区 Socket Buffer 对象等做好准备，预留内存空间。</p><p>套接字层初始化要完成的基本任务包括后面这三项。</p><ul><li><p>\\1. 初始化套接字的<strong>缓存槽</strong></p></li><li><p>\\2. 为 Socket Buffer 创建<strong>内存缓存槽</strong></p></li><li><p>\\3. 创建<strong>虚拟文件</strong>系统</p></li></ul><p>初始化函数代码如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">sock_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">int</span> err<span class="token punctuation">;</span>       
 <span class="token comment">/*      
  *      初始化.sock缓存       
  */</span>        
 <span class="token function">sk_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       
  <span class="token comment">/*     
  *      初始化sk_buff缓存       
        skb_init();           
  /*      初始化协议模块缓存      
        
  init_inodecache();           
  /* 注册文件系统类型   */</span>
err <span class="token operator">=</span> <span class="token function">register_filesystem</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sock_fs_type<span class="token punctuation">)</span><span class="token punctuation">;</span>       
<span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span>           <span class="token keyword">goto</span> out_fs<span class="token punctuation">;</span>       
sock_mnt <span class="token operator">=</span> <span class="token function">kern_mount</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sock_fs_type<span class="token punctuation">)</span><span class="token punctuation">;</span>       
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>sock_mnt<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        
  err <span class="token operator">=</span> <span class="token function">PTR_ERR</span><span class="token punctuation">(</span>sock_mnt<span class="token punctuation">)</span><span class="token punctuation">;</span>         
   <span class="token keyword">goto</span> out_mount<span class="token punctuation">;</span>      
  <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="地址族的值和协议交换表" tabindex="-1"><a class="header-anchor" href="#地址族的值和协议交换表" aria-hidden="true">#</a> 地址族的值和协议交换表</h2><p>套接字是一个通用接口，它可以与多个协议族建立接口，每个协议族中又可以实现多个协议实例。</p><p>TCP/IP 协议栈处理完输入数据包后，将数据包交给套接字层，放在套接字的接收缓冲区队列（sk_rcv_queue）。然后数据包从套接字层离开内核，送给应用层等待数据包的用户程序。用户程序向外发送的数据包缓存在套接字的传送缓冲区队列（sk_write_queue），从套接字层进入内核地址空间。</p><p>在同一个主机中，可以同时在多个协议上打开多个套接字，来接收和发送网络数据，套接字层必须确定哪个套接字是当前数据包的目标套接字。</p><p>怎么精准确定呢？</p><p>在 Linux 内核里有一个叫做 struct inet_protosw 的数据结构，它就负责完成这个功能，具体来看就是管理和描述 struct proto_ops 和 struct proto 之间的对应关系。这里 struct proto_ops 就是系统调用套接字的操作函数块，而 struct proto 就是跟内核协议相关的套接字操作函数块。</p><p>后面这段代码是 inet_protosw。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">inet_protosw</span> <span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">list_head</span> list<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">short</span>   type<span class="token punctuation">;</span>     <span class="token comment">/* AF_INET协议族套接字的类型,如TCP为SOCK_STREAM*/</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">short</span>   protocol<span class="token punctuation">;</span> <span class="token comment">/* 协议族中某个协议实例的编号。如TCP协议的编码为IPPROTO_TCP  */</span>
 
  <span class="token keyword">struct</span> <span class="token class-name">proto</span>   <span class="token operator">*</span>prot<span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">proto_ops</span> <span class="token operator">*</span>ops<span class="token punctuation">;</span>
  
  <span class="token keyword">unsigned</span> <span class="token keyword">char</span>   flags<span class="token punctuation">;</span>      <span class="token comment">/* 该套接字属性的相关标志  */</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结合上面代码我们发现，内核使用 <strong>struct</strong> <strong>inet_protosw</strong> 数据结构实现的协议交换表，将应用程序通过 socketcall 系统调用指定的套接字操作，转换成对某个协议实例实现的套接字操作函数的调用。</p><p>struct inet_protosw 类型把 INET 套接字的协议族操作集与传输层协议操作集关联起来。该类型的 <strong>inetsw_array</strong> 数组变量实现了 INET 套接字的协议族操作集与具体的传输层协议关联。由 struct inet_protosw 数据结构类型数组 inetsw_array[]构成的向量表，称为<strong>协议交换表</strong>，协议交换表满足了套接字支持多协议栈这项功能。</p><h2 id="重点回顾" tabindex="-1"><a class="header-anchor" href="#重点回顾" aria-hidden="true">#</a> 重点回顾</h2><p>好，这节课的内容告一段落了，我来给你做个总结。这节课我们一起理解了 Linux 内核套接字的概念。</p><p>套接字是 UNIX 兼容系统的一大特色，是 UNIX 一切皆是文件操作概念的具体实现，从实现的角度来看，**套接字是通信的抽象描述；**从内核角度看，同时也是一个管理通信过程的对象——<strong>struct socket 结构</strong>。</p><p>Linux 的网络体系结构可以支持多个协议栈和网络地址类型，通过地址族的值和协议交换表，Linux 的套接字实现了支持多协议栈这项功能。</p><p>我特意为你梳理了这节课最关键的两个要点，需要你重点理解。</p><ul><li><p>\\1. 从描述 Linux 套接字接口的数据结构、套接字接口初始化过程可知，</p><p>Linux 套接字体系结构独立于具体网络协议栈的套接字，可以同时支持多个网络协议栈的工作。</p></li><li><p>\\2. 套接字内核实现，我们具体分析了套接字从创建的过程。</p><p>根据分析我们可以发现，任何协议栈都可以在套接字通用体系结构的基础上，派生出具有<strong>协议族特点</strong>的套接字接口。</p></li></ul><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题" aria-hidden="true">#</a> 思考题</h2><p>套接字也是一种进程间通信机制，它和其他通信机制有什么不同？</p><blockquote><p>进程间的通信方式有很多，比如说管道，共享内存，信号等，但这些通信方式都有一个很大的局限性，那就是无法跨物理机通信，只能与同一个机器上的其它进程通信，而套接字恰好打破了这个桎梏，只要你在线上(网络上)，我就可以通过ip地址打你电话，和你说话！即套接字可以跨主机，其他的不可以</p></blockquote><h2 id="课后讨论" tabindex="-1"><a class="header-anchor" href="#课后讨论" aria-hidden="true">#</a> 课后讨论</h2>`,75),d={href:"https://mp.weixin.qq.com/s/XqXIvEfhNPXQ1RSs0XeFUQ",target:"_blank",rel:"noopener noreferrer"},k=n("p",null,[s("今天一天看完了您的所有课程，收获非常非常大。尤其是：要实现一个"),n("mark",null,"功能模块"),s("，首先要设计出相应的"),n("mark",null,"数据结构"),s("(以及这些数据结构的"),n("mark",null,"管理数据结构"),s("，比如链表等)，基于数据结构设计"),n("mark",null,"初始化函数"),s("以及该功能模块对应的"),n("mark",null,"业务函数"),s("。为学习操作系统模块或所有技术项目代码提供了思路，感谢东哥。"),n("br"),s(" 作者回复: 哈哈 对的 基于数据结构才能解决问题")],-1);function m(v,_){const a=t("ExternalLinkIcon");return o(),c("div",null,[u,n("p",null,[s("昨天一天撸完，体会很深，专门写了一个学习总结与linux的爬坡之路，"),n("a",d,[s("https://mp.weixin.qq.com/s/XqXIvEfhNPXQ1RSs0XeFUQ"),p(a)]),s(" 麻烦多指正，过去一直持续在学linux，这个时候看到您的文章对我是一个很好的沉淀与认知突破，巨感谢大佬")]),k])}const g=e(l,[["render",m],["__file","L39-Linux中Socket接口.html.vue"]]);export{g as default};
