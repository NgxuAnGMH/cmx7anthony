import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{r,o as s,c as o,a as e,b as a,e as i,d as g}from"./app-cdabc73c.js";const d="/assets/640-1691463245591-45-c0cef2dd.png",c="/assets/640-1691463245591-46-d2937feb.png",p="/assets/640-1691463245591-47-b6d044fd.png",l="/assets/640-1691463245592-48-ed3b057f.png",u="/assets/640-1691463245592-49-cc0018ad.png",h="/assets/640-1691463245592-50-5fa39a66.png",f="/assets/640-1691463245592-51-4e56b0b5.png",z="/assets/640-1691463245592-52-f4201ef1.png",m="/assets/640-1691463245592-53-b7f9c588.png",_={},b=e("h1",{id:"_48-白泽带你读论文丨ijon-exploring-deep-state-spaces-via-fuzzing",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_48-白泽带你读论文丨ijon-exploring-deep-state-spaces-via-fuzzing","aria-hidden":"true"},"#"),a(" 48-白泽带你读论文丨IJON: Exploring Deep State Spaces via Fuzzing")],-1),x=e("p",null,[e("strong",null,"IJON: Exploring Deep State Spaces via Fuzzing")],-1),v=e("p",null,"论文链接：",-1),w={href:"https://www.syssec.ruhr-uni-bochum.de/media/emma/veroeffentlichungen/2020/02/27/IJON-Oakland20.pdf",target:"_blank",rel:"noopener noreferrer"},S=e("p",null,"YouTube 视频介绍：",-1),I={href:"https://www.youtube.com/watch?v=XuyF-Jb2hQ4&list=PL0pRF4xvoD0n5MV4cPdF-AvrvRGQVYa-q&index=79&t=0s",target:"_blank",rel:"noopener noreferrer"},F={href:"https://github.com/RUB-SysSec/ijon",target:"_blank",rel:"noopener noreferrer"},y=g('<p>本文选自S&amp;P 2020，作者均来自德国的波鸿鲁尔大学系统安全实验室，如果对该实验室感兴趣，可以去他们的官方网站上获得更多信息。</p><h2 id="_1-主要内容" tabindex="-1"><a class="header-anchor" href="#_1-主要内容" aria-hidden="true">#</a> <strong>1．主要内容</strong></h2><p>Fuzzing是时下最为流行的寻找漏洞的技术，当前的afl fuzzer 普遍基于代码覆盖率而设计，因为无法完备地描述Program State，Edge Coverage作为折中是目前使用最为广泛的覆盖率统计方法。而很多情况下，fuzzer 在fuzzing 一段时间后会由于不能提升 Code Coverage进而陷入停滞状态。</p><p>因此，受到工业界在 fuzzing 过程中 fuzzing =&gt; 分析结果 =&gt; 调整 seed 和 fuzz 策略 =&gt; fuzzing 的启发，结合human-in-the-loop 思想，本文提出了一个名为 IJON 的 fuzzer 辅助工具。该工具允许研究人员<em>利用注解来指导 afl fuzzer 的行为，以提高代码覆盖率以及状态空间中某些选定状态的覆盖率</em>。</p><p>通过实验，作者证明了 IJON 能有效地提高 fuzzer 的效果，解决了 10 个 CGC 挑战中的难题，并成功在真实软件 dmg2img 中找到了 3 个新的漏洞。</p><h2 id="_2-设计实现" tabindex="-1"><a class="header-anchor" href="#_2-设计实现" aria-hidden="true">#</a> <strong>2．设计实现</strong></h2><p>fuzzer 的目标是尽可能在程序的状态空间中找到“有趣”的区域，但“有趣”不是一个明确的指标，而afl 家族的成功表明 Edge Coverage 是一个非常有效的指标，每一条新的边都代表着一种新的情况。但在有些情况下，如果不结合额外的状态描述，fuzzer 很难产生新的代码覆盖率，即单单Edge Coverage在stuck后无法给予fuzzer有效的guidance。因此，作者认为此时需要研究人员通过对这些中间状态进行抽象总结并反馈给 fuzzer的方式让fuzzer 解决覆盖率的问题。</p><p>为此，论文中总结了三种需要分析总结的中间状态，并进行了详细分析：</p><h3 id="a-known-relevant-state-values" tabindex="-1"><a class="header-anchor" href="#a-known-relevant-state-values" aria-hidden="true">#</a> a) Known Relevant State Values</h3><p>以下面这段 C 实现的迷宫代码为例，可以看到只有当变量 x / y 满足一定条件时才会触发 Bug() 函数，但如果以 Edge Coverage 计算的话，一般情况下在覆盖四个分支（四个移动方向）后就不会再增加了，此时 fuzz 将进入没有正向回馈的停滞状态。因此，如果能有效地将 x / y 这两个变量值的变化作为反馈的因素，则能有效地提高 fuzz 的效率。</p><figure><img src="'+d+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>类似的，游戏超级马里奥也同样关注玩家的坐标，相比于庞大的状态空间，分析人员如果能提供一个更清晰的目标——比如说增加 x 坐标的值，fuzzer 就能更有效地探索程序的状态空间。</p><h3 id="b-known-state-changes" tabindex="-1"><a class="header-anchor" href="#b-known-state-changes" aria-hidden="true">#</a> b) Known State Changes</h3><p>有些情况下，虽然程序的状态变化是已知的，但哪些状态更“有趣”更值得研究是不确定的，因此也很难有效地对 fuzzer 的工作给予反馈。以下面这段代码为例，fuzzer 能覆盖三种不同的消息处理逻辑，但 fuzzer 很难生成有意思的消息序列。即使不同的消息序列会导致状态机内部的状态发生变化，fuzzer 也并没有区分出这种状态变化的能力。</p><figure><img src="'+c+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h3 id="c-missing-intermediate-state" tabindex="-1"><a class="header-anchor" href="#c-missing-intermediate-state" aria-hidden="true">#</a> c) Missing Intermediate State</h3><p>有些情况下，比如 magic number 的校验，程序的覆盖率和值都无法提供有效的反馈，因为该比较只有成功/失败两种可能性，但分析人员可以基于推断出的程序逻辑，结合人为的中间状态，为 fuzzing 提供指示。以下面的代码为例，该代码片段来自于 objdump，包含一个哈希表查找和一个 if 条件判断，用于搜索含有给定的字符串的项。fuzzer 需要解决比较问题，使得保持输入的哈希值始终等于目标字符串的哈希值。</p><figure><img src="'+p+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>为了研究人员能有效地解决上述三种情况，本文根据以下四个出发点设计了 IJON，一套辅助 AFL fuzzer 的注解机制。</p><ol><li>允许分析人员选择与解决当前的问题相关的代码区域。</li><li>允许对 AFL bitmap 的直接添加和设置条目，从而将状态值直接反馈给 Fuzzer。</li><li>允许分析人员影响覆盖率的计算，相同的 Edge Coverage 也可以得到不同的 Bitmap Coverage，由此能得到更细粒度的反馈。</li><li>引入了一个新的原语，使得分析人员能够在状态空间爆炸的情况下，利用爬山算法进行优化。</li></ol><p>该设计的整体示意图如下：</p><figure><img src="'+l+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h2 id="_3-实验评估" tabindex="-1"><a class="header-anchor" href="#_3-实验评估" aria-hidden="true">#</a> <strong>3．实验评估</strong></h2><p>实验机器配置：Debian 4.9.65-3，Intel Xeon E5-2667（12核），2.9GHz，94GB RAM</p><h3 id="a-the-maze-–-small-known-state-values" tabindex="-1"><a class="header-anchor" href="#a-the-maze-–-small-known-state-values" aria-hidden="true">#</a> a) The Maze – Small, Known State Values</h3><p>迷宫实验是符号执行工具最常见的测试用例。一般来说，AFL 和类似的 fuzzer 无法在合理的时间内解决问题，而 KLEE 可以在几秒钟内找到解决方案，因为该游戏的有效状态空间在采取的步骤数上是线性的，不会发生状态爆炸。为此，作者特意设计了一种复杂度更高的迷宫：玩家可以退后并停留在同一位置。此时，状态空间的可能性呈指数增长，连 KLEE 也无法成功解决迷宫问题。</p><p>作者还对每个版本的迷宫设计了小/大两个版本。在不同版本的迷宫实验中，实验使用的工具均会执行三次并统计；实验结果证明了该注解非常有效：</p><figure><img src="'+u+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h3 id="b-super-mario-bros-–-large-known-state-values" tabindex="-1"><a class="header-anchor" href="#b-super-mario-bros-–-large-known-state-values" aria-hidden="true">#</a> b) Super Mario Bros. – Large Known State Values</h3><p>第二个则是该文章最出圈的超级马里奥实验，作者对游戏进行了一定的修改，会从 stdin 读取所有键盘命令，并且游戏角色Mario始终会始终向右跑，停止移动时会死亡。这主要是为了加快游戏的节奏。作者使用IJON_MAX 注解来在每一个高度来最大化玩家的 x 坐标。在IJON的辅助下，Mario能顺利地通过关卡，而单纯的AFL则无法实现。</p><figure><img src="'+h+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h3 id="c-structured-input-formats-–-state-change-logging" tabindex="-1"><a class="header-anchor" href="#c-structured-input-formats-–-state-change-logging" aria-hidden="true">#</a> c) Structured Input Formats – State Change Logging</h3><p>该实验有两个组成部分，第一个实验是对论文 AFLSMART 的测试目标——libpng 和 WavPack 进行了测试，利用随机 wav/png 文件的前 1024 个字节作为种子，IJON 能发现该篇论文发现的所有漏洞；相应的，AFL 没有找到任何漏洞。此外，该工具还在 libpng 中发现了另一个越界读漏洞。</p><p>第二个实验则是在 LIBTPMS 上进行，在本实验中，作者并不关心是否解决约束，而是关注探索的不同消息序列的数量，所以只对 AFL 和 AFL+IJON 进行了评估，结果如下表所示，可以看到 IJON 很明显地增加了消息序列的数量。</p><figure><img src="'+f+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h3 id="d-binutils-hash-map-missing-intermediate-states" tabindex="-1"><a class="header-anchor" href="#d-binutils-hash-map-missing-intermediate-states" aria-hidden="true">#</a> d) Binutils Hash map - Missing Intermediate States</h3><p>作者使用带有和不带有 IJON 自定义注解的 fuzzer 进行了实验， 可以看到基本任何 fuzzer 都无法解决未修改的约束，但在使用了 IJON 注解后，基本所有的 fuzzer 都可以在几分钟内解决约束，只有 AFLFAST 在三分之二的测试中失败了，但唯一成功的一次也在 6 分钟内解决了约束。</p><figure><img src="'+z+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h3 id="e-cyber-grand-challenge" tabindex="-1"><a class="header-anchor" href="#e-cyber-grand-challenge" aria-hidden="true">#</a> e) Cyber Grand Challenge</h3><p>在随机选取的 30 个 CGC 挑战问题中，其中的八个目标，由于可能是移植版本的原因，即使用提供的 PoV 也不会导致崩溃。在剩下 22 个目标里，又有 12 个因为种种原因不能生效，最后 IJON 成功触发了 10 个挑战问题的 Crash，并证实有效地提高了AFL的覆盖率。</p><figure><img src="'+m+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h3 id="f-real-world-software" tabindex="-1"><a class="header-anchor" href="#f-real-world-software" aria-hidden="true">#</a> f) Real-World Software</h3><p>作者在这里选取了另一款 fuzz 工具 WEIZZ fuzz 过的工具 dmg2img 作为测试目标，在应用了补丁的版本上找到了三个全新的漏洞，前两个漏洞是 WEIZZ 找到的漏洞的变体，第三个漏洞是整数溢出，会导致 malloc(0) 的情况。</p><h2 id="_4-总结" tabindex="-1"><a class="header-anchor" href="#_4-总结" aria-hidden="true">#</a> <strong>4．总结</strong></h2><p>虽然 AFL 创新性地采取了 Edge Coverage 作为反馈的标准带来了非常优秀的效果，但不得不承认的是，这种策略在当下仍有无法解决的挑战。因此，在实际的 fuzzing 过程中，往往有人工的介入来对 fuzzer 的 seed 或者生成策略进行调整。本文工作创新性地将当前业界常用的 fuzz =&gt; 反馈 =&gt; 调整 =&gt; 继续 fuzz 这样一套流程系统化为了<mark>注解机制</mark>，允许研究人员用一到两行注解完成对 fuzzer 的干预，简化了研究人员与 fuzzer 间交互的成本。这种用人工指导fuzzer 的思路，在时下fuzzing相关研究陷入瓶颈的时候，具有非常重要的创新意义。</p><p>不过虽然该工作在论文的最后强调这种注解可能在未来的工作中可以尝试自动化地生成，但仍然具有很大的挑战。而如果人工的分析并加入注解，则需要大量的时间投入。此外，该工作在现实世界应用的例子也较为简单，找到的也是dmg2img 这种比较小众工具的漏洞。</p>',46);function k(N,C){const t=r("ExternalLinkIcon");return s(),o("div",null,[b,x,v,e("p",null,[e("a",w,[a("https://www.syssec.ruhr-uni-bochum.de/media/emma/veroeffentlichungen/2020/02/27/IJON-Oakland20.pdf"),i(t)])]),S,e("p",null,[e("a",I,[a("https://www.youtube.com/watch?v=XuyF-Jb2hQ4&list=PL0pRF4xvoD0n5MV4cPdF-AvrvRGQVYa-q&index=79&t=0s"),i(t)])]),e("p",null,[a("项目地址："),e("a",F,[a("https://github.com/RUB-SysSec/ijon"),i(t)])]),y])}const J=n(_,[["render",k],["__file","48-白泽带你读论文丨IJON Exploring Deep State Spaces via Fuzzing.html.vue"]]);export{J as default};
