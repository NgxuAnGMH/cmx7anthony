import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as c,o as r,c as p,a as e,b as a,d as s,e as o}from"./app-063765ff.js";const d="/assets/ed27329a1fb82df016d60a196yybb00b-6745e74e.jpg",i={},l=o('<h1 id="√课前热身-学习这门课前-你需要了解哪些知识" tabindex="-1"><a class="header-anchor" href="#√课前热身-学习这门课前-你需要了解哪些知识" aria-hidden="true">#</a> √课前热身｜学习这门课前，你需要了解哪些知识？</h1><p>你好，我是于航。</p><p>在我们正式进入到 C 语言课程的学习之前，为了帮助你更好地理解课程内容，我为你准备了一节基础知识讲解课。这是一节选学课，你可以根据自己的实际情况选择性学习。</p><p>在这一讲中，我会用通俗易懂的方式，为你介绍这门课中最常用的一些基础知识，分别是<code>常见数据量单位、汇编语言，以及 CPU 指令集中涉及的不同类型的寄存器。</code>如果你对这些内容还不太熟悉，那么通过这一讲，你可以对它们有一个大致的印象。我们后面的课程还会提到汇编指令或寄存器，我会视情况进行更加具体的讲解，帮你加深理解。</p><h2 id="数据量单位" tabindex="-1"><a class="header-anchor" href="#数据量单位" aria-hidden="true">#</a> 数据量单位</h2><h3 id="位bit-字节byte-固定通用" tabindex="-1"><a class="header-anchor" href="#位bit-字节byte-固定通用" aria-hidden="true">#</a> 位bit 字节byte (固定通用)</h3><p>==位（bit）==是计算机中最小的存储单位，每一个位可以存储一个二进制码值的 0 或 1。</p><p>而==字节（byte）==则通常是由<code>八个位</code>组成的一个存储单元。在计算机中，字节是<code>最小的可寻址单位</code>，这意味着 CPU 在使用数据时，可以以字节为单位，为每一字节内存分配一个相应的独立地址。</p><blockquote><p>位和字节是在我们的日常工作中最为常见的两个数据量概念，你应该很熟悉。</p></blockquote><h3 id="处理器的自然字word-硬件相关" tabindex="-1"><a class="header-anchor" href="#处理器的自然字word-硬件相关" aria-hidden="true">#</a> 处理器的自然字word (硬件相关)</h3><p>不过，==字（word）==的概念就没有这么清晰了。<strong>字的大小并不固定</strong>，一个字的大小可能是 2 的幂次个位，比如 16 位、32 位，也有可能是 12 位、27 位等一些并不常见的大小。而这主要是因为字的概念与<code>具体的处理器 或 硬件体系架构</code>直接相关，它跟位、字节这种较为通用和统一的数据量概念并不相同。</p><p>字是<code>处理器</code>设计时使用的<code>自然数据单位</code>，通常，这个大小会反映在计算机结构和相关操作的多个方面中。</p><ul><li>比如，处理器中大多数<code>寄存器的容量</code>是与字同样大小的，</li><li>处理器<code>单个指令可以操作的最大内存块</code>一般为一个字大小，</li><li>而<code>用于指定内存中某个具体位置的地址</code>，一般也是以处理器的自然字为宽度的。</li></ul><p>需要说明下，在这门课后面的内容中，<strong>所有给出的示例代码和相关分析，都是在平台类型为 x86-64 的实验机上进行的，而该平台的<code>字长为 64 位</code>。</strong></p><h2 id="汇编语言-cpu架构相关" tabindex="-1"><a class="header-anchor" href="#汇编语言-cpu架构相关" aria-hidden="true">#</a> 汇编语言(CPU架构相关)</h2><p>在计算机编程中，汇编语言（Assembly Language）是一种低级编程语言，语言使用的<code>指令与具体平台紧密相关</code>。</p><blockquote><p>这意味着，针对不同 <code>CPU 体系架构</code>设计的汇编语言<code>无法共用，也不具备可移植性</code>。</p></blockquote><h3 id="观察底层汇编代码" tabindex="-1"><a class="header-anchor" href="#观察底层汇编代码" aria-hidden="true">#</a> 观察底层汇编代码</h3><p><mark>汇编代码</mark>可以经由<mark>汇编程序（如 as）<mark>进行转换，从而得到</mark>二进制的可执行代码</mark>。不同于高级编程语言，汇编语言在机器指令之上基本不具有任何抽象。<strong>因此，通过观察一个程序的汇编代码，我们可以详细了解到<code>程序运行时的每一个具体步骤</code>。所以，在这门课中，我们会<code>通过汇编代码来观察</code> C 语法的实现细节，并同时探索<code>程序运行时 与操作系统交互的一些关键步骤</code>。</strong></p><h3 id="常见操作的助记符" tabindex="-1"><a class="header-anchor" href="#常见操作的助记符" aria-hidden="true">#</a> 常见操作的助记符</h3><p>汇编语言使用==助记符（Mnemonic）==来表示每个低级的机器指令。助记符是<code>一类带有自然语义的符号</code>，比如 mov 指令，它是英文单词 “move” 的简写，这个指令用来将一个操作数从计算机中的某个位置移动到另一个位置。而 add 指令的语义就更加直观了，它用来将计算机中某个位置上的数据量累加到另一个数据量上。</p><p>不同的汇编指令可以使用不同的参数形式。比如，就 mov 指令来说，对于可以使用该指令来移动的数据，它们通常会位于计算机中三个不同的位置上：</p><ul><li><p><strong>MOV r/m, r</strong></p></li><li><p><strong>MOV r, r/m</strong></p></li><li><p><strong>MOV r/m, imm</strong></p></li></ul><p>在这些指令的参数中，</p><ol><li>r 表示 register，即<code>寄存器</code>；</li><li>m 表示 memory，即<code>内存中的某个具体位置</code>；</li><li>imm 表示 immediate，即<code>直接书写在指令中的立即数</code>。</li></ol><p>因此，指令 mov ebx, 1 的正确含义是：将立即数 1 存放到寄存器 ebx 中（左侧参数为<mark>移动的目的地 dest</mark>，右侧参数为<mark>数据来源 src</mark>）。</p><blockquote><p>为了跟这门课后续的内容保持一致，这里我们直接使用 x86-64 平台，并基于 Intel 指令集的方式来书写和解读汇编代码。</p><p>需要注意的是，在 x86 指令集中，受限于 CPU 实现的复杂度，不存在可以<code>将两个内存地址同时作为 src 和 dest 参数的指令</code>。</p><p>意思就是：无论咋地都需要寄存器中转一下！</p></blockquote><h3 id="汇编指令集-所有助记符" tabindex="-1"><a class="header-anchor" href="#汇编指令集-所有助记符" aria-hidden="true">#</a> 汇编指令集 = 所有助记符</h3><p><mark>汇编指令</mark>由助记符组成，而<mark>汇编器</mark>则负责把这些助记符组成的有效语法格式转换成对应的<mark>二进制机器指令</mark>。比如就上面提到的汇编指令 mov ebx, 1 而言，它所对应的机器指令代码为二进制值 bb 01 00 00 00 。</p><h3 id="汇编器-二进制机器指令-大端小端" tabindex="-1"><a class="header-anchor" href="#汇编器-二进制机器指令-大端小端" aria-hidden="true">#</a> 汇编器 -&gt; 二进制机器指令 / 大端小端</h3><p>与<mark>汇编代码</mark>不同的是，<mark>二进制机器指令代码</mark>的组成结构要复杂许多。</p><p>上面的汇编指令对应的机器指令是由 OpCode 和 Immediate Data 两部分组成的。</p><ol><li>OpCode 在这里占用一个字节，这个字节是由指令对应的 0xb8 ，外加特定目的寄存器对应的寄存器域值 0x3 组成的。</li><li>而紧跟着 OpCode 的，便是立即数 1 对应的部分。</li><li>由于该指令用于传送 32 位数，因此立即数这里单独占用 4 个字节。</li><li>需要注意的是，对于这段机器指令代码，最左侧的字节 0xbb 处在内存的低位（<code>即小端序</code>）。</li></ol><p>在较为复杂的机器指令中，还可能包含有与 ModR/M、SIB、Displacement 以及 REX 等有关的信息。而这些信息有些<code>并不会直接体现</code>在上层的汇编代码中，它们大多仅与<code>当前平台 CPU 的体系架构</code>，或<code>操作系统所处的模式</code>有关。</p><h2 id="汇编指令集中的寄存器" tabindex="-1"><a class="header-anchor" href="#汇编指令集中的寄存器" aria-hidden="true">#</a> 汇编指令集中的寄存器</h2><p>在编写汇编语言代码时，我们经常会跟寄存器打交道。那么，什么是寄存器呢？</p><p>寄存器有时也被称为“<code>寄存器文件（Register File）</code>”，你可以把它简单理解为由 CPU 提供的<mark>一组位于芯片上的高速存储器硬件</mark>，可用于存储数据。通常来说，寄存器可以使用 <code>SRAM</code> 来实现。SRAM 是一种<code>高速随机访问存储器</code>，它将每个位的数据存放在一个对应的“双稳态”存储器中，<em>从而保持较强的抗干扰能力和较快的数据访问速度</em>。在整个计算机体系架构中，<strong>寄存器拥有最快的数据访问速度和最低的延迟</strong>。</p><p>通常来说，我们在汇编代码中使用的寄存器（比如之前提到的 ebx）可能<strong>并不与 CPU 上的物理寄存器完全一一对应</strong>，<code>CPU 会使用额外的方式来保证它们之间的动态对应关系。</code>这些参与到程序运行过程的寄存器，一般可以分为：</p><ul><li>通用目的寄存器、</li><li>状态寄存器、</li><li>系统寄存器，</li><li>以及用于支持浮点数计算和 SIMD 的 AVX、SSE 寄存器等。</li></ul><h3 id="通用目的寄存器" tabindex="-1"><a class="header-anchor" href="#通用目的寄存器" aria-hidden="true">#</a> 通用目的寄存器</h3><p>在这些寄存器中，通用目的寄存器一般用于存放程序运行过程中产生的<code>临时数据</code>，这些寄存器在大多数情况下都可以被当作普通寄存器使用。</p><p>而在某些特殊情况下，它们可能会被用于存放<code>指令计算结果、系统调用号，以及与栈帧相关的内存地址等</code>信息。</p><h3 id="状态寄存器" tabindex="-1"><a class="header-anchor" href="#状态寄存器" aria-hidden="true">#</a> 状态寄存器</h3><p>状态寄存器一般用于存放<code>与指令执行结果相关的状态信息</code>，比如<code>指令执行是否引起进位、计算结果是否为 0 等</code>。</p><h3 id="系统寄存器" tabindex="-1"><a class="header-anchor" href="#系统寄存器" aria-hidden="true">#</a> 系统寄存器</h3><p>系统寄存器一般<code>由操作系统使用</code>，这些寄存器描述了与<code>虚拟内存、中断、CPU 模式等</code>有关的信息。</p><h2 id="cpu-指令集架构-isa" tabindex="-1"><a class="header-anchor" href="#cpu-指令集架构-isa" aria-hidden="true">#</a> CPU 指令集架构（ISA）</h2><p>在 x86-64 架构下，==CPU 指令集架构（ISA）==中一共定义了 16 个通用目的寄存器。这些寄存器最大可以存放 4 个指令字，即 64 位长的数据。需要注意的是，<strong>这里我们提到的“<code>指令字(固定16位)</code>”与之前介绍的用于描述 CPU 硬件特征的“<code>硬件字(处理器设计)</code>”有所不同</strong></p><p>（指令字与硬件字这两个叫法只是我用来区分这两种字概念的）。<code>由于历史原因</code>，在现代 x86 系列 CPU 的指令集文档中，你可能会看到对 WORD 一词的使用。虽然这个单词可以被翻译为“字”，但在这样的环境下，它实则代表着固定 16 位的长度。关于它的具体使用方式，我会在 03 讲 中详细介绍。</p><h2 id="寄存器的别名" tabindex="-1"><a class="header-anchor" href="#寄存器的别名" aria-hidden="true">#</a> 寄存器的别名</h2><p>在汇编代码中，我们可以使用每个寄存器不同部分对应的别名，来针对性地访问它们的<code>低 8 位、低 16 位、低 32 位，以及完整的 64 位</code>数据。关于这些寄存器的具体名称，你可以参考下面这张图：</p><p>这张图怎么看呢？这里以我们之前遇到的 ebx 寄存器为例：观察上图可以得知，通过 <mark>ebx</mark>，我们可以访问大小为 32 位的数据，该数据为寄存器 <mark>rbx</mark> 的低 32 位。因此，直接使用 rbx 便可访问该寄存器的全部 64 位数据。而使用 <mark>bx</mark> 与 <mark>bl</mark> ，便可相应访问该寄存器的低 16 位与低 8 位数据。</p><img src="'+d+`" alt="img" style="zoom:25%;"><h2 id="同一寄存器的不同位置" tabindex="-1"><a class="header-anchor" href="#同一寄存器的不同位置" aria-hidden="true">#</a> 同一寄存器的不同位置</h2><p>另外，还需注意的一点是：我们可以通过 <em>不同的寄存器别名</em> 来读写 <em>同一寄存器不同位置</em> 上的数据。</p><ul><li>当某个指令需要重写寄存器的低 16 位或低 8 位数据时，<code>寄存器中其他位上的数据不会被修改</code>。</li><li>而当指令需要重写寄存器低 32 位的数据时，<code>高 32 位的数据会被同时复位，即置零</code>。</li></ul><p>听到这里，你可能觉得理解起来有些困难，不用担心，在课程的后面我还会多次介绍有关寄存器的内容。你可以先试着在 x86-64 平台上使用 GNU GCC 编译和运行下面这段代码。这里注意，<strong>在编译时不要为编译器指定任何优化参数</strong>。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">register</span> <span class="token keyword">long</span> num <span class="token keyword">asm</span><span class="token punctuation">(</span><span class="token string">&quot;rax&quot;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0x100000000</span><span class="token punctuation">;</span>
  <span class="token comment">// 0x代表16进制，而后面一共有9位数，一位16进制需要用4个二进制位表示。</span>
  <span class="token comment">// 由于先有八个0，即二进制表示有32个0，即0-31都是0，32位置1。</span>
  <span class="token keyword">asm</span><span class="token punctuation">(</span><span class="token string">&quot;movl $0x1, %eax&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// asm(&quot;movw $0x1, %ax&quot;);</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%ld\\n&quot;</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样，你就可以看到，当指令作用于寄存器的不同部分时，CPU 对寄存器其他部分的影响。这里我们将<mark>值 0x100000000</mark> 放入寄存器 <mark>rax</mark> 中，在该 64 位值（long）对应的二进制编码中，其第 32 位被置位。第一句汇编指令将值 0x1 通过 movl 移动到 rax 寄存器的低 32 位；而第二句汇编指令将值 0x1 通过 movw 移动到 rax 寄存器的低 16 位。那么，通过这两种方式分别处理后的变量 num 的值是否相同呢？你可以自己进行实践，并在评论区留下答案。</p><blockquote><p>随着课程的学习，你会看到这门课给出的示例代码中，存在着大量对这些通用寄存器的使用过程。<code>而如何高效、有序地分配和使用寄存器，是编译器的重要任务之一</code>，你会在后面的课程中了解到<em>编译器<strong>在使用不同优化等级时</strong>对待寄存器的区别</em>。</p></blockquote><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>讲到这里，今天的内容也就基本结束了。最后我们来一起总结下吧。</p><p>今天我主要介绍了常见数据量单位、汇编语言，以及指令集中寄存器的相关知识，希望这些基础知识能够为你接下来的学习提供一些帮助。</p><p>常见数据量单位包括位、字节和字。其中，一个字节等于 8 位，而字的大小则与具体的 CPU 体系结构紧密相关，常见大小可以是 32 位与 64 位。</p><p>汇编语言是一种低级编程语言，它用助记符的形式来描述程序对应机器指令的基本逻辑。由于它直接对应于 CPU 指令集之上，因此不具有可移植性。</p><p>寄存器是位于 CPU 芯片上的高速数据存储单元，根据功能，它可以被分为通用目的寄存器、状态寄存器等多种类型。x86-64 一共提供了 16 个通用目的寄存器，通过在汇编代码中使用不同的寄存器别名，我们可以快速访问这些寄存器中存放的数据。</p><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题" aria-hidden="true">#</a> 思考题</h2><p>这里，我们来一起做个思考题，巩固下今天的学习内容吧。</p><p>阅读下面的汇编代码，并尝试分析：当所有指令执行完毕时，寄存器 eax 中的值是多少？</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>mov eax, 0x1
inc eax
sub eax, 10
xor eax, eax
add eax, 1
mul eax
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这节选学课到这里就结束了，希望可以帮助到你，也希望你在下方的留言区和我交流讨论。如果这节课对你有帮助，也欢迎你把它分享给你的朋友或者同事。</p><h2 id="课后讨论" tabindex="-1"><a class="header-anchor" href="#课后讨论" aria-hidden="true">#</a> 课后讨论</h2><p><mark>汇编助记符 mov 是如何被翻译为二进制的 ? 是通过在哪里查的表吗 ，如果是查的表，那表又存在哪里呢</mark></p>`,73),u={href:"https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html",target:"_blank",rel:"noopener noreferrer"},m=e("p",null,[e("mark",null,"根据机器码二进制能否推导出汇编代码呢？")],-1),h=e("p",null,[a("二进制状态下的机器指令识别可以通过"),e("code",null,"每个指令对应的 OpCode 字节"),a("进行切分，然后再根据相应的结构解析出整体指令的结构。")],-1),k=e("p",null,[e("mark",null,"使用c语言进行cuda编程是否可以理解为c语言被编译为了GPU的汇编指令，是否也就是说c语言只要有对应的编译器，就可以在任何处理器上进行编程呢？")],-1),b={href:"https://cilvr.cs.nyu.edu/diglib/lsml/lecture05-cuda-02.pdf%E3%80%82",target:"_blank",rel:"noopener noreferrer"},x=e("p",null,[a("NVIDIA 本身是有一套针对各个 GPU 的闭源机器指令的，在实际执行时 CUDA 程序中，device component 按我的理解应该是会被编译成这些特殊的机器指令的。nvcc 在处理代码时就会将源码分成普通 C/C++ 代码和运行于 GPU 的 C/C++ 代码，然后分别处理。回到你的问题，实际上是没错的，"),e("code",null,"只要计算机采用的是冯诺依曼体系"),a("，C 语言作为高级语言"),e("code",null,"就可以被各类编译器"),a("转换成对应的机器语言，进而在这些体系上完成相应任务。")],-1),v=e("p",null,[e("mark",null,"怎么知道不同型号 CPU 寄存器的名称的？ 比如我是 M1 Max 芯片的 CPU 使用 rax 报错提示 unknown register name 'rax' in asm")],-1),g={href:"https://developer.arm.com/documentation/ddi0487/ga",target:"_blank",rel:"noopener noreferrer"},_=e("p",null,[a("请教老师， 文中 mov ebx, 1 ，它所对应的机器指令代码为二进制值 bb 01 00 00 00 ，问题有两个："),e("br"),a(" 1、汇编助记符 mov 是如何被翻译为二进制的 ? 是通过在哪里查的表吗 ，如果是查的表，那表又存在哪里呢"),e("br"),a(" 2、 那根据机器码二进制能否推导出汇编代码呢？bb 01 00 00 00 ==》mov ebx, 1"),e("br"),a(" 作者回复: 很好的问题！")],-1),w=e("mark",null,"汇编器",-1),f={href:"https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html",target:"_blank",rel:"noopener noreferrer"},C=o(`<p>第二个问题：二进制状态下的机器指令识别可以通过<mark>每个指令对应的 OpCode 字节</mark>进行切分，然后再根据<mark>相应的结构</mark>解析出整体指令的结构。</p><hr><p>验证重写64位寄存器低32位/低16位/低8位的代码中如果不是按照文中那样给寄存器赋值，而是任意赋值，建议大家将printf(&quot;%ld\\n&quot;, num);改为printf(&quot;%lx\\n&quot;, num);，输出16进制数，这样才能观察到正确的结果，否则输出10进制数，一开始没注意的话会发现结果很奇怪</p><p>思考题：<br> xor eax, eax是异或，eax自己与自己异或应该为0<br> add eax, 1，相当于0x0+0x1=0x1<br> mul eax之后eax的结果应该还是0x1，不知道理论分析是否正确，汇编还不是很熟<br> 作者回复: 答案是正确的哈！</p><hr><p>xor eax，eax 相当于把eax置零了，最后+1，然后mul相乘 默认与eax相乘，最后还是为1<br> 作者回复: 没错！</p><p>eax异或后为0，然后再加1，因此eax中的内容变为1，最后与1相乘，结果仍然为1<br> 作者回复: 正解！</p><hr><p>在clang下，rax寄存器虽然被置位，但在此之前会将rax寄存器的值拷贝到<em>栈</em>中，在输出时不会把被置位后的rax输出，<em>而是从栈中重新取出num的值</em><br> 作者回复: 这是一个很好的发现！</p><hr><p>在 x86-64 架构下，CPU 指令集架构（ISA）中一共定义了 16 个通用目的寄存器，这些寄存器最大可以存放 4 个字，即 64 位长的数据。在汇编代码中 x86-64 下一个字长不就 64bit 了吗，为什么这里说 「4 个字，即 64 位长的数据」<br> 作者回复: 这是一个很好的发现！我们修改了文章，稍后会更新。</p><p>简单来讲就是：<em>字这个概念会在多个地方的多种不同场景下使用</em>。而文中我们介绍的字实际上是指可以体现 CPU 硬件特征的那个字，我一般会称它为硬件字。而在 CPU 指令集中，字也被用来作为衡量数据大小的单位。<u>x86 架构由于历史原因</u>，会将指令集中出现的 WORD 定义为固定 16 位的大小。所以实际文中提到的 4 个字你可以理解为指令字，它的单位是 WORD，4 个字即对应 64 位大小。</p><hr><p>请问clang与gcc编译内嵌asm的代码时，是需要做什么参数指定吗，文稿中的这段代码，用gcc编译是正常的，但用clang得到的是不同的结果</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">register</span> <span class="token keyword">long</span> num <span class="token keyword">asm</span><span class="token punctuation">(</span><span class="token string">&quot;rax&quot;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0x100000000</span><span class="token punctuation">;</span>
<span class="token keyword">asm</span><span class="token punctuation">(</span><span class="token string">&quot;movl $0x1, %eax&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// asm(&quot;movw $0x1, %ax&quot;);</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%ld\\n&quot;</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>作者回复: 实际上，除基本的调用约定以及 asm 那句代码以外，其他具体实现都是 <em>implementation-dependent</em> 的，也就是说，<strong>编译器会保证在不违背上述两个必须满足的条件之下，用各种不同方式来实现这段代码</strong>（当然，外部可观测行为也不会发生变化是个大前提）。所以，<u>这段代码并不会在所有编译器上都得到相同的效果</u>。</p><hr><p>老师好，请问Intel的寄存器在存储数据和读取数据时，也遵循小头优先吗？<br> 作者回复: 其他 Intel CPU 不太清楚诶，在 x86-64 上是小端序的。</p>`,18);function y(U,q){const n=c("ExternalLinkIcon");return r(),p("div",null,[l,e("p",null,[a("每一个汇编指令都有其对应的组成结构，汇编器会根据助记符的名称进行相应的转换。具体的转换细节可以参考官方手册。比如对于 x86-64："),e("a",u,[a("https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html"),s(n)])]),m,h,k,e("p",null,[a("我不太熟悉 CUDA，找到了一个 slide，不知道对你的问题有没有帮助："),e("a",b,[a("https://cilvr.cs.nyu.edu/diglib/lsml/lecture05-cuda-02.pdf。"),s(n)])]),x,v,e("p",null,[a("每一类体系架构的 CPU 都有自己独立的 ISA，其中便描述了机器指令可以使用哪些寄存器。关于 M1 Max，你可以参考这里哈："),e("a",g,[a("https://developer.arm.com/documentation/ddi0487/ga"),s(n)])]),e("blockquote",null,[_,e("p",null,[a("第一个问题：每一个汇编指令都有其对应的组成结构，"),w,a("会根据助记符的名称进行相应的转换。具体的转换细节可以参考官方手册。比如对于 x86-64："),e("a",f,[a("https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html"),s(n)])]),C])])}const A=t(i,[["render",y],["__file","√A00-课前热身.html.vue"]]);export{A as default};
