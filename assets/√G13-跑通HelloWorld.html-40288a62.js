import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o,c as l,a as s,b as e,e as a,d as r}from"./app-cdabc73c.js";const c="/assets/1893274bf776382cd139692e9aaf397d-36e4023c.jpg",d="/assets/612cb5524109cc97a8ce1e4b2810d922-171812fa.jpg",p="/assets/5f293367bb0821cyy49ee1d3a2c4bfa0-067c4ab6.jpg",u="/assets/eff44c66b93b1aa531b46b47f2095d3c-e4044b4d.jpg",b="/assets/e80a0f46c534d870483fb74df77ecb01-167e1daa.jpg",m="/assets/65c609a360d33dfa7b1399c115yy49fc-f2054ea2.jpg",g="/assets/7fd7yycd59e982ec7b104b47cf5009f1-04fc38a2.jpg",h="/assets/80870a7d1a7f35b11228f6e7810c145b-56350da7.jpg",v="/assets/9c14c4def94c7d719f732822b7fc807b-aea77101.jpg",f="/assets/ba36676884beyy0be6ec1f267b6215be-be396508.jpg",_={},x=s("h1",{id:"√13-小试牛刀-跑通risc-v平台的hello-world程序",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#√13-小试牛刀-跑通risc-v平台的hello-world程序","aria-hidden":"true"},"#"),e(" √13｜小试牛刀：跑通RISC-V平台的Hello World程序")],-1),C=s("p",null,"你好，我是 LMOS。",-1),M=s("p",null,"在上一课中，我们一起约定了主环境，安装了编译工具和依赖库，构建了交叉编译 RISC-V 工具链。",-1),U={href:"https://gitee.com/lmos/Geek-time-computer-foundation/tree/master/lesson12~13",target:"_blank",rel:"noopener noreferrer"},E=r('<p>话不多说，我们开始吧。</p><h2 id="risc-v-运行平台" tabindex="-1"><a class="header-anchor" href="#risc-v-运行平台" aria-hidden="true">#</a> RISC-V 运行平台</h2><p>有了上节课成功构建好的交叉编译器，有很多同学可能按捺不住，急着想写一个简单的 Hello World 程序，来测试一下刚刚构建的交叉编译器。</p><p>恕我直言，这时你写出来的 Hello World 程序，虽然会无警告、无错误的编译成功，但是只要你一运行，铁定会出错。</p><p>这是为什么呢？因为你忘记了交叉编译器，生成的是 RISC-V 平台的可执行程序，这样的程序自然无法在你的宿主机 x86 平台上运行，它只能在 RISC-V 平台上运行。</p><p>摸着自己的荷包，你可能陷入了沉思：难道我还要买一台 RISC-V 平台的计算机？这样成本可太高了，不划算。</p><p>贫穷让人学会变通，为了节约成本，我们希望能用软件模拟 RISC-V 平台。嘿！这当然可以，而且前辈们，早已给我们写好了这样的软件，它就是 QEMU。</p><h2 id="揭秘-qemu" tabindex="-1"><a class="header-anchor" href="#揭秘-qemu" aria-hidden="true">#</a> 揭秘 QEMU</h2><p>什么是 QEMU？QEMU 是一个仿真器或者说是模拟器软件，与市面上 BOCHS 类似，由软件来实现模拟。</p><p>QEMU 就像计算机界的“孙悟空”，变化多端，能模拟出多种类型的 CPU，比如 IA32、AMD64、ARM、MIPS、PPC、SPARC、RISC-V 等。QUEM 通过动态二进制转换来模拟 CPU。除了 CPU，它还支持模拟各种 IO 设备，并提供一系列的硬件模型。这使得 QEMU 能模拟出完整的硬件平台，使得 QEMU 能运行各种操作系统，如 Windows 和 Linux。</p><p>你可以把 QEMU 当做一个“双面间谍”，因为在它上面运行的操作系统，也许还认为自己在和硬件直接打交道，其实是同 QEMU 模拟出来的硬件打交道，QEMU 再将这些指令翻译给真正硬件进行操作。通过这种模式，QEMU 运行的操作系统就能和宿主机上的硬盘、网卡、CPU、CD-ROM、音频设备、USB 设备等进行交互了。</p><p>由于 QEMU 的以上这些特点，导致 QEMU 在宿主平台上可以模拟出其它不同于宿主平台的硬件体系，这是 QEMU 的优点。</p><p>不过，由于是用了软件来实现的模拟，所以性能很差，这也是 QEMU 的缺点。正因为这个缺点，后来就出现了 <strong>QEMU 和 KVM 结合使用的解决方案</strong>。</p><p>KVM 基于硬件辅助的虚拟化技术，主要负责比较繁琐的 CPU 和内存虚拟化，而 QEMU 则负责 I/O 设备的模拟，两者合作各自发挥自身的优势，成就了强强联合的典范。</p><p>回归主题，关于 QEMU，现阶段你最需要记住的就是，它有两种主要工作模式：<mark>系统模式</mark>和<mark>用户模式</mark>。</p><ul><li>在系统工作模式下，QEMU 能模拟整个计算机系统，包括 CPU 及其他 IO 设备。它能运行和调试不同平台开发的操作系统，也能在宿主机上虚拟不同数量、不同平台的虚拟电脑。</li><li>而在用户工作模式，QEMU 能建立一个普通进程，运行那些由不同体系处理器编译的应用程序，比如后面我们要动手编写的 RISC-V 版的 Hello World 程序。</li></ul><h2 id="构建我们的-定制款-qemu" tabindex="-1"><a class="header-anchor" href="#构建我们的-定制款-qemu" aria-hidden="true">#</a> 构建我们的“定制款”QEMU</h2><p>说了这么多，其实是想让你更加了解 QEMU。</p><p>下面我们来办正事儿——构建适合我们的 QEMU，如果我们不是有特殊要求——模拟 RISC-V 平台且带调试功能的 QEMU，用不着亲自动手去构建，只需要一条安装指令就完事了。</p><p>构建 QEMU 用四步就能搞定：首先下载 QEMU 源代码，接着配置 QEMU 功能选项，然后编译 QEMU，最后安装 QEMU。</p>',20),V={href:"https://www.qemu.org/",target:"_blank",rel:"noopener noreferrer"},S={href:"https://download.qemu.org/qemu-6.2.0.tar.xz",target:"_blank",rel:"noopener noreferrer"},q=r(`<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">wget</span> https://download.qemu.org/qemu-6.2.0.tar.xz <span class="token comment">#下载源码包</span>
<span class="token function">tar</span> xvJf qemu-6.2.0.tar.xz <span class="token comment">#解压源码包</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这里跑完第一条指令以后，下载下来的是压缩的 QEMU 源码包。所以，在下载完成后，你要用第二条指令来解压。</p><p>由于上节课我们构建 RISC-V 工具链时，已经统一安装了构建 QEMU 所需要的相关依赖库，所以这里就不用安装相关依赖库了。</p><p>解压成功后，我们就要开始配置 QEMU 的功能了。同样，为了不污染源代码目录，我们可以先在 qemu-6.2.0 目录下，建立一个 build 目录，然后切换到 build 目录下进行配置，输入如下指令：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">mkdir</span> build <span class="token comment">#建立build目录</span>
<span class="token builtin class-name">cd</span> build <span class="token comment">#切换到build目录下</span>
<span class="token punctuation">..</span>/configure <span class="token parameter variable">--prefix</span><span class="token operator">=</span>/opt/riscv/qemu --enable-sdl --enable-tools --enable-debug --target-list<span class="token operator">=</span>riscv32-softmmu,riscv64-softmmu,riscv32-linux-user,riscv64-linux-user <span class="token comment">#配置QEMU</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述配置选项中，<code>–prefix</code> 表示 QEMU 的安装目录，我们一起约定为“/opt/riscv/qemu”目录，<code>–enable-sdl</code> 表示 QEMU 使用 sdl 图形库， <code>--enable-tools</code> 表示生成 QEMU 工具集，<code>–enable-debug</code> 表示打开 QEMU 调试功能。</p><p>最重要的是 <strong>--target-list</strong> 这个选项，它表示生成 QEMU 支持的模拟目标机器。不同选项所支持的平台不同，我们的选择如下表所示：</p><figure><img src="`+c+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>如果你什么都不选的话，它会默认生成 QEMU 支持的所有平台。按前面我们讲的操作配置，配置成功后，build 目录下会生成后面截图里展示的文件和目录。</p><figure><img src="'+d+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>配置好功能选项之后，下一步就是编译 QEMU 了。只要配置成功了，编译这事儿就非常简单了，我们只要输入如下指令，然后交给计算机编译就好了。别忘了等待期间泡杯茶，不知道你会不会像我一样哼起那首歌：“世上有没有人，安静的等待你，一直不愿回神……”</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>sudo make -j8
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>最后就是安装 QEMU，经过漫长等待以后，我们终于迎来编译的成功。这时，你还需要输入如下指令进行安装。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>sudo make install
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这里说明一下，QEMU 不像 RISC-V 工具链那样，会在编译结束后自动安装，它需要手动安装。</p><p>我们在终端中切换到“/opt/riscv/qemu/bin”目录下，执行如下指令：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>qemu-riscv32 -version &amp;&amp; qemu-riscv64 -version &amp;&amp; qemu-system-riscv32 -version &amp;&amp; qemu-system-riscv64 -version
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上述指令会输出 qemu-riscv32、qemu-riscv64、qemu-system-riscv32、qemu-system-riscv64 的版本信息，以证明能运行 RISC-V 平台可执行程序的 QEMU 构建成功。你可以对照一下后面的截图。</p><figure><img src="`+p+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>到这里，RISC-V 平台的编译环境和执行环境已经构建完成，并且能生成和执行 32 位或者 64 位的 RISC-V 平台的可执行程序，无论是 RISC-V 平台的应用程序，还是 RISC-V 平台的操作系统。</p><h3 id="处理环境变量" tabindex="-1"><a class="header-anchor" href="#处理环境变量" aria-hidden="true">#</a> 处理环境变量</h3><p>不知道你发现了没有？我们运行 QEMU 和 RISC-V 工具链相关的程序，都要切换到 /opt/riscv/xxxx/bin 目录中才可以运行，而不是像 Linux 中的其它程序，可以直接在终端中直接运行。</p><p>革命还未成功，我们还得努力。这是因为我们没有将 QEMU 和 RISC-V 工具链的安装目录，加入到 Linux 的环境变量中。</p><p>接下来我们就开始处理环境变量，修改环境的方法有好几种。这里我为你演示比较常用的一种，那就是在当前用户目录下的“.bashrc”文件中，加入相关的指令。</p><p>这里说的“当前用户的目录”就是在终端中执行&quot;cd ~&quot; 指令。怎么操作呢？我们切换到当前用户目录下，来执行这个指令。然后，在文件尾部加上两行信息就行了。具体指令如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>cd ~ #切换到当前用户目录下
vim ./.bashrc #打开.bashrc文件进行编辑

#在.bashrc文件末尾加入如下信息
export PATH=/opt/riscv/gcc/bin:$PATH
export PATH=/opt/riscv/qemu/bin:$PATH
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述操作完成以后，你会看到下图所示的结果：</p><figure><img src="`+u+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>随后，我们按下键盘上 ESC 键，接着输入&quot;:wq&quot;以便保存并退出 Vim。这样操作后，你会发现环境变量并没有生效。</p><p>这里还差最后一步，我们在终端中输入如下指令，让环境变量生效：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>source ./.bashrc
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>现在，你在任何目录之下输入 QEMU 和 RISC-V 工具链相关的程序命令，它们就都可以正常运行了。</p><h3 id="安装-vscode" tabindex="-1"><a class="header-anchor" href="#安装-vscode" aria-hidden="true">#</a> 安装 VSCode</h3><p>有了 QEMU 和 RISC-V 工具链相关的程序命令，我们虽然可以编译调试和执行 RISC-V 平台的程序了，但是必须在终端中输入多条指令，才能完成相关的工作。</p><p>这对于很多同学来说，肯定觉得很陌生，特别是在图形化盛行的今天，我们更期待能有个轻量级的 IDE。</p>`,35),Q={href:"https://code.visualstudio.com/Download",target:"_blank",rel:"noopener noreferrer"},k=r(`<div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>sudo apt-get install -f *.deb
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>安装好后，在你的桌面会出现 VSCode 图标，双击打开后的页面如下所示：</p><figure><img src="`+b+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>不过，有了 VSCode 我们目前只能写代码，还不能编译和调试代码，所以需要给 VSCode 安装 C/C++ 扩展。我们只需打开 VSCode，按下 ctrl+shift+x，就能打开 VSCode 的扩展页面，在搜索框中输入 C/C++ 就可以安装了，如下所示：</p><figure><img src="'+m+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>至此，我们的 VSCode 及其需要的扩展组件就安装完成了。</p>',6),I={href:"https://gitee.com/lmos/Geek-time-computer-foundation/tree/master/lesson12~13/.vscode",target:"_blank",rel:"noopener noreferrer"},R=r('<figure><img src="'+g+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>在.vscode 文件夹中有个 tasks.json 文件，它主要负责完成用 RISC-V 编译器编译代码的功能，还有用 QEMU 运行可执行文件的功能。</p><p>我们先说说这里的编译工作是怎么完成的。具体就是通过调用 make，读取代码目录中的 Makefile 脚本，在这个脚本中会调用 riscv64-unknown-elf-gcc 完成编译。等编译成功后，才会调用 QEMU 来接手，由它运行编译好的可执行程序。代码注释已经写得很清楚了，你可以停下来仔细看看。</p><p>不过，tasks.json 文件虽然解决了编译与运行的问题，但是它也是被其它文件调用的。被谁调用呢？那就是我们的调试配置文件 launch.json 文件，它用于启动调试器 GDB，只不过这里启动的不是宿主平台上的 GDB，而 RISC-V 工具链中的 GDB。其内容如下所示：</p><figure><img src="'+h+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>当我们写好代码后，按下 F5 键后，VSCode 就会执行 launch.json 文件的调试操作了。这里调试器和要调试的可执行程序已经制定好了。不过由于 preLaunchTask 的指定，开始执行调试命令之前，VSCode 会首先执行 tasks.json 文件中的操作，即编译和运行。</p><h3 id="运行-hello-world" tabindex="-1"><a class="header-anchor" href="#运行-hello-world" aria-hidden="true">#</a> 运行 Hello World</h3><p>下面我们一起来写下那个著名的程序——Hello World！写好后，在 main 函数所在的行前打上一个断点，按下 F5 键，就会看到如下界面。</p><figure><img src="'+v+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>如果不出意外，哈哈，放心，按我提供给你的步骤，也出不了意外，你一定会看到以上界面。</p><p>我们重点来观察红色方框中的信息，可以查看代码变量值、CPU 的寄存器值、函数的调用栈、断点信息、源代码以及程序执行后在 VSCode 内嵌终端中输出的信息。有了这些信息，我们就能清楚地看到一个程序运行过程的状态和结果。</p><p>走到这里，我们的定制款 QEMU 以及 VSCode 就搭好了，可以去图形化编辑、编译、运行和调试 RISC-V 平台的可执行程序了。</p><h2 id="重点回顾" tabindex="-1"><a class="header-anchor" href="#重点回顾" aria-hidden="true">#</a> 重点回顾</h2><p>好了，我们的 RISC-V 平台的 Hello World，也是我们在宿主机上开发的第一个非宿主机的程序，现在已经成功运行，这说明我们之前的工作完成得很完美，今天的课程不知不觉也接近了尾声。</p><p>下面来回顾一下，这节课我们都做了些什么。</p><p>首先，我们构建了能运行 RISC-V 可执行程序的 QEMU 模拟器，这使得我们不必购买 RISC-V 平台的机器，就能在宿主机上运行 RISC-V 可执行程序。这不但大大方便了我们的开发工作，而且节约了成本。</p><p>然后，我们处理了环境变量，方便我们在任何目录下，都可以随意使用 RISC-V 工具链中的命令和 QEMU 相关的命令。</p><p>最后，我们安装了 VSCode，还在其中安装 C/C++ 扩展并对其进行了相应的配置。以后我们在 VSCode 图形环境下编写代码、编译代码和调试代码，就能一气呵成了。</p><p>这节课的要点我整理了导图，供你参考。</p><figure><img src="'+f+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>恭喜你坚持到这里，通过两节课的内容，我们拿下了开发环境这一关，这对我们后续课程中的实验相当重要。下一模块讲解和调试 RISC-V 汇编指令的时候，你会进一步体会到环境搭建好的便利，先好好休息一下，咱们下节课见。</p><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题" aria-hidden="true">#</a> 思考题</h2><p>处理环境变量后为什么要执行 source ./.bashrc，才会生效？</p><p>欢迎你在留言区提问或者晒晒你的实验记录。如果觉得有收获，也推荐你把这节课分享给你的朋友。</p>',24),y=r("<p>如果有不想编译的同学，可以按照以下步骤运行：</p><p>1、安装Ubuntu 22.04</p><p>2、安装编译环境：<br> $ sudo apt-get install autoconf automake autotools-dev curl python3 libmpc-dev libmpfr-dev libgmp-dev gawk build-essential bison flex texinfo gperf libtool patchutils bc zlib1g-dev libexpat-dev</p><p>3、直接安装riscv-gcc发行包：<br> $ sudo apt install gcc-riscv64-linux-gnu gcc-riscv64-unknown-elf picolibc-riscv64-unknown-elf</p><p>4、直接安装qemu发行包：<br> $ sudo apt install qemu-user qemu-system-misc</p><p>5、编写hello.c<br> #include&lt;stdio.h&gt;<br> int main()<br> {<br> printf(&quot;Hello, riscv!\\n&quot;);<br> return 0;<br> }</p><p>6、编译：<br> $ riscv64-linux-gnu-gcc hello.c -o hello</p><p>7、运行：<br> $ qemu-riscv64 hello<br> qemu-riscv64: Could not open &#39;/lib/ld-linux-riscv64-lp64d.so.1&#39;: No such file or directory</p><p>如果报错找不到/lib/ld-linux-riscv64-lp64d.so.1，是因为这个文件实际上在/usr/riscv64-linux-gnu/lib下，加个参数运行：</p><p>$ qemu-riscv64 -L /usr/riscv64-linux-gnu hello<br> Hello, riscv!</p><p>最后，riscv64-unknown-elf-gcc编译还没搞定，正在找原因<br> 作者回复: 可能 是 网络原因</p><hr>",12),j=s("br",null,null,-1),w=s("br",null,null,-1),z={href:"https://github.com/microsoft/vscode-remote-release/issues/854",target:"_blank",rel:"noopener noreferrer"},H=s("br",null,null,-1),L=r("<hr><p>纠正一下。在环境变量设置好之前，即使在<code>/opt/riscv/qemu/bin</code>目录下，也不能直接跑<code> qemu-riscv32 -version &amp;&amp; qemu-riscv64 -version &amp;&amp; qemu-system-riscv32 -version &amp;&amp; qemu-system-riscv64 -version</code>. 而是需要<code>./qemu-riscv32 ...</code>.<br> 作者回复: 嗯 嗯</p><hr><p>source 的主要用途是执行文件并从文件加载变量及函数到执行环境。<br> ~/.bashrc文件中的环境变量已经在用户登录shell的时候加载进执行环境了，此时编辑不会触发加载。必须使用source或者重新登录才能触发重新加载<br> 作者回复: 是的</p><hr><p>在build 目录下执行配置命令时，遇到几个包缺失，依次安装就好：<br> sudo apt install libglib2.0-dev libpixman-1-dev libsdl2-dev<br> 作者回复: 嗯嗯 加油</p><hr><p>tasks.json和launch.json在老师给的代码，gitee仓库下有，main.c文件里还需要放Makefile后才能按F5编译<br> 作者回复: 有啊</p><hr><p>root@zgye-ubuntu:~/test# cat hello.s<br> .file &quot;hello.c&quot;<br> .option nopic<br> .attribute arch, &quot;rv64i2p0_m2p0_a2p0_f2p0_d2p0_c2p0&quot;<br> .attribute unaligned_access, 0<br> .attribute stack_align, 16<br> .text<br> .section .rodata<br> .align 3<br> .LC0:<br> .string &quot;Risc-V&quot;<br> .align 3<br> .LC1:<br> .string &quot;Hello %s\\n&quot;<br> .text<br> .align 1<br> .globl main<br> .type main, @function<br> main:<br> addi sp,sp,-16<br> sd ra,8(sp)<br> sd s0,0(sp)<br> addi s0,sp,16<br> lui a5,%hi(.LC0)<br> addi a1,a5,%lo(.LC0)<br> lui a5,%hi(.LC1)<br> addi a0,a5,%lo(.LC1)<br> call printf<br> li a5,0<br> mv a0,a5<br> ld ra,8(sp)<br> ld s0,0(sp)<br> addi sp,sp,16<br> jr ra<br> .size main, .-main<br> .ident &quot;GCC: () 12.1.0&quot;<br> root@zgye-ubuntu:~/test# /opt/riscv/qemu/bin/qemu-riscv64 hello<br> Hello Risc-V<br> root@zgye-ubuntu:~/test#</p><p>ubuntu22.04上跑通。<br> 作者回复: 666666</p><hr>",12),P={href:"https://gitee.com/lmos/Geek-time-computer-foundation/blob/master/lesson12~13/main.c#L7-8",target:"_blank",rel:"noopener noreferrer"},G=s("br",null,null,-1);function W(A,B){const i=t("ExternalLinkIcon");return o(),l("div",null,[x,C,M,s("p",null,[e("今天我们继续构建 RISC-V 版的模拟器 QEMU（"),s("a",U,[e("代码你可以从这里下载"),a(i)]),e("），让它成为“定制款”，更匹配我们的学习需要。为此，我们需要设置好主环境的环境变量，安装好 VSCode 及其插件，这样才能实现编辑、编译、运行、调试 RISC-V 程序的一体化、自动化。")]),E,s("p",null,[e("我们需要从 "),s("a",V,[e("QEMU官网"),a(i)]),e("上下载"),s("a",S,[e("稳定版本"),a(i)]),e("的 QEMU 源代码。如果你和我一样，觉得在浏览器上点来点去非常麻烦，也可以在切换到 RISCV_TOOLS 目录的终端下，输入如下指令：")]),q,s("p",null,[e("这里我们约定使用 VSCode，它安装起来也很简单。在 "),s("a",Q,[e("VSCode 官网"),a(i)]),e("上下载 deb 包，下载后双击 deb 安装，或者切换到刚才下载 VSCode 目录的终端中，输入如下指令就行了。")]),k,s("p",null,[e("下一步，我们还需要在你的代码目录下建立一个.vscode 文件夹，并在文件里写上"),s("a",I,[e("两个配置文件"),a(i)]),e("。这两个配置文件我已经帮你写好了，如下所示。")]),R,s("blockquote",null,[y,s("p",null,[e("使用了 VS Code 的 Remote Development 远程调试，发现 F5 debug 回找不到编译器和 qemu，shell"),j,e(" 登录可以，一通谷歌是 .bashrc 与 .bash_profile 的问题，把环境变量加到 bash_profile 就可以了，vscode 是运行在 login shell 的，加载的是 bash_profile ，不会加载 .bashrc"),w,e(" refs: "),s("a",z,[e("https://github.com/microsoft/vscode-remote-release/issues/854"),a(i)]),H,e(" 作者回复: 66666")]),L,s("p",null,[e("想问一下，"),s("a",P,[e("https://gitee.com/lmos/Geek-time-computer-foundation/blob/master/lesson12~13/main.c#L7-8"),a(i)]),e(" 这里面func和sumdata分别都是什么呢？没有看到哪个地方有定义这两个东西，跑make或者vscode里面按F5也是会报错。"),G,e(" 作者回复: 故意 的 请详细读文稿")])])])}const $=n(_,[["render",W],["__file","√G13-跑通HelloWorld.html.vue"]]);export{$ as default};
