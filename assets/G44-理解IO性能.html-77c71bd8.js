import{_ as p}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as t,c as r,a,b as s,e as c,d as n}from"./app-cdabc73c.js";const l="/assets/a227f1a299a3774c4e1067436decf7ff-114f9aaf.png",i="/assets/57443821861f73e4d04ab4d64e6908a4-e65cce6d.png",u={},d=n('<h1 id="_44-理解io-wait-i-o性能到底是怎么回事儿" tabindex="-1"><a class="header-anchor" href="#_44-理解io-wait-i-o性能到底是怎么回事儿" aria-hidden="true">#</a> 44 | 理解IO_WAIT：I/O性能到底是怎么回事儿？</h1><p>在专栏一开始的时候，我和你说过，在计算机组成原理这门课里面，很多设计的核心思路，<em>都来源于性能</em>。在前面讲解 CPU 的时候，相信你已经有了切身的感受了。</p><p>大部分程序员开发的都是应用系统。在开发应用系统的时候，我们遇到的性能瓶颈大部分都在 I/O 上。在第 36 讲讲解局部性原理的时候，我们一起看了通过把内存当作是缓存，来提升系统的整体性能。在第 37 讲讲解 CPU Cache 的时候，我们一起看了 CPU Cache 和主内存之间性能的巨大差异。</p><p>然而，我们知道，并不是所有问题都能靠利用内存或者 CPU Cache 做一层缓存来解决。特别是在这个“大数据”的时代。我们在硬盘上存储了越来越多的数据，一个 MySQL 数据库的单表有个几千万条记录，早已经不算是什么罕见现象了。这也就意味着，用内存当缓存，存储空间是不够用的。<em>大部分时间，我们的请求还是要打到硬盘上</em>。那么，这一讲我们就来看看硬盘 I/O 性能的事儿。</p><h2 id="io-性能、顺序访问和随机访问" tabindex="-1"><a class="header-anchor" href="#io-性能、顺序访问和随机访问" aria-hidden="true">#</a> IO 性能、顺序访问和随机访问</h2><p>如果去看硬盘厂商的性能报告，通常你会看到两个指标。一个是<strong>响应时间</strong>（Response Time），另一个叫作<strong>数据传输率</strong>（Data Transfer Rate）。没错，这个和我们在专栏的一开始讲的 CPU 的性能一样，前面那个就是响应时间，后面那个就是吞吐率了。</p><p>我们先来看一看后面这个指标，<mark>数据传输率</mark>。</p><p>我们现在常用的硬盘有两种。一种是 <mark>HDD 硬盘</mark>，也就是我们常说的<mark>机械硬盘</mark>。另一种是 <mark>SSD 硬盘</mark>，一般也被叫作<mark>固态硬盘</mark>。</p><ul><li>现在的 HDD 硬盘，<br> 用的是 SATA 3.0 的接口。</li><li>而 SSD 硬盘呢，通常会用两种接口，<br> 一部分用的也是 SATA 3.0 的接口；<br> 另一部分呢，用的是 PCI Express 的接口。</li></ul><h3 id="_1-机械hdd-固态ssd-性能对比" tabindex="-1"><a class="header-anchor" href="#_1-机械hdd-固态ssd-性能对比" aria-hidden="true">#</a> 1 机械HDD/固态SSD：性能对比</h3><p>现在我们常用的 SATA 3.0 的接口，带宽是 6Gb/s。这里的“b”是比特。这个带宽相当于每秒可以传输 768MB 的数据。而我们日常用的 HDD 硬盘的数据传输率，差不多在 200MB/s 左右。</p><figure><img src="'+l+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>这是在我自己的电脑上，运行 AS SSD 测算 SATA 接口 SSD 硬盘性能的结果，第一行的 Seq 就是顺序读写硬盘得到的数据传输率的实际结果</p><p>当我们换成 SSD 的硬盘，性能自然会好上不少。比如，我最近刚把自己电脑的 HDD 硬盘，换成了一块 Crucial MX500 的 SSD 硬盘。它的数据传输速率能到差不多 500MB/s，比 HDD 的硬盘快了一倍不止。不过 SATA 接口的硬盘，差不多到这个速度，性能也就到顶了。<em>因为 SATA 接口的速度也就这么快</em>。</p><figure><img src="'+i+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>不过，实际 SSD 硬盘能够更快，所以我们可以换用 <mark>PCI Express 的接口</mark>。我自己电脑的系统盘就是一块使用了 PCI Express 的三星 SSD 硬盘。<em>它的数据传输率，在读取的时候就能做到 2GB/s 左右，差不多是 HDD 硬盘的 10 倍，而在写入的时候也能有 1.2GB/s</em>。</p><p>除了数据传输率这个吞吐率指标，另一个我们关心的指标<mark>响应时间</mark>，其实也可以在 AS SSD 的测试结果里面看到，就是这里面的 <mark>Acc.Time 指标</mark>。</p><p>这个指标，其实就是程序发起一个硬盘的写入请求，直到这个请求返回的时间。可以看到，在上面的两块 SSD 硬盘上，大概时间都是在几十微秒这个级别。如果你去测试一块 HDD 的硬盘，通常会在几毫秒到十几毫秒这个级别。<em>这个性能的差异，就不是 10 倍了，而是在几十倍，乃至几百倍</em>。</p><p>光看响应时间和吞吐率这两个指标，似乎我们的硬盘性能很不错。即使是廉价的 HDD 硬盘，接收一个来自 CPU 的请求，也能够在几毫秒时间返回。一秒钟能够传输的数据，也有 200MB 左右。你想一想，我们平时往数据库里写入一条记录，也就是 1KB 左右的大小。我们拿 200MB 去除以 1KB，那差不多每秒钟可以插入 20 万条数据呢。但是这个计算出来的数字，似乎和我们日常的经验不符合啊？这又是为什么呢？</p><p>答案就来自于硬盘的读写。在<strong>顺序读写</strong>和<strong>随机读写</strong>的情况下，<code>硬盘的性能是完全不同的</code>。</p><h3 id="_2-顺序读写-随机读写" tabindex="-1"><a class="header-anchor" href="#_2-顺序读写-随机读写" aria-hidden="true">#</a> 2 顺序读写/随机读写</h3><p>我们回头看一下上面的 AS SSD 的性能指标。你会看到，里面有一个“4K”的指标。这个指标是什么意思呢？它其实就是我们的程序，去随机读取磁盘上某一个 4KB 大小的数据，一秒之内可以读取到多少数据。</p><p>你会发现，在这个指标上，我们使用 SATA 3.0 接口的硬盘和 PCI Express 接口的硬盘，<em><code>性能差异变得很小</code>。这是因为，在这个时候，<code>接口本身的速度</code>已经不是我们硬盘访问速度的瓶颈了</em>。更重要的是，你会发现，即使我们用 PCI Express 的接口，在随机读写的时候，数据传输率也只能到 40MB/s 左右，是顺序读写情况下的几十分之一。</p><p>我们拿这个 40MB/s 和一次读取 4KB 的数据算一下。</p><p>40MB / 4KB = 10,000</p><p>也就是说，一秒之内，这块 SSD 硬盘可以随机读取 1 万次的 4KB 的数据。如果是写入的话呢，会更多一些，90MB /4KB 差不多是 2 万多次。</p><p>这个每秒读写的次数，我们称之为<mark>IOPS</mark>，也就是**<code>每秒输入输出操作的次数</code>**。事实上，比起<mark>响应时间</mark>，我们更关注 <mark>IOPS</mark> 这个性能指标。<mark>IOPS</mark> 和 <mark>DTR</mark>（Data Transfer Rate，数据传输率）才是输入输出性能的核心指标。</p><p>这是因为，我们在实际的应用开发当中，对于数据的访问，<strong>更多的是<code>随机读写</code>，而不是顺序读写</strong>。我们平时所说的服务器承受的“<em>并发</em>”，其实是在说，<em>会有很多个不同的进程和请求来访问服务器</em>。自然，它们在硬盘上访问的数据，是很难顺序放在一起的。<em>这种情况下</em>，<code>随机读写</code>的 <mark>IOPS</mark> 才是服务器性能的核心指标。</p><p>好了，回到我们引出 IOPS 这个问题的 HDD 硬盘。我现在要问你了，那一块 HDD 硬盘能够承受的 IOPS 是多少呢？其实我们应该已经在第 36 讲说过答案了。</p><p>HDD 硬盘的 IOPS 通常也就在 100 左右，而不是在 20 万次。在后面讲解机械硬盘的原理和性能优化的时候，我们还会再来一起看一看，这个 100 是怎么来的，以及我们可以有哪些优化的手段。</p><h2 id="如何定位-io-wait" tabindex="-1"><a class="header-anchor" href="#如何定位-io-wait" aria-hidden="true">#</a> 如何定位 IO_WAIT？</h2><p>我们看到，即使是用上了 PCI Express 接口的 <mark>SSD 硬盘</mark>，IOPS 也就是在 2 万左右。而我们的 <mark>CPU</mark> 的主频通常在 2GHz 以上，也就是每秒可以做 20 亿次操作。</p><p>即使 CPU 向硬盘发起一条读写指令，需要很多个时钟周期，一秒钟 CPU 能够执行的指令数，和我们硬盘能够进行的操作数，<em>也有好几个数量级的差异</em>。这也是为什么，我们在应用开发的时候往往会说*“性能瓶颈在 I/O 上”*。因为很多时候，CPU 指令发出去之后，不得不去“等”我们的 I/O 操作完成，才能进行下一步的操作。</p><h3 id="_1-top" tabindex="-1"><a class="header-anchor" href="#_1-top" aria-hidden="true">#</a> 1 top</h3><p>那么，在实际遇到服务端程序的性能问题的时候，我们怎么知道这个问题是不是来自于 CPU 等 I/O 来完成操作呢？别着急，我们接下来，就通过 <code>top</code> 和 <code>iostat</code> 这些命令，一起来看看 CPU 到底有没有在等待 io 操作。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">top</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>你一定在 Linux 下用过 top 命令。对于很多刚刚入门 Linux 的同学，会用 top 去看服务的负载，也就是 <code>load average</code>。不过，在 top 命令里面，我们一样可以看到 <code>CPU 是否在等待 IO 操作完成</code>。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>top <span class="token operator">-</span> <span class="token number">06</span><span class="token operator">:</span><span class="token number">26</span><span class="token operator">:</span><span class="token number">30</span> up <span class="token number">4</span> days<span class="token punctuation">,</span> <span class="token number">53</span> min<span class="token punctuation">,</span>  <span class="token number">1</span> user<span class="token punctuation">,</span>  load average<span class="token operator">:</span> <span class="token number">0.79</span><span class="token punctuation">,</span> <span class="token number">0.69</span><span class="token punctuation">,</span> <span class="token number">0.65</span>
Tasks<span class="token operator">:</span> <span class="token number">204</span> total<span class="token punctuation">,</span>   <span class="token number">1</span> running<span class="token punctuation">,</span> <span class="token number">203</span> sleeping<span class="token punctuation">,</span>   <span class="token number">0</span> stopped<span class="token punctuation">,</span>   <span class="token number">0</span> zombie
<span class="token operator">%</span><span class="token function">Cpu</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token number">20.0</span> us<span class="token punctuation">,</span>  <span class="token number">1.7</span> sy<span class="token punctuation">,</span>  <span class="token number">0.0</span> ni<span class="token punctuation">,</span> <span class="token number">77.7</span> id<span class="token punctuation">,</span>  <span class="token number">0.0</span> wa<span class="token punctuation">,</span>  <span class="token number">0.0</span> hi<span class="token punctuation">,</span>  <span class="token number">0.7</span> si<span class="token punctuation">,</span>  <span class="token number">0.0</span> st
KiB Mem<span class="token operator">:</span>   <span class="token number">7679792</span> total<span class="token punctuation">,</span>  <span class="token number">6646248</span> used<span class="token punctuation">,</span>  <span class="token number">1033544</span> free<span class="token punctuation">,</span>   <span class="token number">251688</span> buffers
KiB Swap<span class="token operator">:</span>        <span class="token number">0</span> total<span class="token punctuation">,</span>        <span class="token number">0</span> used<span class="token punctuation">,</span>        <span class="token number">0</span> free<span class="token punctuation">.</span>  <span class="token number">4115536</span> cached Mem
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>top 命令的输出结果</p><p>在 top 命令的输出结果里面，有一行是以 %CPU 开头的。这一行里，有一个叫作 <mark>wa</mark> 的指标，这个指标就代表着 <mark>iowait</mark>，也就是 <em>CPU 等待 IO 完成操作花费的时间占 CPU 的百分比</em>。下一次，当你自己的服务器遇到性能瓶颈，load 很大的时候，你就可以通过 top 看一看这个指标。</p><h3 id="_2-iostat" tabindex="-1"><a class="header-anchor" href="#_2-iostat" aria-hidden="true">#</a> 2 iostat</h3><p>知道了 iowait 很大，那么我们就要去看一看，实际的 I/O 操作情况是什么样的。这个时候，你就可以去用 iostat 这个命令了。我们输入“<code>iostat</code>”，就能够看到实际的硬盘读写情况。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>$ iostat
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>avg<span class="token operator">-</span>cpu<span class="token operator">:</span>  <span class="token operator">%</span>user   <span class="token operator">%</span>nice <span class="token operator">%</span>system <span class="token operator">%</span>iowait  <span class="token operator">%</span>steal   <span class="token operator">%</span>idle
          <span class="token number">17.02</span>    <span class="token number">0.01</span>    <span class="token number">2.18</span>    <span class="token number">0.04</span>    <span class="token number">0.00</span>   <span class="token number">80.76</span>
Device<span class="token operator">:</span>            tps    kB_read<span class="token operator">/</span>s    kB_wrtn<span class="token operator">/</span>s    kB_read    kB_wrtn
sda               <span class="token number">1.81</span>         <span class="token number">2.02</span>        <span class="token number">30.87</span>     <span class="token number">706768</span>   <span class="token number">10777408</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你会看到，这个命令里，不仅有 <mark>iowait</mark> 这个 CPU 等待时间的百分比，还有一些更加具体的指标了，并且它还是按照你机器上安装的多块不同的硬盘划分的。</p><p>这里的 <mark>tps</mark> 指标，其实就对应着我们上面所说的<em>硬盘的 IOPS 性能</em>。而 <mark>kB_read/s</mark> 和 <mark>kB_wrtn/s</mark> 指标，就对应着我们的<em>数据传输率</em>的指标。</p><h3 id="_3-iotop" tabindex="-1"><a class="header-anchor" href="#_3-iotop" aria-hidden="true">#</a> 3 iotop</h3><p>知道实际硬盘读写的 tps、kB_read/s 和 kb_wrtn/s 的指标，我们基本上可以判断出，机器的性能是不是卡在 I/O 上了。那么，接下来，我们就是要找出到底是<code>哪一个进程</code>是这些 I/O 读写的来源了。这个时候，你需要“<code>iotop</code>”这个命令。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>$ iotop
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>Total DISK READ <span class="token operator">:</span>       <span class="token number">0.00</span> B<span class="token operator">/</span>s <span class="token operator">|</span> Total DISK WRITE <span class="token operator">:</span>      <span class="token number">15.75</span> K<span class="token operator">/</span>s
Actual DISK READ<span class="token operator">:</span>       <span class="token number">0.00</span> B<span class="token operator">/</span>s <span class="token operator">|</span> Actual DISK WRITE<span class="token operator">:</span>      <span class="token number">35.44</span> K<span class="token operator">/</span>s
  TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO<span class="token operator">&gt;</span>    COMMAND                                             
  <span class="token number">104</span> be<span class="token operator">/</span><span class="token number">3</span> root        <span class="token number">0.00</span> B<span class="token operator">/</span>s    <span class="token number">7.88</span> K<span class="token operator">/</span>s  <span class="token number">0.00</span> <span class="token operator">%</span>  <span class="token number">0.18</span> <span class="token operator">%</span> <span class="token punctuation">[</span>jbd2<span class="token operator">/</span>sda1<span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">]</span>
  <span class="token number">383</span> be<span class="token operator">/</span><span class="token number">4</span> root        <span class="token number">0.00</span> B<span class="token operator">/</span>s    <span class="token number">3.94</span> K<span class="token operator">/</span>s  <span class="token number">0.00</span> <span class="token operator">%</span>  <span class="token number">0.00</span> <span class="token operator">%</span> rsyslogd <span class="token operator">-</span>n <span class="token punctuation">[</span>rs<span class="token operator">:</span>main Q<span class="token operator">:</span>Reg<span class="token punctuation">]</span>
 <span class="token number">1514</span> be<span class="token operator">/</span><span class="token number">4</span> www<span class="token operator">-</span>data    <span class="token number">0.00</span> B<span class="token operator">/</span>s    <span class="token number">3.94</span> K<span class="token operator">/</span>s  <span class="token number">0.00</span> <span class="token operator">%</span>  <span class="token number">0.00</span> <span class="token operator">%</span> nginx<span class="token operator">:</span> worker process

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过 <code>iotop</code> 这个命令，你可以看到<code>具体是哪一个进程</code>实际占用了大量 I/O，那么你就可以有的放矢，去优化对应的程序了。</p><h3 id="_4-stress模拟" tabindex="-1"><a class="header-anchor" href="#_4-stress模拟" aria-hidden="true">#</a> 4 stress模拟</h3><p>上面的这些示例里，不管是 wa 也好，tps 也好，它们都很小。那么，接下来，我就给你用 Linux 下，用 stress 命令，来模拟一个高 I/O 复杂的情况，来看看这个时候的 iowait 是怎么样的。</p><p>我在一台云平台上的单个 CPU 核心的机器上输入“<code>stress -i 2</code>”，让 stress 这个程序模拟两个进程不停地从内存里往硬盘上写数据。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>$ stress <span class="token operator">-</span>i <span class="token number">2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>$ top
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>你会看到，在 <code>top</code> 的输出里面，CPU 就有大量的 <mark>sy</mark> 和 <mark>wa</mark>，也就是<em>系统调用</em>和 <em>iowait</em>。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>top <span class="token operator">-</span> <span class="token number">06</span><span class="token operator">:</span><span class="token number">56</span><span class="token operator">:</span><span class="token number">02</span> up <span class="token number">3</span> days<span class="token punctuation">,</span> <span class="token number">19</span><span class="token operator">:</span><span class="token number">34</span><span class="token punctuation">,</span>  <span class="token number">2</span> users<span class="token punctuation">,</span>  load average<span class="token operator">:</span> <span class="token number">5.99</span><span class="token punctuation">,</span> <span class="token number">1.82</span><span class="token punctuation">,</span> <span class="token number">0.63</span>
Tasks<span class="token operator">:</span>  <span class="token number">88</span> total<span class="token punctuation">,</span>   <span class="token number">3</span> running<span class="token punctuation">,</span>  <span class="token number">85</span> sleeping<span class="token punctuation">,</span>   <span class="token number">0</span> stopped<span class="token punctuation">,</span>   <span class="token number">0</span> zombie
<span class="token operator">%</span><span class="token function">Cpu</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">:</span>  <span class="token number">3.0</span> us<span class="token punctuation">,</span> <span class="token number">29.9</span> sy<span class="token punctuation">,</span>  <span class="token number">0.0</span> ni<span class="token punctuation">,</span>  <span class="token number">0.0</span> id<span class="token punctuation">,</span> <span class="token number">67.2</span> wa<span class="token punctuation">,</span>  <span class="token number">0.0</span> hi<span class="token punctuation">,</span>  <span class="token number">0.0</span> si<span class="token punctuation">,</span>  <span class="token number">0.0</span> st
KiB Mem <span class="token operator">:</span>  <span class="token number">1741304</span> total<span class="token punctuation">,</span>  <span class="token number">1004404</span> free<span class="token punctuation">,</span>   <span class="token number">307152</span> used<span class="token punctuation">,</span>   <span class="token number">429748</span> buff<span class="token operator">/</span>cache
KiB Swap<span class="token operator">:</span>        <span class="token number">0</span> total<span class="token punctuation">,</span>        <span class="token number">0</span> free<span class="token punctuation">,</span>        <span class="token number">0</span> used<span class="token punctuation">.</span>  <span class="token number">1245700</span> avail Mem 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>$ iostat <span class="token number">2</span> <span class="token number">5</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果我们通过 <code>iostat</code>，查看硬盘的 I/O，你会看到，里面的 <mark>tps</mark> 很快就到了 4 万左右，占满了对应硬盘的 <em>IOPS</em>。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>avg<span class="token operator">-</span>cpu<span class="token operator">:</span>  <span class="token operator">%</span>user   <span class="token operator">%</span>nice <span class="token operator">%</span>system <span class="token operator">%</span>iowait  <span class="token operator">%</span>steal   <span class="token operator">%</span>idle
           <span class="token number">5.03</span>    <span class="token number">0.00</span>   <span class="token number">67.92</span>   <span class="token number">27.04</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>
Device<span class="token operator">:</span>            tps    kB_read<span class="token operator">/</span>s    kB_wrtn<span class="token operator">/</span>s    kB_read    kB_wrtn
sda           <span class="token number">39762.26</span>         <span class="token number">0.00</span>         <span class="token number">0.00</span>          <span class="token number">0</span>          <span class="token number">0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果这个时候我们去看一看 <code>iotop</code>，你就会发现，我们的 I/O 占用，<em>都来自于 stress 产生的两个进程了</em>。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>$ iotop
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>Total DISK READ <span class="token operator">:</span>       <span class="token number">0.00</span> B<span class="token operator">/</span>s <span class="token operator">|</span> Total DISK WRITE <span class="token operator">:</span>       <span class="token number">0.00</span> B<span class="token operator">/</span>s
Actual DISK READ<span class="token operator">:</span>       <span class="token number">0.00</span> B<span class="token operator">/</span>s <span class="token operator">|</span> Actual DISK WRITE<span class="token operator">:</span>       <span class="token number">0.00</span> B<span class="token operator">/</span>s
  TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO<span class="token operator">&gt;</span>    COMMAND                                             
<span class="token number">29161</span> be<span class="token operator">/</span><span class="token number">4</span> xuwenhao    <span class="token number">0.00</span> B<span class="token operator">/</span>s    <span class="token number">0.00</span> B<span class="token operator">/</span>s  <span class="token number">0.00</span> <span class="token operator">%</span> <span class="token number">56.71</span> <span class="token operator">%</span> stress <span class="token operator">-</span>i <span class="token number">2</span>
<span class="token number">29162</span> be<span class="token operator">/</span><span class="token number">4</span> xuwenhao    <span class="token number">0.00</span> B<span class="token operator">/</span>s    <span class="token number">0.00</span> B<span class="token operator">/</span>s  <span class="token number">0.00</span> <span class="token operator">%</span> <span class="token number">46.89</span> <span class="token operator">%</span> stress <span class="token operator">-</span>i <span class="token number">2</span>
    <span class="token number">1</span> be<span class="token operator">/</span><span class="token number">4</span> root        <span class="token number">0.00</span> B<span class="token operator">/</span>s    <span class="token number">0.00</span> B<span class="token operator">/</span>s  <span class="token number">0.00</span> <span class="token operator">%</span>  <span class="token number">0.00</span> <span class="token operator">%</span> init
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>相信到了这里，你也应该学会了怎么通过 <code>top</code>、<code>iostat</code> 以及 <code>iotop</code>，一步一步快速定位服务器端的 I/O 带来的性能瓶颈了。你也可以自己<em>通过 Linux 的 man 命令</em>，看一看这些命令还有哪些参数，以及通过 <code>stress</code> 来模拟其他更多不同的性能压力，看看我们的机器负载会发生什么变化。</p><h2 id="总结延伸" tabindex="-1"><a class="header-anchor" href="#总结延伸" aria-hidden="true">#</a> 总结延伸</h2><p>这一讲里，我们从硬盘的两个核心指标，<mark>响应时间</mark>和<mark>数据传输率</mark>，来理解和研究 I/O 的性能问题。你也自己可以通过 <mark>as ssd</mark> 这样的性能评测软件，看一看自己的硬盘性能。</p><p>在顺序读取的情况下，无论是 <mark>HDD 硬盘</mark>还是 <mark>SSD 硬盘</mark>，性能看起来都是很不错的。不过，等到进行<em>随机读取</em>测试的时候，硬盘的性能才能见了真章。<em>因为在大部分的应用开发场景下</em>，我们关心的并不是在顺序读写下的数据量，而是<em>每秒钟能够进行输入输出的操作次数</em>，也就是 <em>IOPS</em> 这个核心性能指标。</p><p>你会发现，即使是使用 PCI Express 接口的 SSD 硬盘，IOPS 也就只是到了 2 万左右。这个性能，和我们 CPU 的每秒 20 亿次操作的能力比起来，<em>可就差得远了</em>。所以很多时候，我们的程序对外响应慢，其实都是 CPU 在等待 I/O 操作完成。</p><p>在 Linux 下，我们可以通过 <code>top</code> 这样的命令，<strong>来看整个服务器的整体负载</strong>。在应用响应慢的时候，我们可以先通过这个指令，来看 CPU 是否在等待 I/O 完成自己的操作。</p><p>进一步地，我们可以通过 <code>iostat</code> 这个命令，<strong>来看到各个硬盘这个时候的读写情况</strong>。</p><p>而 <code>iotop</code> 这个命令，能够帮助我们定位到到底是<strong>哪一个进程</strong>在进行大量的 I/O 操作。</p><p>这些命令的组合，可以快速帮你定位到是不是我们的程序遇到了 I/O 的瓶颈，以及这些瓶颈来自于哪些程序，你就可以根据定位的结果来优化你自己的程序了。</p><h2 id="推荐阅读" tabindex="-1"><a class="header-anchor" href="#推荐阅读" aria-hidden="true">#</a> 推荐阅读</h2>`,74),k={href:"https://louwrentius.com/understanding-iops-latency-and-storage-performance.html",target:"_blank",rel:"noopener noreferrer"},m=n('<h2 id="课后思考" tabindex="-1"><a class="header-anchor" href="#课后思考" aria-hidden="true">#</a> 课后思考</h2><p>你能去下载一个 AS SSD 软件，测试一下你自己硬盘的性能吗？特别是如果你手上还有 HDD 硬盘的话，可以尝试测试一下 HDD 硬盘的性能是怎么样的。</p><p>在上面的性能指标上，我们已经讲解了 Seq，4K 以及 Acc.Time 这三个指标，那么 4K-Thrd 这个指标又是什么意思呢？测试这个指标对应的应用场景又是怎么样的呢？</p><p>请你研究一下，把你得到的答案写在留言区，和大家一起分享讨论吧。另外，如果有收获，也欢迎你把这篇文章分享给你的朋友。</p><blockquote><p>4K-64Thrd是随机64队列深度测试，软件则会生成64个16MB大小的测试文件（共计1GB），然后同时以4KB的单位尺寸，同时在这64个文件中进行写入和读取测试，最后依然以平均成绩为结果!</p><p>才注意到，硬盘的随机读的性能是不如随机写的。我以前一直以为是反过来的，但是为什么呢？按这个现象，原来硬盘类设备是“写多读少”的设计思路？</p><p>请问下顺序IO在开发上是怎么实现的？比如对于C开发，就是以append only的方式打开一个文件直接写就行了？还是说有什么特别的控制指令？<br> 我看挺多数据库软件写日志的时候用的都是所谓的AOF文件，说顺序写完日志再应用到库里，是不是也是同样的方式？<br> 作者回复: 在应用开发层面，的确只要append only直接写文件就OK了。<br> 是的，这种先写日志，再commit到实际的数据库内部的存储结构的WAL（Write Ahead Logging）日志的方式，其实也就是AOF（Append Only File）的方式。</p></blockquote>',5);function b(v,h){const e=o("ExternalLinkIcon");return t(),r("div",null,[d,a("p",null,[s("关于 IO_WAIT 的文章，在互联网上已经有不少了。你可以读一读这一篇"),a("a",k,[s("Understanding IOPS Latency and Storage Performance"),c(e)]),s("，进一步理解一下什么是 IOPS 和 IO_WAIT。")]),m])}const S=p(u,[["render",b],["__file","G44-理解IO性能.html.vue"]]);export{S as default};
