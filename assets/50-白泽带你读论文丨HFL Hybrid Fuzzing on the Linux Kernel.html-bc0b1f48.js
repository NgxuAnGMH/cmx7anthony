import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o as t,c as o,a as e,b as n,e as s,d as l}from"./app-cdabc73c.js";const p="/assets/640-1691462282244-15-cf91ac86.png",u="/assets/640-1691462282245-16-1e52bc9d.png",c="/assets/640-1691462282245-17-b4c4d238.png",z="/assets/640-1691462282245-18-ad9ce049.png",d={},f=e("h1",{id:"_50-白泽带你读论文丨hfl-hybrid-fuzzing-on-the-linux-kernel",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_50-白泽带你读论文丨hfl-hybrid-fuzzing-on-the-linux-kernel","aria-hidden":"true"},"#"),n(" 50-白泽带你读论文丨HFL: Hybrid Fuzzing on the Linux Kernel")],-1),g=e("p",null,[e("strong",null,"HFL: Hybrid Fuzzing on the Linux Kernel")],-1),h={href:"https://www.ndss-symposium.org/wp-content/uploads/2020/02/24018-paper.pdf",target:"_blank",rel:"noopener noreferrer"},_=l('<p>本文发表在NDSS 2020，第一作者是来自普渡大学的Kyungtae Kim，也是之前做了Razzer工作的作者。</p><h2 id="_1-主要内容" tabindex="-1"><a class="header-anchor" href="#_1-主要内容" aria-hidden="true">#</a> <strong>1 主要内容</strong></h2><p>在自动化漏洞挖掘领域，学界相继提出了fuzzing和hybrid fuzzing的概念，前者是通过传统的模糊测试技术对各类软件、程序进行漏洞挖掘，具有代表性的有<mark>AFL</mark>等，后者是在传统模糊测试技术的基础上，引入<em>符号执行技术</em>帮助求解fuzzing难以解决的约束条件，从而增加fuzzing的代码覆盖率，具有代表性的有<mark>QSYM</mark>等。但是，当前的fuzzing技术难以直接应用于操作系统内核上进行漏洞挖掘。作者总结了三个由于内核特性导致的技术限制：</p><p>（1）内核中由于运行时多态性导致大量存在的间接调用；</p><p>（2）内核中各个系统调用间存在的隐含依赖关系；</p><p>（3）系统调用中涉及到未知嵌套参数的类型推断。</p><p>这三个问题会导致在内核上进行hybrid fuzzing时的代码覆盖率低，且很难发现漏洞。</p><p>因此，为了解决以上的问题，作者提出了一种基于hybrid fuzzing技术的内核漏洞挖掘工具<mark>HFL</mark>。该工具通过将间接调用转换为直接调用、推断系统调用依赖关系、推断嵌套参数类型来提高hybird fuzzing的覆盖率，从而挖掘Linux内核中的漏洞。最后作者使用该工具发现了24个新的漏洞，代码覆盖率比<mark>Moonshine</mark>提升15%，比<mark>Syzkaller</mark>提升26%。</p><h2 id="_2-设计与实现" tabindex="-1"><a class="header-anchor" href="#_2-设计与实现" aria-hidden="true">#</a> <strong>2 设计与实现</strong></h2><figure><img src="'+p+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>如图是HFL的设计架构图，整个工具的流程大致和hybrid fuzzer相同，通过给定一些syscall输入到fuzzer，当fuzzer遇到难以解决的分支时，会将相应的输入传给symbolic analyzer进行求解，并将求解结果返回给fuzzer进行下一步的路径探索。作者提到的三个challenges会在各个过程中进行解决。主要包含以下四个工作流程：</p><p>（1）首先在内核上进行过程间的静态分析，获取可能存在依赖关系的系统调用对作为fuzzer的输入，这里的依赖关系是通过指针分析，定位会在相同内存位置进行读写操作的指令对得到的；</p><p>（2）然后在fuzzer启动前，工具会在编译内核期间进行间接控制流的转换，转换的思路主要是通过一个比较简单的数据流分析，识别和系统调用参数有关的虚表索引值，并对这些索引值进行分支转换（插入一个条件指令跳转到相应的函数指针），使得间接控制流转换为直接控制流。转换后的内核会在后续给symbolic analyzer使用；</p><p>（3）之后工具启动fuzzer进行漏洞挖掘，在fuzzer遇到难以解决的分支时，会将相应的输入传给symbolic analyzer进行求解。这里作者定义了一个频率计数表来统计fuzzing过程中条件判断语句为true或者false的频度，从而得知程序是否“卡”住，进而确定切换为符号执行的时机。</p><p>（4）在symbolic analyzer中的分析除了常规的约束求解外，还利用符号状态等信息进行进一步的分析并将结果反馈给fuzzer，指导后续输入的mutation。其分析主要分为两部分：</p><p>a. <em>根据依赖关系确定系统调用间的顺序</em>：程序在symbolic执行期间会对第一步中静态分析时收集的读/写指令对进行实时的校验，检查指令是否访问相同的内存地址，从而确定系统调用的顺序，并根据符号信息得知系统调用参数间的依赖。</p><p>b. <em>推断嵌套参数类型信息</em>：程序在执行期间监视传递函数（指用户态和内核态间传输数据的函数，比如copy_from_user，syscall的参数数据一般通过该函数进行传输）的调用，当源数据区被symbolic taint（来自系统调用的参数）时，使用符号状态对目标数据区进行跟踪，从而确定嵌套结构的内存位置以及相应缓冲区的长度，构建出嵌套参数的类型信息。</p><h2 id="_3-实验与分析" tabindex="-1"><a class="header-anchor" href="#_3-实验与分析" aria-hidden="true">#</a> <strong>3 实验与分析</strong></h2><p>作者将Linux kernel的子系统根据功能划分为三个分类：<mark>设备驱动</mark>、<mark>网络</mark>、<mark>文件系统</mark>，针对下列的syscall进行测试。</p><figure><img src="'+u+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>（1）漏洞发现能力：HFL在Linux kernel中发现了24个新的bug，包括UAF、整数溢出等类型，其中17个被Linux开发社区确认。</p><p>（2）漏洞发现效率：作者选取了13个HFL和Syzkaller都能发现的bug进行测试，结果如下图，可以发现，HFL发现漏洞的效率比Syzkaller快3倍多。</p><figure><img src="'+c+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>（3）代码覆盖率：作者将HFL和一些现有的kernel fuzzer进行比较，包括Moonshine，<mark>kAFL</mark>等，使用KCOV-based作为测试标准，结果如下图，可以发现HFL的覆盖率均比其他被测工具高，高于15%到4倍。</p><figure><img src="'+z+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h2 id="_4-评价" tabindex="-1"><a class="header-anchor" href="#_4-评价" aria-hidden="true">#</a> <strong>4 评价</strong></h2><p>HFL是第一个在Linux kernel上进行hybird fuzzing的自动化漏洞挖掘工具。通过解决了三个由于内核特性带来的挑战，工具成功在Linux kernel上找到了24个未知的漏洞。并且从代码覆盖率上来看，其表现都要优于之前做kernel fuzz工作的Moonshine和Syzkaller。另外，文章比较创新地运用了符号执行中的相关符号状态等信息进行污点分析，从而获取辅助信息反馈给fuzzer，指导其后续输入的mutation。</p>',27);function m(y,k){const r=i("ExternalLinkIcon");return t(),o("div",null,[f,g,e("p",null,[n("论文链接："),e("a",h,[n("https://www.ndss-symposium.org/wp-content/uploads/2020/02/24018-paper.pdf"),s(r)])]),_])}const L=a(d,[["render",m],["__file","50-白泽带你读论文丨HFL Hybrid Fuzzing on the Linux Kernel.html.vue"]]);export{L as default};
