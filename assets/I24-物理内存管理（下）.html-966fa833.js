import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{r as c,o,c as l,a as n,b as s,e as t,d as p}from"./app-cdabc73c.js";const i="/assets/172839800c8d51c49b67ec8c4d07315e-96570c00.jpeg",u="/assets/45f38a0c7bce8c98881bbe8b8b4c190a-db34fefc.jpeg",r="/assets/527e5c861fd06c6eb61a761e4214ba54-8b030c4a.jpeg",k={},d=p(`<h1 id="_24-物理内存管理-下-会议室管理员如何分配会议室" tabindex="-1"><a class="header-anchor" href="#_24-物理内存管理-下-会议室管理员如何分配会议室" aria-hidden="true">#</a> 24 | 物理内存管理（下）：会议室管理员如何分配会议室？</h1><p>前一节，前面我们解析了整页的分配机制。如果遇到小的对象，物理内存是如何分配的呢？这一节，我们一起来看一看。</p><blockquote><p>大块内存分配 mmap</p></blockquote><h2 id="小内存的分配" tabindex="-1"><a class="header-anchor" href="#小内存的分配" aria-hidden="true">#</a> 小内存的分配</h2><p>前面我们讲过，如果遇到小的对象，会使用 slub 分配器进行分配。那我们就先来解析它的工作原理。</p><p>还记得咱们创建进程的时候，会调用 dup_task_struct，它想要试图复制一个 task_struct 对象，需要先调用 alloc_task_struct_node，分配一个 task_struct 对象。</p><p>从这段代码可以看出，它调用了 kmem_cache_alloc_node 函数，在 task_struct 的缓存区域 task_struct_cachep 分配了一块内存。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>task_struct_cachep<span class="token punctuation">;</span>

task_struct_cachep <span class="token operator">=</span> <span class="token function">kmem_cache_create</span><span class="token punctuation">(</span><span class="token string">&quot;task_struct&quot;</span><span class="token punctuation">,</span>
      arch_task_struct_size<span class="token punctuation">,</span> align<span class="token punctuation">,</span>
      SLAB_PANIC<span class="token operator">|</span>SLAB_NOTRACK<span class="token operator">|</span>SLAB_ACCOUNT<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token function">alloc_task_struct_node</span><span class="token punctuation">(</span><span class="token keyword">int</span> node<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">kmem_cache_alloc_node</span><span class="token punctuation">(</span>task_struct_cachep<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">free_task_struct</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">kmem_cache_free</span><span class="token punctuation">(</span>task_struct_cachep<span class="token punctuation">,</span> tsk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在系统初始化的时候，task_struct_cachep 会被 kmem_cache_create 函数创建。这个函数也比较容易看懂，专门用于分配 task_struct 对象的缓存。这个缓存区的名字就叫 task_struct。缓存区中每一块的大小正好等于 task_struct 的大小，也即 arch_task_struct_size。</p><p>有了这个缓存区，每次创建 task_struct 的时候，我们不用到内存里面去分配，先在缓存里面看看有没有直接可用的，这就是 <strong>kmem_cache_alloc_node</strong> 的作用。</p><p>当一个进程结束，task_struct 也不用直接被销毁，而是放回到缓存中，这就是 <strong>kmem_cache_free</strong> 的作用。这样，新进程创建的时候，我们就可以直接用现成的缓存中的 task_struct 了。</p><h3 id="缓存区" tabindex="-1"><a class="header-anchor" href="#缓存区" aria-hidden="true">#</a> 缓存区</h3><p>我们来仔细看看，缓存区 struct kmem_cache 到底是什么样子。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_cpu</span> __percpu <span class="token operator">*</span>cpu_slab<span class="token punctuation">;</span>
  <span class="token comment">/* Used for retriving partial slabs etc */</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> min_partial<span class="token punctuation">;</span>
  <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token comment">/* The size of an object including meta data */</span>
  <span class="token keyword">int</span> object_size<span class="token punctuation">;</span>  <span class="token comment">/* The size of an object without meta data */</span>
  <span class="token keyword">int</span> offset<span class="token punctuation">;</span>    <span class="token comment">/* Free pointer offset. */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_SLUB_CPU_PARTIAL</span></span>
  <span class="token keyword">int</span> cpu_partial<span class="token punctuation">;</span>  <span class="token comment">/* Number of per cpu partial objects to keep around */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
  <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_order_objects</span> oo<span class="token punctuation">;</span>
  <span class="token comment">/* Allocation and freeing of slabs */</span>
  <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_order_objects</span> max<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_order_objects</span> min<span class="token punctuation">;</span>
  <span class="token class-name">gfp_t</span> allocflags<span class="token punctuation">;</span>  <span class="token comment">/* gfp flags to use on each alloc */</span>
  <span class="token keyword">int</span> refcount<span class="token punctuation">;</span>    <span class="token comment">/* Refcount for slab cache destroy */</span>
  <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>ctor<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>  <span class="token comment">/* Name (only for display!) */</span>
  <span class="token keyword">struct</span> <span class="token class-name">list_head</span> list<span class="token punctuation">;</span>  <span class="token comment">/* List of slab caches */</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_node</span> <span class="token operator">*</span>node<span class="token punctuation">[</span>MAX_NUMNODES<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 struct kmem_cache 里面，有个变量 struct list_head list，这个结构我们已经看到过多次了。我们可以想象一下，对于操作系统来讲，要创建和管理的缓存绝对不止 task_struct。难道 mm_struct 就不需要吗？fs_struct 就不需要吗？都需要。因此，所有的缓存最后都会放在一个链表里面，也就是 LIST_HEAD(slab_caches)。</p><p>对于缓存来讲，其实就是分配了连续几页的大内存块，然后根据缓存对象的大小，切成小内存块。</p><h3 id="缓存区进一步划分" tabindex="-1"><a class="header-anchor" href="#缓存区进一步划分" aria-hidden="true">#</a> 缓存区进一步划分</h3><p>所以，我们这里有三个 kmem_cache_order_objects 类型的变量。这里面的 order，就是 2 的 order 次方个页面的大内存块，objects 就是能够存放的缓存对象的数量。</p><p>最终，我们将大内存块切分成小内存块，样子就像下面这样。</p><img src="`+i+'" alt="img" style="zoom:25%;"><p>每一项的结构都是缓存对象后面跟一个下一个空闲对象的指针，这样非常方便将所有的空闲对象链成一个链。其实，这就相当于咱们数据结构里面学的，用数组实现一个可随机插入和删除的链表。</p><p>所以，这里面就有三个变量：</p><ol><li>size 是包含这个指针的大小，</li><li>object_size 是纯对象的大小，</li><li>offset 就是把下一个空闲对象的指针存放在这一项里的偏移量。</li></ol><p>那这些缓存对象哪些被分配了、哪些在空着，什么情况下整个大内存块都被分配完了，需要向<mark>伙伴系统</mark>申请几个页形成新的大内存块？这些信息该由谁来维护呢？</p><h3 id="每个-numa-节点的分配" tabindex="-1"><a class="header-anchor" href="#每个-numa-节点的分配" aria-hidden="true">#</a> 每个 NUMA 节点的分配</h3><p>接下来就是最重要的两个成员变量出场的时候了。kmem_cache_cpu 和 kmem_cache_node，它们都是每个 NUMA 节点上有一个，我们只需要看一个节点里面的情况。</p><img src="'+u+`" alt="img" style="zoom:25%;"><p>在分配缓存块的时候，要分两种路径，<strong>fast path</strong> 和 <strong>slow path</strong>，也就是<strong>快速通道</strong>和<strong>普通通道</strong>。</p><ul><li>其中 kmem_cache_cpu 就是快速通道，kmem_cache_node 是普通通道。</li><li>每次分配的时候，要先从 kmem_cache_cpu 进行分配。如果 kmem_cache_cpu 里面没有空闲的块，那就到 kmem_cache_node 中进行分配；</li><li>如果还是没有空闲的块，才去伙伴系统分配新的页。</li></ul><h3 id="_1-快速通道-快速分配路径" tabindex="-1"><a class="header-anchor" href="#_1-快速通道-快速分配路径" aria-hidden="true">#</a> 1 快速通道/快速分配路径</h3><p>我们来看一下，kmem_cache_cpu 里面是如何存放缓存块的。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">kmem_cache_cpu</span> <span class="token punctuation">{</span>
  <span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span>freelist<span class="token punctuation">;</span>  <span class="token comment">/* Pointer to next available object */</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> tid<span class="token punctuation">;</span>  <span class="token comment">/* Globally unique transaction id */</span>
  <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">;</span>  <span class="token comment">/* The slab from which we are allocating */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_SLUB_CPU_PARTIAL</span></span>
  <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>partial<span class="token punctuation">;</span>  <span class="token comment">/* Partially allocated frozen slabs */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这里，page 指向大内存块的第一个页，缓存块就是从里面分配的。freelist 指向大内存块里面第一个空闲的项。按照上面说的，这一项会有指针指向下一个空闲的项，最终所有空闲的项会形成一个链表。</p><p>partial 指向的也是大内存块的第一个页，之所以名字叫 partial（部分），就是因为它里面部分被分配出去了，部分是空的。这是一个备用列表，当 page 满了，就会从这里找。</p><h3 id="_2-普通通道-慢速分配路径" tabindex="-1"><a class="header-anchor" href="#_2-普通通道-慢速分配路径" aria-hidden="true">#</a> 2 普通通道/慢速分配路径</h3><p>我们再来看 kmem_cache_node 的定义。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">kmem_cache_node</span> <span class="token punctuation">{</span>
  <span class="token class-name">spinlock_t</span> list_lock<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_SLUB</span></span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> nr_partial<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">list_head</span> partial<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里面也有一个 partial，是一个链表。这个链表里存放的是部分空闲的内存块。这是 kmem_cache_cpu 里面的 partial 的备用列表，如果那里没有，就到这里来找。</p><h2 id="分配过程" tabindex="-1"><a class="header-anchor" href="#分配过程" aria-hidden="true">#</a> 分配过程</h2><p>下面我们就来看看这个分配过程。kmem_cache_alloc_node 会调用 slab_alloc_node。你还是先重点看这里面的注释，这里面说的就是快速通道和普通通道的概念。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/*
 * Inlined fastpath so that allocation functions (kmalloc, kmem_cache_alloc)
 * have the fastpath folded into their functions. So no function call
 * overhead for requests that can be satisfied on the fastpath.
 *
 * The fastpath works by first checking if the lockless freelist can be used.
 * If not then __slab_alloc is called for slow processing.
 *
 * Otherwise we can simply pick the next object from the lockless free list.
 */</span>
<span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">slab_alloc_node</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>s<span class="token punctuation">,</span>
    <span class="token class-name">gfp_t</span> gfpflags<span class="token punctuation">,</span> <span class="token keyword">int</span> node<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> addr<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">void</span> <span class="token operator">*</span>object<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_cpu</span> <span class="token operator">*</span>c<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> tid<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  tid <span class="token operator">=</span> <span class="token function">this_cpu_read</span><span class="token punctuation">(</span>s<span class="token operator">-&gt;</span>cpu_slab<span class="token operator">-&gt;</span>tid<span class="token punctuation">)</span><span class="token punctuation">;</span>
  c <span class="token operator">=</span> <span class="token function">raw_cpu_ptr</span><span class="token punctuation">(</span>s<span class="token operator">-&gt;</span>cpu_slab<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  object <span class="token operator">=</span> c<span class="token operator">-&gt;</span>freelist<span class="token punctuation">;</span>
  page <span class="token operator">=</span> c<span class="token operator">-&gt;</span>page<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span>object <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">node_match</span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    object <span class="token operator">=</span> <span class="token function">__slab_alloc</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> gfpflags<span class="token punctuation">,</span> node<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">stat</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> ALLOC_SLOWPATH<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> 
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">return</span> object<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>快速通道很简单，取出 cpu_slab 也即 kmem_cache_cpu 的 freelist，这就是第一个空闲的项，可以直接返回了。如果没有空闲的了，则只好进入普通通道，调用 __slab_alloc。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">___slab_alloc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token class-name">gfp_t</span> gfpflags<span class="token punctuation">,</span> <span class="token keyword">int</span> node<span class="token punctuation">,</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> addr<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_cpu</span> <span class="token operator">*</span>c<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">void</span> <span class="token operator">*</span>freelist<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
redo<span class="token operator">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token comment">/* must check again c-&gt;freelist in case of cpu migration or IRQ */</span>
  freelist <span class="token operator">=</span> c<span class="token operator">-&gt;</span>freelist<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>freelist<span class="token punctuation">)</span>
    <span class="token keyword">goto</span> load_freelist<span class="token punctuation">;</span>


  freelist <span class="token operator">=</span> <span class="token function">get_freelist</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> page<span class="token punctuation">)</span><span class="token punctuation">;</span>


  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>freelist<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    c<span class="token operator">-&gt;</span>page <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token function">stat</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> DEACTIVATE_BYPASS<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">goto</span> new_slab<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>


load_freelist<span class="token operator">:</span>
  c<span class="token operator">-&gt;</span>freelist <span class="token operator">=</span> <span class="token function">get_freepointer</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> freelist<span class="token punctuation">)</span><span class="token punctuation">;</span>
  c<span class="token operator">-&gt;</span>tid <span class="token operator">=</span> <span class="token function">next_tid</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>tid<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> freelist<span class="token punctuation">;</span>


new_slab<span class="token operator">:</span>


  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">slub_percpu_partial</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    page <span class="token operator">=</span> c<span class="token operator">-&gt;</span>page <span class="token operator">=</span> <span class="token function">slub_percpu_partial</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">slub_set_percpu_partial</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> page<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">stat</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> CPU_PARTIAL_ALLOC<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">goto</span> redo<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>


  freelist <span class="token operator">=</span> <span class="token function">new_slab_objects</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> gfpflags<span class="token punctuation">,</span> node<span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">return</span> freeli

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这里，我们首先再次尝试一下 kmem_cache_cpu 的 freelist。为什么呢？万一当前进程被中断，等回来的时候，别人已经释放了一些缓存，说不定又有空间了呢。如果找到了，就跳到 load_freelist，在这里将 freelist 指向下一个空闲项，返回就可以了。</p><p>如果 freelist 还是没有，则跳到 new_slab 里面去。这里面我们先去 kmem_cache_cpu 的 partial 里面看。如果 partial 不是空的，那就将 kmem_cache_cpu 的 page，也就是快速通道的那一大块内存，替换为 partial 里面的大块内存。然后 redo，重新试下。这次应该就可以成功了。</p><p>如果真的还不行，那就要到 new_slab_objects 了。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">new_slab_objects</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token class-name">gfp_t</span> flags<span class="token punctuation">,</span>
      <span class="token keyword">int</span> node<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_cpu</span> <span class="token operator">*</span><span class="token operator">*</span>pc<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">void</span> <span class="token operator">*</span>freelist<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_cpu</span> <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token operator">*</span>pc<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">;</span>


  freelist <span class="token operator">=</span> <span class="token function">get_partial</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> node<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>


  <span class="token keyword">if</span> <span class="token punctuation">(</span>freelist<span class="token punctuation">)</span>
    <span class="token keyword">return</span> freelist<span class="token punctuation">;</span>


  page <span class="token operator">=</span> <span class="token function">new_slab</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>page<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    c <span class="token operator">=</span> <span class="token function">raw_cpu_ptr</span><span class="token punctuation">(</span>s<span class="token operator">-&gt;</span>cpu_slab<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>page<span class="token punctuation">)</span>
      <span class="token function">flush_slab</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>


    freelist <span class="token operator">=</span> page<span class="token operator">-&gt;</span>freelist<span class="token punctuation">;</span>
    page<span class="token operator">-&gt;</span>freelist <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>


    <span class="token function">stat</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> ALLOC_SLAB<span class="token punctuation">)</span><span class="token punctuation">;</span>
    c<span class="token operator">-&gt;</span>page <span class="token operator">=</span> page<span class="token punctuation">;</span>
    <span class="token operator">*</span>pc <span class="token operator">=</span> c<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span>
    freelist <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>


  <span class="token keyword">return</span> freelis
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这里面，get_partial 会根据 node id，找到相应的 kmem_cache_node，然后调用 get_partial_node，开始在这个节点进行分配。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/*
 * Try to allocate a partial slab from a specific node.
 */</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">get_partial_node</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_node</span> <span class="token operator">*</span>n<span class="token punctuation">,</span>
        <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_cpu</span> <span class="token operator">*</span>c<span class="token punctuation">,</span> <span class="token class-name">gfp_t</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">,</span> <span class="token operator">*</span>page2<span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token operator">*</span>object <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> available <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> objects<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token function">list_for_each_entry_safe</span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> page2<span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token operator">-&gt;</span>partial<span class="token punctuation">,</span> lru<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>t<span class="token punctuation">;</span>


    t <span class="token operator">=</span> <span class="token function">acquire_slab</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> n<span class="token punctuation">,</span> page<span class="token punctuation">,</span> object <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>objects<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>t<span class="token punctuation">)</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>


    available <span class="token operator">+=</span> objects<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>object<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      c<span class="token operator">-&gt;</span>page <span class="token operator">=</span> page<span class="token punctuation">;</span>
      <span class="token function">stat</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> ALLOC_FROM_PARTIAL<span class="token punctuation">)</span><span class="token punctuation">;</span>
      object <span class="token operator">=</span> t<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">put_cpu_partial</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> page<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">stat</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> CPU_PARTIAL_NODE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">kmem_cache_has_cpu_partial</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
      <span class="token operator">||</span> available <span class="token operator">&gt;</span> <span class="token function">slub_cpu_partial</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">return</span> object<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>acquire_slab 会从 kmem_cache_node 的 partial 链表中拿下一大块内存来，并且将 freelist，也就是第一块空闲的缓存块，赋值给 t。并且当第一轮循环的时候，将 kmem_cache_cpu 的 page 指向取下来的这一大块内存，返回的 object 就是这块内存里面的第一个缓存块 t。如果 kmem_cache_cpu 也有一个 partial，就会进行第二轮，再次取下一大块内存来，这次调用 put_cpu_partial，放到 kmem_cache_cpu 的 partial 里面。</p><p>如果 kmem_cache_node 里面也没有空闲的内存，这就说明原来分配的页里面都放满了，就要回到 new_slab_objects 函数，里面 new_slab 函数会调用 allocate_slab。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span><span class="token function">allocate_slab</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token class-name">gfp_t</span> flags<span class="token punctuation">,</span> <span class="token keyword">int</span> node<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">kmem_cache_order_objects</span> oo <span class="token operator">=</span> s<span class="token operator">-&gt;</span>oo<span class="token punctuation">;</span>
  <span class="token class-name">gfp_t</span> alloc_gfp<span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token operator">*</span>start<span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
  <span class="token keyword">int</span> idx<span class="token punctuation">,</span> order<span class="token punctuation">;</span>
  bool shuffle<span class="token punctuation">;</span>


  flags <span class="token operator">&amp;=</span> gfp_allowed_mask<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  page <span class="token operator">=</span> <span class="token function">alloc_slab_page</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> alloc_gfp<span class="token punctuation">,</span> node<span class="token punctuation">,</span> oo<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span>page<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    oo <span class="token operator">=</span> s<span class="token operator">-&gt;</span>min<span class="token punctuation">;</span>
    alloc_gfp <span class="token operator">=</span> flags<span class="token punctuation">;</span>
    <span class="token comment">/*
     * Allocation may have failed due to fragmentation.
     * Try a lower order alloc if possible
     */</span>
    page <span class="token operator">=</span> <span class="token function">alloc_slab_page</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> alloc_gfp<span class="token punctuation">,</span> node<span class="token punctuation">,</span> oo<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span>page<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token keyword">goto</span> out<span class="token punctuation">;</span>
    <span class="token function">stat</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> ORDER_FALLBACK<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">return</span> page<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这里，我们看到了 alloc_slab_page 分配页面。分配的时候，要按 kmem_cache_order_objects 里面的 order 来。如果第一次分配不成功，说明内存已经很紧张了，那就换成 min 版本的 kmem_cache_order_objects。</p><p>好了，这个复杂的层层分配机制，我们就讲到这里，你理解到这里也就够用了。</p><h2 id="页面换出-分配内存时-内核线程kswapd" tabindex="-1"><a class="header-anchor" href="#页面换出-分配内存时-内核线程kswapd" aria-hidden="true">#</a> 页面换出: 分配内存时/内核线程kswapd</h2><p>另一个物理内存管理必须要处理的事情就是，<strong>页面换出</strong>。每个进程都有自己的虚拟地址空间，无论是 32 位还是 64 位，虚拟地址空间都非常大，物理内存不可能有这么多的空间放得下。**所以，一般情况下，<code>页面只有在被使用的时候</code>，才会放在物理内存中。如果过了一段时间不被使用，<code>即便用户进程并没有释放它</code>，物理内存管理也有责任做一定的干预。**例如，将这些物理内存中的页面换出到硬盘上去；将空出的物理内存，交给活跃的进程去使用。</p><p>什么情况下会触发页面换出呢？</p><p>可以想象，最常见的情况就是，分配内存的时候，发现没有地方了，就试图回收一下。例如，咱们解析申请一个页面的时候，会调用 get_page_from_freelist，接下来的调用链为 get_page_from_freelist-&gt;node_reclaim-&gt;__node_reclaim-&gt;shrink_node，通过这个调用链可以看出，<strong>页面换出也是以<code>内存节点</code>为单位的</strong>。</p><p>当然还有一种情况，就是作为内存管理系统应该主动去做的，而不能等真的出了事儿再做，这就是<mark>内核线程 <strong>kswapd</strong></mark>。这个内核线程，在系统初始化的时候就被创建。这样它会进入一个无限循环，直到系统停止。在这个循环中，如果内存使用没有那么紧张，那它就可以放心睡大觉；如果内存紧张了，就需要去检查一下内存，看看是否需要换出一些内存页。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/*
 * The background pageout daemon, started as a kernel thread
 * from the init process.
 *
 * This basically trickles out pages so that we have _some_
 * free memory available even if there is no other activity
 * that frees anything up. This is needed for things like routing
 * etc, where we otherwise might have all activity going on in
 * asynchronous contexts that cannot page things out.
 *
 * If there are applications that are active memory-allocators
 * (most normal use), this basically shouldn&#39;t matter.
 */</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">kswapd</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> alloc_order<span class="token punctuation">,</span> reclaim_order<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> classzone_idx <span class="token operator">=</span> MAX_NR_ZONES <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token class-name">pg_data_t</span> <span class="token operator">*</span>pgdat <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">pg_data_t</span><span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk <span class="token operator">=</span> current<span class="token punctuation">;</span>


    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token function">kswapd_try_to_sleep</span><span class="token punctuation">(</span>pgdat<span class="token punctuation">,</span> alloc_order<span class="token punctuation">,</span> reclaim_order<span class="token punctuation">,</span>
          classzone_idx<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        reclaim_order <span class="token operator">=</span> <span class="token function">balance_pgdat</span><span class="token punctuation">(</span>pgdat<span class="token punctuation">,</span> alloc_order<span class="token punctuation">,</span> classzone_idx<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的调用链是 balance_pgdat-&gt;kswapd_shrink_node-&gt;shrink_node，是以内存节点为单位的，最后也是调用 shrink_node。</p><p>shrink_node 会调用 shrink_node_memcg。这里面有一个循环处理页面的列表，看这个函数的注释，其实和上面我们想表达的内存换出是一样的。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/*
 * This is a basic per-node page freer.  Used by both kswapd and direct reclaim.
 */</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">shrink_node_memcg</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pglist_data</span> <span class="token operator">*</span>pgdat<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">mem_cgroup</span> <span class="token operator">*</span>memcg<span class="token punctuation">,</span>
            <span class="token keyword">struct</span> <span class="token class-name">scan_control</span> <span class="token operator">*</span>sc<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span>lru_pages<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> nr<span class="token punctuation">[</span>NR_LRU_LISTS<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">enum</span> <span class="token class-name">lru_list</span> lru<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>nr<span class="token punctuation">[</span>LRU_INACTIVE_ANON<span class="token punctuation">]</span> <span class="token operator">||</span> nr<span class="token punctuation">[</span>LRU_ACTIVE_FILE<span class="token punctuation">]</span> <span class="token operator">||</span>
          nr<span class="token punctuation">[</span>LRU_INACTIVE_FILE<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> nr_anon<span class="token punctuation">,</span> nr_file<span class="token punctuation">,</span> percentage<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> nr_scanned<span class="token punctuation">;</span>


    <span class="token function">for_each_evictable_lru</span><span class="token punctuation">(</span>lru<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>nr<span class="token punctuation">[</span>lru<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        nr_to_scan <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>nr<span class="token punctuation">[</span>lru<span class="token punctuation">]</span><span class="token punctuation">,</span> SWAP_CLUSTER_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>
        nr<span class="token punctuation">[</span>lru<span class="token punctuation">]</span> <span class="token operator">-=</span> nr_to_scan<span class="token punctuation">;</span>


        nr_reclaimed <span class="token operator">+=</span> <span class="token function">shrink_list</span><span class="token punctuation">(</span>lru<span class="token punctuation">,</span> nr_to_scan<span class="token punctuation">,</span>
                  lruvec<span class="token punctuation">,</span> memcg<span class="token punctuation">,</span> sc<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里面有个 lru 列表。从下面的定义，我们可以想象，所有的页面都被挂在 LRU 列表中。LRU 是 Least Recent Use，也就是最近最少使用。也就是说，这个列表里面会按照活跃程度进行排序，这样就容易把不怎么用的内存页拿出来做处理。</p><h3 id="内存页-匿名页-内存映射" tabindex="-1"><a class="header-anchor" href="#内存页-匿名页-内存映射" aria-hidden="true">#</a> 内存页: 匿名页/内存映射</h3><p>内存页总共分两类，</p><ol><li>一类是<strong>匿名页</strong>，和虚拟地址空间进行关联；</li><li>一类是<strong>内存映射</strong>，不但和虚拟地址空间关联，还和文件管理关联。</li></ol><p>它们每一类都有两个列表，一个是 active，一个是 inactive。顾名思义，active 就是比较活跃的，inactive 就是不怎么活跃的。这两个里面的页会变化，过一段时间，活跃的可能变为不活跃，不活跃的可能变为活跃。如果要换出内存，那就是从不活跃的列表中找出最不活跃的，换出到硬盘上。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">enum</span> <span class="token class-name">lru_list</span> <span class="token punctuation">{</span>
  LRU_INACTIVE_ANON <span class="token operator">=</span> LRU_BASE<span class="token punctuation">,</span>
  LRU_ACTIVE_ANON <span class="token operator">=</span> LRU_BASE <span class="token operator">+</span> LRU_ACTIVE<span class="token punctuation">,</span>
  LRU_INACTIVE_FILE <span class="token operator">=</span> LRU_BASE <span class="token operator">+</span> LRU_FILE<span class="token punctuation">,</span>
  LRU_ACTIVE_FILE <span class="token operator">=</span> LRU_BASE <span class="token operator">+</span> LRU_FILE <span class="token operator">+</span> LRU_ACTIVE<span class="token punctuation">,</span>
  LRU_UNEVICTABLE<span class="token punctuation">,</span>
  NR_LRU_LISTS
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">for_each_evictable_lru</span><span class="token expression"><span class="token punctuation">(</span>lru<span class="token punctuation">)</span> <span class="token keyword">for</span> <span class="token punctuation">(</span>lru <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> lru <span class="token operator">&lt;=</span> LRU_ACTIVE_FILE<span class="token punctuation">;</span> lru<span class="token operator">++</span><span class="token punctuation">)</span></span></span>


<span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">shrink_list</span><span class="token punctuation">(</span><span class="token keyword">enum</span> <span class="token class-name">lru_list</span> lru<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> nr_to_scan<span class="token punctuation">,</span>
         <span class="token keyword">struct</span> <span class="token class-name">lruvec</span> <span class="token operator">*</span>lruvec<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">mem_cgroup</span> <span class="token operator">*</span>memcg<span class="token punctuation">,</span>
         <span class="token keyword">struct</span> <span class="token class-name">scan_control</span> <span class="token operator">*</span>sc<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_active_lru</span><span class="token punctuation">(</span>lru<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">inactive_list_is_low</span><span class="token punctuation">(</span>lruvec<span class="token punctuation">,</span> <span class="token function">is_file_lru</span><span class="token punctuation">(</span>lru<span class="token punctuation">)</span><span class="token punctuation">,</span>
           memcg<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> true<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token function">shrink_active_list</span><span class="token punctuation">(</span>nr_to_scan<span class="token punctuation">,</span> lruvec<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> lru<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>


  <span class="token keyword">return</span> <span class="token function">shrink_inactive_list</span><span class="token punctuation">(</span>nr_to_scan<span class="token punctuation">,</span> lruvec<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> lru<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的代码可以看出，shrink_list 会先缩减活跃页面列表，再压缩不活跃的页面列表。对于不活跃列表的缩减，shrink_inactive_list 就需要对页面进行回收；对于匿名页来讲，需要分配 swap，将内存页写入文件系统；对于内存映射关联了文件的，我们需要将在内存中对于文件的修改写回到文件中。</p><h2 id="总结时刻" tabindex="-1"><a class="header-anchor" href="#总结时刻" aria-hidden="true">#</a> 总结时刻</h2><p>好了，对于物理内存的管理就讲到这里了，我们来总结一下。对于物理内存来讲，从下层到上层的关系及分配模式如下：</p><ul><li>物理内存分 NUMA 节点，分别进行管理；</li><li>每个 NUMA 节点分成多个内存区域；</li><li>每个内存区域分成多个物理页面；</li><li>伙伴系统将多个连续的页面作为一个大的内存块分配给上层；</li><li>kswapd 负责物理页面的换入换出；</li><li>Slub Allocator 将从伙伴系统申请的大内存块切成小块，分配给其他系统。</li></ul><img src="`+r+'" alt="img" style="zoom:25%;"><blockquote><ul><li>小内存分配, 例如分配 task_struct 对象</li><li>会调用 kmem_cache_alloc_node 函数, 从 task_struct 缓存区域 task_struct_cachep(在系统初始化时, 由 kmem_cache_create 创建) 分配一块内存 <ul><li>使用 task_struct 完毕后, 调用 kmem_cache_free 回收到缓存池中</li><li>struct kmem_cache 用于表示缓存区信息, 缓存区即分配连续几个页的大块内存, 再切成小内存</li><li>小内存即缓存区的每一项, 都由对象和指向下一项空闲小内存的指针组成(随机插入/删除+快速查找空闲)</li><li>struct kmem_cache 中三个 kmem_cache_order_objects 表示不同的需要分配的内存块大小的阶数和对象数</li><li>分配缓存的小内存块由两个路径 fast path 和 slow path , 分别对应 struct kmem_cache 中的 kmem_cache_cpu 和 kmem_cache_node</li><li>分配时先从 kmem_cache_cpu 分配, 若其无空闲, 再从 kmem_cache_node 分配, 还没有就从伙伴系统申请新内存块</li><li>struct kmem_cache_cpu 中</li><li>page 指向大内存块的第一个页 <ul><li>freelist 指向大内存块中第一个空闲项</li><li>partial 指向另一个大内存块的第一个页, 但该内存块有部分已分配出去, 当 page 满后, 在 partial 中找</li></ul></li><li>struct kmem_cache_node</li><li>也有 partial, 是一个链表, 存放部分空闲的多个大内存块, 若 kmem_cacche_cpu 中的 partial 也无空闲, 则在这找</li><li>分配过程</li><li>kmem_cache_alloc_node-&gt;slab_alloc_node <ul><li>快速通道, 取出 kmem_cache_cpu 的 freelist , 若有空闲直接返回</li><li>普通通道, 若 freelist 无空闲, 调用 <code>__slab_alloc</code></li><li><code>__slab_alloc</code> 会重新查看 freelist, 若还不满足, 查看 kmem_cache_cpu 的 partial</li><li>若 partial 不为空, 用其替换 page, 并重新检查是否有空闲</li><li>若还是无空闲, 调用 new_slab_objects</li><li>new_slab_objects 根据节点 id 找到对应 kmem_cache_node , 调用 get_partial_node</li><li>首先从 kmem_cache_node 的 partial 链表拿下一大块内存, 替换 kmem_cache_cpu 的 page, 再取一块替换 kmem_cache_cpu 的 partial</li><li>若 kmem_cache_node 也没有空闲, 则在 new_slab_objects 中调用 new_slab-&gt;allocate_slab-&gt;alloc_slab_page 根据某个 kmem_cache_order_objects 设置申请大块内存</li></ul></li></ul></li><li>页面换出</li><li>触发换出: <ul><li><ol><li>分配内存时发现没有空闲; 调用 <code>get_page_from_freelist-&gt;node_reclaim-&gt;__node_reclaim-&gt;shrink_node</code></li></ol></li><li><ol start="2"><li>内存管理主动换出, 由内核线程 kswapd 实现</li></ol></li><li>kswapd 在内存不紧张时休眠, 在内存紧张时检测内存 调用 balance_pgdat-&gt;kswapd_shrink_node-&gt;shrink_node</li><li>页面都挂在 lru 链表中, 页面有两种类型: 匿名页; 文件内存映射页</li><li>每一类有两个列表: active 和 inactive 列表</li><li>要换出时, 从 inactive 列表中找到最不活跃的页换出</li><li>更新列表, shrink_list 先缩减 active 列表, 再缩减不活跃列表</li><li>缩减不活跃列表时对页面进行回收:</li><li>匿名页回收: 分配 swap, 将内存也写入文件系统 <ul><li>文件内存映射页: 将内存中的文件修改写入文件中</li></ul></li></ul></li></ul></blockquote><h2 id="课堂练习" tabindex="-1"><a class="header-anchor" href="#课堂练习" aria-hidden="true">#</a> 课堂练习</h2><p>内存的换入和换出涉及 swap 分区，那你知道如何检查当前 swap 分区情况，如何启用和关闭 swap 区域，如何调整 swappiness 吗？</p><p>欢迎留言和我分享你的疑惑和见解，也欢迎你收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习、进步。</p><h2 id="课后讨论" tabindex="-1"><a class="header-anchor" href="#课后讨论" aria-hidden="true">#</a> 课后讨论</h2><hr><p>作者回复: 如此认真，典范啊</p><p><mark>1.系统在什么情况下才会使用SWAP？</mark><br> 实际上，并不是等所有的物理内存都消耗完毕之后，才去使用swap的空间，什么时候使用是<strong>由 swappiness 参数值控制</strong>。<br> [root@rhce ~]# <code>cat /proc/sys/vm/swappiness</code><br> 60<br> 该值默认值是60.<br> swappiness=0的时候表示最大限度使用物理内存，然后才是 swap空间，<br> swappiness＝100的时候表示积极的使用swap分区，并且把内存上的数据及时的搬运到swap空间里面。<br> 现在服务器的内存动不动就是上百G，所以我们可以把这个参数值设置的低一些，让操作系统尽可能的使用物理内存，降低系统对swap的使用，从而提高系统的性能。</p><p><mark>2.如何修改swappiness参数？</mark><br> --临时性修改：<br> [root@rhce ~]# <code>sysctl vm.swappiness=10</code><br> vm.swappiness = 10<br> [root@rhce ~]# cat /proc/sys/vm/swappiness<br> 10<br> 这里我们的修改已经生效，但是如果我们重启了系统，又会变成60.<br><strong>--永久修改：</strong><br> 在 <code>/etc/sysctl.conf 文件</code>里添加如下参数：**<br> vm.swappiness=10<br> 或者：<br> [root@rhce ~]# <code>echo &#39;vm.swappiness=10&#39; &gt;&gt;/etc/sysctl.conf</code><br> 保存，重启，就生效了。</p><p><mark>3.如何查看swap分区</mark><br><code>swapon -s</code><br><code>cat /proc/swaps</code><br><code>free</code><br><code>vmstat</code><br> 以上4类命令都可以查看swap分区的大小和使用情况</p><hr><p>看到现在，代码越来越多，关于代码的阅读需要么？怎么去做呢<br> 作者回复: <strong>重点关注流程，不关注细节</strong></p>',86),v=n("br",null,null,-1),m={href:"https://www.cnblogs.com/luoahong/p/10907734.html",target:"_blank",rel:"noopener noreferrer"},_=n("br",null,null,-1),b={href:"https://events.static.linuxfound.org/sites/events/files/slides/slaballocators.pdf",target:"_blank",rel:"noopener noreferrer"},g=n("br",null,null,-1),h=n("p",null,[s("真的应该少粘代码 多讲原理、多抽象，不然很难将您讲的东西串联起来，连基本原理都不了解硬生生的讲代码实在是让人困惑"),n("br"),s(" 作者回复: 其实是有一个整体思路的，被代码打断了，可以讲代码总结一个段落大意，然后再穿起来看，是不是好一些")],-1),f={href:"https://mp.weixin.qq.com/s/6JVpke8bDKI9lvh_l6QF-w",target:"_blank",rel:"noopener noreferrer"},w=n("br",null,null,-1),y=p("<p>这个专栏最大的好处就是能将那些专业的厚的书籍的宽泛知识点串起来，能帮助深入理解！！！<br> 网友回复: 精髓</p><p>老师好，这两节讲的是物理内存的管理和分配，大概逻辑是看的懂的，细节需要继续反复研读才行。其中有个问题，kmem_cache部分已经属于页内小内存分配，这个分配算法属于虚拟内存分配，不算物理内存管理范畴吧？ 就是说先分配物理内存页，映射到虚拟内存空间，再在这个虚拟内存分配小内存给程序逻辑使用。希望老师解答一下。<br> 作者回复: 是的，会映射成为虚拟地址，是整页会有虚拟地址</p><p>有了快速通道，为什么还需要普通通道，这一点搞不明白<br> 网友回复: <strong>快速通道是cahe_cpu，比普通通道代价更大</strong></p><p>对于slab分配内存的机制，是不是可以用个流程图来表示会更好一点？还有就是快慢通道的速度差距和具体设计原因能不能说明一下，感谢老师<br> 作者回复: 其实通过里面的图，基本能够理解整个流程。<strong>大概的思想和咱们通过多级缓存加速数据库访问差不多，一级找不到找二级，二级找不到找数据库</strong>。</p><p>老师，slub存在回收机制吧？就是slub中空闲很多的时候，是不是会这些内存块释放，返回给系统呢？<br> 作者回复: <strong>一个内存块的slub全部释放之后，整个页都会回收</strong></p><p>老师，kmem_cache_cpu中的page和partial不是指向同一块内存区域的吧，为什么会这么设计呢？partial的作用是什么呢？<br> 作者回复: <strong>不是同一块的。备用列表，当 page 满了，就会从这里找</strong></p><p>kswapd 在内存紧张的时候，开始工作，那么这个紧张的条件是什么？总的物理内存还是按照 zone 来区分呢？<br> 作者回复: <strong>对每个NUMA结点来说，都有一个单独的kswapd守护进程</strong></p><p>老师，有个疑问，这些内存小块的分配及释放，都是在物理内存中完成的呢，还是在虚拟内存中完成再映射对对应的物理内存呢？<br> 作者回复: <strong>物理内存分配完毕一整页的时候，会通过page_address分配一个虚拟地址，小块都是基于这个虚拟地址的</strong>。</p><p>slab分配器内容很多，这样讲一讲大体框架也不错，要不然就更看不懂了<br> 作者回复: 对的对的，可以讲好久呢</p><p><strong>讲的很好，是看源码特别好的指导文档</strong>。很多人反馈看不懂，主要是这门课不适合，而不是课程不好。对照源码按照老师的独立走一遍就可以熟悉linux内存管理的核心了。</p><p>讲的真好，不然光自己看深入理解linux内核那本书内存管理章节，也无法把流程梳理的那么清楚，老师这两章有图有文有代码，看了两天也能做到理解大体框架和关键结构，再整理笔记时不时复习下，效率很高。</p><p>kmem_cache应该是种高速缓存，用来解决对象频繁分配和释放的问题，其实就是直接把不用的对象在放回链表里，而不是释放对象的内存</p><p>我想知道文中 “对于缓存来讲，其实就是分配了连续几页的大内存块，然后根据缓存对象大小，切成小内存块” 中，小内存块和页大小是怎么个关系？按我的理解小内存块就是task_struct对象大小，一个页中有很多。而kmem_cache_cpu中对于中freelist是大内存块中的项，这个这个项和小内存块或task_struct有个什么关系？是大小一样呢，还是怎个关系？还有最后讲页面换出单位是内存节点，这个节点不可能是整个NUMA节吧，是指啥我没看明白<br> 作者回复: <strong>这里的意思是每个NUMA节点，自己换出自己的，不是将整个NUMA节点都换出</strong></p><p>老师能讲讲大块内存的分配吗<br> 作者回复: <strong>mmap</strong></p><p>麻烦问下，换出不活跃物理页的时候，对于原来进程A是无感知的，A中的页表保存了虚拟地址到物理地址的映射，在A视角看来还是原来大小的内存，但当A需要访问这个不活跃的页时，这个映射关系已经不成立，所以我的问题就是当换出发生的时候，对A的页表是进行了什么特殊处理，望老师答疑下<br> 作者回复: 在页表做了标记，说明已经换出了</p><p>讲得真好，深入到代码层面，否则要是自己研究太困难了，不过也确实需要一定的Linux基础，根据老师的讲解再去看下linux内核的书籍，会提升的更快的<br> 作者回复: <strong>谢谢，这门课主要强调流程，代码是个印证，不适合作为特别严肃的代码分析书籍看，为了突出内核工作机制和流程，删除和省略了很多内核代码</strong></p>",16);function L(A,x){const a=c("ExternalLinkIcon");return o(),l("div",null,[d,n("p",null,[s("花了4个多小时终于把笔记做完分享给大家："),v,n("a",m,[s("https://www.cnblogs.com/luoahong/p/10907734.html"),t(a)]),_,s(" 作者回复: 赞")]),n("p",null,[n("a",b,[s("https://events.static.linuxfound.org/sites/events/files/slides/slaballocators.pdf"),t(a)]),s(" 這裡有清楚的視意圖，對照著看會更清楚！"),g,s(" 作者回复: 赞")]),h,n("p",null,[s("参考文章："),n("a",f,[s("https://mp.weixin.qq.com/s/6JVpke8bDKI9lvh_l6QF-w"),t(a)]),w,s(" 作者回复: 赞")]),y])}const N=e(k,[["render",L],["__file","I24-物理内存管理（下）.html.vue"]]);export{N as default};
