import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as a,d as p}from"./app-cdabc73c.js";const t="/assets/79bfa1d036ebb27yy17ae3edf768ba4c-9bef23dc.jpeg",e="/assets/619c27c6400344db2310fb82ce8d5788-c03c4fed.jpg",o={},c=p(`<h1 id="_08-锁-并发操作中-解决数据同步的四种方法" tabindex="-1"><a class="header-anchor" href="#_08-锁-并发操作中-解决数据同步的四种方法" aria-hidden="true">#</a> 08 | 锁：并发操作中，解决数据同步的四种方法</h1><p>你好，我是 LMOS。</p><p>我们在前面的课程中探索了，开发操作系统要了解的最核心的硬件——CPU、MMU、Cache、内存，知道了它们的工作原理。在程序运行中，它们起到了至关重要的作用。</p><p>在开发我们自己的操作系统以前，还不能一开始就把机器跑起来，而是先要弄清楚数据同步的问题。如果不解决掉数据同步的问题，后面机器跑起来，就会出现很多不可预知的结果。</p><p>通过这节课，我会给你讲清楚为什么在并发操作里，很可能得不到预期的访问数据，还会带你分析这个问题的原因以及解决方法。有了这样一个研究、解决问题的过程，对最重要的几种锁（<strong>原子变量，关中断，信号量，自旋锁</strong>），你就能做到心中有数了。</p><h2 id="非预期结果的全局变量" tabindex="-1"><a class="header-anchor" href="#非预期结果的全局变量" aria-hidden="true">#</a> 非预期结果的全局变量</h2><p>来看看下面的代码，描述的是一个线程中的函数和中断处理函数，它们分别对一个全局变量执行加 1 操作，代码如下。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">interrupt_handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    a<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">thread_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    a<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先我们梳理一下编译器的翻译过程，通常编译器会把 a++ 语句翻译成这 3 条指令。</p><p>\\1. 把 a 加载某个寄存器中。</p><p>\\2. 这个寄存器加 1。</p><p>\\3. 把这个寄存器写回内存。</p><p>那么不难推断，可能导致结果不确定的情况是这样的：thread_func 函数还没运行完第 2 条指令时，中断就来了。</p><p>因此，CPU 转而处理中断，也就是开始运行 interrupt_handle 函数，这个函数运行完 a=1，CPU 还会回去继续运行第 3 条指令，此时 a 依然是 1，这显然是错的。</p><p>下面来看一下表格，你就明白了。</p><img src="`+t+`" alt="img" style="zoom:25%;"><p>显然在 t2 时刻发生了中断，导致了 t2 到 t4 运行了 interrupt_handle 函数，t5 时刻 thread_func 又恢复运行，导致 interrupt_handle 函数中 a 的操作丢失，因此出错。</p><blockquote><p>这篇文章帮助我又从新梳理了一边锁机制，温故知新，又有了新的认识。<br> 认识锁机制（资源竞争和同步）主要抓住2条线：1）保护资源的大小；2）CPU数<br> 从保护资源的大小由大到小排列：<br> 1.单变量资源（例如整型变量），可使用原子变量, CPU核数不影响。<br> 2.超过单变量数目的少量资源，此时操作数很多，寄存器就容不下了。<br> 1）对于单核CPU，因为单核CPU的任务调度也是通过中断发起的，在加上对普通中断函数的处理，直接关中断即可。<br> 2）对于多核CPU，引入自旋锁，同时要注意为了防止当前CPU中断嵌套拿锁造成死锁的情况，自旋锁需要关闭本地CPU中断。<br> 3.对于需要长时间等待处理完成的资源，为了避免忙等造成CPU资源的浪费，需要设计出一套既能安全的竞争又能尽可能释放CPU能力的机制，这就是信号量了。<br> 1）包含等待、互斥和唤醒等操作，当拿不到信号量时CPU可以做其他事情；<br> 2）信号量的操作同样需要用自旋锁（关中断）保证排他性；<br> 3）单核和多核CPU都适用。<br> 以上，谢谢。</p></blockquote><h2 id="方法一-原子操作-原生变量-简单资源" tabindex="-1"><a class="header-anchor" href="#方法一-原子操作-原生变量-简单资源" aria-hidden="true">#</a> 方法一：原子操作 原生变量/简单资源</h2><p>要解决上述场景中的问题，有这样两种思路。</p><ol><li><p>一种是<strong>把 a++ 变成原子操作</strong>，这里的原子是不可分隔的，也就是说要 a++ 这个操作不可分隔，即 a++ 要么不执行，要么一口气执行完；</p></li><li><p>另一种就是<strong>控制中断</strong>，比如在执行 a++ 之前<code>关掉中断</code>，执行完了之后<code>打开中断</code>。</p></li></ol><p>我们先来看看原子操作，显然靠编译器自动生成原子操作不太可能。</p><ul><li>第一，编译器没有这么智能，能检测哪个变量需要原子操作；</li><li>第二，编译器必须要考虑代码的移植性，例如有些硬件平台支持原子操作的机器指令，有的硬件平台不支持原子操作。</li></ul><p>既然实现原子操作无法依赖于具体编译器，那就需要我们自己动手，x86 平台支持很多原子指令，我们只需要直接应用这些指令，比如原子加、原子减，原子读写等，用汇编代码写出对应的原子操作函数就行了。</p><p>好在现代 <strong>C 语言</strong>已经支持嵌入汇编代码，可以<strong>在 C 函数中按照特定的方式嵌入汇编代码</strong>了，实现原子操作就更方便了，代码如下。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//定义一个原子类型</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">s_ATOMIC</span><span class="token punctuation">{</span>
    <span class="token keyword">volatile</span> <span class="token class-name">s32_t</span> a_count<span class="token punctuation">;</span> <span class="token comment">//在变量前加上volatile，是为了禁止编译器优化，使其每次都从内存中加载变量</span>
<span class="token punctuation">}</span><span class="token class-name">atomic_t</span><span class="token punctuation">;</span>
<span class="token comment">//原子读</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token class-name">s32_t</span> <span class="token function">atomic_read</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">atomic_t</span> <span class="token operator">*</span>v<span class="token punctuation">)</span>
<span class="token punctuation">{</span>        
        <span class="token comment">//x86平台取地址处是原子</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token class-name">u32_t</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token operator">-&gt;</span>a_count<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//原子写</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">atomic_write</span><span class="token punctuation">(</span><span class="token class-name">atomic_t</span> <span class="token operator">*</span>v<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        <span class="token comment">//x86平台把一个值写入一个地址处也是原子的 </span>
        v<span class="token operator">-&gt;</span>a_count <span class="token operator">=</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//原子加上一个整数</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">atomic_add</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token class-name">atomic_t</span> <span class="token operator">*</span>v<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        __asm__ <span class="token function">__volatile__</span><span class="token punctuation">(</span><span class="token string">&quot;lock;&quot;</span> <span class="token string">&quot;addl %1,%0&quot;</span>
                     <span class="token operator">:</span> <span class="token string">&quot;+m&quot;</span> <span class="token punctuation">(</span>v<span class="token operator">-&gt;</span>a_count<span class="token punctuation">)</span>
                     <span class="token operator">:</span> <span class="token string">&quot;ir&quot;</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//原子减去一个整数</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">atomic_sub</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token class-name">atomic_t</span> <span class="token operator">*</span>v<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        __asm__ <span class="token function">__volatile__</span><span class="token punctuation">(</span><span class="token string">&quot;lock;&quot;</span> <span class="token string">&quot;subl %1,%0&quot;</span>
                     <span class="token operator">:</span> <span class="token string">&quot;+m&quot;</span> <span class="token punctuation">(</span>v<span class="token operator">-&gt;</span>a_count<span class="token punctuation">)</span>
                     <span class="token operator">:</span> <span class="token string">&quot;ir&quot;</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//原子加1</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">atomic_inc</span><span class="token punctuation">(</span><span class="token class-name">atomic_t</span> <span class="token operator">*</span>v<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        __asm__ <span class="token function">__volatile__</span><span class="token punctuation">(</span><span class="token string">&quot;lock;&quot;</span> <span class="token string">&quot;incl %0&quot;</span>
                       <span class="token operator">:</span> <span class="token string">&quot;+m&quot;</span> <span class="token punctuation">(</span>v<span class="token operator">-&gt;</span>a_count<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//原子减1</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">atomic_dec</span><span class="token punctuation">(</span><span class="token class-name">atomic_t</span> <span class="token operator">*</span>v<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
       __asm__ <span class="token function">__volatile__</span><span class="token punctuation">(</span><span class="token string">&quot;lock;&quot;</span> <span class="token string">&quot;decl %0&quot;</span>
                     <span class="token operator">:</span> <span class="token string">&quot;+m&quot;</span> <span class="token punctuation">(</span>v<span class="token operator">-&gt;</span>a_count<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>以上代码中，加上 lock 前缀的 addl、subl、incl、decl 指令都是原子操作，lock 前缀表示锁定总线</strong>。</p><p>我们还是来看看 GCC 支持嵌入汇编代码的模板，不同于其它 C 编译器支持嵌入汇编代码的方式，为了优化用户代码，GCC 设计了一种特有的嵌入方式，它规定了汇编代码嵌入的形式和嵌入汇编代码需要由哪几个部分组成，如下面代码所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>__asm__ <span class="token function">__volatile__</span><span class="token punctuation">(</span>代码部分<span class="token operator">:</span>输出部分列表<span class="token operator">:</span> 输入部分列表<span class="token operator">:</span>损坏部分列表<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可以看到代码模板从 <strong>asm</strong> 开始（当然也可以是 asm），紧跟着 <strong>volatile</strong>，然后是跟着一对括号，最后以分号结束。括号里大致分为 4 个部分：</p><p>\\1. 汇编代码部分，这里是实际嵌入的汇编代码。</p><p>\\2. 输出列表部分，让 GCC 能够处理 C 语言左值表达式与汇编代码的结合。</p><p>\\3. 输入列表部分，也是让 GCC 能够处理 C 语言表达式、变量、常量，让它们能够输入到汇编代码中去。</p><p>\\4. 损坏列表部分，告诉 GCC 汇编代码中用到了哪些寄存器，以便 GCC 在汇编代码运行前，生成保存它们的代码，并且在生成的汇编代码运行后，恢复它们（寄存器）的代码。</p><p>它们之间用冒号隔开，如果只有汇编代码部分，后面的冒号可以省略。但是有输入列表部分而没有输出列表部分的时候，输出列表部分的冒号就必须要写，否则 GCC 没办法判断，同样的道理对于其它部分也一样。</p><p>这里不会过多展开讲这个技术，详情可参阅GCC 手册。你可以重点看 GAS 相关的章节。</p><p>下面将用上面一个函数 atomic_add 为例子说一下，如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">atomic_add</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token class-name">atomic_t</span> <span class="token operator">*</span>v<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        __asm__ <span class="token function">__volatile__</span><span class="token punctuation">(</span><span class="token string">&quot;lock;&quot;</span> <span class="token string">&quot;addl %1,%0&quot;</span>
                     <span class="token operator">:</span> <span class="token string">&quot;+m&quot;</span> <span class="token punctuation">(</span>v<span class="token operator">-&gt;</span>a_count<span class="token punctuation">)</span>
                     <span class="token operator">:</span> <span class="token string">&quot;ir&quot;</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//&quot;lock;&quot; &quot;addl %1,%0&quot; 是汇编指令部分，%1,%0是占位符，它表示输出、输入列表中变量或表态式，占位符的数字从输出部分开始依次增加，这些变量或者表态式会被GCC处理成寄存器、内存、立即数放在指令中。 </span>
<span class="token comment">//: &quot;+m&quot; (v-&gt;a_count) 是输出列表部分，“+m”表示(v-&gt;a_count)和内存地址关联</span>
<span class="token comment">//: &quot;ir&quot; (i) 是输入列表部分，“ir” 表示i是和立即数或者寄存器关联</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有了这些原子操作函数之后 ，前面场景中的代码就变成下面这样了：无论有没有中断，或者什么时间来中断，都不会出错。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token class-name">atomic_t</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">interrupt_handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">atomic_inc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">thread_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">atomic_inc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>好，说完了原子操作，我们再看看怎么用中断控制的思路解决数据并发访问的问题。</p><h2 id="方法二-中断控制-复杂数据结构-单cpu" tabindex="-1"><a class="header-anchor" href="#方法二-中断控制-复杂数据结构-单cpu" aria-hidden="true">#</a> 方法二：中断控制 复杂数据结构（单CPU）</h2><p>中断是 CPU 响应外部事件的重要机制，时钟、键盘、硬盘等 IO 设备都是通过发出中断来请求 CPU 执行相关操作的（即执行相应的中断处理代码），比如下一个时钟到来、用户按下了键盘上的某个按键、硬盘已经准备好了数据。</p><p>但是中断处理代码中如果操作了其它代码的数据，这就需要相应的控制机制了，这样才能保证在操作数据过程中不发生中断。</p><p>你或许在想，可以用原子操作啊？不过，<strong>原子操作只适合于单体变量</strong>，如整数。操作系统的数据结构有的可能有几百字节大小，其中可能包含多种不同的基本数据类型。这显然用原子操作无法解决。</p><p>下面，我们就要写代码实现<code>关闭开启</code>中断了，x86 CPU 上关闭、开启中断有专门的指令，即 cli、sti 指令，它们主要是对 CPU 的 eflags 寄存器的 <strong>IF 位</strong>（第 9 位）进行清除和设置，CPU 正是通过此位来决定是否响应中断信号。这两条指令只能 Ring0 权限才能执行，代码如下。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//关闭中断</span>
<span class="token keyword">void</span> <span class="token function">hal_cli</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    __asm__ <span class="token function">__volatile__</span><span class="token punctuation">(</span><span class="token string">&quot;cli&quot;</span><span class="token operator">:</span> <span class="token operator">:</span> <span class="token operator">:</span><span class="token string">&quot;memory&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//开启中断</span>
<span class="token keyword">void</span> <span class="token function">hal_sti</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    __asm__ <span class="token function">__volatile__</span><span class="token punctuation">(</span><span class="token string">&quot;sti&quot;</span><span class="token operator">:</span> <span class="token operator">:</span> <span class="token operator">:</span><span class="token string">&quot;memory&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//使用场景</span>
<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">hal_cli</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//操作数据……</span>
    <span class="token function">hal_sti</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">hal_cli</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//操作数据……</span>
    <span class="token function">hal_sti</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你可以自己思考一下，前面这段代码效果如何？</p><p>它看似完美地解决了问题，其实有重大缺陷，hal_cli()，hal_sti()，<strong>无法嵌套使用</strong>，看一个例子你就明白了，代码如下。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">hal_cli</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//操作数据第一步……</span>
    <span class="token function">hal_sti</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">hal_cli</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//操作数据第二步……</span>
    <span class="token function">hal_sti</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码的关键问题在 bar 函数在关中断下调用了 foo 函数，foo 函数中先关掉中断，处理好数据然后开启中断，回到 bar 函数中，bar 函数还天真地以为中断是关闭的，接着处理数据，以为不会被中断抢占。</p><p>那么怎么解决上面的问题呢？我们只要修改一下开启、关闭中断的函数就行了。</p><p>我们可以这样操作：在关闭中断函数中先保存 eflags 寄存器，然后执行 cli 指令，在开启中断函数中直接恢复之前保存的 eflags 寄存器就行了，具体代码如下。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token class-name">u32_t</span> <span class="token class-name">cpuflg_t</span><span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">hal_save_flags_cli</span><span class="token punctuation">(</span><span class="token class-name">cpuflg_t</span><span class="token operator">*</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
     __asm__ <span class="token function">__volatile__</span><span class="token punctuation">(</span>
            <span class="token string">&quot;pushfl \\t\\n&quot;</span> <span class="token comment">//把eflags寄存器压入当前栈顶</span>
            <span class="token string">&quot;cli    \\t\\n&quot;</span> <span class="token comment">//关闭中断</span>
            <span class="token string">&quot;popl %0 \\t\\n&quot;</span><span class="token comment">//把当前栈顶弹出到flags为地址的内存中        </span>
            <span class="token operator">:</span> <span class="token string">&quot;=m&quot;</span><span class="token punctuation">(</span><span class="token operator">*</span>flags<span class="token punctuation">)</span>
            <span class="token operator">:</span>
            <span class="token operator">:</span> <span class="token string">&quot;memory&quot;</span>
          <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">hal_restore_flags_sti</span><span class="token punctuation">(</span><span class="token class-name">cpuflg_t</span><span class="token operator">*</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    __asm__ <span class="token function">__volatile__</span><span class="token punctuation">(</span>
              <span class="token string">&quot;pushl %0 \\t\\n&quot;</span><span class="token comment">//把flags为地址处的值寄存器压入当前栈顶</span>
              <span class="token string">&quot;popfl \\t\\n&quot;</span>   <span class="token comment">//把当前栈顶弹出到eflags寄存器中</span>
              <span class="token operator">:</span>
              <span class="token operator">:</span> <span class="token string">&quot;m&quot;</span><span class="token punctuation">(</span><span class="token operator">*</span>flags<span class="token punctuation">)</span>
              <span class="token operator">:</span> <span class="token string">&quot;memory&quot;</span>
              <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的代码中不难发现，硬件工程师早就想到了如何解决在嵌套函数中关闭、开启中断的问题：pushfl 指令把 eflags 寄存器压入当前栈顶，popfl 把当前栈顶的数据弹出到 eflags 寄存器中。</p><p>hal_restore_flags_sti() 函数的执行，是否开启中断完全取决于上一次 eflags 寄存器中的值，并且 popfl 指令只会影响 eflags 寄存器中的 IF 位。<strong>这样，无论函数嵌套调用多少层都没有问题</strong>。</p><h2 id="方法三-自旋锁-协调多核心-cpu" tabindex="-1"><a class="header-anchor" href="#方法三-自旋锁-协调多核心-cpu" aria-hidden="true">#</a> 方法三：自旋锁 协调多核心 CPU</h2><p>前面说的控制中断，看似解决了问题，那是因为以前是<strong>单 CPU</strong>，同一时刻只有一条代码执行流，除了中断会中止当前代码执行流，转而运行另一条代码执行流（中断处理程序），再无其它代码执行流。这种情况下只要控制了中断，就能安全地操作全局数据。</p><p>但是我们都知道，现在情况发生了改变，CPU 变成了多核心，或者主板上安装了多颗 CPU，同一时刻下系统中存在多条代码执行流，<strong>控制中断只能控制本地 CPU 的中断，无法控制其它 CPU 核心的中断</strong>。</p><p>所以，原先通过控制中断来维护全局数据安全的方案失效了，这就需要全新的机制来处理这样的情况，于是就轮到自旋锁登场了。</p><p>我们先看看自旋锁的原理，它是这样的：首先读取锁变量，判断其值是否已经加锁，如果未加锁则执行加锁，然后返回，表示加锁成功；如果已经加锁了，就要返回第一步继续执行后续步骤，因而得名自旋锁。为了让你更好理解，下面来画一个图描述这个算法。</p><img src="`+e+`" alt="img" style="zoom:15%;"><p>自旋锁原理示意图</p><p>这个算法看似很好，但是想要正确执行它，就**必须保证读取锁变量和判断并加锁的操作是原子执行的。**否则，CPU0 在读取了锁变量之后，CPU1 读取锁变量判断未加锁执行加锁，然后 CPU0 也判断未加锁执行加锁，这时就会发现两个 CPU 都加锁成功，因此这个算法出错了。</p><p>怎么解决这个问题呢？这就要找硬件要解决方案了，x86 CPU 给我们提供了一个原子交换指令，xchg，它可以让寄存器里的一个值跟内存空间中的一个值做交换。例如，让 eax=memlock，memlock=eax 这个动作是原子的，不受其它 CPU 干扰。</p><p>下面我们就去实现自旋锁，代码如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//自旋锁结构</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">{</span>
     <span class="token keyword">volatile</span> <span class="token class-name">u32_t</span> lock<span class="token punctuation">;</span><span class="token comment">//volatile可以防止编译器优化，保证其它代码始终从内存加载lock变量的值 </span>
<span class="token punctuation">}</span> <span class="token class-name">spinlock_t</span><span class="token punctuation">;</span>
<span class="token comment">//锁初始化函数</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">x86_spin_lock_init</span><span class="token punctuation">(</span><span class="token class-name">spinlock_t</span> <span class="token operator">*</span> lock<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
     lock<span class="token operator">-&gt;</span>lock <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//锁值初始化为0是未加锁状态</span>
<span class="token punctuation">}</span>
<span class="token comment">//加锁函数</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">x86_spin_lock</span><span class="token punctuation">(</span><span class="token class-name">spinlock_t</span> <span class="token operator">*</span> lock<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    __asm__ <span class="token function">__volatile__</span> <span class="token punctuation">(</span>
    <span class="token string">&quot;1: \\n&quot;</span>
    <span class="token string">&quot;lock; xchg  %0, %1 \\n&quot;</span><span class="token comment">//把值为1的寄存器和lock内存中的值进行交换</span>
    <span class="token string">&quot;cmpl   $0, %0 \\n&quot;</span> <span class="token comment">//用0和交换回来的值进行比较</span>
    <span class="token string">&quot;jnz    2f \\n&quot;</span>  <span class="token comment">//不等于0则跳转后面2标号处运行</span>
    <span class="token string">&quot;jmp 3f \\n&quot;</span>     <span class="token comment">//若等于0则跳转后面3标号处返回</span>
    <span class="token string">&quot;2:         \\n&quot;</span> 
    <span class="token string">&quot;cmpl   $0, %1  \\n&quot;</span><span class="token comment">//用0和lock内存中的值进行比较</span>
    <span class="token string">&quot;jne    2b      \\n&quot;</span><span class="token comment">//若不等于0则跳转到前面2标号处运行继续比较  </span>
    <span class="token string">&quot;jmp    1b      \\n&quot;</span><span class="token comment">//若等于0则跳转到前面1标号处运行，交换并加锁</span>
    <span class="token string">&quot;3:  \\n&quot;</span>     <span class="token operator">:</span>
    <span class="token operator">:</span> <span class="token string">&quot;r&quot;</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;m&quot;</span><span class="token punctuation">(</span><span class="token operator">*</span>lock<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//解锁函数</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">x86_spin_unlock</span><span class="token punctuation">(</span><span class="token class-name">spinlock_t</span> <span class="token operator">*</span> lock<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    __asm__ <span class="token function">__volatile__</span><span class="token punctuation">(</span>
    <span class="token string">&quot;movl   $0, %0\\n&quot;</span><span class="token comment">//解锁把lock内存中的值设为0就行</span>
    <span class="token operator">:</span>
    <span class="token operator">:</span> <span class="token string">&quot;m&quot;</span><span class="token punctuation">(</span><span class="token operator">*</span>lock<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码的中注释已经很清楚了，关键点在于 xchg 指令，xchg %0, %1 。</p><p>其中，%0 对应 “r”(1)，表示由编译器自动分配一个通用寄存器，并填入值 1，例如 mov eax，1。而 %1 对应&quot;m&quot;(*lock)，表示 lock 是内存地址。把 1 和内存中的值进行交换，若内存中是 1，则不会影响；因为本身写入就是 1，若内存中是 0，一交换，内存中就变成了 1，即加锁成功。</p><p>自旋锁依然有中断嵌套的问题，也就是说，在使用自旋锁的时候我们仍然要注意中断。</p><p>在中断处理程序访问某个自旋锁保护的某个资源时，依然有问题，（你可以想象一下 一 cpu上的运行程序 获取了自旋锁 没有释放自旋锁 中断发生了，中断处理程序 也要获取 自旋锁 会是什么情况）所以我们要写的自旋锁函数必须适应这样的中断环境，也就是说，它需要在处理中断的过程中也能使用，如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">x86_spin_lock_disable_irq</span><span class="token punctuation">(</span><span class="token class-name">spinlock_t</span> <span class="token operator">*</span> lock<span class="token punctuation">,</span><span class="token class-name">cpuflg_t</span><span class="token operator">*</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    __asm__ <span class="token function">__volatile__</span><span class="token punctuation">(</span>
    <span class="token string">&quot;pushfq                 \\n\\t&quot;</span>
    <span class="token string">&quot;cli                    \\n\\t&quot;</span>
    <span class="token string">&quot;popq %0                \\n\\t&quot;</span>
    <span class="token string">&quot;1:         \\n\\t&quot;</span>
    <span class="token string">&quot;lock; xchg  %1, %2 \\n\\t&quot;</span>
    <span class="token string">&quot;cmpl   $0,%1       \\n\\t&quot;</span>
    <span class="token string">&quot;jnz    2f      \\n\\t&quot;</span>
    <span class="token string">&quot;jmp    3f      \\n&quot;</span>  
    <span class="token string">&quot;2:         \\n\\t&quot;</span>
    <span class="token string">&quot;cmpl   $0,%2       \\n\\t&quot;</span> 
    <span class="token string">&quot;jne    2b      \\n\\t&quot;</span>
    <span class="token string">&quot;jmp    1b      \\n\\t&quot;</span>
    <span class="token string">&quot;3:     \\n&quot;</span>     
     <span class="token operator">:</span><span class="token string">&quot;=m&quot;</span><span class="token punctuation">(</span><span class="token operator">*</span>flags<span class="token punctuation">)</span>
    <span class="token operator">:</span> <span class="token string">&quot;r&quot;</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;m&quot;</span><span class="token punctuation">(</span><span class="token operator">*</span>lock<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">x86_spin_unlock_enabled_irq</span><span class="token punctuation">(</span><span class="token class-name">spinlock_t</span><span class="token operator">*</span> lock<span class="token punctuation">,</span><span class="token class-name">cpuflg_t</span><span class="token operator">*</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    __asm__ <span class="token function">__volatile__</span><span class="token punctuation">(</span>
    <span class="token string">&quot;movl   $0, %0\\n\\t&quot;</span>
    <span class="token string">&quot;pushq %1 \\n\\t&quot;</span>
    <span class="token string">&quot;popfq \\n\\t&quot;</span>
    <span class="token operator">:</span>
    <span class="token operator">:</span> <span class="token string">&quot;m&quot;</span><span class="token punctuation">(</span><span class="token operator">*</span>lock<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;m&quot;</span><span class="token punctuation">(</span><span class="token operator">*</span>flags<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上代码实现了关中断下获取自旋锁，以及恢复中断状态释放自旋锁。在中断环境下也完美地解决了问题。</p><h2 id="方法四-信号量-cpu-时间管理大师" tabindex="-1"><a class="header-anchor" href="#方法四-信号量-cpu-时间管理大师" aria-hidden="true">#</a> 方法四：信号量 CPU 时间管理大师</h2><blockquote><p>请问彭老师，信号量实现用的是自旋锁而不是原子变量，是不是因为原子变量在多CPU，多线程的环境下还是存在并发问题？毕竟每个CPU有自己的缓存，原子操作并不能保证CPU缓存之间的同步，原子操作并没有涉及MESI协议？<br> 作者回复: 是的，信号量本身会被多个cpu并行访问，所以它自己也受保护。<br> 信号量有两种，一种是互斥信号量 一种是计数信号量，我的代码是防止小于0，因为我的信号量值类型是无符号类型，实现方式不同。</p></blockquote><p>无论是原子操作，还是自旋锁，<strong>都不适合长时间等待的情况</strong>，因为有很多资源（数据）它有一定的时间性，你想去获取它，CPU 并不能立即返回给你，而是要等待一段时间，才能把数据返回给你。这种情况，你用自旋锁来同步访问这种资源，你会发现这是对 CPU 时间的巨大浪费。</p><p>下面我们看看另一种同步机制，既能对资源数据进行保护（同一时刻只有一个代码执行流访问），又能在资源无法满足的情况下，让 CPU 可以执行其它任务。</p><p>如果你翻过操作系统的理论书，应该对信号量这个词并不陌生。信号量是 1965 年荷兰学者 Edsger Dijkstra 提出的，是一种用于资源互斥或者进程间同步的机制。这里我们就来看看如何实现这一机制。</p><p>你不妨想象这样一个情境：微信等待你从键盘上的输入信息，然后把这个信息发送出去。</p><p>这个功能我们怎么实现呢？下面我们就来说说实现它的一般方法，当然具体实现中可能不同，但是原理是相通的，具体如下。</p><p>\\1. <strong>一块内存，相当于缓冲区</strong>，用于保存键盘的按键码。</p><p>\\2. <strong>需要一套控制机制</strong>，比如微信读取这个缓冲区，而该缓冲区为空时怎么处理；该缓冲区中有了按键码，却没有代码执行流来读取，又该怎么处理。</p><p>我们期望是这样的，一共有三点。</p><p>\\1. 当微信获取键盘输入信息时，发现键盘缓冲区中是空的，就进入等待状态。</p><p>\\2. 同一时刻，只能有一个代码执行流操作键盘缓冲区。</p><p>\\3. 当用户按下键盘时，我们有能力把按键码写入缓冲区中，并且能看一看微信或者其它程序是否在等待该缓冲区，如果是就重新激活微信和其它的程序，让它们重新竞争读取键盘缓冲区，如果竞争失败依然进入等待状态。</p><p>其实以上所述无非是三个问题：<strong>等待、互斥、唤醒（即重新激活等待的代码执行流）。</strong></p><p>这就需要一种全新的数据结构来解决这些问题。根据上面的问题，这个数据结构至少需要一个变量来表示互斥，比如大于 0 则代码执行流可以继续运行，等于 0 则让代码执行流进入等待状态。还需要一个等待链，用于保存等待的代码执行流。</p><p>这个数据结构的实现代码如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SEM_FLG_MUTEX</span> <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SEM_FLG_MULTI</span> <span class="token expression"><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SEM_MUTEX_ONE_LOCK</span> <span class="token expression"><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SEM_MULTI_LOCK</span> <span class="token expression"><span class="token number">0</span></span></span>
<span class="token comment">//等待链数据结构，用于挂载等待代码执行流（线程）的结构，里面有用于挂载代码执行流的链表和计数器变量，这里我们先不深入研究这个数据结构。</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">s_KWLST</span>
<span class="token punctuation">{</span>   
    <span class="token class-name">spinlock_t</span> wl_lock<span class="token punctuation">;</span>
    <span class="token class-name">uint_t</span>   wl_tdnr<span class="token punctuation">;</span>
    <span class="token class-name">list_h_t</span> wl_list<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token class-name">kwlst_t</span><span class="token punctuation">;</span>
<span class="token comment">//信号量数据结构</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">s_SEM</span>
<span class="token punctuation">{</span>
    <span class="token class-name">spinlock_t</span> sem_lock<span class="token punctuation">;</span><span class="token comment">//维护sem_t自身数据的自旋锁</span>
    <span class="token class-name">uint_t</span> sem_flg<span class="token punctuation">;</span><span class="token comment">//信号量相关的标志</span>
    <span class="token class-name">sint_t</span> sem_count<span class="token punctuation">;</span><span class="token comment">//信号量计数值</span>
    <span class="token class-name">kwlst_t</span> sem_waitlst<span class="token punctuation">;</span><span class="token comment">//用于挂载等待代码执行流（线程）结构</span>
<span class="token punctuation">}</span><span class="token class-name">sem_t</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>搞懂了信号量的结构，我们再来看看信号量的一般用法，注意信号量在使用之前需要<strong>先进行初始化</strong>。这里假定信号量数据结构中的 sem_count 初始化为 1，sem_waitlst 等待链初始化为空。</p><p>使用信号量的步骤，我已经给你列好了。</p><p><strong>第一步，获取信号量。</strong></p><p>\\1. 首先对用于保护信号量自身的自旋锁 sem_lock 进行加锁。</p><p>\\2. 对信号值 sem_count 执行“减 1”操作，并检查其值是否小于 0。</p><p>\\3. 上步中检查 sem_count 如果小于 0，就让进程进入等待状态并且将其挂入 sem_waitlst 中，然后调度其它进程运行。否则表示获取信号量成功。当然最后别忘了对自旋锁 sem_lock 进行解锁。</p><p><strong>第二步，代码执行流开始执行相关操作，例如读取键盘缓冲区。</strong></p><p><strong>第三步，释放信号量。</strong></p><p>\\1. 首先对用于保护信号量自身的自旋锁 sem_lock 进行加锁。</p><p>\\2. 对信号值 sem_count 执行“加 1”操作，并检查其值是否大于 0。</p><p>\\3. 上步中检查 sem_count 值如果大于 0，就执行唤醒 sem_waitlst 中进程的操作，并且需要调度进程时就执行进程调度操作，不管 sem_count 是否大于 0（通常会大于 0）都标记信号量释放成功。当然最后别忘了对自旋锁 sem_lock 进行解锁。</p><p>这里我给你额外分享一个小技巧，<strong><code>写代码之前</code>我们常常需要<code>先想清楚算法步骤</code>，建议你像我这样<code>分条列出</code>，因为串联很容易含糊其辞，不利于后面顺畅编码。</strong></p><p>好，下面我们来看看实现上述这些功能的代码，按照理论书籍上说，信号量有两个操作：down，up，代码如下。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//获取信号量</span>
<span class="token keyword">void</span> <span class="token function">krlsem_down</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span><span class="token operator">*</span> sem<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">cpuflg_t</span> cpufg<span class="token punctuation">;</span>
start_step<span class="token operator">:</span>    
    <span class="token function">krlspinlock_cli</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-&gt;</span>sem_lock<span class="token punctuation">,</span><span class="token operator">&amp;</span>cpufg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>sem<span class="token operator">-&gt;</span>sem_count<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span><span class="token comment">//如果信号量值小于1,则让代码执行流（线程）睡眠</span>
        <span class="token function">krlwlst_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-&gt;</span>sem_waitlst<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">krlspinunlock_sti</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-&gt;</span>sem_lock<span class="token punctuation">,</span><span class="token operator">&amp;</span>cpufg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">krlschedul</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//切换代码执行流，下次恢复执行时依然从下一行开始执行，所以要goto开始处重新获取信号量</span>
        <span class="token keyword">goto</span> start_step<span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
    sem<span class="token operator">-&gt;</span>sem_count<span class="token operator">--</span><span class="token punctuation">;</span><span class="token comment">//信号量值减1,表示成功获取信号量</span>
    <span class="token function">krlspinunlock_sti</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-&gt;</span>sem_lock<span class="token punctuation">,</span><span class="token operator">&amp;</span>cpufg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//释放信号量</span>
<span class="token keyword">void</span> <span class="token function">krlsem_up</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span><span class="token operator">*</span> sem<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">cpuflg_t</span> cpufg<span class="token punctuation">;</span>
    <span class="token function">krlspinlock_cli</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-&gt;</span>sem_lock<span class="token punctuation">,</span><span class="token operator">&amp;</span>cpufg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    sem<span class="token operator">-&gt;</span>sem_count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//释放信号量</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>sem<span class="token operator">-&gt;</span>sem_count<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span><span class="token comment">//如果小于1,则说数据结构出错了，挂起系统</span>
        <span class="token function">krlspinunlock_sti</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-&gt;</span>sem_lock<span class="token punctuation">,</span><span class="token operator">&amp;</span>cpufg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">hal_sysdie</span><span class="token punctuation">(</span><span class="token string">&quot;sem up err&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//唤醒该信号量上所有等待的代码执行流（线程）</span>
    <span class="token function">krlwlst_allup</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-&gt;</span>sem_waitlst<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">krlspinunlock_sti</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-&gt;</span>sem_lock<span class="token punctuation">,</span><span class="token operator">&amp;</span>cpufg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">krlsched_set_schedflgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中的 krlspinlock_cli，krlspinunlock_sti 两个函数，只是对前面自旋锁函数的一个<strong>封装</strong>，krlschedul、krlwlst_wait、krlwlst_allup、krlsched_set_schedflgs 这几个函数会在进程相关课程进行探讨。</p><h2 id="重点回顾" tabindex="-1"><a class="header-anchor" href="#重点回顾" aria-hidden="true">#</a> 重点回顾</h2><p>又到了这节课结束的时候，我们回顾一下今天都讲了什么。我把这节课的内容为你梳理一下，要点如下。</p><p>\\1. 原子变量，在只有<strong>单个变量全局数据</strong>的情况下，这种变量非常实用，如全局计数器、状态标志变量等。我们利用了 CPU 的原子指令实现了一组操作原子变量的函数。</p><p>\\2. 中断的控制。当要操作的数据很多的情况下，用原子变量就不适合了。但是我们发现在<strong>单核心的 CPU</strong>，同一时刻只有一个代码执行流，除了响应中断导致代码执行流切换，不会有其它条件会干扰全局数据的操作，所以我们只要在操作全局数据时关闭或者开启中断就行了，为此我们开发了控制中断的函数。</p><p>\\3. 自旋锁。由于<strong>多核心的 CPU</strong> 出现，控制中断已经失效了，因为<strong>系统中同时有多个代码执行流</strong>，为了解决这个问题，我们开发了自旋锁，自旋锁要么一下子获取锁，要么循环等待最终获取锁。</p><p>\\4. 信号量。如果长时间等待后才能获取数据，在这样的情况下，前面中断控制和自旋锁都不能很好地解决，于是我们开发了信号量。信号量由一套数据结构和函数组成，它能使获取数据的代码执行流进入睡眠，然后在相关条件满足时被唤醒，这样就能让 CPU 能有时间处理其它任务。所以信号量同时解决了三个问题：<strong>等待、互斥、唤醒。</strong></p><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题" aria-hidden="true">#</a> 思考题</h2><p>请用代码展示一下自旋锁或者信号量，可能的使用形式是什么样的？</p><p>期待你在留言区的分享，也欢迎你把这节课的内容分享给身边的朋友，跟他一起学习交流。</p><p>我是 LMOS，我们下节课见！</p><h2 id="【】课后讨论" tabindex="-1"><a class="header-anchor" href="#【】课后讨论" aria-hidden="true">#</a> 【】课后讨论</h2><p>今天的专栏可谓是精彩至极！<br> 锁是解决并发同步问题的关键，从本文来看，锁有两个核心点，一个是原子操作，另一个则是中断；<br> 1 通过原子操作来实现临界区标志位的改变，<br> 2 关闭中断来避免CPU中途离开导致数据同步失败问题。<br> 3 自旋锁(spinlock)是锁的最小原型，其它锁都是以它为基础来实现的，自旋锁的实现也颇为简单，只需一个简单的原子标志位就可以实现了，当然还要妥善管理中断。<br> 在 xv6 中，对锁的实现只有两种，一种是刚才提到的 spinlock，而另外一种则是 sleeplock，spinlock 不会让出 CPU 执行权，而 sleeplock 则是在 spinlock 的基础上，增加 sleep 功能，即如果一个执行体(线程或者进程)加锁失败，就会进入休眠状态，让出 CPU 执行权，让其它的任务也能得以执行。<br> 4 本文中的信号量(sem)也是 sleeplock 的一种，sem 的实现更为精致，通过等待队列来记录加锁失败的执行体，并后续通过一定的策略来选择唤醒，这也是很多编程语言中信号量的实现方式。<br> 5 当然不同的语言会有不同的优化，比如 <code>go 的 Mutex</code> 是非公平的唤醒机制，但是针对非公平的场景，又设有饥饿补偿，总之本文中实现的 sem 几乎是任何信号量（锁）实现的基础蓝本。<br> 对于思考题答案，这里就顺便贴一下吧，如果有啥问题，欢迎大家交流指正：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>  <span class="token class-name">spinlock_t</span> lock<span class="token punctuation">;</span>
  <span class="token function">x86_spin_lock_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 加锁，如果加锁成功则进入下面代码执行</span>
  <span class="token comment">// 否则，一直自旋，不断检查 lock 值为否为 0</span>
  <span class="token function">x86_spin_lock_disable_irq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 处理一些数据同步、协同场景</span>
  <span class="token function">doing_something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 解锁</span>
  <span class="token function">x86_spin_unlock_enabled_irq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>


  <span class="token class-name">sem_t</span> sem<span class="token punctuation">;</span>
  <span class="token function">x86_sem_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 加锁，减少信号量，如果信号量已经为 0</span>
  <span class="token comment">// 则加锁失败，当前线程会改变为 sleeping 状态</span>
  <span class="token comment">// 并让出 CPU 执行权</span>
  <span class="token function">krlsem_down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 处理一些数据同步、协同场景</span>
  <span class="token function">doing_something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 解锁，增加信号量，唤醒等待队列中的其它线程（若存在）</span>
  <span class="token function">krlsem_up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>作者回复: 我非常喜欢你这样的读者，你总是能抓住问题的本质，继续保持，为你点赞</p><hr><p>当前版本还有几个问题还没有解决，希望后面课程有进一步详解：<br> 1、跨用户进程时，如何共享内核的同一个锁或信号量<br> 2、没有提供锁的可重入不可重入的限制<br> 3、锁自旋时不会让渡CPU时间<br> 4、暂时没有提供公平锁算法<br> 5、暂时没有提供乐观锁算法<br> 基于本节，其实大家可以尝试一下：<br> 1、信号量如何提供最大资源数限制<br> 2、信号量如何提供扣除多个资源的支持<br> 3、如何实现互斥量这一类数据结构呢<br> 4、如何实现读写锁这一类数据结构呢<br> 锁一般用来做线程间或进程间的互斥操作<br> 信号量一般用来做线程间或进程间资源同步操作，比如资源的占用和释放等<br> 作者回复: 是的，我们后面会有介绍的</p><hr><p>记录下我学习本节内容的一些思考：</p><ol><li><p>学习到这里还没有引入抢占这个概念，所以讨论环境中默认进程上下文不会发生抢占，同样也没有进程切换这些东西。</p><p>其实讲进程上下文也不对，我们都还没有引入这些东西，暂且凑合这么用吧。</p></li><li><p>首先讨论了单 cpu 情况下，保证数据一致性的方式，这一时期我们主要防中断：</p><ul><li>对于单个变量我们实现了原子变量（由硬件提供支持），中断是不能打断这个操作的</li><li>对于复杂变量的操作，这个时候中断可以乱入了，我们通过关中断来保证单 cpu 下这些数据的正确</li></ul></li><li><p>到了多 cpu 时代，不止有中断这个小三，还有隔壁老王（其他核），关中断已经不管用了，</p><p>为了数据的一致需要大家在操作前都走自旋流程，自旋需要新的原子操作支持（xchg），到此我们解决了老王带来的问题。</p></li><li><p>但是我们还需要面对中断的问题，自旋锁的实现是带条件的死循环，这也引入了一个问题：死锁。</p><p>cpu 间的互相抢锁最多抢不到等一会，但是 cpu 和本地中断之间就不同了。<br> 当本 cpu 占有了锁，此时打来中断，假如中断中也要抢这把锁，那他抢不到嘛，只好死给你看咯。<br> 而中断也可以嵌套，这种情况也可能死。所以对自旋锁升级，添加了关中断的操作。</p></li><li><p>最后老师介绍了信号量，这里其实已经带入了调度的概念。</p></li><li><p>最后在思考一下抢占和中断优先级带来的问题，其实也还是死锁的问题。</p><p>上面我们设想了两种死锁的情况。我们泛化一下，其实中断可以看作比普通进程优先级更高的进程，<br> 只要是构成这种 低级持锁，高级来抢 的局面都可能死锁。而抢占和中断优先级创造了更多的阶级，<br> 也就产生了更多的可能。所以 Linux 中自旋锁的实现第一步是关抢占。<br> 错误或疏漏的地方还请指正，抱拳了老铁。</p></li></ol><p>作者回复: 你好，你学的很认真，学的很通透，总结很到位</p><hr><p>这个问题抽象下就是在如何在并行执行中做到串联有序<br> 解决思路就两个：<br> 1.在结果端（确保内存一致）<br> 2.在过程端（确保cpu计算中不被打断）<br> 原子性就是确保内存一致，但是因为cpu计算需要时间所以只能保证一个单位的绝对一致<br> 至于锁、信号都是在对上面两种思路的组合，妙的是会出现跨代组合来实现更多样化的应用<br> 老师从根本上分析问题，由简到繁，一下抓住根本和牛逼<br> 其实操作系统就是对简单的功能的组合重复实现无限复杂操作<br> 这种思路和软件开发是一致的，用一种语言API，各种的组合重复利用时间空间的重复解决各种复杂问题<br> 作者回复: 很好，学到了</p><hr><p>本节是关于共享数据的并发修改问题，总结了不同场景下的使用方式：<br> 当共享数据是<mark>单体变量</mark>时，可以尝试使用原子操作指令；<br> 当共享数据是<mark>复杂的数据结构</mark>时：<br> 当是单CPU环境时，只有中断和业务进程两个代码操作流，此时我们可以手动控制CPU中断关闭/开启，要注意解决CPU中断关闭/开启的嵌套调用问题；<br> 当是<mark>多CPU环境</mark>时，就不能同时控制多个CPU的中断了，此时我们用到了<mark>自旋锁</mark>；多个CPU进程竞争自旋锁，成功加锁的进程，可以执行自己的业务流程；这里要注意的是要保证自旋锁流程中的读取锁变量和判断并加锁的操作是原子执行的；<br> 在多CPU环境时，没有获取自旋锁的CPU，就会一直在循环读取锁变量和判断是否加锁的流程当中，浪费了CPU资源，为了解决这个问题，引入了<mark>信号量</mark>；<br> 首先，各个进程会去竞争信号量；<br> 没有获取信号量的进程放入等待队列，这样该进程所在的CPU就可以去执行其他业务进程了；<br> 获取信号量的进程执行完后，会释放信号量后，同时会去唤醒在等待队列中的进程，这样等待的进程就会再次去竞争信号量；<br> 思考：<br> 1.那一个进程中的多个线程并发修改共享数据的模型，应该也是同样的道理吧？？<br> 2.锁，应该是操作的前提条件，有了锁才能去执行业务代码；<br> 但对原子操作来说，好像是加锁和业务操作一起执行了。<br> 作者回复: 你好，总结到位</p><p>看到楼上的各位都发表了那么多的总结，感觉你们都太厉害了！<br> 我也跟着你们的脚步，谈谈我对这节课的理解：<br> 1、对原子的理解：<br> 抽象理解为一条指令，要么执行完成，要么没有执行<br> 2、对中断的理解：<br> 单个CPU中多个进程并发执行，是靠使用中断进行切换，关闭中断后，只有一个进程在执行这块临界区代码，其他进程无法切换执行，执行完这块代码后，再打开中断，再去切换到别的进程执行<br> 3、对自旋锁的理解：<br><strong>自旋锁解决多个CPU，多个进程并行执行的情况</strong>；<br> 多个进程对同一个物理内存地址进行访问，先访问并判断为0的进程，进程加锁设置为1，执行临界区代码；<br> 其他的进程陷入访问，判断为1的流程中，死循环；<br> 执行完临界区的进程将地址设置为0，其他进程再去争抢<br> 4、对信号量的理解：<br> 信号量解决自旋锁中其他得不到执行的进程一直在轮询的问题，这个一直轮询会导致CPU无法切换到其他不需要执行该临界区的进程执行，效率低下；<br> 所以引入能睡眠的机制，得不到的进程不让他们继续等了，先睡觉，负责其他进程执行的CPU去切换到别的进程执行；<br> 等执行完临界区的进程OK后，再把这些睡觉的进程唤醒，他们再争抢<br> 理解能力有限，只明白这么多，如果有不对的，麻烦指正！<br> 作者回复: 对头</p><hr><p>#单CPU下<br> 业务函数和中断函数会存在并发访问同一资源<br> 1.对于简单资源(<code>原型变量</code>？)，可以把访问资源变成原子操作，使用带lock前缀的<code>addl subl incl decl</code>原子指令；<br> 2.对于复杂资源(<code>复合类型变量</code>)，可以把访问资源处业务函数关掉中断，保证此处是串行访问资源；需要解决嵌套问题，通过在关中断前使用pushfl、popl保存之前的中断状态，在下一次开启中断时恢复该状态；<br> #多CPU下<br> 除了每个CPU存在业务函数和中断函数并发问题，还存在不同CPU之间并发问题；<br> 在保证单CPU使用同步的情况下，还需要保证多个CPU同步；<br> 1.简单资源的原子访问操作：个人理解是因为锁了总线，所以单个、多个CPU均适用；<br> 2.自旋锁：关键指令xchg，确保 read(if) &amp; set 在多个CPU之间是原子的<br> #信号量<br> 在复杂的上下文中保护多个复合资源<br> 使用spinlock和wait_queue以及resource_count实现等待、互斥、唤醒</p><p>使用方法<br> // spinlock<br> spinlock_t spinlock;<br> spinlock_init(&amp;spinlock)</p><p>// cpu转圈圈，直到获取锁<br> spinlock_lock(&amp;spinlock)<br> // dosomething()<br> spinlock_unlock(&amp;spinlock)</p><p>// semaphore<br> sem_t sem;<br> sem_init(&amp;sem);</p><p>// 线程会休眠 直到拿到信号量<br> sem_down(&amp;sem);<br> // dosomething()<br> sem_up(&amp;sem);<br> 作者回复: 对正确的</p><hr><p>锁用来保证资源的使用不被打断，打断的情况包括中断，其他cpu执行流，其他线程<br><strong>保护的情况有原子操作，关中断，自旋锁，信号量</strong><br> 原子操作好比瞬时动作，动作只有一个，不被打断<br> 关中断好比学习的时候关闭电话，不被分心，专心学习<br> 自旋锁好比上厕所的时候锁上门，其他人只能在外面团团转，干着急，其他事儿干不了<br> 信号量好比正在忙，门口挂个闲人免进，等自己办完事儿再通知他过来，他可以先去处理其他事情<br> 作者回复: 是的 是的</p><hr><p>感觉信号量好就好在与操作系统的进程/线程调度整合在一起，所以就能够在没有资源时（即信号量等于0），触发进程调度，避免了自旋锁的CPU空转，在拥有资源时能够唤起对应的代码执行下去（即goto start_step）；而至于为什么要用到自旋锁，而不用普通的锁，估计只是因为<strong>自旋锁在临界区较短的时候效率更高</strong>。 不知道对不对<br> 作者回复: 对的</p><hr><p>之前没有学习过操作系统，看了两遍，总结一下自己的理解,。<br> 1.原子操作，可以解决单个变量并发问题。不管后续多核cpu还是单核cpu.<br> 缺点在于只对于单个变量有效。<br> 实现方式，汇编lock.<br> 汇编lock这种方式后续几种方法都会涉及到。<br> 2.中断。单核cpu时只有一个流，唯一可能的并发就是中断，关闭中断即可解决问题。<br> 缺点，只对于单核cpu有效。<br> 实现方式，关闭中断。<br> 不管单核还是多核，都会存在中断引起并发的情况，所以后面两种方法都涉及关闭中断。<br> 3.自旋锁。可以突破原子操作和中断的限制，<strong>即支持多个变量并发以及多核cpu.</strong> 额外增加锁变量，锁变量值为0还是1指使此时是否存在并发。存在并发时，循环判断此锁变量的值，直到其他并发结束。不存在并发时，对锁变量加锁。需要关闭中断避免中断的影响。<br> 缺点，存在并发时，其他流一直试图获取锁变量，占用cpu资源。<br> 实现方式，增加锁变量，指使是否存在并发。<br> 4.信号量。**增加结构体，结构体中包含count信号量计数值和list用于挂载等待任务流列表。**count为0，任务流进入休眠状态(释放出cpu, 可以调度其他任务流)。count为1.获取信号量，可执行后续操作，并将count置为0，表示已占用，执行完成后，将count加1，<br> 作者回复: 对的 你很牛</p><hr><p>单核cpu，切换进程必须通过中断，因此可以通过关中断来执行一些同步操作。<br> 多核cpu，同步的数据可能会收到别的核心上的进程影响，因此不能仅仅通过关闭当前核心的中断来执行同步操作。因此通过自旋锁。<strong>自旋锁要么被获得，要么就一直循环的申请，直到被获得。</strong><br> 前面的同步操作，都要求锁的使用时间短，否则就会存在多个经常一直在等待某个进程，造成资源的浪费。**信号量通过挂起的操作，让获取锁失败的进程，不再进行循环申请的操作，不再占用cpu资源。**直到释放锁的进程，在释放的时候，才将挂起的进程释放，让他们进入竞争锁的状态。<br> 作者回复: 是的 是的</p><hr><p>一开始，从单个变量可能由于中断，而产生达不到预期结果的情况，可以通过硬件层面的原子操作，来解决相应问题；<strong>但硬件层面的的原子操作没办法适应多种多样的数据结构</strong>，这个时候就需要对中断来进行处理，保证数据处理过程中的“原子性”，对于嵌套中断的问题采用栈来保存对应的标志寄存器内容，用于还原来解决嵌套问题；但多核CPU可以绕过单个CPU的中断从而影响数据处理的“原子性”（个人理解希望老师指点），<strong>这时候通过硬件提供一个变量来形成自旋锁</strong>，保证处理的“原子性”，但是仍会由于嵌套中断从而导致占有自旋锁后进入死循环，<strong>因此引入关中断自旋锁来保证“原子性”</strong>；最后以上三种情况都不支持长时间等待情况，因此引入了信号量，注意对信号量的操作时要使用自旋锁来保证其“原子性”，如有不对希望大家指正。<br> 作者回复: 你好，正确的</p><hr><p>看了好多遍. 终于有点看懂了, 我总结一下我的笔记<br> 锁是为了解决多并发安全处理一个数据<br> 1.当这个数据比较简单或者处理的数据比较简单时, 如果保证只有原子操作, 就能够很好的解决这个问题<br> 2.当这个数据比较复杂, 比如一个数据结构, 可以同时修改数据结构中不同的属性的时候, 就需要中断来解决这个问题, 但是单CPU的中断有个问题就是嵌套会出现bug, <strong>于是把eflag的F位值+栈+内存巧妙的解决了这个问题</strong><br> 3.随着计算机的发展, 大家开始有多CPU了, Eflag的F是不能解决这个问题, 这个时候科学家用了一个自旋锁, 自旋锁的实现也很巧妙, <strong>操作系统提供一个函数, 保证程序读取锁, 上锁, 开锁都可以是原子性的, 感觉这个是大家使用分布式锁的原型</strong><br> 4.现在多个CPU, 但是不能只执行你一个多并发程序, 其他的进程可能会占用你的CPU, 所以有信号量这个数据结构, 其中count=1可以抢占, 用悲观锁的思想, 抢占这个信令先锁住这个信令, 然后count-1, 然后执行doSomethins, 然后如果有新的程序来占取, 如果count &lt; 1, 则到队列中排队, 等处理完了，唤醒队列中的人物, 就count+=1, 然后释放sem的锁</p><p>读后总结一下：<br> 1）我们首先以单核 CPU 演进，首先提出了原子操作的概念，再提出中断。原子操作是对单体变量进行原子性修改，以保证共享数据的安全性，关闭中断则是防止 CPU 中途执行其他代码而导致数据同步问题。原子操作问题在于尽管能够解决同步问题，但是仅仅是作用于单体变量；而关闭中断尽管能够使 CPU 不响应中断继续执行对多个变量的操作，但是没法应对嵌套操作，于是又引入对嵌套操作的改进。<br> 2）这时，我们已经拥有了足以应对单核 CPU 同步问题的工具，但是毕竟如今的 CPU 是多核的，关闭中断没法应对，原子操作还是老毛病（没法应对多个变量的同步），势必需要新的工具来应对。<br> 3）首先引入自旋锁，机制很简单，按照我的理解，自旋锁的设计就是原子操作的基础，通过原子操作将一段代码的操作权交给某个线程（进程）。原子操作保证的是自旋锁的上锁和解锁，自旋锁保证的是多个操作的同步安全。当然中断的问题也是要同时解决。<br> 4）既然自旋锁已经能够解决我们对于同步问题的需求，为什么还要提出「信号量」这个概念呢？能吃饱后就想吃的好，操作系统也是如此。尽管自旋锁能够解决大部分问题，但是他的性能消耗太严重了，同步代码在执行期间只允许一个线程执行，其他的线程只能自旋干等着，如果同步代码执行时间过长，其他线程岂不是一直自旋，不做其他事了？<br> 5）那么就引入了「信号量」这个概念，信号量除了也能保证同步代码的安全，还同时还对没有获取到信号量的线程提供一个「休息」的地方，称之为「阻塞队列」。之后就是对信号量的操作，也不必过多解析。<br> 6）补充一下，信号量同步的代码块是可以多个线程同时执行的（需要看信号量的设置），但是对信号量的操作是不允许同时进行的，这需要进行同步，所以我们可以看到文章中的信号量结构体中有设计一个自旋锁用于对信号量操作。<br> 以上就是我对本课文章的一个总结，好多概念性的定义我有点模糊不清，所以如果有问题欢迎讨论指点~</p><hr><p>感谢老师，结合我们在高级语言中常用到的mutex操作，差不多实现应该就是文中介绍的最后一种信号量的方式吧，思想就是以最小粒度加锁（xchg）+屏蔽中断（防止锁嵌套）+及时调度（schedule），即“能锁就锁，不锁就睡”<br> 作者回复: 是的</p><hr><p>由于调度切换运行（假并行）以及多核多处理器的同时操作（真并行），对共同数据的操作可能会存在不符合预期的结果。有四种方法应对：<br> 1）使用处理器提供的原子操作指令，调度切换时不会分隔，从而保证数据一致。但该类指令有限，只能用于单体变量的操作，而且对多核处理器无效。<br> 2）关闭中断，也就直接禁止了调度切换。这个同样对多核处理器无效。<br> 3）自旋锁，利用了原子性的比较与交换指令，通过设置内置中变量的值，<strong>做到多核处理器之间的同步</strong>。如果其中一个进程长时间占用锁，其他进程会持续地重复尝试获取锁，这样会很浪费处理器计算资源。<br> 4）信号量，<strong>在尝试获取信号量（锁）失败时会主动挂起自己切换到其他进程执行</strong>，下次调度运行时再次尝试获取。另外，信号量的使用增加了初始化步骤，可用于多个信号量的情况，而不是自旋锁的独占资源用法。<br> 作者回复: 是啊，你总结的对</p><hr><p>”锁“的进化。想到一个问题，如果有大量的并发操作，会影响中断的处理吧（比如键盘输入），日常碰到的类似的问题是否也有这一方面的原因。<br> 作者回复: 你好，你的想法很正确，<strong>所以我们要尽量少使用锁，减少加锁时间</strong>。</p>`,155),l=[c];function i(u,r){return s(),a("div",null,l)}const m=n(o,[["render",i],["__file","C08-并发中常用的锁.html.vue"]]);export{m as default};
