import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as p,o,c,a as n,b as s,e as l,d as a}from"./app-cdabc73c.js";const i="/assets/89723dc967b59f6f49419082f6ab7659-d25c4806.jpg",r="/assets/f83b8d49b4e74c0e255b5735044c1eb1-364d1fc3.jpg",u="/assets/7af58012466c7d006511a7e16143314c-3c60508a.jpeg",d="/assets/83a6511faf802014fbc2c02afc397a04-00fc7a0d.jpg",k="/assets/7eaf620768c62ff53e5ea2b11b4940f6-e94e759b.jpg",m="/assets/2861968d1907bc314b82c34c221aace8-a240a5f0.jpeg",v="/assets/2ad275ff8fdf6aafced4a7aeea4ca0ce-75034975.jpeg",_={},b=a(`<h1 id="_22-进程空间管理-项目组还可以自行布置会议室" tabindex="-1"><a class="header-anchor" href="#_22-进程空间管理-项目组还可以自行布置会议室" aria-hidden="true">#</a> 22 | 进程空间管理：项目组还可以自行布置会议室</h1><p>上两节，我们讲了内存管理的三个方面，虚拟内存空间的管理、物理内存的管理以及内存映射。你现在对进程内存空间的整体布局应该有了一个大致的了解。今天我们就来详细看看第一个方面，进程的虚拟内存空间是如何管理的。</p><p>32 位系统和 64 位系统的内存布局有的地方相似，有的地方差别比较大，接下来介绍的时候，请你注意区分。好，我们现在正式开始！</p><h2 id="用户态和内核态的划分" tabindex="-1"><a class="header-anchor" href="#用户态和内核态的划分" aria-hidden="true">#</a> 用户态和内核态的划分</h2><p>进程的虚拟地址空间，其实就是站在项目组的角度来看内存，所以我们就从 task_struct 出发来看。这里面有一个 <code>struct mm_struct 结构</code>来管理内存。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">mm_struct</span>    <span class="token operator">*</span>mm<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在 struct mm_struct 里面，有这样一个成员变量：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">unsigned</span> <span class="token keyword">long</span> task_size<span class="token punctuation">;</span>    <span class="token comment">/* size of task vm space */</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>我们之前讲过，整个虚拟内存空间要一分为二，一部分是<strong>用户态地址空间</strong>，一部分是<strong>内核态地址空间</strong>，那这两部分的分界线在哪里呢？这就要 <code>task_size</code> 来定义。</p><p>对于 32 位的系统，内核里面是这样定义 TASK_SIZE 的：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_X86_32</span></span>
<span class="token comment">/*
 * User space process size: 3GB (default).
 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_SIZE</span>    <span class="token expression">PAGE_OFFSET</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_SIZE_MAX</span>    <span class="token expression">TASK_SIZE</span></span>
<span class="token comment">/*
config PAGE_OFFSET
        hex
        default 0xC0000000
        depends on X86_32
*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
<span class="token comment">/*
 * User space process size. 47bits minus one guard page.
*/</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_SIZE_MAX</span>  <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1UL</span> <span class="token operator">&lt;&lt;</span> <span class="token number">47</span><span class="token punctuation">)</span> <span class="token operator">-</span> PAGE_SIZE<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_SIZE</span>    <span class="token expression"><span class="token punctuation">(</span><span class="token function">test_thread_flag</span><span class="token punctuation">(</span>TIF_ADDR32<span class="token punctuation">)</span> <span class="token operator">?</span> </span><span class="token punctuation">\\</span>
          <span class="token expression">IA32_PAGE_OFFSET <span class="token operator">:</span> TASK_SIZE_MAX<span class="token punctuation">)</span></span></span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当执行一个新的进程的时候，会做以下的设置：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>current<span class="token operator">-&gt;</span>mm<span class="token operator">-&gt;</span>task_size <span class="token operator">=</span> TASK_SIZE<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>对于 32 位系统，最大能够寻址 2^32=4G，其中<strong>用户态</strong>虚拟地址空间是 3G，<strong>内核态</strong>是 1G。</p><p>对于 64 位系统，虚拟地址只使用了 48 位。就像代码里面写的一样，1 左移了 47 位，就相当于 48 位地址空间一半的位置，0x0000800000000000，然后减去一个页，就是 0x00007FFFFFFFF000，<strong>用户空间</strong>共 128T。同样，<strong>内核空间</strong>也是 128T。内核空间和用户空间之间<strong>隔着很大的空隙</strong>，以此来进行隔离。</p><img src="`+i+`" alt="img" style="zoom:25%;"><h2 id="用户态布局" tabindex="-1"><a class="header-anchor" href="#用户态布局" aria-hidden="true">#</a> 用户态布局</h2><p>我们先来看用户态虚拟空间的布局。</p><p>之前我们讲了用户态虚拟空间里面有几类数据，例如<strong>代码、全局变量、堆、栈、内存映射区</strong>等。</p><p>在 struct mm_struct 里面，有下面这些变量定义了这些区域的统计信息和位置。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">unsigned</span> <span class="token keyword">long</span> mmap_base<span class="token punctuation">;</span>  <span class="token comment">/* base of mmap area */</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> total_vm<span class="token punctuation">;</span>    <span class="token comment">/* Total pages mapped */</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> locked_vm<span class="token punctuation">;</span>  <span class="token comment">/* Pages that have PG_mlocked set */</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> pinned_vm<span class="token punctuation">;</span>  <span class="token comment">/* Refcount permanently increased */</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> data_vm<span class="token punctuation">;</span>    <span class="token comment">/* VM_WRITE &amp; ~VM_SHARED &amp; ~VM_STACK */</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> exec_vm<span class="token punctuation">;</span>    <span class="token comment">/* VM_EXEC &amp; ~VM_WRITE &amp; ~VM_STACK */</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> stack_vm<span class="token punctuation">;</span>    <span class="token comment">/* VM_STACK */</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> start_code<span class="token punctuation">,</span> end_code<span class="token punctuation">,</span> start_data<span class="token punctuation">,</span> end_data<span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> start_brk<span class="token punctuation">,</span> brk<span class="token punctuation">,</span> start_stack<span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> arg_start<span class="token punctuation">,</span> arg_end<span class="token punctuation">,</span> env_start<span class="token punctuation">,</span> env_end<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-映射相关信息" tabindex="-1"><a class="header-anchor" href="#_1-映射相关信息" aria-hidden="true">#</a> 1 映射相关信息</h3><p>其中，<code>total_vm</code> 是总共映射的页的数目。我们知道，这么大的虚拟地址空间，不可能都有真实内存对应，所以这里是映射的数目。</p><h3 id="_2-页面换入换出" tabindex="-1"><a class="header-anchor" href="#_2-页面换入换出" aria-hidden="true">#</a> 2 页面换入换出</h3><p>当内存吃紧的时候，有些页可以换出到硬盘上，有的页因为比较重要，不能换出。</p><ol><li><code>locked_vm</code> 就是被锁定不能换出，</li><li><code>pinned_vm</code> 是不能换出，也不能移动。</li></ol><h3 id="_3-页面总数" tabindex="-1"><a class="header-anchor" href="#_3-页面总数" aria-hidden="true">#</a> 3 页面总数</h3><ol><li><code>data_vm</code> 是存放数据的页的数目，</li><li><code>exec_vm</code> 是存放可执行文件的页的数目，</li><li><code>stack_vm</code> 是栈所占的页的数目。</li></ol><h3 id="_4-代码段-text" tabindex="-1"><a class="header-anchor" href="#_4-代码段-text" aria-hidden="true">#</a> 4 代码段 .text</h3><p><code>start_code</code> 和 <code>end_code</code> 表示可执行代码的开始和结束位置，</p><ul><li>.text: 程序代码</li></ul><h3 id="_5-数据段-rodata-data-bss" tabindex="-1"><a class="header-anchor" href="#_5-数据段-rodata-data-bss" aria-hidden="true">#</a> 5 数据段 .rodata .data .bss</h3><p><code>start_data</code> 和 <code>end_data</code> 表示已初始化数据的开始位置和结束位置。</p><ul><li>.rodata: 只读常量</li><li>.data: (已经/需要)初始化的数据</li><li>.bss: (无需初始化)默认初始值的数据</li></ul><h3 id="_6-堆段-堆区" tabindex="-1"><a class="header-anchor" href="#_6-堆段-堆区" aria-hidden="true">#</a> 6 堆段/堆区</h3><p><code>start_brk</code> 是堆的起始位置，<code>brk</code> 是堆当前的结束位置。前面咱们讲过 <strong>malloc</strong> 申请一小块内存的话，就是通过改变 brk 位置实现的。</p><h3 id="_7-栈段-栈区" tabindex="-1"><a class="header-anchor" href="#_7-栈段-栈区" aria-hidden="true">#</a> 7 栈段/栈区</h3><p><code>start_stack</code> 是栈的起始位置，栈的结束位置在<code>寄存器的栈顶指针</code>中。</p><h3 id="_8-参数列表-环境变量" tabindex="-1"><a class="header-anchor" href="#_8-参数列表-环境变量" aria-hidden="true">#</a> 8 参数列表 &amp; 环境变量</h3><p><code>arg_start</code> 和 <code>arg_end</code> 是参数列表的位置， <code>env_start</code> 和 <code>env_end</code> 是环境变量的位置。它们都位于<strong>栈中最高地址的地方</strong>。</p><h3 id="_9-内存映射区-动态链接共享库" tabindex="-1"><a class="header-anchor" href="#_9-内存映射区-动态链接共享库" aria-hidden="true">#</a> 9 内存映射区/动态链接共享库</h3><p><code>mmap_base</code> 表示虚拟地址空间中用于内存映射的起始地址。一般情况下，这个空间是**(堆与栈之间)从高地址到低地址增长**的。前面咱们讲 malloc 申请一大块内存的时候，就是通过 <strong>mmap</strong> 在这里映射一块区域到物理内存。<strong>咱们加载动态链接库 so 文件</strong>，也是在这个区域里面，映射一块区域到 so 文件。</p><h2 id="小结图" tabindex="-1"><a class="header-anchor" href="#小结图" aria-hidden="true">#</a> 小结图</h2><p>这下所有用户态的区域的位置基本上都描述清楚了。整个布局就像下面这张图这样。虽然 32 位和 64 位的空间相差很大，但是区域的类别和布局是相似的。</p><img src="`+r+`" alt="img" style="zoom:20%;"><h3 id="_1-区域属性相关-内核方便管理" tabindex="-1"><a class="header-anchor" href="#_1-区域属性相关-内核方便管理" aria-hidden="true">#</a> 1 区域属性相关/内核方便管理</h3><p>除了位置信息之外，struct mm_struct 里面还专门有一个结构 <code>vm_area_struct</code>，来描述这些<strong>区域的属性</strong>。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span>mmap<span class="token punctuation">;</span>    <span class="token comment">/* list of VMAs */</span>
<span class="token keyword">struct</span> <span class="token class-name">rb_root</span> mm_rb<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这里面一个是单链表，用于将这些区域串起来。另外还有一个红黑树。又是这个数据结构，在进程调度的时候我们用的也是<mark>红黑树</mark>。它的好处就是<strong>查找和修改都很快</strong>。这里用红黑树，就是为了快速查找一个内存区域，并在需要改变的时候，能够快速修改。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token punctuation">{</span>
  <span class="token comment">/* The first cache line has the info for VMA tree walking. */</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> vm_start<span class="token punctuation">;</span>    <span class="token comment">/* Our start address within vm_mm. */</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> vm_end<span class="token punctuation">;</span>    <span class="token comment">/* The first byte after our end address within vm_mm. */</span>
  <span class="token comment">/* linked list of VM areas per task, sorted by address */</span>
  <span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span>vm_next<span class="token punctuation">,</span> <span class="token operator">*</span>vm_prev<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> vm_rb<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>vm_mm<span class="token punctuation">;</span>  <span class="token comment">/* The address space we belong to. */</span>
  <span class="token keyword">struct</span> <span class="token class-name">list_head</span> anon_vma_chain<span class="token punctuation">;</span> <span class="token comment">/* Serialized by mmap_sem &amp;
            * page_table_lock */</span>
  <span class="token keyword">struct</span> <span class="token class-name">anon_vma</span> <span class="token operator">*</span>anon_vma<span class="token punctuation">;</span>  <span class="token comment">/* Serialized by page_table_lock */</span>
  <span class="token comment">/* Function pointers to deal with this struct. */</span>
  <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">vm_operations_struct</span> <span class="token operator">*</span>vm_ops<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span> vm_file<span class="token punctuation">;</span>    <span class="token comment">/* File we map to (can be NULL). */</span>
  <span class="token keyword">void</span> <span class="token operator">*</span> vm_private_data<span class="token punctuation">;</span>    <span class="token comment">/* was vm_pte (shared mem) */</span>
<span class="token punctuation">}</span> __randomize_layout<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>vm_start</code> 和 <code>vm_end</code> 指定了该区域在用户空间中的起始和结束地址。</li><li><code>vm_next</code> 和 <code>vm_prev</code> 将这个区域串在链表上。</li><li><code>vm_rb</code> 将这个区域放在红黑树上。</li><li><code>vm_ops</code> 里面是对这个内存区域可以做的操作的定义。</li></ul><h3 id="_2-映射物理内存-匿名映射-映射文件" tabindex="-1"><a class="header-anchor" href="#_2-映射物理内存-匿名映射-映射文件" aria-hidden="true">#</a> 2 映射物理内存(匿名映射)/映射文件</h3><p>虚拟内存区域可以映射到物理内存，也可以映射到文件，</p><ul><li>映射到物理内存的时候称为<mark>匿名映射</mark>，<code>anon_vma</code> 中，anoy 就是 anonymous，匿名的意思，</li><li>映射到文件就需要有 <code>vm_file</code> 指定被映射的文件。</li></ul><p>那这些 <code>vm_area_struct</code> 是如何和上面的内存区域关联的呢？</p><h2 id="还得是你-load-elf-binary" tabindex="-1"><a class="header-anchor" href="#还得是你-load-elf-binary" aria-hidden="true">#</a> 还得是你: load_elf_binary</h2><p>这个事情是在 <code>load_elf_binary</code> 里面实现的。没错，就是它。加载内核的是它，启动第一个用户态进程 init 的是它，fork 完了以后，调用 exec 运行一个二进制程序的也是它。</p><p>当 exec 运行一个二进制程序的时候，除<strong>了解析 ELF 的格式</strong>之外，另外一个重要的事情就是<strong>建立内存映射</strong>。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">load_elf_binary</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">linux_binprm</span> <span class="token operator">*</span>bprm<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token function">setup_new_exec</span><span class="token punctuation">(</span>bprm<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  retval <span class="token operator">=</span> <span class="token function">setup_arg_pages</span><span class="token punctuation">(</span>bprm<span class="token punctuation">,</span> <span class="token function">randomize_stack_top</span><span class="token punctuation">(</span>STACK_TOP<span class="token punctuation">)</span><span class="token punctuation">,</span>
         executable_stack<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  error <span class="token operator">=</span> <span class="token function">elf_map</span><span class="token punctuation">(</span>bprm<span class="token operator">-&gt;</span>file<span class="token punctuation">,</span> load_bias <span class="token operator">+</span> vaddr<span class="token punctuation">,</span> elf_ppnt<span class="token punctuation">,</span>
        elf_prot<span class="token punctuation">,</span> elf_flags<span class="token punctuation">,</span> total_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  retval <span class="token operator">=</span> <span class="token function">set_brk</span><span class="token punctuation">(</span>elf_bss<span class="token punctuation">,</span> elf_brk<span class="token punctuation">,</span> bss_prot<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  elf_entry <span class="token operator">=</span> <span class="token function">load_elf_interp</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loc<span class="token operator">-&gt;</span>interp_elf_ex<span class="token punctuation">,</span>
              interpreter<span class="token punctuation">,</span>
              <span class="token operator">&amp;</span>interp_map_addr<span class="token punctuation">,</span>
              load_bias<span class="token punctuation">,</span> interp_elf_phdata<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  current<span class="token operator">-&gt;</span>mm<span class="token operator">-&gt;</span>end_code <span class="token operator">=</span> end_code<span class="token punctuation">;</span>
  current<span class="token operator">-&gt;</span>mm<span class="token operator">-&gt;</span>start_code <span class="token operator">=</span> start_code<span class="token punctuation">;</span>
  current<span class="token operator">-&gt;</span>mm<span class="token operator">-&gt;</span>start_data <span class="token operator">=</span> start_data<span class="token punctuation">;</span>
  current<span class="token operator">-&gt;</span>mm<span class="token operator">-&gt;</span>end_data <span class="token operator">=</span> end_data<span class="token punctuation">;</span>
  current<span class="token operator">-&gt;</span>mm<span class="token operator">-&gt;</span>start_stack <span class="token operator">=</span> bprm<span class="token operator">-&gt;</span>p<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>load_elf_binary 会完成以下的事情：</p><ul><li>调用 setup_new_exec，设置内存映射区 <code>mmap_base</code>；</li><li>调用 setup_arg_pages，设置栈的 <code>vm_area_struct</code>，这里面设置了 mm-&gt;arg_start 是指向栈底的，current-&gt;mm-&gt;start_stack 就是栈底；</li><li><code>elf_map</code> 会将 ELF 文件中的代码部分映射到内存中来；</li><li><code>set_brk</code> 设置了堆的 vm_area_struct，这里面设置了 current-&gt;mm-&gt;start_brk = current-&gt;mm-&gt;brk，也即堆里面还是空的；</li><li><code>load_elf_interp</code> 将依赖的 so 映射到内存中的内存映射区域。</li></ul><p>最终就形成下面这个内存映射图。</p><img src="`+u+`" alt="img" style="zoom:25%;"><h3 id="初始化之后需要修改的情况" tabindex="-1"><a class="header-anchor" href="#初始化之后需要修改的情况" aria-hidden="true">#</a> 初始化之后需要修改的情况</h3><p>映射完毕后，什么情况下会修改呢？</p><p><strong>第一种情况</strong>是函数的调用，涉及函数栈的改变，主要是改变栈顶指针。</p><p><strong>第二种情况</strong>是通过 malloc 申请一个堆内的空间，当然底层要么执行 brk，要么执行 mmap。关于内存映射的部分，我们后面的章节讲，这里我们重点看一下 brk 是怎么做的。</p><p>brk 系统调用实现的入口是 sys_brk 函数，就像下面代码定义的一样。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token function">SYSCALL_DEFINE1</span><span class="token punctuation">(</span>brk<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> brk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> retval<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> newbrk<span class="token punctuation">,</span> oldbrk<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>mm <span class="token operator">=</span> current<span class="token operator">-&gt;</span>mm<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  newbrk <span class="token operator">=</span> <span class="token function">PAGE_ALIGN</span><span class="token punctuation">(</span>brk<span class="token punctuation">)</span><span class="token punctuation">;</span>
  oldbrk <span class="token operator">=</span> <span class="token function">PAGE_ALIGN</span><span class="token punctuation">(</span>mm<span class="token operator">-&gt;</span>brk<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>oldbrk <span class="token operator">==</span> newbrk<span class="token punctuation">)</span>
    <span class="token keyword">goto</span> set_brk<span class="token punctuation">;</span>


  <span class="token comment">/* Always allow shrinking brk. */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>brk <span class="token operator">&lt;=</span> mm<span class="token operator">-&gt;</span>brk<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">do_munmap</span><span class="token punctuation">(</span>mm<span class="token punctuation">,</span> newbrk<span class="token punctuation">,</span> oldbrk<span class="token operator">-</span>newbrk<span class="token punctuation">,</span> <span class="token operator">&amp;</span>uf<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token keyword">goto</span> set_brk<span class="token punctuation">;</span>
    <span class="token keyword">goto</span> out<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>


  <span class="token comment">/* Check against existing mmap mappings. */</span>
  next <span class="token operator">=</span> <span class="token function">find_vma</span><span class="token punctuation">(</span>mm<span class="token punctuation">,</span> oldbrk<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">&amp;&amp;</span> newbrk <span class="token operator">+</span> PAGE_SIZE <span class="token operator">&gt;</span> <span class="token function">vm_start_gap</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">goto</span> out<span class="token punctuation">;</span>


  <span class="token comment">/* Ok, looks good - let it rip. */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">do_brk</span><span class="token punctuation">(</span>oldbrk<span class="token punctuation">,</span> newbrk<span class="token operator">-</span>oldbrk<span class="token punctuation">,</span> <span class="token operator">&amp;</span>uf<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword">goto</span> out<span class="token punctuation">;</span>


set_brk<span class="token operator">:</span>
  mm<span class="token operator">-&gt;</span>brk <span class="token operator">=</span> brk<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">return</span> brk<span class="token punctuation">;</span>
out<span class="token operator">:</span>
  retval <span class="token operator">=</span> mm<span class="token operator">-&gt;</span>brk<span class="token punctuation">;</span>
  <span class="token keyword">return</span> retval
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>前面我们讲过了，堆是从低地址向高地址增长的，sys_brk 函数的参数 brk 是新的堆顶位置，而当前的 mm-&gt;brk 是原来堆顶的位置。</p><p>首先要做的第一个事情，将原来的堆顶和现在的堆顶，都按照页对齐地址，然后比较大小。如果两者相同，说明这次增加的堆的量很小，还在一个页里面，不需要另行分配页，直接跳到 set_brk 那里，设置 mm-&gt;brk 为新的 brk 就可以了。</p><p>如果发现新旧堆顶不在一个页里面，麻烦了，这下要跨页了。如果发现新堆顶小于旧堆顶，这说明不是新分配内存了，而是释放内存了，释放的还不小，至少释放了一页，于是调用 do_munmap 将这一页的内存映射去掉。</p><p>如果堆将要扩大，就要调用 find_vma。如果打开这个函数，看到的是对红黑树的查找，找到的是原堆顶所在的 vm_area_struct 的下一个 vm_area_struct，看当前的堆顶和下一个 vm_area_struct 之间还能不能分配一个完整的页。如果不能，没办法只好直接退出返回，内存空间都被占满了。</p><p>如果还有空间，就调用 do_brk 进一步分配堆空间，从旧堆顶开始，分配计算出的新旧堆顶之间的页数。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">do_brk</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> addr<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">list_head</span> <span class="token operator">*</span>uf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">do_brk_flags</span><span class="token punctuation">(</span>addr<span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> uf<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">do_brk_flags</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> addr<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> request<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">list_head</span> <span class="token operator">*</span>uf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>mm <span class="token operator">=</span> current<span class="token operator">-&gt;</span>mm<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span>vma<span class="token punctuation">,</span> <span class="token operator">*</span>prev<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span><span class="token operator">*</span>rb_link<span class="token punctuation">,</span> <span class="token operator">*</span>rb_parent<span class="token punctuation">;</span>
  <span class="token class-name">pgoff_t</span> pgoff <span class="token operator">=</span> addr <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">;</span>
  <span class="token keyword">int</span> error<span class="token punctuation">;</span>


  len <span class="token operator">=</span> <span class="token function">PAGE_ALIGN</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token function">find_vma_links</span><span class="token punctuation">(</span>mm<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> addr <span class="token operator">+</span> len<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prev<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rb_link<span class="token punctuation">,</span>
            <span class="token operator">&amp;</span>rb_parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  vma <span class="token operator">=</span> <span class="token function">vma_merge</span><span class="token punctuation">(</span>mm<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> addr <span class="token operator">+</span> len<span class="token punctuation">,</span> flags<span class="token punctuation">,</span>
      <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> pgoff<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> NULL_VM_UFFD_CTX<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>vma<span class="token punctuation">)</span>
    <span class="token keyword">goto</span> out<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  vma <span class="token operator">=</span> <span class="token function">kmem_cache_zalloc</span><span class="token punctuation">(</span>vm_area_cachep<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vma<span class="token operator">-&gt;</span>anon_vma_chain<span class="token punctuation">)</span><span class="token punctuation">;</span>
  vma<span class="token operator">-&gt;</span>vm_mm <span class="token operator">=</span> mm<span class="token punctuation">;</span>
  vma<span class="token operator">-&gt;</span>vm_start <span class="token operator">=</span> addr<span class="token punctuation">;</span>
  vma<span class="token operator">-&gt;</span>vm_end <span class="token operator">=</span> addr <span class="token operator">+</span> len<span class="token punctuation">;</span>
  vma<span class="token operator">-&gt;</span>vm_pgoff <span class="token operator">=</span> pgoff<span class="token punctuation">;</span>
  vma<span class="token operator">-&gt;</span>vm_flags <span class="token operator">=</span> flags<span class="token punctuation">;</span>
  vma<span class="token operator">-&gt;</span>vm_page_prot <span class="token operator">=</span> <span class="token function">vm_get_page_prot</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">vma_link</span><span class="token punctuation">(</span>mm<span class="token punctuation">,</span> vma<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> rb_link<span class="token punctuation">,</span> rb_parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
out<span class="token operator">:</span>
  <span class="token function">perf_event_mmap</span><span class="token punctuation">(</span>vma<span class="token punctuation">)</span><span class="token punctuation">;</span>
  mm<span class="token operator">-&gt;</span>total_vm <span class="token operator">+=</span> len <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">;</span>
  mm<span class="token operator">-&gt;</span>data_vm <span class="token operator">+=</span> len <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> VM_LOCKED<span class="token punctuation">)</span>
    mm<span class="token operator">-&gt;</span>locked_vm <span class="token operator">+=</span> <span class="token punctuation">(</span>len <span class="token operator">&gt;&gt;</span> PAGE_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span>
  vma<span class="token operator">-&gt;</span>vm_flags <span class="token operator">|=</span> VM_SOFTDIRTY<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 do_brk 中，调用 find_vma_links 找到将来的 vm_area_struct 节点在红黑树的位置，找到它的父节点、前序节点。接下来调用 vma_merge，看这个新节点是否能够和现有树中的节点合并。如果地址是连着的，能够合并，则不用创建新的 vm_area_struct 了，直接跳到 out，更新统计值即可；如果不能合并，则创建新的 vm_area_struct，既加到 anon_vma_chain 链表中，也加到红黑树中。</p><h2 id="内核态的布局" tabindex="-1"><a class="header-anchor" href="#内核态的布局" aria-hidden="true">#</a> 内核态的布局</h2><p>用户态虚拟空间分析完毕，接下来我们分析内核态虚拟空间。</p><p>内核态的虚拟空间<strong>和某一个进程没有关系</strong>，所有进程通过系统调用进入到内核之后，<strong>看到的虚拟地址空间都是一样的</strong>。</p><p>这里强调一下，千万别以为到了内核里面，咱们就会直接使用物理内存地址了，想当然地认为下面讨论的都是物理内存地址，不是的，这里讨论的还是<strong>虚拟内存地址</strong>，但是由于内核总是涉及管理物理内存，因而总是隐隐约约发生关系，所以这里必须思路清晰，分清楚物理内存地址和虚拟内存地址。</p><p>在内核态，32 位和 64 位的布局差别比较大，主要是因为 32 位内核态空间太小了。</p><h2 id="_32位内核态" tabindex="-1"><a class="header-anchor" href="#_32位内核态" aria-hidden="true">#</a> 32位内核态</h2><p>我们来看 32 位的内核态的布局。</p><img src="`+d+`" alt="img" style="zoom:25%;"><h3 id="_1-896m-直接映射区-连续且简单的映射关系" tabindex="-1"><a class="header-anchor" href="#_1-896m-直接映射区-连续且简单的映射关系" aria-hidden="true">#</a> 1 [896M] 直接映射区/连续且简单的映射关系</h3><p>32 位的内核态虚拟地址空间一共就 1G，占绝大部分的前 <code>896M</code>，我们称为**<code>直接映射区</code>**。</p><p>所谓的直接映射区，就是这一块空间是<strong>连续的，和物理内存是非常简单的映射关系</strong>，其实就是虚拟内存(最高)地址减去 3G，就得到物理内存的位置。</p><p>在内核里面，有两个宏：(方便快速得到[虚拟/物理]对应的[物理/虚拟])</p><ul><li>__pa(vaddr) 返回与虚拟地址 vaddr 相关的物理地址；</li><li>__va(paddr) 则计算出对应于物理地址 paddr 的虚拟地址。</li></ul><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__va</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span>      <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">+</span>PAGE_OFFSET<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__pa</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span>    <span class="token function">__phys_addr</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__phys_addr</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span>    <span class="token function">__phys_addr_nodebug</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span></span></span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__phys_addr_nodebug</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">-</span> PAGE_OFFSET<span class="token punctuation">)</span></span></span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是你要注意，这里虚拟地址和物理地址发生了关联关系，在物理内存的开始的 896M 的空间，会被直接映射到 3G 至 3G+896M 的虚拟地址，这样容易给你一种感觉，这些内存访问起来和物理内存差不多，别这样想，<strong><code>在大部分情况下</code>，对于这一段内存的访问，在内核中，<code>还是会使用虚拟地址的</code>，并且将来也会为这一段空间<code>建设页表</code>，对这段地址的访问也会走上一节我们讲的<code>分页地址的流程</code>，只不过页表里面比较简单，<code>是直接的一一对应而已</code>。</strong></p><h4 id="系统启动时" tabindex="-1"><a class="header-anchor" href="#系统启动时" aria-hidden="true">#</a> 系统启动时</h4><p>这 896M 还需要仔细分解。在系统启动的时候，物理内存的<strong>前 1M 已经被占用了</strong>，从 1M 开始加载内核代码段，然后就是内核的全局变量、BSS 等，也是 ELF 里面涵盖的。这样内核的代码段，全局变量，BSS 也就会被映射到 3G 后的虚拟地址空间里面。具体的物理内存布局可以查看 <code>/proc/iomem</code>。</p><h4 id="内核代码段-全局变量-bss" tabindex="-1"><a class="header-anchor" href="#内核代码段-全局变量-bss" aria-hidden="true">#</a> 内核代码段，全局变量，BSS</h4><p>在内核运行的过程中，如果碰到系统调用创建进程，会创建 task_struct 这样的实例，内核的进程管理代码会将实例创建在 3G 至 3G+896M 的虚拟空间中，当然也会被放在物理内存里面的前 <code>896M</code> 里面，相应的页表也会被创建。</p><h4 id="内核栈分配" tabindex="-1"><a class="header-anchor" href="#内核栈分配" aria-hidden="true">#</a> 内核栈分配</h4><p>在内核运行的过程中，会涉及内核栈的分配，内核的进程管理的代码会将内核栈创建在 3G 至 3G+896M 的虚拟空间中，当然也就会被放在物理内存里面的前 <code>896M</code> 里面，相应的页表也会被创建。</p><h4 id="辨析-高端内存" tabindex="-1"><a class="header-anchor" href="#辨析-高端内存" aria-hidden="true">#</a> 辨析: 高端内存</h4><p><code>896M</code> 这个值在内核中被定义为 <code>high_memory</code>，在此之上常称为“<code>高端内存</code>”。这是个很笼统的说法，到底是虚拟内存的 3G+896M 以上的是高端内存，还是物理内存 896M 以上的是高端内存呢？</p><p>这里仍然需要辨析一下，高端内存是<strong>物理内存的概念</strong>。它仅仅是内核中的内存管理模块看待物理内存的时候的概念。前面我们也说过，<strong>在内核中，除了内存管理模块直接操作物理地址之外</strong>，内核的其他模块，仍然要操作虚拟地址，<strong>而虚拟地址是需要内存管理模块分配和映射好的</strong>。</p><h4 id="举个例子" tabindex="-1"><a class="header-anchor" href="#举个例子" aria-hidden="true">#</a> 举个例子</h4><p>假设咱们的电脑有 2G 内存，现在如果内核的其他模块想要访问物理内存 1.5G 的地方，应该怎么办呢？如果你觉得，我有 32 位的总线，访问个 2G 还不小菜一碟，这就错了。</p><p>首先，你不能使用物理地址。你需要使用内存管理模块给你分配的虚拟地址，但是虚拟地址的 0 到 3G 已经被用户态进程占用去了，你作为内核不能使用。因为你写 1.5G 的虚拟内存位置，一方面你不知道应该根据哪个进程的页表进行映射；另一方面，就算映射了也不是你真正想访问的物理内存的地方，所以你发现你作为内核，能够使用的虚拟内存地址，只剩下 1G 减去 896M 的空间了。(意思是这 896M 是铁定需要的无法将就)</p><h3 id="_2-8m-留出空白" tabindex="-1"><a class="header-anchor" href="#_2-8m-留出空白" aria-hidden="true">#</a> 2 [8M] 留出空白</h3><p>于是，我们可以将剩下的虚拟内存地址分成下面这几个部分。</p><p>在 896M 到 VMALLOC_START 之间有 <code>8M</code> 的空间。</p><h3 id="_3-动态映射空间-vmalloc-内核堆" tabindex="-1"><a class="header-anchor" href="#_3-动态映射空间-vmalloc-内核堆" aria-hidden="true">#</a> 3 动态映射空间 vmalloc [内核堆?]</h3><p>VMALLOC_START 到 VMALLOC_END 之间称为内核**<code>动态映射空间</code><strong>，也即内核想像用户态进程一样 malloc 申请内存，在内核里面可以使用 <code>vmalloc</code>。假设物理内存里面，896M 到 1.5G 之间已经被用户态进程占用了，并且映射关系放在了进程的页表中，内核 vmalloc 的时候，只能从分配物理内存 1.5G 开始，就需要使用</strong>这一段的虚拟地址<strong>进行映射，映射关系放在</strong>专门给内核自己用的页表**里面。</p><h3 id="_4-持久内核映射-kmap-内核共享库映射" tabindex="-1"><a class="header-anchor" href="#_4-持久内核映射-kmap-内核共享库映射" aria-hidden="true">#</a> 4 持久内核映射 kmap [内核共享库映射?]</h3><p>PKMAP_BASE 到 FIXADDR_START 的空间称为**<code>持久内核映射</code>**。使用 alloc_pages() 函数的时候，在物理内存的高端内存得到 struct page 结构，可以调用 <code>kmap</code> 将其映射到这个区域。</p><h3 id="_5-固定映射区域-kmap-atomic-临时内核映射" tabindex="-1"><a class="header-anchor" href="#_5-固定映射区域-kmap-atomic-临时内核映射" aria-hidden="true">#</a> 5 固定映射区域 kmap_atomic 临时内核映射</h3><p>FIXADDR_START 到 FIXADDR_TOP(0xFFFF F000) 的空间，称为**<code>固定映射区域</code>**，主要用于满足特殊需求。</p><p>在最后一个区域可以通过 <code>kmap_atomic</code> 实现<strong>临时内核映射</strong>。[之后再通过 <code>kunmap_atomic</code> 解决移交这部分映射关系数据到用户态?]</p><p>假设用户态的进程要映射一个文件到内存中，先要映射<strong>用户态进程空间</strong>的一段虚拟地址到物理内存，然后<strong>将文件内容写入</strong>这个(进程VAS对应的)物理内存供用户态进程访问。给用户态进程分配物理内存页可以通过 alloc_pages()，分配完毕后，按说将用户态进程虚拟地址和物理内存的映射关系放在<strong>用户态进程的页表</strong>中，就完事大吉了。这个时候，用户态进程可以通过用户态的虚拟地址，也即 0 至 3G 的部分，经过页表映射后访问物理内存，并不需要内核态的虚拟地址里面也划出一块来，映射到这个物理内存页。</p><p>但是如果要把文件内容写入(非进程VAS对应/另外的)物理内存，这件事情要内核来干了，这就只好通过 <code>kmap_atomic</code> 做一个临时映射，写入物理内存完毕后，再 <code>kunmap_atomic</code> 来解映射即可。</p><h2 id="_64位内核态" tabindex="-1"><a class="header-anchor" href="#_64位内核态" aria-hidden="true">#</a> 64位内核态</h2><p>32 位的内核态布局我们看完了，接下来我们再来看 64 位的内核布局。</p><p>其实 64 位的内核布局反而简单，因为虚拟空间实在是太大了，根本不需要所谓的高端内存，因为内核是 128T，根本不可能有物理内存超过这个值。</p><p>64 位的内存布局如图所示。</p><img src="`+k+'" alt="img" style="zoom:25%;"><p>64 位的内核主要包含以下几个部分。</p><h3 id="_1-8t-空档区域" tabindex="-1"><a class="header-anchor" href="#_1-8t-空档区域" aria-hidden="true">#</a> 1 [8T] 空档区域</h3><p>从 0xffff800000000000 开始就是内核的部分，只不过一开始有 8T 的空档区域。</p><h3 id="_2-64t-直接映射区-连续且简单的映射关系" tabindex="-1"><a class="header-anchor" href="#_2-64t-直接映射区-连续且简单的映射关系" aria-hidden="true">#</a> 2 [64T] 直接映射区/连续且简单的映射关系</h3><p>从 __PAGE_OFFSET_BASE(0xffff880000000000) 开始的 64T 的虚拟地址空间是直接映射区域，也就是减去 PAGE_OFFSET 就是<strong>物理地址</strong>。虚拟地址和物理地址之间的映射在大部分情况下还是会通过建立页表的方式进行映射。</p><h3 id="_3-1t-留出空白" tabindex="-1"><a class="header-anchor" href="#_3-1t-留出空白" aria-hidden="true">#</a> 3 [1T] 留出空白</h3><p>在 64T 到 VMALLOC_START 之间有 <code>1T</code> 的空间。</p><h3 id="_4-动态映射空间-vmalloc-内核堆" tabindex="-1"><a class="header-anchor" href="#_4-动态映射空间-vmalloc-内核堆" aria-hidden="true">#</a> 4 动态映射空间 vmalloc [内核堆?]</h3><p>从 VMALLOC_START（0xffffc90000000000）开始到 VMALLOC_END（0xffffe90000000000）的 32T 的空间是给 vmalloc 的。</p><h3 id="_5-1t-留出空白" tabindex="-1"><a class="header-anchor" href="#_5-1t-留出空白" aria-hidden="true">#</a> 5 [1T] 留出空白</h3><p>在 VMALLOC_END 到 VMEMMAP_START 之间有 <code>1T</code> 的空间。</p><h3 id="_6-1t-专区存放物理页-struct-page" tabindex="-1"><a class="header-anchor" href="#_6-1t-专区存放物理页-struct-page" aria-hidden="true">#</a> 6 [1T] 专区存放物理页 struct page</h3><p>从 VMEMMAP_START（0xffffea0000000000）开始的 1T 空间用于存放物理页面的描述结构 struct page 的。</p><h3 id="_7-512m-内核代码段、全局变量、bss-等" tabindex="-1"><a class="header-anchor" href="#_7-512m-内核代码段、全局变量、bss-等" aria-hidden="true">#</a> 7 [512M] 内核代码段、全局变量、BSS 等</h3><p>从 __START_KERNEL_map（0xffffffff80000000）开始的 512M 用于存放内核代码段、全局变量、BSS 等。这里对应到物理内存开始的位置，减去 __START_KERNEL_map 就能得到物理内存的地址。这里和<mark>直接映射区</mark>有点像，但是不矛盾，因为直接映射区之前有 8T 的空当区域，早就过了内核代码在物理内存中加载的位置。</p><blockquote><p>这部分有点额外的感觉, 因为参考32位的内核态, 其实 [内核代码段、全局变量、BSS 等] 都和直接映射区有关? anyway反正感觉是个辅助的补充</p><p>看下述的总结对比图中差异[直接映射区对应的物理内存]? 可能64位的内核空间:</p><ul><li><p>7 [512M] 内核代码段、全局变量、BSS 等: <strong><code>专门静态的存放所有</code>?</strong></p></li><li><p>2 [64T] 直接映射区/连续且简单的映射关系: 是一个区域的概念, <strong><code>可供所有其他区域数据加载进这块内存</code>?</strong>(毕竟是连续且简单的映射关系)</p></li></ul></blockquote><p>到这里内核中虚拟空间的布局就介绍完了。</p><h2 id="总结时刻" tabindex="-1"><a class="header-anchor" href="#总结时刻" aria-hidden="true">#</a> 总结时刻</h2><p>还记得咱们上一节咱们收集项目组需求的时候，我们知道一个进程要运行起来需要以下的内存结构。</p><p>用户态：</p><ul><li>代码段、全局变量、BSS</li><li>函数栈</li><li>堆</li><li>内存映射区</li></ul><p>内核态：</p><ul><li>内核的代码、全局变量、BSS</li><li>内核数据结构例如 task_struct</li><li>内核栈</li><li>内核中动态分配的内存</li></ul><p>现在这些是不是已经都有了着落？</p><p>我画了一个图，总结一下进程运行状态在 32 位下对应关系。</p><img src="'+m+'" alt="img" style="zoom:25%;"><p>对于 64 位的对应关系，只是稍有区别，我这里也画了一个图，方便你对比理解。</p><img src="'+v+'" alt="img" style="zoom:25%;"><h2 id="课堂练习" tabindex="-1"><a class="header-anchor" href="#课堂练习" aria-hidden="true">#</a> 课堂练习</h2><p>请通过命令行工具查看进程虚拟内存的布局和物理内存的布局，对照着这一节讲的内容，看一下各部分的位置。</p><p>欢迎留言和我分享你的疑惑和见解，也欢迎你收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习、进步。</p><h2 id="课后讨论" tabindex="-1"><a class="header-anchor" href="#课后讨论" aria-hidden="true">#</a> 课后讨论</h2><p>老师，之前你说过，内核态对于所有进程都是相同的，那时我就问过，这话的意思是不是说内核态内存在真实的物理内存里其实只有1份？<br> 作者回复: **是的，内核对于所有的进程，不但物理内存只有一份，虚拟内存也是只有一份。**也就是说A进程用户态访问x虚拟地址和B进程用户态访问x虚拟地址是不同的虚拟地址，也即A进程用户态在x虚拟地址里面放了一个数值w，B进程用户态的x虚拟地址看不到w，对应的也是不同的物理地址。A进程内核态访问的y虚拟地址，和B进程内核态访问的y虚拟地址，是同一个虚拟地址，也对应相同的物理地址。也即A进程内核态在y虚拟地址方一个数值n，B进程的内核态如果能够访问y虚拟地址的话，也能看到n</p><ul><li>内存管理信息在 task_struct 的 mm_struct 中</li><li>task_size 指定用户态虚拟地址大小</li><li>32 位系统：3G 用户态, 1G 内核态 <ul><li>64 位系统(只利用 48 bit 地址): 128T 用户态; 128T 内核态</li></ul></li><li>用户态地址空间布局和管理</li><li>mm_struct 中有映射页的统计信息(总页数, 锁定页数, 数据/代码/栈映射页数等)以及各区域地址 <ul><li>有 vm_area_struct 描述各个区域(代码/数据/栈等)的属性(包含起始/终止地址, 可做的操作等), 通过链表和红黑树管理</li><li>在 load_elf_bianry 时做 vm_area_struct 与各区域的映射, 并将 elf 映射到内存, 将依赖 so 添加到内存映射</li><li>在函数调用时会修改栈顶指针; malloc 分配内存时会修改对应的区域信息(调用 brk 堆; 或调用 mmap 内存映射)</li><li>brk 判断是否需要分配新页, 并做对应操作; 需要分配新页时需要判断能否与其他 vm_area_struct 合并</li></ul></li><li>内核地址空间布局和管理</li><li>所有进程看到的内核虚拟地址空间是同一个 <ul><li>32 位系统, 前 896MB 为直接映射区(虚拟地址 - 3G = 物理地址)</li><li>直接映射区也需要建立页表, 通过虚拟地址访问(除了内存管理模块) <ul><li>直接映射区组成: 1MB 启动时占用; 然后是内核代码/全局变量/BSS等,即 内核 ELF文件内容; 进程 task_struct 即内核栈也在其中</li><li>896MB 也称为高端内存(指物理内存)</li><li>剩余虚拟空间组成: 8MB 空余; 内核动态映射空间(动态分配内存, 映射放在内核页表中); 持久内存映射(储存物理页信息); 固定内存映射; 临时内存映射(例如为进程映射文件时使用)</li></ul></li><li>64 位系统: 8T 空余; 64T 直接映射区域; 32T(动态映射); 1T(物理页描述结构 struct page); 512MB(内核代码, 也采用直接映射)</li></ul></li></ul>',154),g=n("br",null,null,-1),h=n("code",null,"/proc/pid/pagemap",-1),f=n("br",null,null,-1),y=n("code",null,"/proc/kpagecount",-1),w=n("br",null,null,-1),x=n("code",null,"/proc/kpageflags",-1),T=n("br",null,null,-1),S=n("code",null,"/proc/kpagecgroup",-1),A=n("br",null,null,-1),E={href:"https://garlicspace.com/2020/04/12/linux%e8%bf%9b%e7%a8%8b%e5%86%85%e5%ad%98%e5%b8%83%e5%b1%80%e5%8f%8a%e6%98%a0%e5%b0%84%e4%bf%a1%e6%81%af/",target:"_blank",rel:"noopener noreferrer"},M=a("<p>看到这里, 我觉得我们不能太关注code问题, 应该多关注数据结构和数据结构的关系, 这样就有目标了<br> 作者回复: <strong>是的，重点关注数据结构和流程，代码作为参考</strong></p><p>刘老师，为什么内核在load用户空间的内存映射到物理页的时候要自己在内核的持久映射区也建议一个映射呢，不能使用用户空间的映射吗？这样的话，持久映射区会不会有空间不够的情况？因为这块的虚拟空间很小(&lt;1G)，如果我mmap一个很大的文件到用户空间，那很明显没办法把这个文件映射到内核的虚拟空间来呀，这块它是怎么做的呢？另外，这个过程跟load elf不是类似的么？对于用户空间的进程的代码区，数据区等，还是需要把磁盘上的页读进内存吧？这个过程也需要在内核先映射，读完之后再解除映射？<br> 作者回复: 在内核里面，得使用虚拟地址将内容读取到内存来。读一部分，映射一部分。load_elf_binary会最终调用do_mmap_pgoff，一样的</p><p>我请问下最后两张图没有看明白<br> 1 32位直接映射区为什么还保存了堆信息？不是存在vmalloc来直接分配内存的嘛？<br> 2 64位 512M 用于存放内核代码段、全局变量、BSS 等。为什么图中却只映射到代码，而是由直接映射区去映射？<br> 作者回复: 可能是图有些误解，堆在High memory区域。图中指的是<strong>数据结构都保存在<mark>直接映射区</mark>。但是<mark>vmalloc</mark>分配出来是给内核用的</strong>。<br> 内核代码，全局变量，bss都是在代码段的。其他动态生成的变量都是在直接映射区的</p><p>问个问题，假如我创建一个只有512M内存的32位的虚拟机，那岂不是所有的物理内存都是对应内核的直接映射区，用户态程序还怎么通过mmap申请内存？<br> 作者回复: <strong>直接映射区是一个区域的名称，不代表直接映射的部分把整个区域都用完，如果用不完，mmap也是可以放在这个区域里面的，只不过不是直接映射的方式访问</strong>，就像客厅叫客厅，也可以摆个床睡觉</p><p>老师，请教下，64位布局里面，为什么会有这个8T空档？另外，32位上用户进程是优先使用高端内存吗？<br> 作者回复: 设计的时候就预留的呀。如果分配堆有高端内存是会优先使用的</p><p>请问页表数据是存在哪了呢？<br> 作者回复: 内存里，特殊位置</p><p>64位系统虽然理论上可以用非常大的内存空间，但是linux系统用户空间最大只有128T可用？<br> 作者回复: 还不够呀</p><p>老师，<strong>分段管理和分页管理是共存的</strong>吗？<br> 作者回复: 是的，<strong>但是以一个为主</strong></p><p>老师，进程堆，栈，BBS，mmap，也是随机分布在内存中不是连续的吧？<br> 作者回复: 也是分页的，一页之内连续，超过一页不保证</p><p>老师，内核对于所有进程都只有一份，多进程共享这一份不会产生冲突吗？另外内核可不可以访问一个进程的用户态的虚拟地址对应的物理内存呀？<br> 网友回复：<strong>内核空间是共享的，但是明确到每个task的内存空间是彼此独立的，不会有冲突</strong></p><p>要分清楚内存分配，以及线程和task；<br><strong>内核态只有task哦，没有进程概念，进程是只有用户态才有的</strong>；用户态有线程pthread，只有需要调用内核态功能的时候，才会通过系统调用生成task完成调用任务；<br> 不过内存分配方面，则是在创建进程的时候，就把用户态和内核态都分配了；</p><p>内存管理部门自己的代码和数据也需要分页分段，它是如何自己管理自己的呢? 留个痕<br> 作者回复: 后面会有页表的简述，的确有自己管理自己，比较绕</p><p>内核栈在哪呢？<br> 作者回复: 内核的虚拟地址空间</p><p>老师，我想问下文中描述的是虚拟内存的布局，即使物理地址比较小，比如32位系统小于4g，于进程而言使用的还是4g的虚拟地址？但现在如果物理内存小于896M，这样物理内存大小小于内核态中直接一对一映射区域的大小，这种linux怎么处理？<br> 作者回复: <strong>内存的分配就在直接映射区了</strong>。</p><p>请问 __randomize_layout 是让 struct 结构变量在编译时候 里面熟悉不按默认的定义顺序存储么？<br> 作者回复: <strong>在编译的时候，结构体的数据存放不会按照声明顺序，而是根据函数名以及随机种子，打乱存储顺序</strong>。</p><p>老师，局部变量是在进程的栈里，它在可执行文件ELF的哪里呢？<br> 作者回复: 局部变量不在可执行文件中，<strong>可执行文件中只有编译阶段就知道值的哪些静态变量啊，全局变量</strong>啊</p>",16);function G(F,L){const e=p("ExternalLinkIcon");return o(),c("div",null,[b,n("p",null,[s("可以通过以下文件查看虚拟内存与物理内存映射关系"),g,s(" -"),h,f,s(" -"),y,w,s(" -"),x,T,s(" -"),S,A,n("a",E,[s("笔记"),l(e)])]),M])}const V=t(_,[["render",G],["__file","I22-进程空间管理.html.vue"]]);export{V as default};
