import{_ as n}from"./640-edc8dc9c.js";import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o,c as s,a as e,b as a,e as d,d as c}from"./app-cdabc73c.js";const p="/assets/640-1691476446813-1-cf791f13.png",h="/assets/640-1691476446813-2-c772ba7d.png",P="/assets/640-1691476446813-3-f4f699b1.png",_={},l=e("h1",{id:"_33-白泽带你读论文丨code-reuse-attacks-in-php-automated-popchaingeneration",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_33-白泽带你读论文丨code-reuse-attacks-in-php-automated-popchaingeneration","aria-hidden":"true"},"#"),a(" 33-白泽带你读论文丨Code Reuse Attacks in PHP: Automated POPChainGeneration")],-1),g=e("h1",{id:"code-reuse-attacks-in-php-automated-pop-chain-generation",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#code-reuse-attacks-in-php-automated-pop-chain-generation","aria-hidden":"true"},"#"),a(),e("strong",null,"Code Reuse Attacks in PHP: Automated POP Chain Generation")],-1),u=e("p",null,"论文链接：",-1),f={href:"https://www.ei.ruhr-uni-bochum.de/media/emma/veroeffentlichungen/2014/09/10/POPChainGeneration-CCS14.pdf",target:"_blank",rel:"noopener noreferrer"},O=c('<p>这篇文章选自CCS 2014，第一作者为Johannes Dahse。</p><h2 id="_1-背景介绍" tabindex="-1"><a class="header-anchor" href="#_1-背景介绍" aria-hidden="true">#</a> <strong>1 背景介绍</strong></h2><p>代码重用攻击是利用已有的代码片段构造攻击，而不需要注入恶意代码，这种攻击方式在PHP应用中也很常见。早在2009年，Stefan Esser就提出了PHP代码重用攻击的可行方法。本文主要解决了利用PHP对象注入（PHP Object Injection，以下简称POI）漏洞生成POP（Property-Oriented Programming）链的过程。</p><figure><img src="'+n+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>POI漏洞生成过程如上图所示。主要有两个步骤，一个是POI，一个是生成POP链。用户的输入经过反序列化，就完成了POI。接下来对这个对象的利用会引起一系列的调用关系，我们把被利用的代码片段称为“gadget”，从一个gadget跳到另一个gadget，就形成了gadget链。一条gadget链可以有一个或多个gadget，链的终点触发一个敏感操作，形成漏洞。</p><h2 id="_1-1-反序列化" tabindex="-1"><a class="header-anchor" href="#_1-1-反序列化" aria-hidden="true">#</a> <strong>1.1 反序列化</strong></h2><p>反序列化是PHP中的一个函数，它的逆过程为序列化。序列化就是使用serialize()将对象的用字符串的方式进行表示，反序列化是使用unserialize()将序列化的字符串构造成相应的对象，反序列化是序列化的逆过程。这两个操作的作用是：将对象的状态通过数值和字符记录下来，以某种存储形式使自定义对象持久化，方便需要时候将对象进行恢复使用，用于对象的传递以及使程序代码更具维护性。攻击者常常可以通过构造特殊字符串，注入恶意对象，从而触发漏洞。</p><h2 id="_1-2-魔法方法" tabindex="-1"><a class="header-anchor" href="#_1-2-魔法方法" aria-hidden="true">#</a> <strong>1.2 魔法方法</strong></h2><p>魔法方法是PHP中的一类特殊函数，它们的函数名都以“__”开头，比如__construct()、 __destruct()。魔法方法一共有15个，它们会在两种情况下被自动调用：</p><ol><li>一个对象被反序列化时。例如__destruct()和__wakeup()魔法方法。</li><li>某些函数被调用时或某些事件发生时。例如isset()函数被调用时，__isset()魔法方法就会被调用。</li></ol><p>由于魔法方法会被自动调用，我们在分析POP链的时候就必须考虑他们。</p><h2 id="_2-实验方法" tabindex="-1"><a class="header-anchor" href="#_2-实验方法" aria-hidden="true">#</a> <strong>2 实验方法</strong></h2><p>首先对PHP代码进行静态分析，接下来找POI漏洞，紧接着通过POI漏洞反推POP链，最终输出结果为POI漏洞和构造出来的POP链。本文的重点在构造POP链，最大的分析难点在于对面向对象（Object-Oriented Programming，简称OOP）的代码进行建模。这就要求我们不能对代码块进行独立的分析，而要考虑它们之间的调用关系。作者对此提出的解决方案是：通过前向数据传播协助后向数据流分析。</p><p>OOP分析可以分为三种类型：</p><ol><li>对象敏感的分析</li></ol><p>目的是标记对象。作者扩展了以往工作中对数据的标记方式，在Value、Variable、ArrayFetch之外新增了“Object”标签，用于标记一个对象。每当有对象通过关键词“new”被生成时，这个对象就被标记为Object。部分魔法方法是对象敏感的。</p><ol start="2"><li>属性敏感的分析</li></ol><p>有时候我们难以确定一个对象属于哪个类。如下图所示的例子。</p><figure><img src="'+p+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>当obj1和obj2以参数或全局变量的形式出现的时候，我们无法立刻判定它是哪个类型的，因为此时没有对它们的声明。又或者在类的定义中，保留字$this所对应的是哪个对象我们也无法确定。这个时候我们就把这些“信息不全”的对象及它的属性储存下来，包括属性的个数和类型，如果它还调用了函数，那么这个函数的参数个数和类型也要被保存下来。同样地，部分魔法方法是属性敏感的。</p><ol start="3"><li>进程间分析</li></ol><p>目的是确定接收方的类型以调用对正确方法的分析。继续用上图做例子，解决方法是：通过在所有类定义中搜索名为method1（）的可用方法来确定$ obj1是哪个类型。但是需要注意的是，在比较方法名称、参数类型和个数的情况下，确实可能出现有多个符合要求的method1()都能被调用的情况。如果这时我们发现在其中一个method1()中，存在敏感的操作，那么攻击者就可以利用这一点发起攻击。同样地，部分魔法方法是调用敏感的，例如__call()。</p><h2 id="_3-实验结果" tabindex="-1"><a class="header-anchor" href="#_3-实验结果" aria-hidden="true">#</a> <strong>3 实验结果</strong></h2><p>本文选取了10个现有的CVE（均为POI漏洞）来验证工具的可靠性。选取的这10个CVE都满足几个要求：有漏洞的应用版本必须仍能被找到；代码量必须多于4万行，且主要是面向对象的代码；应用中不能有第三方的插件或框架，POI漏洞能在应用本身构造出POP链。</p><figure><img src="'+h+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>实验结果如上图。在10个有CVE的应用程序中，该工具检测出来8个，并在每个应用中检测到至少一个POI。对于其中4个应用程序，该工具发现了至少一个以前的CVE中未包含的新的POI漏洞。该工在6个应用程序中检测到了gadget链，并且检测到了以前未知的28个小工具链。</p><p>实验结果中也出现了没能检测出已有漏洞或者误报的情况，作者对这些问题进行了分析：</p><p>对于POI检测：该工具未检测到Open Web Analytics和Wordpress中的POI漏洞。对Open Web Analytics分析不到位的根本原因是对反射的分析不足，这在静态分析领域是一个未解决的问题。下图中显示了OWA中POI简化的代码。可以看到，对用户输入的每次访问都是通过第5行中定义的静态方法getRequestParam()执行的。该方法通过第6行中的类class Factory()来获取新对象。并在request属性上调用方法getParam()作为接收者。因为在classFactory()中使用的方法factory()在内部使用反射，所以工具在分析时缺失了关于第6行分配给$ service的对象的信息。它的属性在factory中的动态对象构建期间填充。</p><figure><img src="'+P+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>Wordpress中的假阴性是由于二级数据流（second-order data flow）出现：有关用户的元数据存储在数据库中，然后在反序列化之前先加载到缓存中。数据库查询是动态构建的，不能被该工具完全重建以识别数据流。</p><p>对于POP链的构建：动态的类调用造成了10次误报。有的应用中出现了假阴性原因是该工具未能精确分析动态OOP功能。</p><h2 id="_4-总结" tabindex="-1"><a class="header-anchor" href="#_4-总结" aria-hidden="true">#</a> <strong>4 总结</strong></h2><p>本文完成了从POI漏洞出发自动化构造POP链的操作，解决了面向对象的PHP代码分析建模问题。工具能完成对多数已知漏洞的检测，说明可靠性较高；但也有该工具无法检测出的POI漏洞，因为该工具还具有一定局限性，比如无法解决动态构建的对象或数据库查询问题，作者认为未来的工作中可以着重解决这类问题。</p>',33);function m(b,C){const t=i("ExternalLinkIcon");return o(),s("div",null,[l,g,u,e("p",null,[e("a",f,[a("https://www.ei.ruhr-uni-bochum.de/media/emma/veroeffentlichungen/2014/09/10/POPChainGeneration-CCS14.pdf"),d(t)])]),O])}const y=r(_,[["render",m],["__file","33-白泽带你读论文丨Code Reuse Attacks in PHP Automated POPChainGeneration.html.vue"]]);export{y as default};
