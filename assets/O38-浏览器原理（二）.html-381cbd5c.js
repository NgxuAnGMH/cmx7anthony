import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as p,o as i,c,a,b as n,e,d as o}from"./app-cdabc73c.js";const l="/assets/5dd83a1fd9eac176c2b3950ce5c9yyff-82940d87.jpg",r="/assets/358aaf70c30a2a45146f8c3a4290a480-c1da6684.jpg",u="/assets/c13aaffaf40e8ef853ebea905ca0yy36-e5e5380b.jpg",m="/assets/c7fafe4b20d4e68d0be01421d4c09cb9-2436f6cc.jpg",d={},k=o('<h1 id="_38-浏览器原理-二-浏览器进程通信与网络渲染详解" tabindex="-1"><a class="header-anchor" href="#_38-浏览器原理-二-浏览器进程通信与网络渲染详解" aria-hidden="true">#</a> 38｜浏览器原理（二）：浏览器进程通信与网络渲染详解</h1><p>你好，我是 LMOS。</p><p>通过前面的学习，你应该对浏览器内的进程和线程已经有了一个大概的印象，也知道了为了避免一些问题，现代浏览器采用了多进程架构。</p><p>这节课，我们首先要说的是 Chrome 中的进程通信。这么多的进程，它们之间是如何进行 IPC 通信的呢？要知道，如果 IPC 通信设计得不合理，就会引发非常多的问题。</p><h2 id="chrome-如何进行进程间的通信" tabindex="-1"><a class="header-anchor" href="#chrome-如何进行进程间的通信" aria-hidden="true">#</a> Chrome 如何进行进程间的通信</h2><p>上节课我们提了一下 Chrome 进程架构，Chrome 有很多类型的进程。<em>这些进程之间需要进行数据交换</em>，其中有一个<mark>浏览器主进程</mark>，每个页面会使用一个<mark>渲染进程</mark>，每个插件会使用一个<mark>插件进程</mark>。除此之外，还有<mark>网络进程</mark>和 <mark>GPU 进程</mark>等功能性进程。</p><p>进程之间需要进程通信，</p><ol><li><mark>渲染进程</mark>和<mark>插件进程</mark>需要同<mark>网络</mark>和 <mark>GPU</mark> 等进程通信，<em>借助<u>操作系统的功能</u>来完成部分功能</em>。</li><li>其次，<u>同一类进程（如多个渲染进程）之间</u>不可以直接通信，<em>需要依赖<u>主进程</u>进行调度中转</em>。</li></ol><p>进程与进程之间的通信，也离不开操作系统的支持。在前面讲 IPC 的时候，我们了解过多种实现方式。这里我们来看看 Chrome 的源码，Chrome 中 IPC 的具体实现是通过 <mark>IPC::Channel</mark> 这个类实现的，具体在 <strong>ipc/ipc_channel.cc</strong> 这个文件中封装了实现的细节。</p><p>但是在查阅代码的过程中，我发现 Chrome 已经不推荐使用 <mark>IPC::Channel</mark> 机制进行通信了，Chrome 实现了一种新的 IPC 机制—— <mark>Mojo</mark>。</p><p>目前 IPC::Channel 底层也是基于 Mojo 来实现的，<em>但是上层接口和旧的 Chrome IPC 保持兼容</em>，IPC::Channel 这种方式即将被淘汰，所以这里我们先重点关注 Mojo，后面我们再简单了解一下 Chrome IPC 接口。</p><h3 id="_1-mojo" tabindex="-1"><a class="header-anchor" href="#_1-mojo" aria-hidden="true">#</a> 1 Mojo</h3><p>Mojo 是<u>一个跨平台 IPC 框架</u>，它源于 Chromium 项目，<u>主要用于进程间的通信</u>，ChromeOS 用的也是 Mojo 框架。</p><p>Mojo 官方文档给出的定义是这样的：</p><blockquote><p>“Mojo 是运行时库的集合，这些运行时库提供了与平台无关的通用 IPC 原语抽象、消息 IDL 格式以及具有用于多重目标语言的代码生成功能的绑定库，<em>以方便在任意跨进程、进程内边界传递消息</em>。”</p></blockquote><img src="'+l+'" alt="img" style="zoom:33%;"><p>在 Chromium 中，有两个基础模块使用 Mojo，分别是 <mark>Services</mark> 和 <mark>IPC::Channel</mark>。</p><p><mark>Services</mark> 是一种更高层次的 IPC 机制，底层通过 Mojo 来实现。<em>Chromium 大量使用这种 IPC 机制来包装各种功能服务</em>，用来取代 IPC::Channel ，比如 <mark>device 服务</mark>，<mark>performance 服务</mark>，<mark>audio 服务</mark>，<mark>viz 服务</mark>等。</p><p>Mojo 支持在<strong>多个</strong>进程之间互相通信，这一点和其他的 IPC 有很大的不同，其他 IPC 大多只支持<strong>2个</strong>进程之间进行通信。</p><ol><li>这些由 Mojo 组成的、可以互相通信的进程就形成了一个网络。</li><li>在这个网络内，任意两个进程都可以进行通信，</li><li>并且每个进程只能处于一个 Mojo 网络中，</li><li>每一个进程内部有且只有一个 Node，每一个 Node 可以提供多个 Port，每个 Port 对应一种服务，<br> 这点类似 TCP/IP 中的 IP 地址和端口的关系。<em>一个 Node:port 对可以唯一确定一个服务</em>。</li></ol><p><u>Node 和 Node 之间通过 Channel 来实现通信</u>，在不同平台上 Channel 有不同的实现方式：</p><ol><li>在 Linux 上是 Domain Socket；</li><li>在 Windows 上是 Named Pipe；</li><li>在 macOS 平台上是 Mach Port。</li></ol><p>在 Port 的上一层，Mojo 封装了 3 个“<code>应用层协议</code>”，分别为 <mark>MessagePipe</mark>，<mark>DataPipe</mark> 和 <mark>SharedBuffer</mark>（这里你是不是感觉很像网络栈，在 TCP 上封装了 HTTP）。整体结构如下图：</p><img src="'+r+`" alt="img" style="zoom:33%;"><p>我们在 Chromium 代码中使用 Mojo，是不必做 Mojo 初始化相关工作的，因为这部分 Chromium 代码已经做好了。<u>如果我们在 Chromium 之外的工程使用 Mojo，还需要做一些初始化的工作</u>，代码如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 初始化CommandLine，DataPipe 依赖它</span>
  base<span class="token operator">::</span>CommandLine<span class="token operator">::</span><span class="token function">Init</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 初始化 mojo</span>
  mojo<span class="token operator">::</span>core<span class="token operator">::</span><span class="token function">Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 创建一个线程，用于Mojo内部收发数据</span>
  base<span class="token operator">::</span>Thread <span class="token function">ipc_thread</span><span class="token punctuation">(</span><span class="token string">&quot;ipc!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  ipc_thread<span class="token punctuation">.</span><span class="token function">StartWithOptions</span><span class="token punctuation">(</span>
    base<span class="token operator">::</span>Thread<span class="token operator">::</span><span class="token function">Options</span><span class="token punctuation">(</span>base<span class="token operator">::</span>MessageLoop<span class="token operator">::</span>TYPE_IO<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 初始化 Mojo 的IPC支持，只有初始化后进程间的Mojo通信才能有效  </span>
  <span class="token comment">// 这个对象要保证一直存活，否则IPC通信就会断开  </span>
  mojo<span class="token operator">::</span>core<span class="token operator">::</span>ScopedIPCSupport <span class="token function">ipc_support</span><span class="token punctuation">(</span>
      ipc_thread<span class="token punctuation">.</span><span class="token function">task_runner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      mojo<span class="token operator">::</span>core<span class="token operator">::</span>ScopedIPCSupport<span class="token operator">::</span>ShutdownPolicy<span class="token operator">::</span>CLEAN<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li><mark>MessagePipe</mark> 用于进程间的双向通信，类似 UDP，消息是基于数据报文的，底层使用 Channel 通道；</li><li><mark>SharedBuffer</mark> 支持双向块数据传递，底层使用系统 Shared Memory 实现；</li><li><mark>DataPipe</mark> 用于进程间单向块数据传递，类似 TCP，消息是基于数据流的，底层使用系统的 Shared Memory 实现。</li></ol><p>一个 MessagePipe 中有一对 handle，分别是 handle0 和 handle1，MessagePipe 向其中一个 handle 写的数据可以从另外一个 handle 读出来。如果把其中的一个 handle 发送到另外一个进程，这一对 handle 之间依然能够相互收发数据。</p><p>Mojo 提供了多种方法来发送 handle 到其他的进程，其中最简单的是使用 Invitation。要在多个进程间使用 Mojo，必须先通过 Invitation 将这些进程“连接”起来，这需要一个进程发送 Invitation，另一个进程接收 Invitation。</p><p>发送 Invitation 的方法如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// 创建一条系统级的IPC通信通道</span>
<span class="token comment">// 在Linux上是 Domain Socket, Windows 是 Named Pipe，macOS是Mach Port，该通道用于支持跨进程的消息通信</span>
mojo<span class="token operator">::</span>PlatformChannel channel<span class="token punctuation">;</span>
<span class="token function">LOG</span><span class="token punctuation">(</span>INFO<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;local: &quot;</span>
          <span class="token operator">&lt;&lt;</span> channel<span class="token punctuation">.</span><span class="token function">local_endpoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">platform_handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GetFD</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
          <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; remote: &quot;</span>
          <span class="token operator">&lt;&lt;</span> channel<span class="token punctuation">.</span><span class="token function">remote_endpoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">platform_handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GetFD</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
mojo<span class="token operator">::</span>OutgoingInvitation invitation<span class="token punctuation">;</span>
<span class="token comment">// 创建1个Ｍessage Pipe用来和其他进程通信</span>
<span class="token comment">// 这里的 pipe 就相当于单进程中的pipe.handle0</span>
<span class="token comment">// handle1 会被存储在invitation中，随后被发送出去</span>
<span class="token comment">// 可以多次调用，以便Attach多个MessagePipe到Invitation中</span>
mojo<span class="token operator">::</span>ScopedMessagePipeHandle pipe <span class="token operator">=</span>
    invitation<span class="token punctuation">.</span><span class="token function">AttachMessagePipe</span><span class="token punctuation">(</span><span class="token string">&quot;my raw pipe&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">LOG</span><span class="token punctuation">(</span>INFO<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;pipe: &quot;</span> <span class="token operator">&lt;&lt;</span> pipe<span class="token operator">-&gt;</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
base<span class="token operator">::</span>LaunchOptions options<span class="token punctuation">;</span>
base<span class="token operator">::</span>CommandLine <span class="token function">command_line</span><span class="token punctuation">(</span>
    base<span class="token operator">::</span>CommandLine<span class="token operator">::</span><span class="token function">ForCurrentProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">GetProgram</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 将PlatformChannel中的RemoteEndpoint的fd作为参数传递给子进程</span>
<span class="token comment">// 在posix中，fd会被复制到新的随机的fd，fd号改变</span>
<span class="token comment">// 在windows中，fd被复制后会直接进行传递，fd号不变</span>
channel<span class="token punctuation">.</span><span class="token function">PrepareToPassRemoteEndpoint</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>options<span class="token punctuation">,</span> <span class="token operator">&amp;</span>command_line<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 启动新进程</span>
base<span class="token operator">::</span>Process child_process <span class="token operator">=</span> base<span class="token operator">::</span><span class="token function">LaunchProcess</span><span class="token punctuation">(</span>command_line<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>
channel<span class="token punctuation">.</span><span class="token function">RemoteProcessLaunchAttempted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 发送Invitation</span>
mojo<span class="token operator">::</span>OutgoingInvitation<span class="token operator">::</span><span class="token function">Send</span><span class="token punctuation">(</span>
    std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>invitation<span class="token punctuation">)</span><span class="token punctuation">,</span> child_process<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    channel<span class="token punctuation">.</span><span class="token function">TakeLocalEndpoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    base<span class="token operator">::</span><span class="token function">BindRepeating</span><span class="token punctuation">(</span>
        <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> error<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">LOG</span><span class="token punctuation">(</span>ERROR<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> error<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在新进程中接收 Invitation 的方法如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// Accept an invitation.</span>
mojo<span class="token operator">::</span>IncomingInvitation invitation <span class="token operator">=</span> mojo<span class="token operator">::</span>IncomingInvitation<span class="token operator">::</span><span class="token function">Accept</span><span class="token punctuation">(</span>
    mojo<span class="token operator">::</span>PlatformChannel<span class="token operator">::</span><span class="token function">RecoverPassedEndpointFromCommandLine</span><span class="token punctuation">(</span>
        <span class="token operator">*</span>base<span class="token operator">::</span>CommandLine<span class="token operator">::</span><span class="token function">ForCurrentProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 取出 Invitation 中的pipe</span>
mojo<span class="token operator">::</span>ScopedMessagePipeHandle pipe <span class="token operator">=</span>
    invitation<span class="token punctuation">.</span><span class="token function">ExtractMessagePipe</span><span class="token punctuation">(</span><span class="token string">&quot;my raw pipe&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">LOG</span><span class="token punctuation">(</span>INFO<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;pipe: &quot;</span> <span class="token operator">&lt;&lt;</span> pipe<span class="token operator">-&gt;</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面使用 Mojo 的方法是通过读写原始的 buffer ，还是比较原始的。</p><p>Chromium 里面使用了更上层的 bindings 接口来进行 IPC 通信。它先定义了一个 mojom 的接口文件，然后生成相关的接口 cpp 代码。发送方调用 cpp 代码接口，接收方去实现 cpp 代码接口。这种用法类似 <mark>Protocol Buffers</mark>。</p><p>我们不需要显式地去建立进程间的 IPC 连接，因为这些 Chromium 代码已经做好了。Chromium 的每个进程都有一个 Service Manage，它管理着多个 Service。每个 Server 又管理着多个 Mojo 接口。在 Chromium 中，我们只需要定义 Mojo 接口，然后在恰当的地方去注册接口、实现接口即可。</p><h3 id="_2-legacy-ipc" tabindex="-1"><a class="header-anchor" href="#_2-legacy-ipc" aria-hidden="true">#</a> 2 legacy IPC</h3>`,37),v={href:"https://source.chromium.org/chromium/chromium/src/+/main:ipc/ipc_message_start.h;bpv=1;bpt=0",target:"_blank",rel:"noopener noreferrer"},h=a("p",null,"后面这张图是官方的经典图解：",-1),b=a("img",{src:u,alt:"img",style:{zoom:"33%"}},null,-1),g={href:"https://www.chromium.org/developers/design-documents/multi-process-architecture/",target:"_blank",rel:"noopener noreferrer"},C=o('<p>我们看到：每个 Render 进程都有一条 Legacy IPC 通过 Channel 和 Browser 连接，ResourceDispacher 通过 Filter 同 Channel 进行连接。IPC 里面有几个重要的概念：</p><ol><li><p>IPC::Channel：一条数据传输通道，提供了数据的发送和接收接口；</p></li><li><p>IPC::Message：在 Channel 中传输的数据，主要通过宏来定义新的 Message；</p></li><li><p>IPC::Listener：提供接收消息的回调，创建 Channel 必须提供一个 Listener；</p></li><li><p>IPC::Sender：提供发送 IPC::Message 的 Send 方法，IPC::Channel 就实现了 IPC::Sender 接口；</p></li><li><p>IPC::MessageFilter：也就是 Filter，用来对消息进行过滤，类似管道的机制，它所能过滤的消息必须由其他 Filter 或者 Listener 传给它；</p></li><li><p>IPC::MessageRouter：一个用来处理 Routed Message 的类。</p></li></ol><hr><p>Legacy IPC 的本质就是<strong>通过 IPC::Channel 接口发送 IPC::Message</strong>，<mark>IPC::Channel</mark> 是封装好的类，<mark>IPC::Message</mark> 需要用户自己定义。</p><p>IPC::Message 有两类，<u>一类是路由消息</u> “routed message”，<u>一类是控制消息</u> “control message”。</p><p>唯一不一样的就是 routing_id() 不同，每一个 IPC::Message 都会有一个 routing_id，控制消息的 routing_id 始终是 MSG_ROUTING_CONTROL ，这是一个常量。除此之外，所有 routing_id 不是这个常量的消息，都是路由消息。</p><h2 id="网页渲染的流程" tabindex="-1"><a class="header-anchor" href="#网页渲染的流程" aria-hidden="true">#</a> 网页渲染的流程</h2><p>前面我们讲了浏览器的架构，进程 / 线程模型以及浏览器内的 IPC 通信实现，有了这些铺垫，我们再来理解浏览器内部的进程模型的工作机制，就更容易了。<em>进程通信会伴随着网络渲染的过程</em>，所以，我推荐你从实际的渲染过程来观察，也就是<em>搞明白浏览器是怎么借助计算机进行页面图像渲染的</em>。</p>',8),_=a("mark",null,"浏览器的网络进程",-1),f=a("mark",null,"操作系统内核网络栈",-1),P={href:"https://time.geekbang.org/column/article/402840",target:"_blank",rel:"noopener noreferrer"},M=a("em",null,"浏览器收到响应后的渲染过程",-1),I=o('<ol><li>在浏览器启动后，浏览器会通过监听系统的某个指定端口号，监听数据的变化。</li><li>在浏览器收到网络数据包后，会根据返回的 <strong>Content-Type 字段</strong> 决定后续的操作， <ol><li>如果是 <strong>HTML</strong>，那么浏览器则会进入渲染的流程。</li></ol></li><li>在渲染过程中，主要工作交由<mark>渲染进程</mark>处理，我们可以简要分为几个部分： <ol><li>建立数据传输管道、</li><li>构建 DOM 树、</li><li>布局阶段、</li><li>绘制以及合成渲染。</li></ol></li></ol><p>下面，我们分别进行讲解。</p><h3 id="_1-与网络进程-建立数据传输管道" tabindex="-1"><a class="header-anchor" href="#_1-与网络进程-建立数据传输管道" aria-hidden="true">#</a> 1 与网络进程：建立数据传输管道</h3><p>当网络进程接收到网络上出来的 HTML 数据包的时候，渲染进程不会等网络进程完全接受完数据，才开始渲染流程。为了提高效率，<em>渲染进程会一边接收一边解析</em>。所以，<mark>渲染进程</mark>在收到主进程准备渲染的消息后，<em>会使用 Mojo 接口</em>，通过边解析边接收数据的方式，和<mark>网络进程</mark>进行 <u>IPC 通信，建立数据传输的管道</u>，将数据提交到<mark>渲染进程</mark>。</p><h3 id="_2-构建-dom-树-html-css-js" tabindex="-1"><a class="header-anchor" href="#_2-构建-dom-树-html-css-js" aria-hidden="true">#</a> 2 构建 DOM 树：HTML-CSS-JS</h3><p><mark>渲染进程</mark>收到的是 HTML 的字符串，是一种无法进程结构化操作的数据，于是我们需要将纯文本转为一种容易操作、有结构的数据 —— <mark>DOM 树</mark>。</p><p>DOM 树本质上是一个以 document 为根节点的<mark>多叉树</mark>，DOM 树是结构化、易操作的，同样浏览器也会提供接口给到开发者，<u>浏览器通过 JS 语言来操作 DOM 树</u>，这样就可以动态修改页面内容了。</p><p><mark>在渲染进程的主线程内部</mark>，存在一个叫 <mark>HTML 解析器</mark>（HTMLParser）的东西，想要将文本解析为 DOM ，离不开它的帮助。<mark>HTML 解析器</mark>会将 <em>HTML 的字节流</em>，通过分词器转为 <em>Token 流</em>，<u>其中维护了一个栈结构，通过不断的压栈和出栈，生成对应的节点，最终生成 DOM 结构</u>。</p><p>在 DOM 解析的过程中当解析到 <code>&lt;script&gt; 标签</code>时，它会暂停 HTML 的解析，等到==渲染进程中的 JS引擎（JS线程）==加载、解析和执行 JavaScript 代码完成后，<strong>才会继续解析</strong>。</p><ol><li>在 JS 解析的过程中，JS 是可能进行 CSS 操作的，<br><em>所以在执行 JS 前还需要解析引用的 CSS 文件</em>，生成 <mark>CSSOM</mark> 后，才能进行 JS 的解析。</li><li>CSSOM 是 DOM 树中每个节点的具体样式和规则对应的树形结构，<br> 在构建完 CSSOM 后，要先进行 JS 的解析执行，<em>然后再进行 DOM 树的构建</em>。</li></ol><blockquote><p>【上面两都是一个意思】<br> 字节流 HTML 转 Token -&gt;<br> 处理 CSS 成 CSSOM -&gt;<br> 解析执行 JavaScript 得到完整的 DOM树 结构。</p></blockquote><h3 id="_3-布局阶段-——-layout-遍历dom计算" tabindex="-1"><a class="header-anchor" href="#_3-布局阶段-——-layout-遍历dom计算" aria-hidden="true">#</a> 3 布局阶段 —— layout：遍历DOM计算</h3><p>这时已经构建完 DOM 树和 CSSOM 树，但是还是无法渲染，因为目前渲染引擎拿到的只是一个树形结构，<em>并不知道具体在浏览器中渲染的具体位置</em>。</p><p>布局就是寻找元素几何形状的过程，具体就是主线程<strong>遍历 DOM 和计算样式</strong>，并创建包含 xy 坐标和边界框大小等信息的布局树。</p><p>布局树可能类似于 DOM 树的结构，但它只包含与页面上可见内容相关的信息。比如说，布局树构建会剔除掉内容，这些内容虽然在 DOM 树上但是不会显示出来，如属性为：<code>display: none</code>的元素；其次，布局树还会计算出布局树节点的具体坐标位置。</p><h3 id="_4-绘制-处理层级得到layertree" tabindex="-1"><a class="header-anchor" href="#_4-绘制-处理层级得到layertree" aria-hidden="true">#</a> 4 绘制：处理层级得到LayerTree</h3><p>渲染进程拿到布局树已经有具体节点的具体位置，但是还缺少一些东西，<em>就是层级</em>。我们知道，页面是类似 PS 的图层，是有图层上下文顺序的，而且还有一些 3D 的属性，浏览器内核还需要处理这些专图层，并生成一棵对应的<mark>图层树（LayerTree）</mark>。</p><p>有了图层的关系，就可以开始准备绘制了，渲染进程会拆分出多个小的绘制指令，然后组装成一个有序的待绘制列表。</p><h3 id="_5-合成渲染-合成线程产出位图" tabindex="-1"><a class="header-anchor" href="#_5-合成渲染-合成线程产出位图" aria-hidden="true">#</a> 5 合成渲染：合成线程产出位图</h3><p>从硬件层面看，渲染操作是由显卡进行的，于是浏览器将具体的绘制动作，转化成待绘制指令列表。</p><p>浏览器渲染进程中的<mark>合成线程</mark>，会将数据传输到栅格化线程池，从而实现图块的栅格化，最终把生成图块的指令发送给 GPU。然后，在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中。</p><p>此时显示器会根据显示器的刷新率，定期从显卡的内存中读取数据。这样，图像就可以正常显示，被我们看到了。</p><p>浏览器渲染的流程比较复杂，其中的细节也比较多，如果要详细分析，还可以拆成一篇超长篇幅，所以这里我们只是了解简单过程。你如果想要了解完整过程，可以阅读拓展材料中的 Chrome 开发者的官方博客。</p><h2 id="chromium-的文件结构解析" tabindex="-1"><a class="header-anchor" href="#chromium-的文件结构解析" aria-hidden="true">#</a> Chromium 的文件结构解析</h2><p>前面课程里，我们通过一些概念和例子简单了解了 WebKit 和 Chromium 的架构，不过这两者是非常庞大的项目，代码量也是非常的巨大，除去其中依赖的第三方库，<u>这两个项目的代码量都是百万级别的</u>，如果直接阅读的话是非常困难的。</p><p>但是良好的代码组织结构，很好地帮助了开发者和学习者们。下面我大致介绍一下它们的目录结构及其用处，方便你快速地理解整个项目。</p>',26),S={href:"https://github.com/chromium/chromium",target:"_blank",rel:"noopener noreferrer"},j={href:"https://github.com/chromium/chromium",target:"_blank",rel:"noopener noreferrer"},O=o(`<div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>├── android_webview - 安卓平台webview的 \`src/content\`  目录所需要的接口
├── apps - chrome打包 apps 的代码
├── base - 基础工具库，所有的子工程公用
├── build  - 公用的编译配置
├── build_overrides // 
├── cc - 合成器
├── chrome - chrome 相关的稳定版本实现比如渲染进程中的某些API 的回调函数和某些功能实现
  ├── app - 程序入口
  ├── browser - 主进程
  ├── renderer - 渲染进程
  ...
├── chromecast
├── chromeos - chromeos 相关
├── components - content层调用的一些组件模块；
├── content - 多进程模型和沙盒实现的代码
  ├── app - contentapi 的部分 app 接口
  ├── browser - 主进程的实现
  ├── common - 基础公共库
  ├── gpu - gpu 进程实现
  ├── ppapi_plugin - plugin  进程实现
  ├── public - contentapi 接口
  ├── renderer - 渲染进程实现
  ...
├── courgette
├── crypto - 加密相关
├── device - 硬件设备的api抽象层
├── docs - 文档
├── gpu - gpu 硬件加速的代码
├── headless - 无头模式，给 puppeteer 使用
├── ipc - ipc 通信的实现，包括 mojo 调用和 ChromeIPC
├── media - 多媒体相关的模块
├── mojo - mojo 底层实现
├── native_client_sdk
├── net - 网络栈相关
├── pdf - pdf 相关
├── ppapi - ppapi 代码
├── printing - 打印相关
├── sandbox - 沙箱项目，安全用防止利用漏洞攻击操作系统和硬件
├── services
├── skia - Android 图形库，直接从 Android 代码树中复制过来的
├── sql - 本地数据库实现
├── storage - 本地存储实现
├── third_party - 三方库
  ├── Webkit
  ...
├── tools
├── ui - 渲染布局的基础框架
├── url - url 解析和序列化
└── v8 - V8 引擎
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="重点回顾" tabindex="-1"><a class="header-anchor" href="#重点回顾" aria-hidden="true">#</a> 重点回顾</h2><p>今天，我们学习了 Chrome 下的多进程之间的协作方式。</p><ul><li>老版本的 Chrome 使用 <mark>Legacy IPC</mark> 进行 IPC 通信，<br> 它的本质就是<u>通过 IPC::Channel 接口发送 IPC::Message</u>。</li><li>而新版本的 Chrome 使用了 <mark>Mojo</mark> 进行 IPC 通信，<br> Mojo 是源于 <u>Chrome 的 IPC 跨平台框架</u>。</li><li>Chrome 在不同的操作系统下的 <mark>IPC 实现方式</mark>有所不同， <ul><li>在 Linux 上是 Domain Socket，</li><li>Windows 是 Named Pipe，</li><li>macOS 是 Mach Port。</li></ul></li></ul><p>之后，我们通过网页渲染的例子深入了解了，不同进程之间如何协作来进行渲染。最后我给你列举了 Chrome 项目的基本目录结构，如果你对其感兴趣，可以自行下载源码，深入探索。</p><p>这节课的导图如下，供你参考：</p><figure><img src="`+m+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="扩展阅读" tabindex="-1"><a class="header-anchor" href="#扩展阅读" aria-hidden="true">#</a> 扩展阅读</h2><p>浏览器是一个极为庞大的项目，仅仅通过两节课的内容，想要完全了解浏览器的特性是不太可能的。希望这两节课能抛砖引玉，更多的内容需要你自己去进行探索。</p><p>这里我为你整理了一些参考资料，如果你能够认真阅读，相信会获得意想不到的收获。</p>',10),L={href:"https://www.chromium.org/developers/design-documents/",target:"_blank",rel:"noopener noreferrer"},y={href:"https://developer.chrome.com/blog/inside-browser-part1/#which-process-controls-what",target:"_blank",rel:"noopener noreferrer"},x={href:"https://chromium.googlesource.com/chromium/src/+/master/mojo/README.md",target:"_blank",rel:"noopener noreferrer"},D={href:"https://book.douban.com/subject/25910556",target:"_blank",rel:"noopener noreferrer"},w=o('<h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题" aria-hidden="true">#</a> 思考题</h2><p>为什么 JS 代码会阻塞页面渲染？从浏览器设计的角度看，浏览器可以做哪些操作来进行优化？在开发前端应用过程中又可以做哪些优化呢？</p><p>欢迎你在留言区和我交流讨论。如果这节课对你有启发，别忘了分享给身边更多朋友。</p><blockquote><p>浏览器无法知道JS代码会对DOM和CSSDOM操作什么，所以要等JS执行完再渲染页面。尽量把<code>&lt;script/&gt;</code>放在HTML最后执行，对用户来说可能体验好一点。<br> 作者回复: 好的</p><hr><p>由于cpu（单核），始终实时只能指向一个栈的入口（可以切换不同的栈）<br> 对于浏览器来说，由于网络重要数据存放在内存条上。需要通过链表的形式来引导cpu在不同栈中切换！也就是说链表存放的内存所在位置会被反复的引用（cpu访问）<br> 那么浏览器可以优化的部分，就是可以制定一个统一的接口标准，方便不同网页的插件进行应用。从而更好的通过数据分流，既流畅也用得舒服的 啊<br> 作者回复: 嗯嗯</p></blockquote>',4);function T(q,N){const s=p("ExternalLinkIcon");return i(),c("div",null,[k,a("p",null,[n("说完 Mojo，我还想带你简单看一下 legacy IPC。虽然它已经被废弃掉，但是目前还有不少逻辑仍在使用它，你可以"),a("a",v,[n("在这里"),e(s)]),n("看到目前还在使用它的部分，都是一些非核心的消息。所以，我们还是要大致理解这种用法。")]),h,b,a("p",null,[n("图片来源 "),a("a",g,[n("https://www.chromium.org/developers/design-documents/multi-process-architecture/"),e(s)])]),C,a("p",null,[n("浏览器接收到用户在地址栏输入的 URL 以后，"),_,n("会利用"),f,n("进行资源获取。在第一季的网络篇，我们曾经用了一节课的时间讲解"),a("a",P,[n("网络数据包是在网络中如何流转的"),e(s)]),n("。如果你想要详细了解，可以去看看。这里我们着重关注"),M,n("。")]),I,a("p",null,[n("因为里面的一二级目录非常多和深，所以我们把焦点放在核心的部分即可。我们可以通过 "),a("a",S,[n("GitHub"),e(s)]),n(" 将 Chromium 的源码下载下来阅读，但是源码非常大，如果你不想下载，可以通过 "),a("a",j,[n("这个链接 访问在线版本"),e(s)]),n("。")]),O,a("ol",null,[a("li",null,[n("首先是 Chromium "),a("a",L,[n("官方的设计文档"),e(s)]),n("，包含了 Chromium and Chromium OS 的设计思维以及对应源码。")]),a("li",null,[n("其次是 Chrome "),a("a",y,[n("开发者的官方博客"),e(s)]),n("，里面的系列文章详细介绍了 Chrome 渲染页面的工作流程。")]),a("li",null,[n("还有 Mojo "),a("a",x,[n("的官方文档"),e(s)]),n("，从这里你可以了解 Mojo 的简单使用以及实现。")]),a("li",null,[n("最后就是"),a("a",D,[n("《WebKit 技术内幕》"),e(s)]),n("，这本书详细介绍了 WebKit 的渲染引擎和 JavaScript 引擎的工作原理")])]),w])}const G=t(d,[["render",T],["__file","O38-浏览器原理（二）.html.vue"]]);export{G as default};
