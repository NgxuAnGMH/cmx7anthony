import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as a,d as t}from"./app-cdabc73c.js";const p="/assets/ab92c2afb4aafb53143c471293ccb2df-b351ee83.png",e="/assets/c028381cf45d65d3f148e57408d26bd8-64adea1f.png",o={},c=t(`<h1 id="_44-socket内核数据结构-如何成立特大项目合作部" tabindex="-1"><a class="header-anchor" href="#_44-socket内核数据结构-如何成立特大项目合作部" aria-hidden="true">#</a> 44 | Socket内核数据结构：如何成立特大项目合作部？</h1><p>上一节我们讲了 Socket 在 TCP 和 UDP 场景下的调用流程。这一节，我们就沿着这个流程到内核里面一探究竟，看看在内核里面，都创建了哪些数据结构，做了哪些事情。</p><h2 id="解析-socket-函数" tabindex="-1"><a class="header-anchor" href="#解析-socket-函数" aria-hidden="true">#</a> <strong>解析 socket 函数</strong></h2><p>我们从 Socket 系统调用开始。这里面的代码比较容易看懂，</p><blockquote><p><mark>Socket 系统调用</mark>会 1. 调用 <code>sock_create</code> 创建一个 <code>struct socket</code> 结构，2. 然后通过 <code>sock_map_fd</code> 和 <code>文件描述符</code> 对应起来。</p><ol><li><code>sock_create</code>(family, type, protocol, &amp;sock)<br> 创建一个 <code>struct socket</code> 结构</li><li><code>sock_map_fd</code>(sock, flags &amp; (O_CLOEXEC | O_NONBLOCK))<br> 并和 <code>文件描述符</code> 对应起来</li></ol></blockquote><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>socket<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> family<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> protocol<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> retval<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token operator">*</span>sock<span class="token punctuation">;</span>
  <span class="token keyword">int</span> flags<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>SOCK_NONBLOCK <span class="token operator">!=</span> O_NONBLOCK <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> SOCK_NONBLOCK<span class="token punctuation">)</span><span class="token punctuation">)</span>
    flags <span class="token operator">=</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> <span class="token operator">~</span>SOCK_NONBLOCK<span class="token punctuation">)</span> <span class="token operator">|</span> O_NONBLOCK<span class="token punctuation">;</span>

  <span class="token comment">// 调用 \`sock_create\` 创建一个 \`struct socket\` 结构</span>
  retval <span class="token operator">=</span> <span class="token function">sock_create</span><span class="token punctuation">(</span>family<span class="token punctuation">,</span> type<span class="token punctuation">,</span> protocol<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token comment">// 然后通过 \`sock_map_fd\` 和\`文件描述符\`对应起来。</span>
  retval <span class="token operator">=</span> <span class="token function">sock_map_fd</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> flags <span class="token operator">&amp;</span> <span class="token punctuation">(</span>O_CLOEXEC <span class="token operator">|</span> O_NONBLOCK<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">return</span> retval<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在创建 Socket 的时候，有三个参数。</p><h3 id="_1-family-地址族【网络层】" tabindex="-1"><a class="header-anchor" href="#_1-family-地址族【网络层】" aria-hidden="true">#</a> 1. family 地址族【网络层】</h3><p>一个是 <strong><code>family</code></strong>，表示<code>地址族</code>。</p><ul><li>不是所有的 Socket 都要通过 IP 进行通信，还有其他的通信方式。</li><li>例如，下面的定义中，domain sockets 就是通过本地文件进行通信的，不需要 IP 地址。</li><li>只不过，通过 IP 地址只是最常用的模式，所以我们这里着重分析这种模式。</li></ul><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">AF_UNIX</span> <span class="token expression"><span class="token number">1</span></span><span class="token comment">/* Unix domain sockets */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">AF_INET</span> <span class="token expression"><span class="token number">2</span></span><span class="token comment">/* Internet IP Protocol */</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-type-类型【数据格式】" tabindex="-1"><a class="header-anchor" href="#_2-type-类型【数据格式】" aria-hidden="true">#</a> 2. type 类型【数据格式】</h3><p>第二个参数是 <strong>type</strong>，也即 <code>Socket 的类型</code>。类型是比较少的。</p><p>常用的 Socket 类型有三种，分别是 <code>SOCK_STREAM</code>、<code>SOCK_DGRAM</code> 和 <code>SOCK_RAW</code>。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">enum</span> <span class="token class-name">sock_type</span> <span class="token punctuation">{</span>
SOCK_STREAM <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>	<span class="token comment">// 面向数据流</span>
SOCK_DGRAM <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span>		<span class="token comment">// 面向数据报</span>
SOCK_RAW <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span>		<span class="token comment">// 原始的 IP 包</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-protocol-协议【传输层】" tabindex="-1"><a class="header-anchor" href="#_3-protocol-协议【传输层】" aria-hidden="true">#</a> 3. protocol 协议【传输层】</h3><p>第三个参数是 <strong>protocol</strong>，是<code>协议</code>。协议数目是比较多的，也就是说，<mark><strong>多个协议</strong>会属于<strong>同一种类型</strong></mark>。</p><p>SOCK_STREAM 是面向数据流的，协议 <code>IPPROTO_TCP</code> 属于这种类型。SOCK_DGRAM 是面向数据报的，协议 <code>IPPROTO_UDP</code> 属于这种类型。如果在内核里面看的话，<code>IPPROTO_ICMP</code> 也属于这种类型。SOCK_RAW 是原始的 IP 包，<code>IPPROTO_IP</code> 属于这种类型。</p><h3 id="sock-stream-类型-ipproto-tcp-协议" tabindex="-1"><a class="header-anchor" href="#sock-stream-类型-ipproto-tcp-协议" aria-hidden="true">#</a> SOCK_STREAM 类型 / IPPROTO_TCP 协议</h3><p><strong>这一节，我们重点看 <code>SOCK_STREAM 类型</code>和 <code>IPPROTO_TCP 协议</code>。</strong></p><p>为了管理 family、type、protocol 这三个分类层次，<code>内核会创建对应的数据结构</code>。</p><h3 id="函数具体细节和流程" tabindex="-1"><a class="header-anchor" href="#函数具体细节和流程" aria-hidden="true">#</a> 函数具体细节和流程</h3><blockquote><p><code>sock_create</code>(family, type, protocol, &amp;sock)<br> 创建一个 <code>struct socket</code> 结构</p><p><code>sock_map_fd</code>(sock, flags &amp; (O_CLOEXEC | O_NONBLOCK))<br> 并和 <code>文件描述符</code> 对应起来</p></blockquote><p>接下来，我们打开 sock_create 函数看一下。</p><ol><li><p>它会调用 <code>__sock_create</code>。</p></li><li><p>这里先是分配了一个 <code>struct socket</code> 结构。</p></li></ol><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// 1. 它会调用 \`__sock_create\`。</span>
<span class="token keyword">int</span> <span class="token function">__sock_create</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">net</span> <span class="token operator">*</span>net<span class="token punctuation">,</span> <span class="token keyword">int</span> family<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span> protocol<span class="token punctuation">,</span>
       <span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token operator">*</span><span class="token operator">*</span>res<span class="token punctuation">,</span> <span class="token keyword">int</span> kern<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> err<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token operator">*</span>sock<span class="token punctuation">;</span>					<span class="token comment">// struct socket</span>
  <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">net_proto_family</span> <span class="token operator">*</span>pf<span class="token punctuation">;</span>	<span class="token comment">// struct net_proto_family</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  sock <span class="token operator">=</span> <span class="token function">sock_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2. 这里先是分配了一个 \`struct socket\` 结构。</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  sock<span class="token operator">-&gt;</span>type <span class="token operator">=</span> type<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token comment">// 3. 接下来我们要用到 family 参数。这里有一个 \`net_families\` 数组，</span>
  pf <span class="token operator">=</span> <span class="token function">rcu_dereference</span><span class="token punctuation">(</span>net_families<span class="token punctuation">[</span>family<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 4. 我们可以以 family 参数为下标，找到对应的 \`struct net_proto_family\`。</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  err <span class="token operator">=</span> pf<span class="token operator">-&gt;</span><span class="token function">create</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> sock<span class="token punctuation">,</span> protocol<span class="token punctuation">,</span> kern<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 5. \`struct net_proto_family\`-&gt;creat()方法，创建socket系统调用</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token operator">*</span>res <span class="token operator">=</span> sock<span class="token punctuation">;</span> <span class="token comment">// End</span>

  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-net-families-family" tabindex="-1"><a class="header-anchor" href="#_1-net-families-family" aria-hidden="true">#</a> ### 1. net_families[family]</h3><ol start="3"><li>接下来我们要用到 <mark>1. family 参数</mark>。这里有一个 <code>net_families 数组</code>，</li><li>我们可以以 family 参数为下标，找到对应的 <code>struct net_proto_family 元素</code>。</li></ol><p><em>+++ A. 我们可以找到 <code>net_families 数组</code>的定义。</em></p><p><em>+++ B. 每一个地址族在这个数组里面都有一项，里面的内容是 <code>net_proto_family 元素</code>。</em></p><p><em>+++ C. 即每一种地址族都有自己的 net_proto_family 元素，</em></p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// A. 我们可以找到 net_families 数组的定义。</span>
<span class="token comment">/* Supported address families. */</span>		<span class="token comment">// B. 每一个地址族在这个数组里面都有一项，里面的内容是 net_proto_family 元素。</span>
										<span class="token comment">// C. 即每一种地址族都有自己的 net_proto_family 元素，</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">AF_UNSPEC</span>  <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">AF_UNIX</span>    <span class="token expression"><span class="token number">1</span>  </span><span class="token comment">/* Unix domain sockets     */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">AF_LOCAL</span>  <span class="token expression"><span class="token number">1</span>  </span><span class="token comment">/* POSIX name for AF_UNIX  */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">AF_INET</span>    <span class="token expression"><span class="token number">2</span>  </span><span class="token comment">/* Internet IP Protocol   */</span></span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">AF_INET6</span>  <span class="token expression"><span class="token number">10</span>  </span><span class="token comment">/* IP version 6      */</span></span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">AF_MPLS</span>    <span class="token expression"><span class="token number">28</span>  </span><span class="token comment">/* MPLS */</span></span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">AF_MAX</span>    <span class="token expression"><span class="token number">44</span>  </span><span class="token comment">/* For now.. */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NPROTO</span>    <span class="token expression">AF_MAX</span></span>

<span class="token keyword">struct</span> <span class="token class-name">net_proto_family</span> __rcu <span class="token operator">*</span>net_families<span class="token punctuation">[</span>NPROTO<span class="token punctuation">]</span> __read_mostly<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><em>+++ D. <code>IP 地址族</code>的 net_proto_family 定义如下，里面最重要的就是，<code>create 函数指向 inet_create</code>。<strong>这个用于<mark>socket系统调用</mark>创建</strong></em></p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// D. IP 地址族的 net_proto_family 定义如下，</span>
<span class="token comment">//net/ipv4/af_inet.c</span>
<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">net_proto_family</span> inet_family_ops <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span>family <span class="token operator">=</span> PF_INET<span class="token punctuation">,</span>
  <span class="token comment">// create 函数指向 inet_create。</span>
  <span class="token punctuation">.</span>create <span class="token operator">=</span> inet_create<span class="token punctuation">,</span>	<span class="token comment">//这个用于==socket系统调用==创建</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="创建socket系统调用" tabindex="-1"><a class="header-anchor" href="#创建socket系统调用" aria-hidden="true">#</a> 创建socket系统调用</h3><ol start="5"><li>**struct net_proto_family<code>-&gt;creat()</code>**方法，创建socket系统调用</li></ol><p>我们回到函数 __sock_create。接下来，在这里面，这个 <code>inet_create</code> 会被调用。</p><p>一 | 在 inet_create 中，我们先会看到一个循环 <code>list_for_each_entry_rcu</code>。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// 5. **struct net_proto_family\`-&gt;creat()\`**方法，创建socket系统调用</span>
<span class="token comment">// 这个 \`inet_create\` 会被调用。</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">inet_create</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">net</span> <span class="token operator">*</span>net<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">int</span> protocol<span class="token punctuation">,</span> <span class="token keyword">int</span> kern<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">;</span>				<span class="token comment">// 而非上层的 socket *sock</span>
  <span class="token keyword">struct</span> <span class="token class-name">inet_protosw</span> <span class="token operator">*</span>answer<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">inet_sock</span> <span class="token operator">*</span>inet<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">proto</span> <span class="token operator">*</span>answer_prot<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">char</span> answer_flags<span class="token punctuation">;</span>
  <span class="token keyword">int</span> try_loading_module <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> err<span class="token punctuation">;</span>

  <span class="token comment">/* Look for the requested type/protocol pair. */</span>
lookup_protocol<span class="token operator">:</span>
  <span class="token comment">// 一 | 在 inet_create 中，我们先会看到一个循环 list_for_each_entry_rcu。</span>
  <span class="token function">list_for_each_entry_rcu</span><span class="token punctuation">(</span>answer<span class="token punctuation">,</span> <span class="token operator">&amp;</span>inetsw<span class="token punctuation">[</span>sock<span class="token operator">-&gt;</span>type<span class="token punctuation">]</span><span class="token punctuation">,</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 二 | 在这里，第二个 ==2. type 参数==开始起作用。因为循环查看的是 inetsw[sock-&gt;type]。</span>
    <span class="token comment">// (1)这是在 \`inetsw 数组\`中，根据 type 找到\`属于这个类型的列表\`，</span>
      
    err <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      
    <span class="token comment">// (2)然后依次比较列表中的 \`struct inet_protosw\` 的 protocol 是不是用户指定的 protocol；</span>
    <span class="token comment">/* Check the non-wild match. */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>protocol <span class="token operator">==</span> answer<span class="token operator">-&gt;</span>protocol<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>protocol <span class="token operator">!=</span> IPPROTO_IP<span class="token punctuation">)</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">/* Check for the two wild cases. */</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>IPPROTO_IP <span class="token operator">==</span> protocol<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        protocol <span class="token operator">=</span> answer<span class="token operator">-&gt;</span>protocol<span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>IPPROTO_IP <span class="token operator">==</span> answer<span class="token operator">-&gt;</span>protocol<span class="token punctuation">)</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// (3)如果是，就得到了符合用户指定的 family-&gt;type-&gt;protocol 的 \`struct inet_protosw *answer 对象\`。</span>
      
    err <span class="token operator">=</span> <span class="token operator">-</span>EPROTONOSUPPORT<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token comment">// (4)接下来，struct socket *sock 的 ops 成员变量，被赋值为 answer 的 ops。</span>
  <span class="token comment">// (5)对于 \`TCP\` 来讲，就是 inet_stream_ops。后面任何用户对于这个 socket 的操作，都是通过 \`inet_stream_ops\` 进行的。</span>
  sock<span class="token operator">-&gt;</span>ops <span class="token operator">=</span> answer<span class="token operator">-&gt;</span>ops<span class="token punctuation">;</span>
  answer_prot <span class="token operator">=</span> answer<span class="token operator">-&gt;</span>prot<span class="token punctuation">;</span>
  answer_flags <span class="token operator">=</span> answer<span class="token operator">-&gt;</span>flags<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token comment">// (6)接下来，我们创建一个 struct sock *sk 对象。</span>
    	<span class="token comment">// ==socket== 是用于负责对上给用户提供接口，并且和文件系统关联。</span>
    	<span class="token comment">// 而 ==sock==，负责向下对接内核网络协议栈。</span>
  sk <span class="token operator">=</span> <span class="token function">sk_alloc</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> PF_INET<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">,</span> answer_prot<span class="token punctuation">,</span> kern<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// (7)在 sk_alloc 函数中，struct inet_protosw *answer 结构的 tcp_prot 赋值给了 struct sock *sk 的 sk_prot 成员。</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token comment">// (8)接下来创建一个 struct inet_sock 结构，</span>
  	  <span class="token comment">// 这个结构一开始就是 struct sock，然后扩展了一些其他的信息，剩下的代码就填充这些信息。</span>
  inet <span class="token operator">=</span> <span class="token function">inet_sk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
  inet<span class="token operator">-&gt;</span>nodefrag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>SOCK_RAW <span class="token operator">==</span> sock<span class="token operator">-&gt;</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    inet<span class="token operator">-&gt;</span>inet_num <span class="token operator">=</span> protocol<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>IPPROTO_RAW <span class="token operator">==</span> protocol<span class="token punctuation">)</span>
      inet<span class="token operator">-&gt;</span>hdrincl <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  inet<span class="token operator">-&gt;</span>inet_id <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token function">sock_init_data</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> sk<span class="token punctuation">)</span><span class="token punctuation">;</span>

  sk<span class="token operator">-&gt;</span>sk_destruct     <span class="token operator">=</span> inet_sock_destruct<span class="token punctuation">;</span>
  sk<span class="token operator">-&gt;</span>sk_protocol     <span class="token operator">=</span> protocol<span class="token punctuation">;</span>
  sk<span class="token operator">-&gt;</span>sk_backlog_rcv <span class="token operator">=</span> sk<span class="token operator">-&gt;</span>sk_prot<span class="token operator">-&gt;</span>backlog_rcv<span class="token punctuation">;</span>

  inet<span class="token operator">-&gt;</span>uc_ttl  <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  inet<span class="token operator">-&gt;</span>mc_loop  <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  inet<span class="token operator">-&gt;</span>mc_ttl  <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  inet<span class="token operator">-&gt;</span>mc_all  <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  inet<span class="token operator">-&gt;</span>mc_index  <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  inet<span class="token operator">-&gt;</span>mc_list  <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
  inet<span class="token operator">-&gt;</span>rcv_tos  <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>inet<span class="token operator">-&gt;</span>inet_num<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    inet<span class="token operator">-&gt;</span>inet_sport <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span>inet<span class="token operator">-&gt;</span>inet_num<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* Add to protocol hash chains. */</span>
    err <span class="token operator">=</span> sk<span class="token operator">-&gt;</span>sk_prot<span class="token operator">-&gt;</span><span class="token function">hash</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>sk<span class="token operator">-&gt;</span>sk_prot<span class="token operator">-&gt;</span>init<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    err <span class="token operator">=</span> sk<span class="token operator">-&gt;</span>sk_prot<span class="token operator">-&gt;</span><span class="token function">init</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token comment">// (9)这一幕我们会经常看到，将一个结构放在另一个结构的开始位置，然后扩展一些成员，通过对于指针的强制类型转换，来访问这些成员。</span>
    <span class="token comment">// socket 的创建至此结束。</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-inetsw-sock-type" tabindex="-1"><a class="header-anchor" href="#_2-inetsw-sock-type" aria-hidden="true">#</a> ### 2. inetsw[sock-&gt;type]</h3><p>二 | 在这里，第二个 <mark>2. type 参数</mark>开始起作用。因为循环查看的是 <code>inetsw[sock-&gt;type] 数组</code>。</p><p>+++ A. 这里的 <code>inetsw</code> 也是一个数组，<code>type</code> 作为下标，里面的内容是 <code>struct inet_protosw，是协议</code>，</p><p>+++ B. 也即 <code>inetsw 数组</code>对于<code>每个类型</code>有一项，<code>这一项</code>里面是<code>属于这个类型的协议</code>。</p><p><mark><strong>多个协议</strong>会属于<strong>同一种类型</strong></mark>。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// A. 这里的 inetsw 也是一个数组，type 作为下标，里面的内容是 \`struct inet_protosw，是协议\`，</span>
<span class="token comment">// B. 也即 \`inetsw 数组\`对于\`每个类型\`有一项，\`这一项\`里面是\`属于这个类型的协议\`。</span>
<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">list_head</span> inetsw<span class="token punctuation">[</span>SOCK_MAX<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// C. inetsw 数组 是在系统初始化的时候初始化的，就像下面代码里面实现的一样。</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">inet_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token comment">/* Register the socket-side information for inet_create. */</span>
  <span class="token comment">// D. 首先，一个循环会将 inetsw 数组的 \`每一项\` ，都初始化为 \`一个链表\` 。</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token operator">&amp;</span>inetsw<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> r <span class="token operator">&lt;</span> <span class="token operator">&amp;</span>inetsw<span class="token punctuation">[</span>SOCK_MAX<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>r<span class="token punctuation">)</span>
    <span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// E. 咱们前面说了，\`一个 type 类型会包含多个 protocol\`，因而我们需要一个链表。</span>
  <span class="token comment">// F. 接下来一个循环，是将 \`inetsw_array\` 注册到 \`inetsw 数组\`里面去。</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>q <span class="token operator">=</span> inetsw_array<span class="token punctuation">;</span> q <span class="token operator">&lt;</span> <span class="token operator">&amp;</span>inetsw_array<span class="token punctuation">[</span>INETSW_ARRAY_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>q<span class="token punctuation">)</span>
    <span class="token function">inet_register_protosw</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>+++ C. <code>inetsw 数组</code>是在<code>系统初始化</code>的时候初始化的，就像下面代码里面实现的一样。</p><p>+++ D. 首先，一个循环会将 inetsw 数组的<code>每一项</code>，都初始化为<code>一个链表</code>。</p><p>+++ E. 咱们前面说了，<code>一个 type 类型会包含多个 protocol</code>，因而我们需要一个链表。</p><p>+++ F. 接下来一个循环，是将 <code>inetsw_array</code> 注册到 <code>inetsw 数组</code>里面去。</p><h3 id="inetsw-array-定义" tabindex="-1"><a class="header-anchor" href="#inetsw-array-定义" aria-hidden="true">#</a> inetsw_array 定义</h3><p><code>inetsw_array</code> 的定义如下，这个数组里面的内容很重要，后面会用到它们。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">inet_protosw</span> inetsw_array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span>
<span class="token punctuation">{</span>
  <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>type <span class="token operator">=</span>       SOCK_STREAM<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>protocol <span class="token operator">=</span>   IPPROTO_TCP<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>prot <span class="token operator">=</span>       <span class="token operator">&amp;</span>tcp_prot<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>ops <span class="token operator">=</span>        <span class="token operator">&amp;</span>inet_stream_ops<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>flags <span class="token operator">=</span>      INET_PROTOSW_PERMANENT <span class="token operator">|</span>
            INET_PROTOSW_ICSK<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>type <span class="token operator">=</span>       SOCK_DGRAM<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>protocol <span class="token operator">=</span>   IPPROTO_UDP<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>prot <span class="token operator">=</span>       <span class="token operator">&amp;</span>udp_prot<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>ops <span class="token operator">=</span>        <span class="token operator">&amp;</span>inet_dgram_ops<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>flags <span class="token operator">=</span>      INET_PROTOSW_PERMANENT<span class="token punctuation">,</span>
     <span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>type <span class="token operator">=</span>       SOCK_DGRAM<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>protocol <span class="token operator">=</span>   IPPROTO_ICMP<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>prot <span class="token operator">=</span>       <span class="token operator">&amp;</span>ping_prot<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>ops <span class="token operator">=</span>        <span class="token operator">&amp;</span>inet_sockraw_ops<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>flags <span class="token operator">=</span>      INET_PROTOSW_REUSE<span class="token punctuation">,</span>
     <span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token punctuation">{</span>
        <span class="token punctuation">.</span>type <span class="token operator">=</span>       SOCK_RAW<span class="token punctuation">,</span>
      <span class="token punctuation">.</span>protocol <span class="token operator">=</span>   IPPROTO_IP<span class="token punctuation">,</span>  <span class="token comment">/* wild card */</span>
      <span class="token punctuation">.</span>prot <span class="token operator">=</span>       <span class="token operator">&amp;</span>raw_prot<span class="token punctuation">,</span>
      <span class="token punctuation">.</span>ops <span class="token operator">=</span>        <span class="token operator">&amp;</span>inet_sockraw_ops<span class="token punctuation">,</span>
      <span class="token punctuation">.</span>flags <span class="token operator">=</span>      INET_PROTOSW_REUSE<span class="token punctuation">,</span>
     <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><mark><strong>我们回到 inet_create 的 list_for_each_entry_rcu 循环中。到这里就好理解了，</strong></mark></p><p>(1)这是在 <code>inetsw 数组</code>中，根据 type 找到<code>属于这个类型的列表</code>，</p><p>(2)然后依次比较列表中的 <code>struct inet_protosw</code> 的 protocol 是不是用户指定的 protocol；</p><p>(3)如果是，就得到了符合用户指定的 family-&gt;type-&gt;protocol 的 <code>struct inet_protosw *answer 对象</code>。</p><p>(4)接下来，struct socket *sock 的 <code>ops 成员变量</code>，被赋值为 answer 的 ops。</p><p>(5)对于 <code>TCP</code> 来讲，就是 inet_stream_ops。后面任何用户对于这个 socket 的操作，都是通过 <code>inet_stream_ops</code> 进行的。</p><p>(6)接下来，我们创建一个 <code>struct sock *sk 对象</code>。这里比较让人困惑。socket 和 sock 看起来几乎一样，容易让人混淆，这里需要说明一下，</p><ul><li><mark>socket</mark> 是用于负责<strong>对上给用户提供接口，并且和文件系统关联</strong>。</li><li>而 <mark>sock</mark>，负责<strong>向下对接内核网络协议栈</strong>。</li></ul><p>(7)在 sk_alloc 函数中，struct inet_protosw *answer 结构的 <code>tcp_prot</code> 赋值给了 struct sock *sk 的 <code>sk_prot</code> 成员。</p><h3 id="tcp-prot-定义" tabindex="-1"><a class="header-anchor" href="#tcp-prot-定义" aria-hidden="true">#</a> tcp_prot 定义</h3><p>tcp_prot 的定义如下，里面定义了很多的函数，都是 sock 之下内核协议栈的动作。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">proto</span> tcp_prot <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span>name      <span class="token operator">=</span> <span class="token string">&quot;TCP&quot;</span><span class="token punctuation">,</span>
  <span class="token punctuation">.</span>owner      <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>close      <span class="token operator">=</span> tcp_close<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>connect    <span class="token operator">=</span> tcp_v4_connect<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>disconnect    <span class="token operator">=</span> tcp_disconnect<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>accept      <span class="token operator">=</span> inet_csk_accept<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>ioctl      <span class="token operator">=</span> tcp_ioctl<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>init      <span class="token operator">=</span> tcp_v4_init_sock<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>destroy    <span class="token operator">=</span> tcp_v4_destroy_sock<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>shutdown    <span class="token operator">=</span> tcp_shutdown<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>setsockopt    <span class="token operator">=</span> tcp_setsockopt<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>getsockopt    <span class="token operator">=</span> tcp_getsockopt<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>keepalive    <span class="token operator">=</span> tcp_set_keepalive<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>recvmsg    <span class="token operator">=</span> tcp_recvmsg<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>sendmsg    <span class="token operator">=</span> tcp_sendmsg<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>sendpage    <span class="token operator">=</span> tcp_sendpage<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>backlog_rcv    <span class="token operator">=</span> tcp_v4_do_rcv<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>release_cb    <span class="token operator">=</span> tcp_release_cb<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>hash      <span class="token operator">=</span> inet_hash<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>get_port    <span class="token operator">=</span> inet_csk_get_port<span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><mark><strong>在 inet_create 函数中，</strong></mark></p><p>(8)接下来创建一个 <code>struct inet_sock</code> 结构，这个结构一开始就是 struct sock，然后扩展了一些其他的信息，剩下的代码就填充这些信息。</p><p>(9)这一幕我们会经常看到，将一个结构放在另一个结构的开始位置，然后扩展一些成员，通过对于指针的强制类型转换，来访问这些成员。在 inet_create 函数中，接下来创建一个 struct inet_sock 结构，这个结构一开始就是 struct sock，然后扩展了一些其他的信息，剩下的代码就填充这些信息。这一幕我们会经常看到，将一个结构放在另一个结构的开始位置，然后扩展一些成员，通过对于指针的强制类型转换，来访问这些成员。</p><p>socket 的创建至此结束。</p><h2 id="解析-bind-函数" tabindex="-1"><a class="header-anchor" href="#解析-bind-函数" aria-hidden="true">#</a> <strong>解析 bind 函数</strong></h2><p>接下来，我们来看 bind。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>bind<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> umyaddr<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> addrlen<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token operator">*</span>sock<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">sockaddr_storage</span> address<span class="token punctuation">;</span>
  <span class="token keyword">int</span> err<span class="token punctuation">,</span> fput_needed<span class="token punctuation">;</span>

  <span class="token comment">// (1) 在 bind 中，\`sockfd_lookup_light\` 会根据 \`fd 文件描述符\`，找到 \`struct socket 结构\`。</span>
  sock <span class="token operator">=</span> <span class="token function">sockfd_lookup_light</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>err<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fput_needed<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>sock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// (2) 然后将 sockaddr 从 用户态 拷贝到 内核态，</span>
    err <span class="token operator">=</span> <span class="token function">move_addr_to_kernel</span><span class="token punctuation">(</span>umyaddr<span class="token punctuation">,</span> addrlen<span class="token punctuation">,</span> <span class="token operator">&amp;</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// (3) 然后调用 struct socket 结构里面 \`ops 的 bind 函数\`。</span>
      err <span class="token operator">=</span> sock<span class="token operator">-&gt;</span>ops<span class="token operator">-&gt;</span><span class="token function">bind</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span>
                  <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span>
                  <span class="token operator">&amp;</span>address<span class="token punctuation">,</span> addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// (4) 根据前面创建 socket 的时候的设定，调用的是 \`inet_stream_ops 的 bind 函数\`，也即调用 \`inet_bind\`。</span>
    <span class="token punctuation">}</span>
    <span class="token function">fput_light</span><span class="token punctuation">(</span>sock<span class="token operator">-&gt;</span>file<span class="token punctuation">,</span> fput_needed<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> err<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>(1) 在 bind 中，<code>sockfd_lookup_light</code> 会根据 <code>fd 文件描述符</code>，找到 <code>struct socket 结构</code>。</p><p>(2) 然后将 sockaddr 从<code>用户态</code>拷贝到<code>内核态</code>，</p><p>(3) 然后调用 struct socket 结构里面 <code>ops 的 bind 函数</code>。</p><p>(4) 根据前面创建 socket 的时候的设定，调用的是 <code>inet_stream_ops 的 bind 函数</code>，也即调用 <code>inet_bind</code>。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">inet_bind</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>uaddr<span class="token punctuation">,</span> <span class="token keyword">int</span> addr_len<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> <span class="token operator">*</span>addr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> <span class="token operator">*</span><span class="token punctuation">)</span>uaddr<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk <span class="token operator">=</span> sock<span class="token operator">-&gt;</span>sk<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">inet_sock</span> <span class="token operator">*</span>inet <span class="token operator">=</span> <span class="token function">inet_sk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">net</span> <span class="token operator">*</span>net <span class="token operator">=</span> <span class="token function">sock_net</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">short</span> snum<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  snum <span class="token operator">=</span> <span class="token function">ntohs</span><span class="token punctuation">(</span>addr<span class="token operator">-&gt;</span>sin_port<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  inet<span class="token operator">-&gt;</span>inet_rcv_saddr <span class="token operator">=</span> inet<span class="token operator">-&gt;</span>inet_saddr <span class="token operator">=</span> addr<span class="token operator">-&gt;</span>sin_addr<span class="token punctuation">.</span>s_addr<span class="token punctuation">;</span>
  <span class="token comment">/* Make sure we are allowed to bind here. */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>snum <span class="token operator">||</span> <span class="token operator">!</span>inet<span class="token operator">-&gt;</span>bind_address_no_port<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
      <span class="token comment">// (5) bind 里面会调用 \`sk_prot 的 get_port 函数\`，也即 \`inet_csk_get_port\` 来检查端口是否冲突，是否可以绑定。</span>
      sk<span class="token operator">-&gt;</span>sk_prot<span class="token operator">-&gt;</span><span class="token function">get_port</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> snum<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// (6) 如果允许，则会设置 struct inet_sock 的 本方的地址 inet_saddr 和 本方的端口 inet_sport</span>
  inet<span class="token operator">-&gt;</span>inet_sport <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span>inet<span class="token operator">-&gt;</span>inet_num<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// (7) \`对方的地址 inet_daddr\` 和\`对方的端口 inet_dport\` 都初始化为 0。</span>
  inet<span class="token operator">-&gt;</span>inet_daddr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  inet<span class="token operator">-&gt;</span>inet_dport <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token function">sk_dst_reset</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>(5) bind 里面会调用 <code>sk_prot 的 get_port 函数</code>，也即 <code>inet_csk_get_port</code> 来检查端口是否冲突，是否可以绑定。</p><p>(6) 如果允许，则会设置 struct inet_sock 的<code>本方的地址 inet_saddr</code> 和<code>本方的端口 inet_sport</code>，</p><p>(7) <code>对方的地址 inet_daddr</code> 和<code>对方的端口 inet_dport</code> 都初始化为 0。</p><p>bind 的逻辑相对比较简单，就到这里了。</p><h2 id="解析-listen-函数" tabindex="-1"><a class="header-anchor" href="#解析-listen-函数" aria-hidden="true">#</a> <strong>解析 listen 函数</strong></h2><p>接下来我们来看 listen。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token function">SYSCALL_DEFINE2</span><span class="token punctuation">(</span>listen<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> backlog<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token operator">*</span>sock<span class="token punctuation">;</span>
  <span class="token keyword">int</span> err<span class="token punctuation">,</span> fput_needed<span class="token punctuation">;</span>
  <span class="token keyword">int</span> somaxconn<span class="token punctuation">;</span>

  <span class="token comment">// (1) 在 listen 中，我们还是通过 \`sockfd_lookup_light\`，根据 \`fd 文件描述符\`，找到 \`struct socket 结构\`。</span>
  sock <span class="token operator">=</span> <span class="token function">sockfd_lookup_light</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>err<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fput_needed<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>sock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    somaxconn <span class="token operator">=</span> <span class="token function">sock_net</span><span class="token punctuation">(</span>sock<span class="token operator">-&gt;</span>sk<span class="token punctuation">)</span><span class="token operator">-&gt;</span>core<span class="token punctuation">.</span>sysctl_somaxconn<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>backlog <span class="token operator">&gt;</span> somaxconn<span class="token punctuation">)</span>
      backlog <span class="token operator">=</span> somaxconn<span class="token punctuation">;</span>
    <span class="token comment">// (2) 接着，我们调用 struct socket 结构里面 \`ops 的 listen 函数\`。</span>
    err <span class="token operator">=</span> sock<span class="token operator">-&gt;</span>ops<span class="token operator">-&gt;</span><span class="token function">listen</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> backlog<span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token comment">// (3) 根据前面创建 socket 的时候的设定，调用的是 inet_stream_ops 的 listen 函数，也即调用 inet_listen。</span>
    <span class="token function">fput_light</span><span class="token punctuation">(</span>sock<span class="token operator">-&gt;</span>file<span class="token punctuation">,</span> fput_needed<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> err<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>(1) 在 listen 中，我们还是通过 <code>sockfd_lookup_light</code>，根据 <code>fd 文件描述符</code>，找到 <code>struct socket 结构</code>。</p><p>(2) 接着，我们调用 struct socket 结构里面 <code>ops 的 listen 函数</code>。</p><p>(3) 根据前面创建 socket 的时候的设定，调用的是 <code>inet_stream_ops 的 listen 函数</code>，也即调用 <code>inet_listen</code>。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">inet_listen</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">int</span> backlog<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk <span class="token operator">=</span> sock<span class="token operator">-&gt;</span>sk<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">char</span> old_state<span class="token punctuation">;</span>
  <span class="token keyword">int</span> err<span class="token punctuation">;</span>
  old_state <span class="token operator">=</span> sk<span class="token operator">-&gt;</span>sk_state<span class="token punctuation">;</span>
  <span class="token comment">/* Really, if the socket is already in listen state
   * we can only allow the backlog to be adjusted.
   */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>old_state <span class="token operator">!=</span> TCP_LISTEN<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// (4) 如果这个 socket 还不在 TCP_LISTEN 状态，会调用 \`inet_csk_listen_start\` 进入\`监听状态\`。</span>
    err <span class="token operator">=</span> <span class="token function">inet_csk_listen_start</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> backlog<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  sk<span class="token operator">-&gt;</span>sk_max_ack_backlog <span class="token operator">=</span> backlog<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>(4) 如果这个 socket 还不在 TCP_LISTEN 状态，会调用 <code>inet_csk_listen_start</code> 进入<code>监听状态</code>。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">inet_csk_listen_start</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">int</span> backlog<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">inet_connection_sock</span> <span class="token operator">*</span>icsk <span class="token operator">=</span> <span class="token function">inet_csk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 维护连接的数据结构</span>
  <span class="token keyword">struct</span> <span class="token class-name">inet_sock</span> <span class="token operator">*</span>inet <span class="token operator">=</span> <span class="token function">inet_sk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> err <span class="token operator">=</span> <span class="token operator">-</span>EADDRINUSE<span class="token punctuation">;</span>
							<span class="token comment">// 已建立连接的队列</span>
  <span class="token function">reqsk_queue_alloc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>icsk<span class="token operator">-&gt;</span>icsk_accept_queue<span class="token punctuation">)</span><span class="token punctuation">;</span>

  sk<span class="token operator">-&gt;</span>sk_max_ack_backlog <span class="token operator">=</span> backlog<span class="token punctuation">;</span>
  sk<span class="token operator">-&gt;</span>sk_ack_backlog <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token function">inet_csk_delack_init</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 初始化完之后，将 TCP 的状态设置为 TCP_LISTEN，</span>
  <span class="token function">sk_state_store</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> TCP_LISTEN<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sk<span class="token operator">-&gt;</span>sk_prot<span class="token operator">-&gt;</span><span class="token function">get_port</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> inet<span class="token operator">-&gt;</span>inet_num<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      	<span class="token comment">// 再次调用 get_port 判断端口是否冲突。</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="维护连接的数据结构" tabindex="-1"><a class="header-anchor" href="#维护连接的数据结构" aria-hidden="true">#</a> 维护连接的数据结构</h3><p>这里面建立了<code>一个新的结构 inet_connection_sock</code>，这个结构一开始是 <code>struct inet_sock</code>，inet_csk 其实做了一次强制类型转换，扩大了结构，看到了吧，又是这个套路。</p><p>struct inet_connection_sock 结构比较复杂。<code>如果打开它</code>，你能看到<code>处于各种状态的队列，各种超时时间、拥塞控制等</code>字眼。我们说 TCP 是面向连接的，就是客户端和服务端都是<code>有一个结构</code>用来<code>维护连接的状态</code>，就是指这个结构。我们这里先不详细分析里面的变量，因为太多了，后面我们遇到一个分析一个。</p><h3 id="已建立连接的队列" tabindex="-1"><a class="header-anchor" href="#已建立连接的队列" aria-hidden="true">#</a> 已建立连接的队列</h3><p>首先，我们遇到的是 <code>icsk_accept_queue</code>。它是干什么的呢？</p><p>在 TCP 的状态里面，有一个 listen 状态，当调用 listen 函数之后，就会进入这个状态，虽然我们写程序的时候，一般要等待服务端调用 accept 后，等待在哪里的时候，让客户端就发起连接。其实服务端一旦处于 listen 状态，不用 accept，客户端也能发起连接。</p><p>其实 TCP 的状态中，没有一个表示是否被 accept 的状态，那 accept 函数的作用是什么呢？</p><p>在内核中，为每个 Socket 维护两个队列。</p><ol><li>一个是已经建立了连接的队列，这时候连接三次握手已经完毕，处于 <code>established 状态</code>；</li><li>一个是还没有完全建立连接的队列，这个时候三次握手还没完成，处于 <code>syn_rcvd 的状态</code>。</li></ol><p>服务端调用 <code>accept 函数</code>，其实是在第一个队列中拿出一个已经完成的连接进行处理。如果还没有完成就阻塞等待。这里的 icsk_accept_queue 就是第一个队列。</p><p>初始化完之后，将 TCP 的状态设置为 TCP_LISTEN，再次调用 <code>get_port</code> 判断端口是否冲突。</p><p>至此，listen 的逻辑就结束了。</p><h2 id="解析-accept-函数" tabindex="-1"><a class="header-anchor" href="#解析-accept-函数" aria-hidden="true">#</a> <strong>解析 accept 函数</strong></h2><p>接下来，我们解析服务端调用 accept。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>accept<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> upeer_sockaddr<span class="token punctuation">,</span>
    <span class="token keyword">int</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> upeer_addrlen<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">sys_accept4</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> upeer_sockaddr<span class="token punctuation">,</span> upeer_addrlen<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">SYSCALL_DEFINE4</span><span class="token punctuation">(</span>accept4<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> upeer_sockaddr<span class="token punctuation">,</span>
    <span class="token keyword">int</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> upeer_addrlen<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token operator">*</span>newsock<span class="token punctuation">;</span>	<span class="token comment">// 监听 socket / 连接 socket</span>
  <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>newfile<span class="token punctuation">;</span>				<span class="token comment">// 新的 file</span>
  <span class="token keyword">int</span> err<span class="token punctuation">,</span> len<span class="token punctuation">,</span> newfd<span class="token punctuation">,</span> fput_needed<span class="token punctuation">;</span>	<span class="token comment">// 新的 fd</span>
  <span class="token keyword">struct</span> <span class="token class-name">sockaddr_storage</span> address<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token comment">// 这里我们会找到原来的 struct socket。监听 socket。</span>
  sock <span class="token operator">=</span> <span class="token function">sockfd_lookup_light</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>err<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fput_needed<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 并基于它去创建一个新的 newsock。这才是连接 socket。</span>
  newsock <span class="token operator">=</span> <span class="token function">sock_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  newsock<span class="token operator">-&gt;</span>type <span class="token operator">=</span> sock<span class="token operator">-&gt;</span>type<span class="token punctuation">;</span>
  newsock<span class="token operator">-&gt;</span>ops <span class="token operator">=</span> sock<span class="token operator">-&gt;</span>ops<span class="token punctuation">;</span>
  <span class="token comment">// 除此之外，我们还会创建一个新的 struct file 和 fd，并关联到 socket。</span>
  newfd <span class="token operator">=</span> <span class="token function">get_unused_fd_flags</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
  newfile <span class="token operator">=</span> <span class="token function">sock_alloc_file</span><span class="token punctuation">(</span>newsock<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> sock<span class="token operator">-&gt;</span>sk<span class="token operator">-&gt;</span>sk_prot_creator<span class="token operator">-&gt;</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 这里面还会调用 struct socket 的 \`sock-&gt;ops-&gt;accept\`，</span>
  <span class="token comment">// 也即会调用 \`inet_stream_ops 的 accept 函数\`，也即 \`inet_accept\`。</span>
  err <span class="token operator">=</span> sock<span class="token operator">-&gt;</span>ops<span class="token operator">-&gt;</span><span class="token function">accept</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> newsock<span class="token punctuation">,</span> sock<span class="token operator">-&gt;</span>file<span class="token operator">-&gt;</span>f_flags<span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>upeer_sockaddr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newsock<span class="token operator">-&gt;</span>ops<span class="token operator">-&gt;</span><span class="token function">getname</span><span class="token punctuation">(</span>newsock<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span> <span class="token operator">&amp;</span>len<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
    err <span class="token operator">=</span> <span class="token function">move_addr_to_user</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span>
          len<span class="token punctuation">,</span> upeer_sockaddr<span class="token punctuation">,</span> upeer_addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">fd_install</span><span class="token punctuation">(</span>newfd<span class="token punctuation">,</span> newfile<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>accept 函数的实现，印证了 socket 的原理中说的那样，原来的 socket 是<code>监听 socket</code>，这里我们会找到原来的 struct socket，并基于它去创建一个新的 newsock。这才是<code>连接 socket</code>。除此之外，我们还会创建一个<code>新的</code> struct <code>file</code> 和 <code>fd</code>，并关联到 socket。</p><p>这里面还会调用 struct socket 的 <code>sock-&gt;ops-&gt;accept</code>，也即会调用 <code>inet_stream_ops 的 accept 函数</code>，也即 <code>inet_accept</code>。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">inet_accept</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token operator">*</span>newsock<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> bool kern<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk1 <span class="token operator">=</span> sock<span class="token operator">-&gt;</span>sk<span class="token punctuation">;</span>
  <span class="token keyword">int</span> err <span class="token operator">=</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
  <span class="token comment">// inet_accept 会调用 \`struct sock 的 sk1-&gt;sk_prot-&gt;accept\`</span>
  <span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk2 <span class="token operator">=</span> sk1<span class="token operator">-&gt;</span>sk_prot<span class="token operator">-&gt;</span><span class="token function">accept</span><span class="token punctuation">(</span>sk1<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> <span class="token operator">&amp;</span>err<span class="token punctuation">,</span> kern<span class="token punctuation">)</span><span class="token punctuation">;</span>
   		<span class="token comment">// 也即 \`tcp_prot 的 accept 函数\`，\`inet_csk_accept\` 函数。</span>
  <span class="token function">sock_rps_record_flow</span><span class="token punctuation">(</span>sk2<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">sock_graft</span><span class="token punctuation">(</span>sk2<span class="token punctuation">,</span> newsock<span class="token punctuation">)</span><span class="token punctuation">;</span>
  newsock<span class="token operator">-&gt;</span>state <span class="token operator">=</span> SS_CONNECTED<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>inet_accept 会调用 <code>struct sock 的 sk1-&gt;sk_prot-&gt;accept</code>，也即 <code>tcp_prot</code> 的 accept 函数，<code>inet_csk_accept</code> 函数。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/*
 * This will accept the next outstanding connection.
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span><span class="token function">inet_csk_accept</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>err<span class="token punctuation">,</span> bool kern<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">inet_connection_sock</span> <span class="token operator">*</span>icsk <span class="token operator">=</span> <span class="token function">inet_csk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">request_sock_queue</span> <span class="token operator">*</span>queue <span class="token operator">=</span> <span class="token operator">&amp;</span>icsk<span class="token operator">-&gt;</span>icsk_accept_queue<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">request_sock</span> <span class="token operator">*</span>req<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>newsk<span class="token punctuation">;</span>
  <span class="token keyword">int</span> error<span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>sk<span class="token operator">-&gt;</span>sk_state <span class="token operator">!=</span> TCP_LISTEN<span class="token punctuation">)</span>
    <span class="token keyword">goto</span> out_err<span class="token punctuation">;</span>

  <span class="token comment">/* Find already established connection */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">reqsk_queue_empty</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">long</span> timeo <span class="token operator">=</span> <span class="token function">sock_rcvtimeo</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> flags <span class="token operator">&amp;</span> O_NONBLOCK<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果 icsk_accept_queue 为空，则调用 \`inet_csk_wait_for_connect\` 进行等待；</span>
    error <span class="token operator">=</span> <span class="token function">inet_csk_wait_for_connect</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> timeo<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 一旦 icsk_accept_queue 不为空，就从 inet_csk_wait_for_connect 中返回，</span>
  req <span class="token operator">=</span> <span class="token function">reqsk_queue_remove</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 在队列中取出一个 struct sock 对象赋值给 newsk。</span>
  newsk <span class="token operator">=</span> req<span class="token operator">-&gt;</span>sk<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token comment">/*
 * Wait for an incoming connection, avoid race conditions. This must be called
 * with the socket locked.
 */</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">inet_csk_wait_for_connect</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">long</span> timeo<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">inet_connection_sock</span> <span class="token operator">*</span>icsk <span class="token operator">=</span> <span class="token function">inet_csk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">DEFINE_WAIT</span><span class="token punctuation">(</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> err<span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">prepare_to_wait_exclusive</span><span class="token punctuation">(</span><span class="token function">sk_sleep</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>wait<span class="token punctuation">,</span>
            TASK_INTERRUPTIBLE<span class="token punctuation">)</span><span class="token punctuation">;</span>					<span class="token comment">// 将进程状态设置为 TASK_INTERRUPTIBLE。</span>
    <span class="token function">release_sock</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">reqsk_queue_empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>icsk<span class="token operator">-&gt;</span>icsk_accept_queue<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token comment">// 等待的时候，调用 \`schedule_timeout\`，让出 CPU，并且将进程状态设置为 TASK_INTERRUPTIBLE。</span>
      timeo <span class="token operator">=</span> <span class="token function">schedule_timeout</span><span class="token punctuation">(</span>timeo<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sched_annotate_sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">lock_sock</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    err <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">reqsk_queue_empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>icsk<span class="token operator">-&gt;</span>icsk_accept_queue<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    err <span class="token operator">=</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>sk<span class="token operator">-&gt;</span>sk_state <span class="token operator">!=</span> TCP_LISTEN<span class="token punctuation">)</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    err <span class="token operator">=</span> <span class="token function">sock_intr_errno</span><span class="token punctuation">(</span>timeo<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果再次 CPU 醒来，我们会接着判断 icsk_accept_queue 是否为空，</span>
    <span class="token comment">// 同时也会调用 \`signal_pending\` 看有没有信号可以处理。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">signal_pending</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    err <span class="token operator">=</span> <span class="token operator">-</span>EAGAIN<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timeo<span class="token punctuation">)</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">finish_wait</span><span class="token punctuation">(</span><span class="token function">sk_sleep</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> err<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>inet_csk_accept 的实现，印证了上面我们讲的两个队列的逻辑。</p><ul><li><p>如果 icsk_accept_queue 为空，则调用 <code>inet_csk_wait_for_connect</code> 进行等待；</p></li><li><p>等待的时候，调用 <code>schedule_timeout</code>，让出 CPU，并且将进程状态设置为 TASK_INTERRUPTIBLE。</p></li><li><p>如果再次 CPU 醒来，我们会接着判断 icsk_accept_queue 是否为空，同时也会调用 <code>signal_pending</code> 看有没有信号可以处理。</p></li><li><p>一旦 icsk_accept_queue 不为空，就从 inet_csk_wait_for_connect 中返回，在队列中取出一个 struct sock 对象赋值给 newsk。</p></li></ul><h2 id="三次握手" tabindex="-1"><a class="header-anchor" href="#三次握手" aria-hidden="true">#</a> 三次握手</h2><p>什么情况下，icsk_accept_queue 才不为空呢？当然是三次握手结束才可以。接下来我们来分析三次握手的过程。</p><figure><img src="`+p+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="解析-connect-函数" tabindex="-1"><a class="header-anchor" href="#解析-connect-函数" aria-hidden="true">#</a> <strong>解析 connect 函数</strong></h2><p>三次握手一般是由<mark>TCP 客户端</mark>调用 <code>connect</code> 发起。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>connect<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> uservaddr<span class="token punctuation">,</span>
    <span class="token keyword">int</span><span class="token punctuation">,</span> addrlen<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token operator">*</span>sock<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">sockaddr_storage</span> address<span class="token punctuation">;</span>
  <span class="token keyword">int</span> err<span class="token punctuation">,</span> fput_needed<span class="token punctuation">;</span>
  <span class="token comment">// 通过 \`sockfd_lookup_light\`，根据 \`fd 文件描述符\`，找到 \`struct socket 结构\`。</span>
  sock <span class="token operator">=</span> <span class="token function">sockfd_lookup_light</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>err<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fput_needed<span class="token punctuation">)</span><span class="token punctuation">;</span>
  err <span class="token operator">=</span> <span class="token function">move_addr_to_kernel</span><span class="token punctuation">(</span>uservaddr<span class="token punctuation">,</span> addrlen<span class="token punctuation">,</span> <span class="token operator">&amp;</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 接着，我们会调用 struct socket 结构里面 \`ops 的 connect 函数\`，</span>
  err <span class="token operator">=</span> sock<span class="token operator">-&gt;</span>ops<span class="token operator">-&gt;</span><span class="token function">connect</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>address<span class="token punctuation">,</span> addrlen<span class="token punctuation">,</span> sock<span class="token operator">-&gt;</span>file<span class="token operator">-&gt;</span>f_flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 根据前面创建 socket 的时候的设定，调用 \`inet_stream_ops 的 connect 函数\`，也即调用 \`inet_stream_connect\`。</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>connect 函数的实现一开始你应该很眼熟，还是通过 <code>sockfd_lookup_light</code>，根据 <code>fd 文件描述符</code>，找到 <code>struct socket 结构</code>。</p><p>接着，我们会调用 struct socket 结构里面 <code>ops 的 connect 函数</code>，</p><p>根据前面创建 socket 的时候的设定，调用 <code>inet_stream_ops 的 connect 函数</code>，也即调用 <code>inet_stream_connect</code>。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/*
 *  Connect to a remote host. There is regrettably still a little
 *  TCP &#39;magic&#39; in here.
 */</span>
<span class="token keyword">int</span> <span class="token function">__inet_stream_connect</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">socket</span> <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>uaddr<span class="token punctuation">,</span>
        <span class="token keyword">int</span> addr_len<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">int</span> is_sendmsg<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk <span class="token operator">=</span> sock<span class="token operator">-&gt;</span>sk<span class="token punctuation">;</span>
  <span class="token keyword">int</span> err<span class="token punctuation">;</span>
  <span class="token keyword">long</span> timeo<span class="token punctuation">;</span>

  <span class="token keyword">switch</span> <span class="token punctuation">(</span>sock<span class="token operator">-&gt;</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">case</span> SS_UNCONNECTED<span class="token operator">:</span>	<span class="token comment">// 如果 socket 处于 \`SS_UNCONNECTED 状态\`，</span>
    err <span class="token operator">=</span> <span class="token operator">-</span>EISCONN<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>sk<span class="token operator">-&gt;</span>sk_state <span class="token operator">!=</span> TCP_CLOSE<span class="token punctuation">)</span>
      <span class="token keyword">goto</span> out<span class="token punctuation">;</span>
	<span class="token comment">// 那就调用 struct sock 的 \`sk-&gt;sk_prot-&gt;connect\`，</span>
    err <span class="token operator">=</span> sk<span class="token operator">-&gt;</span>sk_prot<span class="token operator">-&gt;</span><span class="token function">connect</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> uaddr<span class="token punctuation">,</span> addr_len<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token comment">// 也即 \`tcp_prot\` 的 connect 函数——\`tcp_v4_connect\` 函数。</span>
    sock<span class="token operator">-&gt;</span>state <span class="token operator">=</span> SS_CONNECTING<span class="token punctuation">;</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  timeo <span class="token operator">=</span> <span class="token function">sock_sndtimeo</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> flags <span class="token operator">&amp;</span> O_NONBLOCK<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> sk<span class="token operator">-&gt;</span>sk_state<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>TCPF_SYN_SENT <span class="token operator">|</span> TCPF_SYN_RECV<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">// 我们回到 __inet_stream_connect 函数，在调用 sk-&gt;sk_prot-&gt;connect 之后，</span>
    <span class="token comment">// inet_wait_for_connect 会一直等待客户端收到服务端的 ACK。而我们知道，服务端在 accept 之后，也是在等待中。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timeo <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">inet_wait_for_connect</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> timeo<span class="token punctuation">,</span> writebias<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token keyword">goto</span> out<span class="token punctuation">;</span>

    err <span class="token operator">=</span> <span class="token function">sock_intr_errno</span><span class="token punctuation">(</span>timeo<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">signal_pending</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token keyword">goto</span> out<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  sock<span class="token operator">-&gt;</span>state <span class="token operator">=</span> SS_CONNECTED<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 __inet_stream_connect 里面，我们发现，如果 socket 处于 <code>SS_UNCONNECTED 状态</code>，</p><p>那就调用 struct sock 的 <code>sk-&gt;sk_prot-&gt;connect</code>，也即 <code>tcp_prot</code> 的 connect 函数——<code>tcp_v4_connect</code> 函数。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">tcp_v4_connect</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>uaddr<span class="token punctuation">,</span> <span class="token keyword">int</span> addr_len<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> <span class="token operator">*</span>usin <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> <span class="token operator">*</span><span class="token punctuation">)</span>uaddr<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">inet_sock</span> <span class="token operator">*</span>inet <span class="token operator">=</span> <span class="token function">inet_sk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">tcp_sock</span> <span class="token operator">*</span>tp <span class="token operator">=</span> <span class="token function">tcp_sk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
  __be16 orig_sport<span class="token punctuation">,</span> orig_dport<span class="token punctuation">;</span>
  __be32 daddr<span class="token punctuation">,</span> nexthop<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">flowi4</span> <span class="token operator">*</span>fl4<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">rtable</span> <span class="token operator">*</span>rt<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  orig_sport <span class="token operator">=</span> inet<span class="token operator">-&gt;</span>inet_sport<span class="token punctuation">;</span>
  orig_dport <span class="token operator">=</span> usin<span class="token operator">-&gt;</span>sin_port<span class="token punctuation">;</span>
  <span class="token comment">// \`ip_route_connect\` 其实是做一个路由的选择。</span>
  rt <span class="token operator">=</span> <span class="token function">ip_route_connect</span><span class="token punctuation">(</span>fl4<span class="token punctuation">,</span> nexthop<span class="token punctuation">,</span> inet<span class="token operator">-&gt;</span>inet_saddr<span class="token punctuation">,</span>
            <span class="token function">RT_CONN_FLAGS</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> sk<span class="token operator">-&gt;</span>sk_bound_dev_if<span class="token punctuation">,</span>
            IPPROTO_TCP<span class="token punctuation">,</span>
            orig_sport<span class="token punctuation">,</span> orig_dport<span class="token punctuation">,</span> sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token function">tcp_set_state</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> TCP_SYN_SENT<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 接下来，在发送 SYN 之前，我们先将客户端 socket 的状态设置为 \`TCP_SYN_SENT\`。</span>
  err <span class="token operator">=</span> <span class="token function">inet_hash_connect</span><span class="token punctuation">(</span>tcp_death_row<span class="token punctuation">,</span> sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">sk_set_txhash</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
  rt <span class="token operator">=</span> <span class="token function">ip_route_newports</span><span class="token punctuation">(</span>fl4<span class="token punctuation">,</span> rt<span class="token punctuation">,</span> orig_sport<span class="token punctuation">,</span> orig_dport<span class="token punctuation">,</span>
             inet<span class="token operator">-&gt;</span>inet_sport<span class="token punctuation">,</span> inet<span class="token operator">-&gt;</span>inet_dport<span class="token punctuation">,</span> sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* OK, now commit destination to socket.  */</span>
  sk<span class="token operator">-&gt;</span>sk_gso_type <span class="token operator">=</span> SKB_GSO_TCPV4<span class="token punctuation">;</span>
  <span class="token function">sk_setup_caps</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rt<span class="token operator">-&gt;</span>dst<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span><span class="token operator">!</span>tp<span class="token operator">-&gt;</span>repair<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tp<span class="token operator">-&gt;</span>write_seq<span class="token punctuation">)</span>
      <span class="token comment">// 然后初始化 TCP 的 seq num，也即 \`write_seq\`，</span>
      tp<span class="token operator">-&gt;</span>write_seq <span class="token operator">=</span> <span class="token function">secure_tcp_seq</span><span class="token punctuation">(</span>inet<span class="token operator">-&gt;</span>inet_saddr<span class="token punctuation">,</span>
                   inet<span class="token operator">-&gt;</span>inet_daddr<span class="token punctuation">,</span>
                   inet<span class="token operator">-&gt;</span>inet_sport<span class="token punctuation">,</span>
                   usin<span class="token operator">-&gt;</span>sin_port<span class="token punctuation">)</span><span class="token punctuation">;</span>
    tp<span class="token operator">-&gt;</span>tsoffset <span class="token operator">=</span> <span class="token function">secure_tcp_ts_off</span><span class="token punctuation">(</span><span class="token function">sock_net</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span>
             inet<span class="token operator">-&gt;</span>inet_saddr<span class="token punctuation">,</span>
             inet<span class="token operator">-&gt;</span>inet_daddr<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  rt <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token comment">// 然后调用 \`tcp_connect\` 进行发送。</span>
  err <span class="token operator">=</span> <span class="token function">tcp_connect</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 tcp_v4_connect 函数中，<code>ip_route_connect</code> 其实是做一个路由的选择。为什么呢？因为三次握手马上就要发送一个 SYN 包了，这就要凑齐源地址、源端口、目标地址、目标端口。<mark>目标地址</mark>和<mark>目标端口</mark>是服务端的，已经知道<mark>源端口</mark>是客户端随机分配的，<mark>源地址</mark>应该用哪一个呢？<code>这时候要选择一条路由</code>，看从哪个网卡出去，就应该填写哪个网卡的 IP 地址。</p><p>接下来，在发送 SYN 之前，我们先将客户端 socket 的状态设置为 <code>TCP_SYN_SENT</code>。然后初始化 TCP 的 seq num，也即 <code>write_seq</code>，然后调用 <code>tcp_connect</code> 进行发送。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/* Build a SYN and send it off. */</span>
<span class="token keyword">int</span> <span class="token function">tcp_connect</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">tcp_sock</span> <span class="token operator">*</span>tp <span class="token operator">=</span> <span class="token function">tcp_sk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 维护连接的数据结构</span>
  <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>buff<span class="token punctuation">;</span>
  <span class="token keyword">int</span> err<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token function">tcp_connect_init</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  buff <span class="token operator">=</span> <span class="token function">sk_stream_alloc_skb</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> sk<span class="token operator">-&gt;</span>sk_allocation<span class="token punctuation">,</span> true<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token comment">// 接下来 \`tcp_init_nondata_skb\` 初始化一个 SYN 包</span>
  <span class="token function">tcp_init_nondata_skb</span><span class="token punctuation">(</span>buff<span class="token punctuation">,</span> tp<span class="token operator">-&gt;</span>write_seq<span class="token operator">++</span><span class="token punctuation">,</span> TCPHDR_SYN<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">tcp_mstamp_refresh</span><span class="token punctuation">(</span>tp<span class="token punctuation">)</span><span class="token punctuation">;</span>
  tp<span class="token operator">-&gt;</span>retrans_stamp <span class="token operator">=</span> <span class="token function">tcp_time_stamp</span><span class="token punctuation">(</span>tp<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">tcp_connect_queue_skb</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> buff<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">tcp_ecn_send_syn</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> buff<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">/* Send off SYN; include data in Fast Open. */</span>
  err <span class="token operator">=</span> tp<span class="token operator">-&gt;</span>fastopen_req <span class="token operator">?</span> <span class="token function">tcp_send_syn_data</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> buff<span class="token punctuation">)</span> <span class="token operator">:</span>
        <span class="token function">tcp_transmit_skb</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> buff<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> sk<span class="token operator">-&gt;</span>sk_allocation<span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token comment">// \`tcp_transmit_skb\` 将 SYN 包发送出去</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  tp<span class="token operator">-&gt;</span>snd_nxt <span class="token operator">=</span> tp<span class="token operator">-&gt;</span>write_seq<span class="token punctuation">;</span>
  tp<span class="token operator">-&gt;</span>pushed_seq <span class="token operator">=</span> tp<span class="token operator">-&gt;</span>write_seq<span class="token punctuation">;</span>
  buff <span class="token operator">=</span> <span class="token function">tcp_send_head</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    tp<span class="token operator">-&gt;</span>snd_nxt  <span class="token operator">=</span> <span class="token function">TCP_SKB_CB</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token operator">-&gt;</span>seq<span class="token punctuation">;</span>
    tp<span class="token operator">-&gt;</span>pushed_seq  <span class="token operator">=</span> <span class="token function">TCP_SKB_CB</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token operator">-&gt;</span>seq<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token comment">/* Timer for repeating the SYN until an answer. */</span>
  <span class="token comment">// \`inet_csk_reset_xmit_timer\` 设置了一个 timer，如果 SYN 发送不成功，则再次发送。</span>
  <span class="token function">inet_csk_reset_xmit_timer</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> ICSK_TIME_RETRANS<span class="token punctuation">,</span>
          <span class="token function">inet_csk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token operator">-&gt;</span>icsk_rto<span class="token punctuation">,</span> TCP_RTO_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="维护连接的数据结构-1" tabindex="-1"><a class="header-anchor" href="#维护连接的数据结构-1" aria-hidden="true">#</a> 维护连接的数据结构</h3><p>在 tcp_connect 中，有一个新的结构 <code>struct tcp_sock</code>，如果打开他，你会发现他是 <code>struct inet_connection_sock</code> 的一个扩展，struct inet_connection_sock 在 struct tcp_sock 开头的位置，通过强制类型转换访问，故伎重演又一次。</p><p>struct tcp_sock 里面<code>维护了更多的 TCP 的状态</code>，咱们同样是遇到了再分析。</p><h3 id="发送-syn-包" tabindex="-1"><a class="header-anchor" href="#发送-syn-包" aria-hidden="true">#</a> 发送 SYN 包</h3><p>接下来 <code>tcp_init_nondata_skb</code> 初始化一个 SYN 包，<code>tcp_transmit_skb</code> 将 SYN 包发送出去，<code>inet_csk_reset_xmit_timer</code> 设置了一个 timer，如果 SYN 发送不成功，则再次发送。</p><p>发送网络包的过程，我们放到下一节讲解。这里我们姑且认为 SYN 已经发送出去了。</p><h3 id="网络包过程" tabindex="-1"><a class="header-anchor" href="#网络包过程" aria-hidden="true">#</a> 网络包过程</h3><p>我们回到 __inet_stream_connect 函数，在调用 sk-&gt;sk_prot-&gt;connect 之后，inet_wait_for_connect 会一直等待客户端收到服务端的 ACK。而我们知道，服务端在 accept 之后，也是在等待中。</p><p>网络包是如何接收的呢？对于解析的详细过程，我们会在下下节讲解，这里为了解析三次握手，我们简单的看网络包接收到 TCP 层做的部分事情。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">net_protocol</span> tcp_protocol <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span>early_demux  <span class="token operator">=</span>  tcp_v4_early_demux<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>early_demux_handler <span class="token operator">=</span>  tcp_v4_early_demux<span class="token punctuation">,</span>
  <span class="token comment">// 通过 struct net_protocol 结构中的 handler 进行接收，调用的函数是 tcp_v4_rcv。</span>
  <span class="token punctuation">.</span>handler  <span class="token operator">=</span>  tcp_v4_rcv<span class="token punctuation">,</span>
  <span class="token comment">// 接下来的调用链为 tcp_v4_rcv-&gt;tcp_v4_do_rcv-&gt;tcp_rcv_state_process。</span>
  <span class="token punctuation">.</span>err_handler  <span class="token operator">=</span>  tcp_v4_err<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>no_policy  <span class="token operator">=</span>  <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token punctuation">.</span>netns_ok  <span class="token operator">=</span>  <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token punctuation">.</span>icmp_strict_tag_validation <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们通过 struct net_protocol 结构中的 handler 进行接收，调用的函数是 <code>tcp_v4_rcv</code>。接下来的调用链为 tcp_v4_rcv-&gt;tcp_v4_do_rcv-&gt;tcp_rcv_state_process。<code>tcp_rcv_state_process</code>，顾名思义，是用来处理接收一个网络包后引起状态变化的。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// \`tcp_rcv_state_process\`，顾名思义，是用来处理接收一个网络包后引起状态变化的。</span>
<span class="token keyword">int</span> <span class="token function">tcp_rcv_state_process</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">tcp_sock</span> <span class="token operator">*</span>tp <span class="token operator">=</span> <span class="token function">tcp_sk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">inet_connection_sock</span> <span class="token operator">*</span>icsk <span class="token operator">=</span> <span class="token function">inet_csk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">tcphdr</span> <span class="token operator">*</span>th <span class="token operator">=</span> <span class="token function">tcp_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">request_sock</span> <span class="token operator">*</span>req<span class="token punctuation">;</span>
  <span class="token keyword">int</span> queued <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  bool acceptable<span class="token punctuation">;</span>

  <span class="token keyword">switch</span> <span class="token punctuation">(</span>sk<span class="token operator">-&gt;</span>sk_state<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">case</span> TCP_LISTEN<span class="token operator">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>th<span class="token operator">-&gt;</span>syn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 目前服务端是处于 TCP_LISTEN 状态的，而且发过来的包是 SYN，</span>
      acceptable <span class="token operator">=</span> icsk<span class="token operator">-&gt;</span>icsk_af_ops<span class="token operator">-&gt;</span><span class="token function">conn_request</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token comment">// 因而就有了上面的代码，调用 icsk-&gt;icsk_af_ops-&gt;conn_request 函数。</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>acceptable<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
      <span class="token function">consume_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>目前服务端是处于 TCP_LISTEN 状态的，而且发过来的包是 SYN，因而就有了上面的代码，调用 icsk-&gt;icsk_af_ops-&gt;conn_request 函数。</p><p>struct inet_connection_sock 对应的操作是 <code>inet_connection_sock_af_ops</code>，按照下面的定义，其实调用的是 <code>tcp_v4_conn_request</code>。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">inet_connection_sock_af_ops</span> ipv4_specific <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span>queue_xmit        <span class="token operator">=</span> ip_queue_xmit<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>send_check        <span class="token operator">=</span> tcp_v4_send_check<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>rebuild_header    <span class="token operator">=</span> inet_sk_rebuild_header<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>sk_rx_dst_set     <span class="token operator">=</span> inet_sk_rx_dst_set<span class="token punctuation">,</span>
    	<span class="token comment">// 按照下面的定义，其实调用的是 \`tcp_v4_conn_request\`</span>
        <span class="token punctuation">.</span>conn_request      <span class="token operator">=</span> tcp_v4_conn_request<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>syn_recv_sock     <span class="token operator">=</span> tcp_v4_syn_recv_sock<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>net_header_len    <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">iphdr</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">.</span>setsockopt        <span class="token operator">=</span> ip_setsockopt<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>getsockopt        <span class="token operator">=</span> ip_getsockopt<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>addr2sockaddr     <span class="token operator">=</span> inet_csk_addr2sockaddr<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>sockaddr_len      <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">.</span>mtu_reduced       <span class="token operator">=</span> tcp_v4_mtu_reduced<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>tcp_v4_conn_request 会调用 <code>tcp_conn_request</code>，这个函数也比较长，里面调用了 <code>send_synack</code>，但实际调用的是 <code>tcp_v4_send_synack</code>。具体发送的过程我们不去管它，看注释我们能知道，这是收到了 SYN 后，回复一个 <code>SYN-ACK</code>，回复完毕后，服务端处于 <code>TCP_SYN_RECV</code>。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">tcp_conn_request</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">request_sock_ops</span> <span class="token operator">*</span>rsk_ops<span class="token punctuation">,</span>
         <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">tcp_request_sock_ops</span> <span class="token operator">*</span>af_ops<span class="token punctuation">,</span>
         <span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token comment">// 里面调用了 \`send_synack\`，但实际调用的是 \`tcp_v4_send_synack\`。</span>
af_ops<span class="token operator">-&gt;</span><span class="token function">send_synack</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> dst<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fl<span class="token punctuation">,</span> req<span class="token punctuation">,</span> <span class="token operator">&amp;</span>foc<span class="token punctuation">,</span>
            <span class="token operator">!</span>want_cookie <span class="token operator">?</span> TCP_SYNACK_NORMAL <span class="token operator">:</span>
               TCP_SYNACK_COOKIE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token comment">/*
 *  Send a SYN-ACK after having received a SYN.
 
 这是收到了 SYN 后，回复一个 \`SYN-ACK\`，回复完毕后，服务端处于 \`TCP_SYN_RECV\`。
 */</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">tcp_v4_send_synack</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dst_entry</span> <span class="token operator">*</span>dst<span class="token punctuation">,</span>
            <span class="token keyword">struct</span> <span class="token class-name">flowi</span> <span class="token operator">*</span>fl<span class="token punctuation">,</span>
            <span class="token keyword">struct</span> <span class="token class-name">request_sock</span> <span class="token operator">*</span>req<span class="token punctuation">,</span>
            <span class="token keyword">struct</span> <span class="token class-name">tcp_fastopen_cookie</span> <span class="token operator">*</span>foc<span class="token punctuation">,</span>
            <span class="token keyword">enum</span> <span class="token class-name">tcp_synack_type</span> synack_type<span class="token punctuation">)</span>
<span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="客户端接收" tabindex="-1"><a class="header-anchor" href="#客户端接收" aria-hidden="true">#</a> 客户端接收</h4><p>这个时候，轮到<mark>TCP 客户端</mark>接收网络包了。都是 TCP 协议栈，所以过程和服务端没有太多区别，还是会走到 <code>tcp_rcv_state_process</code> 函数的，只不过由于客户端目前处于 <code>TCP_SYN_SENT</code> 状态，就进入了下面的代码分支。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">tcp_rcv_state_process</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">tcp_sock</span> <span class="token operator">*</span>tp <span class="token operator">=</span> <span class="token function">tcp_sk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">inet_connection_sock</span> <span class="token operator">*</span>icsk <span class="token operator">=</span> <span class="token function">inet_csk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">tcphdr</span> <span class="token operator">*</span>th <span class="token operator">=</span> <span class="token function">tcp_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">request_sock</span> <span class="token operator">*</span>req<span class="token punctuation">;</span>
  <span class="token keyword">int</span> queued <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  bool acceptable<span class="token punctuation">;</span>

  <span class="token keyword">switch</span> <span class="token punctuation">(</span>sk<span class="token operator">-&gt;</span>sk_state<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">case</span> TCP_SYN_SENT<span class="token operator">:</span>			<span class="token comment">// TCP_SYN_SENT</span>
    tp<span class="token operator">-&gt;</span>rx_opt<span class="token punctuation">.</span>saw_tstamp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">tcp_mstamp_refresh</span><span class="token punctuation">(</span>tp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// tcp_rcv_synsent_state_process 会调用 \`tcp_send_ack\`，</span>
          <span class="token comment">// 发送一个 \`ACK-ACK\`，发送后客户端处于 \`TCP_ESTABLISHED 状态\`。</span>
    queued <span class="token operator">=</span> <span class="token function">tcp_rcv_synsent_state_process</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> th<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>queued <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
      <span class="token keyword">return</span> queued<span class="token punctuation">;</span>
    <span class="token comment">/* Do step6 onward by hand. */</span>
    <span class="token function">tcp_urg</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> skb<span class="token punctuation">,</span> th<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">__kfree_skb</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">tcp_data_snd_check</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>tcp_rcv_synsent_state_process 会调用 <code>tcp_send_ack</code>，发送一个 <code>ACK-ACK</code>，发送后客户端处于 <code>TCP_ESTABLISHED 状态</code>。</p><h3 id="服务端接收" tabindex="-1"><a class="header-anchor" href="#服务端接收" aria-hidden="true">#</a> 服务端接收</h3><p>又轮到服务端接收网络包了，我们还是归 tcp_rcv_state_process 函数处理。由于服务端目前处于状态 <code>TCP_SYN_RECV 状态</code>，因而又走了另外的分支。当收到这个网络包的时候，服务端也处于 <code>TCP_ESTABLISHED 状态</code>，三次握手结束。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">tcp_rcv_state_process</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sk_buff</span> <span class="token operator">*</span>skb<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">tcp_sock</span> <span class="token operator">*</span>tp <span class="token operator">=</span> <span class="token function">tcp_sk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">inet_connection_sock</span> <span class="token operator">*</span>icsk <span class="token operator">=</span> <span class="token function">inet_csk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">tcphdr</span> <span class="token operator">*</span>th <span class="token operator">=</span> <span class="token function">tcp_hdr</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">request_sock</span> <span class="token operator">*</span>req<span class="token punctuation">;</span>
  <span class="token keyword">int</span> queued <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  bool acceptable<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>sk<span class="token operator">-&gt;</span>sk_state<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">case</span> TCP_SYN_RECV<span class="token operator">:</span>		<span class="token comment">// TCP_SYN_RECV</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>req<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">inet_csk</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token operator">-&gt;</span>icsk_retransmits <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token function">reqsk_fastopen_remove</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> req<span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">/* Make sure socket is routed, for correct metrics. */</span>
      icsk<span class="token operator">-&gt;</span>icsk_af_ops<span class="token operator">-&gt;</span><span class="token function">rebuild_header</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">tcp_call_bpf</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">tcp_init_congestion_control</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token function">tcp_mtup_init</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
      tp<span class="token operator">-&gt;</span>copied_seq <span class="token operator">=</span> tp<span class="token operator">-&gt;</span>rcv_nxt<span class="token punctuation">;</span>
      <span class="token function">tcp_init_buffer_space</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">smp_mb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">tcp_set_state</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> TCP_ESTABLISHED<span class="token punctuation">)</span><span class="token punctuation">;</span>
    sk<span class="token operator">-&gt;</span><span class="token function">sk_state_change</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>sk<span class="token operator">-&gt;</span>sk_socket<span class="token punctuation">)</span>
      <span class="token function">sk_wake_async</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> SOCK_WAKE_IO<span class="token punctuation">,</span> POLL_OUT<span class="token punctuation">)</span><span class="token punctuation">;</span>
    tp<span class="token operator">-&gt;</span>snd_una <span class="token operator">=</span> <span class="token function">TCP_SKB_CB</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>ack_seq<span class="token punctuation">;</span>
    tp<span class="token operator">-&gt;</span>snd_wnd <span class="token operator">=</span> <span class="token function">ntohs</span><span class="token punctuation">(</span>th<span class="token operator">-&gt;</span>window<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> tp<span class="token operator">-&gt;</span>rx_opt<span class="token punctuation">.</span>snd_wscale<span class="token punctuation">;</span>
    <span class="token function">tcp_init_wl</span><span class="token punctuation">(</span>tp<span class="token punctuation">,</span> <span class="token function">TCP_SKB_CB</span><span class="token punctuation">(</span>skb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>seq<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="总结时刻" tabindex="-1"><a class="header-anchor" href="#总结时刻" aria-hidden="true">#</a> <strong>总结时刻</strong></h2><p>这一节除了网络包的接收和发送，其他的系统调用我们都分析到了。可以看出来，它们有一个统一的数据结构和流程。具体如下图所示：</p><figure><img src="`+e+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>首先，Socket 系统调用会有三级参数 family、type、protocal，通过这三级参数，分别在 net_proto_family 表中找到 type 链表，在 type 链表中找到 protocal 对应的操作。这个操作分为两层，对于 TCP 协议来讲，第一层是 inet_stream_ops 层，第二层是 tcp_prot 层。</p><p>于是，接下来的系统调用规律就都一样了：</p><ul><li>bind 第一层调用 inet_stream_ops 的 inet_bind 函数，<br> 第二层调用 tcp_prot 的 inet_csk_get_port 函数；</li><li>listen 第一层调用 inet_stream_ops 的 inet_listen 函数，<br> 第二层调用 tcp_prot 的 inet_csk_get_port 函数；</li><li>accept 第一层调用 inet_stream_ops 的 inet_accept 函数，<br> 第二层调用 tcp_prot 的 inet_csk_accept 函数；</li><li>connect 第一层调用 inet_stream_ops 的 inet_stream_connect 函数，<br> 第二层调用 tcp_prot 的 tcp_v4_connect 函数。</li></ul><h2 id="课堂练习" tabindex="-1"><a class="header-anchor" href="#课堂练习" aria-hidden="true">#</a> <strong>课堂练习</strong></h2><p>TCP 的三次握手协议非常重要，请你务必跟着代码走读一遍。另外我们这里重点关注了 TCP 的场景，请走读代码的时候，也看一下 UDP 是如何实现各层的函数的。</p><p>欢迎留言和我分享你的疑惑和见解 ，也欢迎可以收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习和进步。</p><h2 id="课后讨论" tabindex="-1"><a class="header-anchor" href="#课后讨论" aria-hidden="true">#</a> 课后讨论</h2><ul><li>tcp_sock 继承自 inet_connection_sock，</li><li>inet_connection_sock 继承自 inet_sock，</li><li>inet_sock 继承自 sock；</li></ul><p>1.上述四个结构的关系具有十足的面向对象的特征，struct是基类，通过层层继承，实现了类的复用；</p><p>2.内核中网络相关的很多函数，参数往往都是struct sock，函数内部依照不同的业务逻辑，将struct sock转换为不同的业务结构；</p><p>这样做的好处： 1.简化接口的设计复杂度； 2.使用基类作为参数，十分类似于面向对象中的多态特性，能够有效的增强接口的稳定性、提升扩展性。</p><p>同一个TCP链接上先后发送2次rpc请求，后发送的请求其结果先返回，先发送的请求结果后返回，这样有没有问题呢，系统能区分各自的返回结果么，靠什么机制保证的呢？一直没有想明白<br> 作者回复：RPC是应用层的，需要应用层自己保证请求和结果的对应。</p><p>一些函数：<br> socket: 根据参数创建相应socket<br> bind: 绑定IP、端口<br> listen: 建立两个队列，改变状态为TCP_LISTEN<br> accept: 从完成三次握手的队列中取出一个socket，没有的话让出cpu<br> connect: 三次握手</p><p>调用accept的时候,会新建一个socket,以及其对应的struct file,然后会从icsk_accept_queue 取出一个req,将其sk赋值给新建的socket-&gt;sk,这样就可以读取到请求的数据了,不理解的是后面讲到接收数据包时tcp层有三个队列,会根据内核低延时 高吞吐量的等策略以及socket当时的状态来决定放入哪个队列,这里的socket是怎么选出来的啊,数据包是先发送到处于监听队列的socket然后由其将数据分发到其通过accept生成的sokcet上吗,如果是直接由通过accept生成的socket来处理,怎么分辨出来到底该给哪个socket呢,根据数据包的源地址与端口吗?<br> 作者回复: 监听的端口号</p><p>syn到底是个什么东西呀？是个integer还是char类型<br> 作者回复: 详见网络包的格式，TCP头里面有syn</p>',169),i=[c];function l(u,k){return s(),a("div",null,i)}const v=n(o,[["render",l],["__file","M44-Socket内核数据结构.html.vue"]]);export{v as default};
