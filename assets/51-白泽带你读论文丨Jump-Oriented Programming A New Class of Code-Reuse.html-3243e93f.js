import{_ as i}from"./640-edc8dc9c.js";import{_ as s}from"./plugin-vue_export-helper-c27b6911.js";import{r,o as n,c as o,a,b as e,e as c,d}from"./app-cdabc73c.js";const g="/assets/640-1691462083261-1-da03f86f.png",p="/assets/640-1691462083261-2-fbe53c62.png",h="/assets/640-1691462083261-3-b88fbf12.png",l="/assets/640-1691462083261-4-359c6e5c.png",m={},_=a("h1",{id:"_51-白泽带你读论文丨jump-oriented-programming-a-new-class-of-code-reuse",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#_51-白泽带你读论文丨jump-oriented-programming-a-new-class-of-code-reuse","aria-hidden":"true"},"#"),e(" 51-白泽带你读论文丨Jump-Oriented Programming: A New Class of Code-Reuse")],-1),f=a("p",null,"Jump-Oriented Programming: A New Class of Code-Reuse Attack",-1),u={href:"https://www.comp.nus.edu.sg/~liangzk/papers/asiaccs11.pdf",target:"_blank",rel:"noopener noreferrer"},b=d('<p>本文发表在AsiaCCS 2011，出自新加坡国立大学梁振凯教授的研究组。</p><h2 id="_1-主要内容" tabindex="-1"><a class="header-anchor" href="#_1-主要内容" aria-hidden="true">#</a> <strong>1 主要内容</strong></h2><p>ROP（Return-oriented Programming）是一种典型的代码复用攻击技术，本文受到ROP攻击的启发，提出了一种新型的利用<mark>跳转指令</mark>拼接控制流的代码复用攻击技术JOP（Jump-Oriented Programming）。在ROP攻击中，攻击者通过控制<em>堆栈中的ret指令的地址</em>来拼凑执行恶意的代码片段（gadgets），而JOP并不依赖堆栈，其通过在程序代码地址空间中寻找可以修改<mark>EIP寄存器</mark>的调度片段（Dispatcher gadgets）来执行指定的攻击代码片段。</p><p>作者设计并实现了一套切实可行的寻找gadgets的方法，并以libc2.7.so为目标在x86架构的Linux系统上实现了该种攻击，证明了该攻击的可行性和破坏性。</p><h2 id="_2-原理与实现" tabindex="-1"><a class="header-anchor" href="#_2-原理与实现" aria-hidden="true">#</a> <strong>2 原理与实现</strong></h2><figure><img src="'+i+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>JOP的攻击原理如上图所示，其中 Dispatcher的作用是控制虚拟PC，进而调用不同的gadgets，而在每个gadgets执行结束后，要求必须通过JMP指令将控制流重新指向Dispatcher，这可以通过控制寄存器中JMP的参数来实现。一个简单的例子如下：</p><figure><img src="'+g+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>Dispatcher使用寄存器edx中的值作为虚拟PC，通过对edx的值进行累加操作以指向dispatch table，随后利用JMP指令来执行不同的gadgets。在gadgets执行完毕后，攻击者可以通过控制寄存器esi、edi来使控制流回到Dispatcher中进行下一轮的分发。</p><h3 id="a-dispatcher-gadgets" tabindex="-1"><a class="header-anchor" href="#a-dispatcher-gadgets" aria-hidden="true">#</a> a) Dispatcher Gadgets</h3><p>Dispatcher需要满足如下范式来控制虚拟PC，虚拟PC可以是内存中的一个值，也可以是寄存器的值。</p><figure><img src="'+p+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>此外，作者设计了以下启发式算法从代码中扫描Dispatcher：</p><p>1）虚拟PC必须在代码片段中有所修改，例如上文例子中的累加操作，</p><p>2）使用无法修改PC的黑名单来过滤代码，</p><p>3）如果有完全覆盖虚拟PC的操作，那么要求覆盖的值必须是自引用的。</p><h3 id="b-functional-gadgets" tabindex="-1"><a class="header-anchor" href="#b-functional-gadgets" aria-hidden="true">#</a> b) Functional Gadgets</h3><p>Dispatcher不执行实际的功能，只是修改虚拟PC使得程序可以跳转到特定Functional gadgets。Functional gadgets主要包含以下几类：Loading data、Memory access、Arithmetic and logic、Branching、System calls。对于大部分类别，使用关键opcode的匹配即可，对于Branching，则利用间接跳转中存在保存比较结果的Flag为特征进行搜索。</p><h3 id="c-initial-attack" tabindex="-1"><a class="header-anchor" href="#c-initial-attack" aria-hidden="true">#</a> c) Initial attack</h3><p>该攻击首先需要通过控制寄存器的值令程序执行Dispatcher。任意控制寄存器的漏洞都可以被用来初始化攻击，一个经典的方法是使用setjmp函数进行初始化，当寄存器的原值在setjmp中被存储入jmp_buf中时，通过缓冲区溢出漏洞复写jmp_buf，从而当setjmp进行恢复寄存器值时，就完成了攻击的初始化。</p><h2 id="_3-攻击实例" tabindex="-1"><a class="header-anchor" href="#_3-攻击实例" aria-hidden="true">#</a> <strong>3 攻击实例</strong></h2><p>文章针对x86 32bit 的Debian Linux 5.0.4 ，以/lib/i686/cmov/libc2.7.so为目标进行gadgets的扫描，初步找出了31,136潜在的gadgets，又以使用最少寄存器为原则经过进一步筛选，最终找到如下可用的Dispatcher：</p><figure><img src="'+h+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>文章的攻击目标为调用一个攻击者可控参数的system call，通过搜索，作者在程序中找出了以下Functional gadgets：</p><figure><img src="'+l+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>该攻击首先设置寄存器eax的值，并通过控制寄存器ebx，ecx与edx来控制系统调用参数，最终开启系统调用。</p><h2 id="_4-总结评价" tabindex="-1"><a class="header-anchor" href="#_4-总结评价" aria-hidden="true">#</a> <strong>4 总结评价</strong></h2><p>本文的攻击与ROP十分类似，从原理上都是通过一些内存漏洞与广义的跳转指令来劫持控制流，与ROP相比该攻击的构造上似乎更为灵活，但实际上针对JMP的构造由于前后的gadgets对寄存器的隐式依赖使得构造十分复杂，且可用gadgets也并没有ROP丰富。但是，利用JMP的思路很新颖，且对于当前针对ROP攻击的防御手段比较有效。</p>',28);function P(x,C){const t=r("ExternalLinkIcon");return n(),o("div",null,[_,f,a("p",null,[e("原文链接："),a("a",u,[e("https://www.comp.nus.edu.sg/~liangzk/papers/asiaccs11.pdf"),c(t)])]),b])}const w=s(m,[["render",P],["__file","51-白泽带你读论文丨Jump-Oriented Programming A New Class of Code-Reuse.html.vue"]]);export{w as default};
