import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as n,c as i,a,b as e,e as d,d as p}from"./app-cdabc73c.js";const s="/assets/640-1691473526971-231-e35cd921.png",l="/assets/640-1691473526971-232-50321727.png",c="/assets/640-1691473526971-233-0eb28c46.png",h="/assets/640-1691473526971-234-909b90f2.png",_={},g=a("h1",{id:"_39-白泽带你读论文丨block-oriented-programming-automating-data-only-attacks",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#_39-白泽带你读论文丨block-oriented-programming-automating-data-only-attacks","aria-hidden":"true"},"#"),e(" 39-白泽带你读论文丨Block Oriented Programming: Automating Data-Only Attacks")],-1),m=a("p",null,[a("strong",null,"Block Oriented Programming: Automating Data-Only Attacks")],-1),f=a("p",null,"原文链接：",-1),u={href:"https://arxiv.org/pdf/1805.04767.pdf%E3%80%82",target:"_blank",rel:"noopener noreferrer"},y=p('<p>这篇文章收录在CCS 2018。其一作来自普渡大学，来自于Mathias Payer教授带领的研究组，从事于软件安全、系统安全、二进制程序分析等领域。</p><h2 id="_1-主要内容" tabindex="-1"><a class="header-anchor" href="#_1-主要内容" aria-hidden="true">#</a> <strong>1 主要内容</strong></h2><p><em>控制流劫持</em>是一种很常见的针对二进制程序的攻击方式。攻击者利用漏洞修改程序的正常执行流程，并将其控制流转移到攻击者指定的代码执行。比如利用buffer overflow漏洞，攻击者可以用一个攻击者可控的地址覆盖函数的返回地址，使得函数返回时跳转到该地址执行。</p><p>当前针对控制流劫持的防御技术主要有以下几类：</p><p>（1）DEP，通过将存放数据的内存页设置为不可执行来防止恶意指令执行。</p><p>（2）ASLR，通过对堆、栈、共享库映射等线性区布局的随机化，增加攻击者预测目的地址的难度，防止攻击者直接定位可利用代码的位置。</p><p>（3）CFI，通过控制程序间接跳转时目的地址的范围来降低攻击者的能力。</p><p>（4）Shadow Stacks，用来保护程序的返回地址。</p><p>尽管已有防御技术可以在一定程度缓解控制流劫持攻击，攻击者仍可通过对程序内存中的数据进行操控，使得程序按照攻击者期望的方式执行，即data-only attacks。</p><p>本篇工作中，作者通过修改内存中的关键数据，在符合程序原有控制流的情况下，达到任意代码执行的目的。作者首先依据跳转指令，将程序划分为一个个基本块。通过对这些基本块进行分析，作者找出其中<mark>能够实现目标payload功能的功能块</mark>和<mark>能够将这些功能块串联起来的分发块</mark>，这些功能块和分发块构成了一条执行目标payload的路径。作者结合程序中已有的内存任意写漏洞，修改关键数据，使得目标程序沿着找出的路径执行目标payload所实现的功能。</p><p>作者基于该方法实现了<mark>BOPC工具</mark>（Block Oriented Programming Compiler，一个在控制流劫持防御技术保护下自动寻找可攻击点的框架），并尝试分别在10个目标程序中执行13段payload，在130次尝试中成功了105次，占总数的81%。</p><h2 id="_2-设计与实现" tabindex="-1"><a class="header-anchor" href="#_2-设计与实现" aria-hidden="true">#</a> <strong>2 设计与实现</strong></h2><p>BOPC工具的输入有3个，分别是目标二进制文件，至少一个任意内存写漏洞，以及供BOPC分析的入口点。BOPC工具的工作流程图如下，主要分为4个大步骤：</p><figure><img src="'+s+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h3 id="_1-编写spl-payload" tabindex="-1"><a class="header-anchor" href="#_1-编写spl-payload" aria-hidden="true">#</a> 1）编写SPL Payload</h3><p>攻击者首先使用SPL语言编写目标payload。SPL语言是作者在本文中提出来的一种高级语言，其语法与C语言相似。使用SPL语言编写payload能够避免考虑指令集之间的差异。SPL语言以语句（Statement）为单位，它定义了一系列虚拟寄存器，可以被映射到真正的寄存器上，以便实现payload时灵活选择。下面是用SPL语言编写的payload的两个实例，他们分别实现了一个循环结构，和一个shell利用的功能：</p><figure><img src="'+l+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>（注：上图中以以两条短横开始的变量指的是寄存器，如__r0）</p><h3 id="_2-选择功能块" tabindex="-1"><a class="header-anchor" href="#_2-选择功能块" aria-hidden="true">#</a> 2）选择功能块</h3><p>通过分析目标程序，该工具首先得到该程序的控制流图。图中的每个基本块都以跳转指令结尾，且每一个块都包含了该块中指令对程序运行时环境影响的信息，比如内存器的改变、内存的改变等。作者认为SPL Payload中的每一条语句都能够被CFG图中某些基本块所实现。因此在这一步中，作者基于CFG图中每个基本块所包含的信息，为spl payload 中的每一条statement找出能够实现其功能的基本块。这些基本块作为潜在的功能块，被称为候选块。</p><h3 id="_3-搜索分发块" tabindex="-1"><a class="header-anchor" href="#_3-搜索分发块" aria-hidden="true">#</a> 3）搜索分发块</h3><p>接着，作者搜索出所有可能的分发路径，并将这些路径上的候选块作为功能块，其余的作为分发块。具体来讲，作者由payload中第一条语句所对应的候选块出发，搜索可以抵达第二条语句所对应的候选块的路径，并依次找出可以抵达所有payload语句的路径。确定分发路径的原则是，路径上的分发块不能破坏当前计算路径的状态。比如，对于一个已经确定值的寄存器，分发块不能修改其中的值，否则终止对于该条路径的搜索。由于每条语句对应着很多候选块，导致存在众多的搜索路径，因此在有限时间里作者仅尝试可能性较高的路径。作者认为如果一条分发路径上的分发块越少，那么该路径中状态被破坏的可能性就越小，因此优先搜索分发块最少的路径。作者通过构建Delta Graph记录分发路径的最小诱导图，以及搜索过程中的状态，从而实现最优搜索。下面是一个Delta Graph的例子：</p><figure><img src="'+c+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h3 id="_4-连接bop指令块" tabindex="-1"><a class="header-anchor" href="#_4-连接bop指令块" aria-hidden="true">#</a> 4）连接BOP指令块</h3><p>对于已有的分发路径，作者通过模拟执行分发路径，确定需要通过何种对内存的修改才能使得程序能够按照这些路径执行。如果在模拟执行过程中，工具发现存在一种内存修改方式，可以使得目标payload中的所有语句都被依次执行，则认为可以成功完成攻击目标。</p><figure><img src="'+h+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>上图展示了BOPC如何利用NGINX服务器程序漏洞执行一段payload。图中矩形和椭圆表示基本块，多边形表示分析得到的功能块，蓝色线条表示最终找到的分发路径。</p><h2 id="_3-实验评估" tabindex="-1"><a class="header-anchor" href="#_3-实验评估" aria-hidden="true">#</a> <strong>3 实验评估</strong></h2><p>作者基于现实中的10个常见应用，分别尝试在其中执行13段payload。这些应用被现有的防御控制流劫持攻击的技术所保护，只能利用其中的内存任意写漏洞来攻击。在总共130次尝试中，有105次成功在目标二进制程序中执行了payload。通过该实验，作者证明了在已有控制流劫持防御技术的保护下，仅使用数据攻击的方案是可行的，并且能够取得不错的效果。</p><h2 id="_4-总结评价" tabindex="-1"><a class="header-anchor" href="#_4-总结评价" aria-hidden="true">#</a> <strong>4 总结评价</strong></h2><p>作者提出的BOPC分析工具想法比较新颖。它能够利用高级语言编写payload，并且基于代码块进行分析，找出实现了payload中语句功能的块，再加以连接，形成最终的BOP利用链。但是本文工作尚有不足，其一是作者只考虑了每条语句仅仅由一个功能块来实现，没有考虑一条语句可能由多个功能块共同实现的情况。另一种是，因为搜索时间限制，作者在尝试分发路径的时候仅仅尝试了有限条可能性较高的路径。在作者的思路下，这两种情况都可能导致丢失最终漏洞利用的方案。</p>',31);function k(P,b){const t=o("ExternalLinkIcon");return n(),i("div",null,[g,m,f,a("p",null,[a("a",u,[e("https://arxiv.org/pdf/1805.04767.pdf。"),d(t)])]),y])}const B=r(_,[["render",k],["__file","39-白泽带你读论文丨Block Oriented Programming Automating Data-Only Attacks.html.vue"]]);export{B as default};
