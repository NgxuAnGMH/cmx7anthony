import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as r,d as i}from"./app-cdabc73c.js";const p="/assets/616bca3d76779c6bb3e7f2b2f77316d3-30fcd5e2.jpg",m="/assets/7fc388859b3981e398fc456b3b5539d3-950418eb.jpg",c="/assets/d78fd983c18af99826bc3a160d19c1ce-6698bbfc.jpg",o="/assets/f3a04735ca4439715b7d5eae386e8509-d82b4d88.jpg",t="/assets/cabf6327b721f48233f5f374f1df32ea-eaaa5d20.jpg",n="/assets/0afee91b6311050140bee36155135203-57a1292b.jpg",h="/assets/9d6efcbbe24d7ae8c58140a11a9a2473-5b58e276.jpg",s="/assets/785f246b72a1b6279bbc5942084dde42-8b3f0848.jpg",d={},l=i(`<h1 id="_31-外设通信-io-cache与io调度" tabindex="-1"><a class="header-anchor" href="#_31-外设通信-io-cache与io调度" aria-hidden="true">#</a> 31｜外设通信：IO Cache与IO调度</h1><p>你好，我是 LMOS。</p><p>从这节课开始，我们进入 IO 相关基础知识的学习，想要开发高性能的应用程序，这些基础知识必不可少。</p><p>前面的课程里，我们已经对进程和内存有了一定了解。进程在运行时刻和 CPU 是紧密相关的，抽象出进程就是为了提高 CPU 的利用率。因此，我们关注进程和内存，等同于关注 CPU 和 RAM。</p><p>一个计算机系统，无论是 PC，还是手机，除了有 CPU 和 RAM，还有各种外设，如键鼠、硬盘、显卡、以太网卡、声卡等各种 USB 扩展设备。</p><p>这些设备独立在 CPU 和内存之外，统称为外设。但是，外设通信的速度、大小、数据类型和传输方式各不相同，所以为了实现系统的整体效率最大化，操作系统实现了 <u>IO Cache</u> 和 <u>IO 调度</u>。今天我们就来研究它们。</p><h2 id="io-cache" tabindex="-1"><a class="header-anchor" href="#io-cache" aria-hidden="true">#</a> IO Cache</h2><p>顾名思义，Cache 即为缓存，IO 是指令外设传输（IN/OUT）数据的操作。</p><p>缓存是怎么回事我们都知道，由此我们就可以这样理解 IO Cache：<em>把外设的 IO 操作的数据保存起来</em>，</p><ol><li>当重新执行 IO 操作时，先从之前保存的地方开始查找， <ol><li>若找到需要的数据，即为命中，这时就不要去操作外设了；</li><li>若没有命中就去操作外设。</li><li>其中的数据，会根据 IO 操作频率进行组织，<br> 把操作最频繁的内容放在最容易找到的位置，达到性能最优化。</li></ol></li></ol><h3 id="_1-命令-free-m" tabindex="-1"><a class="header-anchor" href="#_1-命令-free-m" aria-hidden="true">#</a> 1 命令：free -m</h3><p>我们在终端中输入如下命令，感受一下 ：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>free -m
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>该命令是用来显示 Linux 系统上内存的使用情况的，单位以 MB 计。</p><p>输入这条命令，我们会得到如下图所示的情况：</p><figure><img src="`+p+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>上图中的 <mark>buff/cache</mark>，就是我们所说的 <em>IO Cache 占用的内存</em>。从这个角度，是不是看得更透彻了？所谓 IO Cache，不过是操作系统基于某种算法管理的一块内存空间，用该内存空间 <em>缓存 IO 设备的数据</em>，应用多次读写外设数据会更方便，而不需要反复发起 IO 操作。</p><ul><li>其实早期的 Cache 是位于 CPU 和内存之间的高速缓存，</li><li>由于<mark>硬件</mark>实现的 Cache 芯片的速度仅次于 CPU，而内存速度远小于 CPU，<br><em>Cache 只是为了缓存内存中的数据</em>，加快 CPU 的性能，避免 CPU 等待内存。</li><li>而 <em>Buffer</em> 是在内存中由<mark>软件</mark>实现的，<em>用于缓存 IO 设备的数据</em>，<br> 缓解由于 IO 设备过慢带来系统性能下降。</li></ul><h3 id="_2-buffer缓存-page缓存" tabindex="-1"><a class="header-anchor" href="#_2-buffer缓存-page缓存" aria-hidden="true">#</a> 2 Buffer缓存 &amp; Page缓存</h3><p>但是现在 Buffer 和 Cache 成了在计算机技术中<u>被用滥的两个名词</u>。在 Linux 的内存管理中，<strong><mark>Buffer</mark> 指 Linux 内存的 <mark>Buffer Cache</mark>，而 <mark>Cache</mark> 是指 Linux 内存中的 <mark>Page Cache</mark></strong>，</p><p>翻译成中文可以叫做<mark>缓冲区缓存</mark>和<mark>页面缓存</mark>，<em>用来缓存 IO 设备的读、写数据</em>。</p><p>补充一句，这里的 <mark>IO 设备</mark>，主要指的是<mark>块设备文件</mark>和<mark>文件系统上的普通文件</mark>。</p><p>在当前的 Linux 内核中，<strong><mark>Buffer Cache</mark> 建立 <mark>Page Cache</mark> 之上</strong>，如下图所示：</p><blockquote><p>可以理解为建立在分页管理机制上？</p></blockquote><img src="'+m+'" alt="img" style="zoom:33%;"><p>在现代 Linux 的实现中，远比上图画得要复杂得多，不过我们只需要关注这个层次结构就行了。<mark>Buffer Cache</mark> 中有多个小<em>块</em>组成，<u>块大小通常为 512 字节</u>，在 Linux 内核中用一个 <em>struct Bio</em> 结构来描述<em>块</em>。</p><ol><li>而一个<em>物理内存页</em>中存在多个<em>块</em>，</li><li>多个 <em>struct Bio</em> 结构形成 <mark>Buffer Cache</mark>，</li><li>多个这种页就形成了 <mark>Page Cache</mark>。</li></ol><p>在操作系统理论中，<strong>这一套实现机制被抽象为 IO Cache</strong>。但是，各种操作系统的实现的叫法不同，在此不必展开了，我们只需要明白它们能在内存中缓存设备数据就行了。</p><h3 id="_3-三大逻辑层" tabindex="-1"><a class="header-anchor" href="#_3-三大逻辑层" aria-hidden="true">#</a> 3 三大逻辑层</h3><p>我们明白了 Buffer Cache 和 Page Cache 的概念，下面我们以 Linux 读写硬盘的过程为例，研究一下 IO 操作时 IO Cache 发挥的作用。</p><p>一般情况下，Linux 内核中的 IO 操作，会从上至下经过三大逻辑层，具体如下：</p><ol><li><p><mark>文件系统层</mark>。因为 Linux 中万物皆为文件，IO 操作首先会经过文件系统，Linux 为了兼容不同的文件系统，对文件、目录等文件系统对象进行了抽象，形成了 <mark>VFS 层</mark>，也是 IO 操作经历的第一层。</p><ol><li>DirectIO：不经过 Cache，直接由块层发送到设备层，完成 IO 操作</li><li>BufferedIO：缓存命中的话，IO 操作到达 Page Cache 之后就返回了</li></ol></li><li><p><mark>块层</mark>。Linux 内核把各种设备分成<mark>块设备</mark>，<mark>字符设备</mark>、</p><ol><li><em>网络设备和硬盘</em>都属于块设备，</li><li>块层主要负责<u>管理<mark>块设备的 IO 队列</mark>，（<mark>IO调度器</mark>）对 IO 请求进行合并、排序等</u>操作。</li></ol></li><li><p><mark>设备层</mark>。具体设备驱动通过 <mark>DMA</mark> 与内存交互，完成数据和具体设备之间的交换，此例子中的设备为硬盘。</p></li></ol><p>我们画一幅图，表示一下这个过程：</p><img src="'+c+'" alt="img" style="zoom:33%;"><p>IO 操作在到达 Linux 的 VFS 层后，会根据相应的 IO 操作标志确定是 <mark>DirectIO</mark> 还是 <mark>BufferedIO</mark>，如果是前者则不经过 Cache，<em>直接由块层发送到设备层</em>，完成 IO 操作；如果是后者，（Cache缓存命中的话）则 IO 操作<em>到达 Page Cache 之后就返回了</em>。</p><p>在某一时刻，Linux 会启动 <mark>pdflush 线程</mark>，该线程会扫描 PageCache 中的<strong>脏页</strong>，进而找到对应的 Bio 结构，然后把 Bio 结构发送给块层的 <mark>IO 调度器</mark>，调度器会对 bio 进行<u>合并、排序，以提高 IO 效率</u>。</p><p>之后，调用设备层的相关函数将 Bio 转发到<mark>设备驱动程序</mark>处理，设备驱动程序函数对 IO 请求队列中每个 Bio 进行分别处理，根据 Bio 中的信息向==磁盘控制器（DMA？）==发送命令。处理完成后，调用 Bio 完成函数以通知上层完成了操作。这便是一个 IO 操作的过程。</p><h2 id="io-调度" tabindex="-1"><a class="header-anchor" href="#io-调度" aria-hidden="true">#</a> IO 调度</h2><p>在前面，我们已经明白了 IO Cache 的概念，它本质是把 IO 操作的数据，保存在内存中，使得在读取外设数据时能直接从内存中读取，或者数据缓存到一定量时，由一个特定任务在以后的某个时间批量地写入外设，<em>这不但会提高系统整体吞吐量，还能保护设备以延长寿命</em>。</p><p>我们把 IO 操作缓存起来了，这样操作系统就对 IO 操作有了控制权，具体点说就是可以对 IO 操作进行调度。</p><p>我先不直接说明 IO 调度是干什么的，先结合例子带你一起分析看看。我们从软件层面来看一个场景：假如一个应用程序往硬盘中写入 1GB 大小的文件，但是这个应用程序很调皮，它每次只写入一个字节。如果没有 IO Cache 和 IO 调度，可以想见，这需要发生多少次 IO 操作才能完成，如果硬件能说话，估计要骂人。</p><p>再来说说硬件自己结构的问题，这里以机械硬盘为主。千万不要感觉机械硬盘已经淘汰了，其实在很多服务器上仍然大量使用它。硬盘结构如下所示：</p><img src="'+o+'" alt="img" style="zoom:25%;"><p>一个硬盘中有多个盘片，一个盘片上有多个同心圆组成的多条磁道，每条磁道上有多个扇区，一个扇区 512 字节，磁头来回移动经过多个同心圆形成的柱面定位到一个扇区。很显然，找到一个扇区花费的时间等于磁头移动时间加上盘片旋转的时间。这些运动都是机械运动，是非常缓慢的。</p><p>以上两个场景，提醒我们有两个问题需要考虑，<em>一是怎么降低 IO 操作次数，二是如何优化硬盘寻址</em>。这两个问题解决好了，都能大大提升系统性能。想解决第一个问题，我们可以对 IO 操作进行缓存和合并；而对于第二个问题，我们可以对 IO 操作进行排序，能让硬盘磁头按照一定的顺序定位扇区，解决这些问题的就是 IO 调度器。</p><p>有了 IO 调度器，还得有相应的调度算法，IO 调度器提供了多种调度算法来适应不同的 IO 请求场景。有的场景需要的是提高 IO 吞吐量，<u>比如数据库后台的储存引擎</u>；有的场景则是要降低 IO 响应时间，<u>比如游戏应用程序</u>。</p><h3 id="调度算法-1-noop" tabindex="-1"><a class="header-anchor" href="#调度算法-1-noop" aria-hidden="true">#</a> 调度算法 1：Noop</h3><p>我们先看看第一种调度算法，该算法名为 Noop。<strong>Noop 是最简单的 IO 调度算法</strong>，其实可以说它是没有“调度”的 IO 调度，因为 Noop 会把所有的 IO 请求，几乎按照先来后到的顺序放入<mark>先进先出队列</mark>之中。</p><p>之所以说“几乎”，是因为 Noop 在先进先出队列的基础上，<em>还做了相邻 IO 操作的合并</em>，而不是完完全全按照先进先出的规则满足 IO 操作。我来给你画一幅图，展示一下这个算法实施的操作，如下所示：</p><figure><img src="'+t+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>一个个 BIo 结构进入 Noop IO 调度器，产生 request 结构，这个结构中包含 Bio 链表。Noop IO 调度器把扇区相邻的 Bio 合并在一起形成 request 结构，然后将 requset 结构挂载到块设备的 requset_queue 中，块设备通常是你的硬盘。</p><h3 id="调度算法-2-cfq" tabindex="-1"><a class="header-anchor" href="#调度算法-2-cfq" aria-hidden="true">#</a> 调度算法 2：CFQ</h3><p>然后，我们来看看第二种调度算法，该算法名为 <mark>CFQ</mark>，全称为 <em>Completely Fair Queuing</em>。由于传统的机械硬盘上，硬盘寻址花去了绝大多数的 IO 操作的时间，所以要优化硬盘寻址所花的时间。</p><p>CFQ 调度器的出发点就是<strong>对 IO 操作扇区地址进行排序</strong>，比如硬盘旋转到 1 号扇区，很快就旋转到 2 号扇区，如果你先访问 2 号扇区再次访问 1 号扇区，则要等到硬盘旋转一周后，才能到达 1 号扇区。CFQ 调度器对其进行排序后，就能通过尽量少的硬盘旋转次数，来满足尽可能多的 IO 操作。CFQ 调度器算法执行逻辑如下图所示：</p><figure><img src="'+n+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>我们看到在 CFQ 调度器下，将多个 BIO 结构生成 requset 结构时，会按照扇区地址升序挂载到块设备的 requset_queue 中，这会使机械硬盘的吞吐量大大提高。</p><p>相比 Noop 调度器，不知道你有没有发现一个问题：先来的 IO 操作并不一定能被满足，还可能会出现饿死的情况。比如，先来一个 IO 操作扇区地址是 1000，然后不停地进入扇区地址小于 1000 的 IO 操作，就会出现饿死现象。</p><h3 id="调度算法-3-deadline" tabindex="-1"><a class="header-anchor" href="#调度算法-3-deadline" aria-hidden="true">#</a> 调度算法 3：Deadline</h3><p>我们来看一看最后一种 IO 调度算法，该算法名为 <mark>Deadline</mark>，Deadline 调度器提供了<mark>两个红黑树</mark>以及<mark>两个先进先出队列</mark>，两个红黑树分别对读、写的 IO 操作按照其扇区地址排序，同时给每个 IO 操作添加超时时间，并插入到对应的（读、写）先进先出的队列尾部。这样一来，一个 IO 操作会同时挂在红黑树和先进先出队列中。</p><p>当 Deadline 调度器在发送一个 IO 操作时，会综合考虑 IO 操作是否超时、是否饥饿，由此决定到底发送哪个 IO 操作，发送 IO 操作之后会将该 IO 操作同时在红黑树和先进先出队列中删除。</p><p>我来画一幅图，展示一下这个算法实施的操作，如下所示：</p><figure><img src="'+h+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>上图中读写队列分开，同时用红黑树对其排序，而且还加入了超时机制。硬盘驱动会找 Deadline IO 调度器获取 IO request，Deadline IO 调度器根据这些数据结构和算法分配 request，完美地解决了 CFQ IO 调度器的缺陷，由于读写分开且读优先于写，导致该算法非常适合<strong>数据库这种随机读写的场景</strong>。</p><h3 id="算法如何选取" tabindex="-1"><a class="header-anchor" href="#算法如何选取" aria-hidden="true">#</a> ##算法如何选取？</h3><p>我们发现，IO 调度器算法多种多样，那么要怎么选择呢？</p><p>其实选择 IO 调度器算法，<em>既要考虑硬件特性，也要考虑应用程序场景</em>。</p><p><strong>在传统的机械硬盘上</strong>，CFQ、Deadline 算法是不错的选择；对于专属的数据库服务器，Deadline IO 调度器的 IO 吞吐量和 IO 响应时间综合性能都表现非常好。</p><p><strong>然而在新兴的固态硬盘</strong>，比如 SSD、NVMe 上，最简单的 NOOP IO 调度器反而是最好的 IO 调度器。因为 CFQ 和 Deadline 调度算法，最主要是为缩短机械硬盘寻址时间而优化的；而固态硬盘没有所谓的机械运动寻址部件需要的时间，而且很快能准备好数据，所以 IO 响应时间非常短。</p><h2 id="重点回顾" tabindex="-1"><a class="header-anchor" href="#重点回顾" aria-hidden="true">#</a> 重点回顾</h2><p>今天，我们一起学习了外设通信中的重要组件——缓存，它主要是在内存中开辟一大空间来暂时保存与外设通信的大量数据。这一点，我们通过在 Linux 上输入 free 命令已经看到，其实其它操作系统也具有类似机制，这里我们只是以 Linux 为例子。</p><p>为了搞明白 IO Cache 的概念，我们从 Linux 的缓存结构入手，发现 Linux 用物理内存页面为基础，建立了 Page Cache。在这个 Page Cache 之上，又建立了 Buffer Cache，BufferCache 组织了传输到 IO 设置上的数据块。我们通过对 IO 流程的探讨，发现 IO 操作可以不经过 IO Cache，而是直接到达设备。</p><p>之后，我们对软件场景和硬盘结构进行了讨论，发现有了 IO Cache 以后，还需要对 IO 请求进行调度，才能使 IO 效率最大化，针对不同的场景有不同 IO 调度器，我们重点讨论了三种 IO 调度算法，分别是 Noop、CFQ、Deadline，其中综合性能最好的是 Deadline。然而硬件技术的升级又产生了固态硬盘，导致这些 IO 调度器没有了用武之地，不调度就是最好的调度。</p><p>这节课的导图如下所示：</p><figure><img src="'+s+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题" aria-hidden="true">#</a> 思考题</h2><p>操作系统为什么要开发 IO Cache？</p><p>欢迎你在留言区和我交流讨论，如果觉得这节课对你有启发，别忘了分享给更多朋友！</p><blockquote><p>牛逼 这节课，很多之前不清楚的概念 弄明白了<br> 作者回复: 哈哈 有帮助就好</p><hr><p>文件系统有ntfs和ext4，很多游戏软件只支持ntfs格式，由于磁盘运行效率远低于cpu，好的算法文件系统可以提高磁盘的利用效率（包括跳过磁片中的坏点）<br> io cache是必须的，就好比如把d盘的文件a剪切到c盘中，观察可以得知，假如传输过程中故意关机等，再次开机文件a还在d盘。预计cpu是传输完再删除，这样尽可能的减少磁盘碎片（特别的减少不能被系统识别的碎片冗余存在），io cache也方便操作系统部分情况下延迟应对硬件需求！<br> 作者回复: 是的</p><hr><p>想问下，mmap 文件的话，是否经过pagecache啊，没搞清楚mmap和pagecache的关系，希望得到老师的指点。<br> 作者回复: 会经过pagecache</p><hr><p>固态硬盘的出现大大降低了io的耗时<br> 作者回复: 是的 正确</p><hr><p>很多不明白的点, 都在这个课程中解答了, 真的牛逼.<br> 想问下这些资料都是从哪获取的呢<br> 作者回复: 没有系统的资料 看linux代码</p></blockquote>',78),O=[l];function I(u,f){return a(),r("div",null,O)}const b=e(d,[["render",I],["__file","M31-设备Cache与IO调度.html.vue"]]);export{b as default};
