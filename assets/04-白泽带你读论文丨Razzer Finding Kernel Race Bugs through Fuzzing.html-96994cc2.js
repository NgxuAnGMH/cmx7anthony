import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o as t,c as o,a as r,b as a,e as s,d as c}from"./app-cdabc73c.js";const g="/assets/640-1691487433521-375-087834a6.jpeg",z="/assets/640-1691487433521-376-0358f241.jpeg",p={},_=r("h1",{id:"_04-白泽带你读论文丨razzer-finding-kernel-race-bugs-through-fuzzing",tabindex:"-1"},[r("a",{class:"header-anchor",href:"#_04-白泽带你读论文丨razzer-finding-kernel-race-bugs-through-fuzzing","aria-hidden":"true"},"#"),a(" 04-白泽带你读论文丨Razzer: Finding Kernel Race Bugs through Fuzzing")],-1),l=r("p",null,[r("strong",null,"Razzer: Finding Kernel Race Bugs through Fuzzing")],-1),u=r("p",null,[a("本文发表在"),r("strong",null,"IEEE Symposium on Security and Privacy 2019"),a("，第一作者是来自韩国科学技术院(KAIST)的DR Jeong。本文的第四作者，来自首尔大学的Byoungyoung Lee，长期从事二进制安全的相关研究，发表过多篇和内核安全有关的工作。")],-1),d={href:"https://github.com/compsec-snu/razzer",target:"_blank",rel:"noopener noreferrer"},h=c('<h2 id="主要内容" tabindex="-1"><a class="header-anchor" href="#主要内容" aria-hidden="true">#</a> 主要内容</h2><p><strong>内核中的数据竞争</strong>可能导致许多有害行为。最严重的后果是数据竞争导致内存污染最终可能造成非法权限提升，例如CVE-2016-8655, CVE-2017-2636, and CVE-2017-17712。目前的技术在内核数据竞争漏洞的检测与防护方面都存在一定的局限性。原因是内核中的数据竞争漏洞受到一些<strong>系统不确定性行为</strong>的影响，比如线程的调度与同步机制。因此与普通的漏洞相比，要检测这类漏洞除了需要控制流和数据流信息以外，还需要精准的并行执行信息。</p><p>在这个工作中，作者设计并提出了<strong>针对内核中的数据竞争类型漏洞的模糊测试（fuzzing）工具Razzer</strong>。作者的思路是引导fuzzing工具去执行可能存在数据竞争漏洞的代码。这包含了两种技术，一是通过<strong>静态分析</strong>来定位潜在存在数据竞争的代码；二是一种确定性的<strong>线程交错技术</strong>，来控制线程调度，以提供精确的并行执行信息，降低不确定性。本工作并没有去解决同步机制对多线程fuzzing的影响。</p><p>作者实现了Razzer的原型，并发现了30个新的内核的数据竞争漏洞，其中16个已经被确认。根据Razzer生成的漏洞报告，有14个已经被修补。</p><h2 id="问题定义" tabindex="-1"><a class="header-anchor" href="#问题定义" aria-hidden="true">#</a> 问题定义</h2><p>为了更好的检测数据竞争类型漏洞，作者对这类问题给出了一个明确的定义。</p><p>如果目标程序内两条内存访问的指令，满足以下3个条件，就是<strong>数据竞争</strong>:</p><ol><li>访问的内存地址相同</li><li>至少其中一条指令是对内存的写</li><li>两条指令可以并发执行</li></ol><p>同时，数据竞争并不都是漏洞，有一些数据竞争可能是开发者有意设计的，有一些数据竞争行为可能产生非预期的行为，这些才是数据竞争漏洞。作者还引入了一些标注，以便后续的说明：</p><p><strong>- RacePair_{cand}</strong>：可能满足上面三个条件的RacePair</p><p><strong>- RacePair_{true}</strong>：已确定满足上面三个条件的RacePair，是RacePair_{cand}的子集</p><p><strong>- RacePair_{benign}</strong>：属于预期内的数据竞争</p><p><strong>- RacePair_{harm}</strong>：非预期的数据竞争</p><h2 id="设计与实现" tabindex="-1"><a class="header-anchor" href="#设计与实现" aria-hidden="true">#</a> 设计与实现</h2><p>作者把检测内核中的数据竞争漏洞拆分成了两个设计需求（或者说任务）。</p><ol><li>找到一个执行RacePair_{cand}的程序。即找到一个多线程的用户态程序，每个线程能够在内核态分别执行到RaceRair_{cand}的指令。</li><li>找到一个线程执行序列，使得这RacePair_{cand}的指令能并行的执行。</li></ol><p>需求1把问题做了简化，并不去考虑并行执行的问题，就不用考虑线程调度对分析的影响。需求2主要是去寻找一个交错执行的线程调度方案，使得RacePair_{cand}的指令能并行执行。现在的大部分工具都是只针对上述的某一个需求的，而且都存在一定的需求。</p><p>Razzer结合使用了静态分析和动态分析的方法。先通过静态分析得到内核种潜在的存在数据竞争的代码RacePair_{cand}。之后会进行两阶段的动态分析，第一阶段进行单线程Fuzz,找到一个能执行到RacePair_{cand}的用户态程序。然后按照算法将这个程序转化为一个多线程程序（满足条件一）。第二个阶段是多线程Fuzz。会寻找特定的线程交错，使得在执行多线程程序的时候能并行执行RacePair_{cand}。如果找到了，则获得了一个RacePair_{true}。Razzer还会检测内核是否出现了错误，如果RacePair_{true}在程序后续执行过程中，导致了内核错误，则得到了一个RacePair_{harm}。整个工具的架构如图：</p><figure><img src="'+g+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>Razzer整体架构</p><p>以下是一些设计上的细节问题：</p><p><strong>1. 静态分析</strong>:作者使用了Point_to分析来寻找内核中对同一个结构体的内存访问。但传统的Point_to分析具有误报率高，复杂度高的缺陷。对于静态分析的结果，Razzer会通过后续的动态分析来确认，以避免误报。在性能上，作者基于一定的insight，对内核代码进行了分部分分析，以减小分析的代码量。</p><p><strong>2. 线程调度</strong>:待Fuzz的内核运行在虚拟化的环境中，为了控制虚拟CPU的调度，作者修改了虚拟环境的Hypervisor，增加了三个功能：1.为每个虚拟CPU设置断点。2.精确的控制，在恢复执行时哪个线程的访存语句先执行。不同的执行顺序会导致后续是否会导致错误行为。新的Hypervisor给Razzer提供了准确控制CPU调度的能力。</p><p><strong>3. 多线程Fuzz</strong>:这一步的关键是将单线程Fuzz输出的一个单线程程序Pst，转化为一个多线程版本Pmt。在转换过程中还会进行一些插桩，与Hypervisor协作控制程序的调度。转化算法如下:</p><figure><img src="'+z+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>转化算法代码</p><p>当Pmt中的RacePair_{cand}指令都触发断点时，Razzer会检查访存指令的访问地址是否相同，如果相同，则判定为RacePair_{true}。可以注意到在Pmt的最后加入了一些随机的syscall，这是为了使数据竞争如果造成了恶性后果，程序会报错。当检测到一个RacePair_{true},会把结果反馈回生成算法，保持前面的代码不变，只修改后续随机添加的syscall，进行新的Fuzz。如果其中某个Pmt使kernel报错，则是一个RacePair_{harm}。</p><h2 id="评价" tabindex="-1"><a class="header-anchor" href="#评价" aria-hidden="true">#</a> 评价</h2><p>Razzer最终发现了30个恶性的数据竞争漏洞。其中有16个已经被确认。此外作者还测量了工具的性能开销，并与最新的Fuzzing工具进行了比较。在可接受的额外开销下，能够更有效率的Fuzz这一类漏洞。</p><p>Razzer是一个专门Fuzz内核中数据竞争漏洞的工具，其<strong>亮点有二</strong>。</p><ol><li>通过静态分析得到一些RacePair_{cand},再用动态分析确认，即降低误报又减少了搜索空间。</li><li>通过算法与工具的结合，给Fuzz工具提供了比较准确的线程并行执行状态，解决了Fuzz多线程程序的重大挑战，值得借鉴。</li></ol>',31);function R(P,f){const e=i("ExternalLinkIcon");return t(),o("div",null,[_,l,u,r("p",null,[a("开源项目地址: "),r("a",d,[a("https://github.com/compsec-snu/razzer"),s(e)])]),h])}const b=n(p,[["render",R],["__file","04-白泽带你读论文丨Razzer Finding Kernel Race Bugs through Fuzzing.html.vue"]]);export{b as default};
