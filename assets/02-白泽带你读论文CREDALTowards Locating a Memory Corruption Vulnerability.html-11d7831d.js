import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as e,d as o}from"./app-cdabc73c.js";const i="/assets/640-1691488035304-384-22841fc8.jpeg",n="/assets/640-1691488035304-385-d1e1e715.jpeg",t={},c=o('<h1 id="_02-白泽带你读论文credal-towards-locating-a-memory-corruption-vulnerability" tabindex="-1"><a class="header-anchor" href="#_02-白泽带你读论文credal-towards-locating-a-memory-corruption-vulnerability" aria-hidden="true">#</a> 02-白泽带你读论文CREDAL:Towards Locating a Memory Corruption Vulnerability</h1><h2 id="论文名称" tabindex="-1"><a class="header-anchor" href="#论文名称" aria-hidden="true">#</a> 论文名称</h2><p><strong>CREDAL: Towards Locating a Memory Corruption Vulnerability with Your Core Dump</strong></p><h2 id="主要内容" tabindex="-1"><a class="header-anchor" href="#主要内容" aria-hidden="true">#</a> 主要内容</h2><p>这篇论文发表在<strong>CCS2016</strong>上，本文的工作主要由来自宾夕法尼亚大学的Jun Xu, Dongliang Mu完成。作者名单包括在安全界研究广泛、高产出的Ping Chen ，Xinyu Xing，Peng Liu等人。</p><p>当程序崩溃时，常常会生成<strong>coredump文件</strong>。coredump文件保存了程序在崩溃瞬间的内存状态和寄存器信息。我们可以利用coredump文件来追踪程序发生崩溃的原因。但是对于内存错误这类崩溃，coredump的作用是非常有限的，因为这类错误常常破坏程序的计数器或者程序的堆栈信息，这给定位程序崩溃点和追踪程序调用栈带来了阻碍。鉴于这一现状，作者设计了自动化调试工具<strong>CREDAL</strong>，这个工具尝试利用栈上的信息来恢复程序计数器的值，同时尽可能恢复程序栈帧的调用情况。此外，根据恢复的程序调用链和源程序构建控制流图来找到变量被破坏的情况，同时在源码上标记出可能被破坏的变量代码。作者测试了80个程序崩溃的coredump文件，发现<strong>CREDAL能够精确地恢复出程序崩溃点和调用栈，减少了手工调试的工作，加快了内存错误漏洞的定位。</strong></p><h2 id="设计与实现" tabindex="-1"><a class="header-anchor" href="#设计与实现" aria-hidden="true">#</a> 设计与实现</h2><p>程序崩溃点是调试诊断工作的开始点，程序的调用栈能够缩小包含漏洞的代码的范围。CREDAL尝试利用栈上保存的上一个函数栈帧信息来恢复程序崩溃点，并且尽可能地恢复程序的调用栈。此外，CREDAL为已恢复的函数调用栈构建CFG图，利用静态分析方法确定控制流图中变量的约束关系，找到coredump文件中违背约束的变量，将其指定为候选的被破坏的错误内存位置，并且在源码中指定这些违背约束的变量的位置。</p><p>CREDAL的设计分成4个阶段：<strong>(1) 确定崩溃的线程，(2) 追踪程序崩溃点，(3) 追踪程序调用栈，(4) 搜索变量约束违背点。</strong></p><ul><li>确定崩溃的线程。多线程程序崩溃时只能生成一个coredump文件，为了确定是哪个线程发生了崩溃，需要检查每个线程的程序计数器。如果pc指向非法的内存地址，或者指向的指令是非法的，或者这个指令尝试访问非法的内存空间，那么对应的线程就发生了崩溃。</li><li>追踪程序崩溃点。如果程序计数器被修改了，那么需要恢复正确的程序崩溃点。 <ul><li>(1)找到崩溃函数。程序崩溃时上一个调用的函数栈帧还保存在崩溃的栈上，那么可以通过这个函数来定位崩溃函数。如下图所示，crash()函数是崩溃函数，func()是崩溃点。bar()函数是崩溃之前调用的上一个函数，它的栈帧还保存在栈上，我们可以找到bar()函数的返回地址，进而确定崩溃函数是crash()。</li><li>(2)找到崩溃指令。根据上一步我们找到了崩溃函数，我们构建函数内的控制流图(Intra-procedural CFG)。如果程序计数器被修改了，那么肯定是间接跳转指令导致的（例如，ret, call eax）。我们根据coredump中的寄存器值和内存值来计算崩溃函数内的间接跳转的目的地址，如果匹配上了崩溃时的pc值，那么对应的间接跳转指令即为崩溃点。</li></ul></li></ul><figure><img src="'+i+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图1 崩溃点的恢复</p><ul><li>追踪程序调用栈。在程序编译时如果携带符号信息，那么coredump文件也会携带符号信息。通过符号信息和DWARF标准，CREDAL可以轻松地找到程序栈帧与相应函数之间的映射关系，继而恢复程序的调用栈信息。在此过程中，CREDAL会检查栈上的返回地址的合法性以及调用栈是否相邻来判断恢复的栈帧的正确性。如果崩溃时程序栈遭到破坏，那么检查失败，追踪过程终止，只能够恢复部分函数调用栈。</li><li>搜索变量约束的违背。根据恢复出的程序崩溃点和程序调用栈，CREDAL尝试找到哪些内存位置代表的变量被破坏，并且在源码上标记出来。实际上这一步是为恢复的函数中的所有变量定义约束，与coredump中的值比较，如果违背了约束范围，那么表明这些变量被破坏了。具体实施是从trace中的入口函数开始到程序崩溃点构建函数间的控制流图（Inter-procedural CFG）。并且为每个函数进行函数内部的point-to指针分析，并且计算函数内变量的reaching define关系。最后将每个函数的分析结果拓展到整个控制路图，构建出图中所有变量的约束关系。如果coredump中的变量值违背了约束，那么找到了变量约束的违背，根据符号信息，确定这些变量在源码中的行数，供安全人员进行进一步的分析。如图2所示，foo()函数是恢复出来的入口函数，其中func()是崩溃点。CREDAL根据恢复的函数调用栈构建出了控制流图，并且通过静态分析为其中的所有变量定义了约束。</li></ul><figure><img src="'+n+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图2 函数间的控制流图及约束生成</p><h2 id="评价" tabindex="-1"><a class="header-anchor" href="#评价" aria-hidden="true">#</a> 评价</h2><p>CREDAL充分利用了coredump文件中的剩余信息，尽可能地定位真实的程序崩溃地址，根据崩溃栈恢复程序的调用栈信息。并且根据恢复的调用栈构建出函数间的控制流图，再利用静态分析方法，例如point-to分析和reaching define分析为图中所有变量定义约束，通过coredump文件中的变量约束违背来找到被破坏的变量，从而定位到可能发生崩溃的源码。CREDAL极大地减少了安全人员的人工分析，加快了内存错误漏洞的定位。但是攻击者可以通过完全破坏程序栈阻止程序栈的恢复，也能够巧妙地构造payload避免对不必要的变量进行破坏来绕过变量约束违背的定位。</p>',17),d=[c];function l(p,s){return a(),e("div",null,d)}const g=r(t,[["render",l],["__file","02-白泽带你读论文CREDALTowards Locating a Memory Corruption Vulnerability.html.vue"]]);export{g as default};
