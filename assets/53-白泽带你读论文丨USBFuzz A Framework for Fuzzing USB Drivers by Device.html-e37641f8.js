import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o as u,c as z,a as e,b as i,e as s,d as o}from"./app-cdabc73c.js";const t="/assets/640-1691397225912-228-91c27168.png",c="/assets/640-1691397225912-229-37dd85cb.png",g="/assets/640-1691397225912-230-cfeb4d0f.png",l="/assets/640-1691397225912-231-3662c540.png",d="/assets/640-1691397225912-232-02e5727e.png",f={},S=e("h1",{id:"_53-白泽带你读论文丨usbfuzz-a-framework-for-fuzzing-usb-drivers-by-device",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_53-白泽带你读论文丨usbfuzz-a-framework-for-fuzzing-usb-drivers-by-device","aria-hidden":"true"},"#"),i(" 53-白泽带你读论文丨USBFuzz: A Framework for Fuzzing USB Drivers by Device")],-1),_=e("p",null,[e("strong",null,"USBFuzz: A Framework for Fuzzing USB Drivers by Device Emulation")],-1),m={href:"https://www.usenix.org/system/files/sec20-peng_0.pdf",target:"_blank",rel:"noopener noreferrer"},p=o('<p>本文发表在Usenix Security 2020，第一作者是来自普渡大学的Hui Peng。</p><h2 id="_1-主要内容" tabindex="-1"><a class="header-anchor" href="#_1-主要内容" aria-hidden="true">#</a> 1 主要内容</h2><p>通用串行总线（USB）是一种被广泛使用的接口，大量的外部设备通过它与主机连接。近年来出现了大量与驱动有关攻击，驱动的安全性引起了更多重视。但测试驱动必须跨过硬件和软件障碍，使测试数据到达驱动程序，这增加了测试驱动的难度。模糊测试（fuzzing）是一种应用最为广泛的程序测试技术，虽然先前已经有研究<em>将fuzzing用于测试驱动</em>，但因为测试驱动必须跨过硬件和软件障碍，先前方法存在不能大规模测试、可移植性差、fuzzing效率低等缺点。</p><p>作者提出了USBFuzz框架，利用软件<em>对USB设备进行模拟</em>，从而将fuzzing产生的输入数据提供给驱动程序，解决了难以使测试数据跨过硬件和软件障碍到达驱动程序的难点。并且软件模拟的USB设备工作在设备级别，不与操作系统或者内核深度绑定，将USBFuzz移植到其他平台非常方便。基于USBFuzz框架，作者在Linux平台实现了效率更高的基于代码覆盖率的fuzzing，对内核中的各种驱动程序进行了测试，并且对USB网络摄像头驱动进行了更加深入的fuzzing。作者也在FreeBSD、MacOS和Windows中进行了fuzzing实验。最后USBFuzz共总发现了26个新bug，包括16个Linux平台上危害程度高的内存bug，1个FreeBSD平台的bug，3个MacOS中bug，4个Windows平台的bug，1个Linux USB主机控制器驱动bug和1个在USB相机驱动中的bug，并且收获了10个CVE。</p><h2 id="_2-原理与实现" tabindex="-1"><a class="header-anchor" href="#_2-原理与实现" aria-hidden="true">#</a> 2 原理与实现</h2><h3 id="a-整体设计" tabindex="-1"><a class="header-anchor" href="#a-整体设计" aria-hidden="true">#</a> a) 整体设计</h3><p>在功能设计上，USBFuzz采用模块化的设计，整体设计分成<mark>宿主系统</mark>和<mark>客户系统</mark>。宿主系统包括<mark>Fuzzer模块</mark>，客户系统是一个建立在宿主系统上的虚拟机，主要包括<mark>Target Kernel</mark>, <mark>Fuzzing Device</mark>, <mark>Communication Device</mark>和<mark>User Mode Agent</mark>模块。</p><figure><img src="'+t+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>Fuzzer运行在宿主系统的用户空间，主要负责：</p><ul><li>(1) 产生随机的测试数据，并把数据输入给模拟的USB设备；</li><li>(2) 获取每一次测试的状态，并控制测试的开始和结束。</li></ul><ol><li>Target Kernel包含待测试的USB驱动程序，测试就是从模拟的USB设备读取输入，并处理输入数据的过程。</li><li>Fuzzing Device是一个模拟的USB设备，通过模拟的USB接口和Target Kernel连接，负责将fuzzer产生的数据交给kernel处理。</li><li>Communicate Device也是一个模拟的设备，负责客户系统和宿主系统的通信，并且将fuzzer的一块内存共享到客户系统，共享内存的主要作用是收集驱动执行的coverage信息，使fuzzer产生更好的测试数据。</li><li>User Mode Agent运行在客户系统的用户空间，作为守护进程监控每一次测试的状态，把状态通过communication device反馈给fuzzer。它还可以根据USB驱动的功能进行定制，并和USB设备交互以进行更加深入地fuzzing。</li></ol><h3 id="b-具体实现" tabindex="-1"><a class="header-anchor" href="#b-具体实现" aria-hidden="true">#</a> b) 具体实现</h3><p>USBFuzz的fuzzing基于AFL工具，使用<mark>QEMU</mark>模拟Fuzzing Device和Communication Device模块，并基于<mark>kcov</mark>工具完成对Linux内核coverage信息的收集。User Mode Agent在Linux和FreeBSD上通过扫描kernel日志得到每一次测试的状态信息。</p><h2 id="_3-实验与分析" tabindex="-1"><a class="header-anchor" href="#_3-实验与分析" aria-hidden="true">#</a> 3 实验与分析</h2><p>作者在Linux内核上对USBFuzz进行了测试，并将USBFuzz应用于FreeBSD, MacOS和Windows上。</p><p>漏洞发现能力：作者用USBFuzz测试了从v4.14.81到v4.20-rc2的9个Linux kernel版本，每个版本用四个实例测试了4周，一共发现了47个unique bug，其中包含了27个未被报告的bug。</p><p>与<mark>syzkaller</mark>的比较：作者分别使用USBFuzz和syzkaller的usb-fuzz模块对Linux Kernel v5.5.0进行了五轮测试，每轮耗时3天。在第一天的fuzzing中，USBFuzz发现了1个触发了BUG_ON语句的bug，syzkaller发现了3个不同的触发了WARNING语句的bug。在代码覆盖率方面syzkaller的总体代码覆盖率优于USBFuzz，并且可以覆盖USB gadget子系统的代码；而USBFuzz可以覆盖到host controller drivers的代码。所以在覆盖到的模块方面syzkaller和USBFuzz各有优劣，互为补充。</p><figure><img src="'+c+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><figure><img src="'+g+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>性能分析：在Linux 4.16的50个小时测试中，USBFuzz (0.1–2.6 exec/sec)和syzkaller (0.1- 2.5 exec/sec)有相似的吞吐量。此外作者还分析了USBFuzz的执行时间开销，发现每次执行的attach/detach的时间开销稳定在0.22秒，测试时间在0.2到10+秒内变化，并且11%的测试用时超过了2秒。这说明在长时间的测试中attach/detach的开销是可忽略的。</p><figure><img src="'+l+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><figure><img src="'+d+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>灵活性/可移植性：作者在FreeBSD, MacOS和Windows上用USBFuzz进行dump fuzzing。虽然作者不能获取这些系统上的coverage信息，但是可以采用异花传粉(cross-pollination)的方式将Linux fuzzing产生的输入作为种子。USBFuzz于1天内在MacOS上找到了3个bug，在Windows上找到了4个bug，并经过2周的fuzzing在FreeBSD上找到了1个bug。此外USBFuzz还在LifeCam VX-800设备的XHCI驱动上发现了一个bug。这些证明了USBFuzz的灵活性和可移植性。作者认为外围设备暴露了很有挑战性的攻击面，所以额外使用USBFuzz测试了SD卡驱动，可惜没有发现bug。</p><h2 id="_4-总结评价" tabindex="-1"><a class="header-anchor" href="#_4-总结评价" aria-hidden="true">#</a> 4 总结评价</h2><p>本文设计并实现了USBFuzz，一个针对USB驱动的Fuzzing工具。USBFuzz采用设备模拟的方式，可以定制化地fuzzing包括Linux, FreeBSD, MacOS和Windows在内的不同操作系统USB驱动。本文还基于kcov设计实现了对Linux中跨中断的代码覆盖率收集。USBFuzz在Linux, FreeBSD, MacOS和Windows上一共发现了26个新的bug证明了它的灵活性和可移植性。</p>',25);function B(h,U){const r=n("ExternalLinkIcon");return u(),z("div",null,[S,_,e("p",null,[i("原文链接："),e("a",m,[i("https://www.usenix.org/system/files/sec20-peng_0.pdf"),s(r)])]),p])}const k=a(f,[["render",B],["__file","53-白泽带你读论文丨USBFuzz A Framework for Fuzzing USB Drivers by Device.html.vue"]]);export{k as default};
