import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as p,o,c,a,b as n,e as l,d as s}from"./app-cdabc73c.js";const i="/assets/0723f72f3016fede96b545e2898c0541-8c42f84c.jpeg",r="/assets/8b9ad674953bf36680e815247de235d3-555c65e0.jpeg",u="/assets/67053624d6aa2a5c27c295e1fda4890d-71dd60d2.jpeg",k={},d=s(`<h1 id="_38-高速缓存-下-你确定你的数据更新了么" tabindex="-1"><a class="header-anchor" href="#_38-高速缓存-下-你确定你的数据更新了么" aria-hidden="true">#</a> 38 | 高速缓存（下）：你确定你的数据更新了么？</h1><p>在我工作的十几年里，写了很多 Java 的程序。同时，我也面试过大量的 Java 工程师。对于一些表示自己深入了解和擅长多线程的同学，我经常会问这样一个面试题：“<strong>volatile 这个关键字有什么作用？</strong>”如果你或者你的朋友写过 Java 程序，不妨来一起试着回答一下这个问题。</p><p>就我面试过的工程师而言，即使是工作了多年的 Java 工程师，也很少有人能准确说出 volatile 这个关键字的含义。这里面最常见的理解错误有两个，</p><ol><li>一个是把 volatile 当成一种锁机制，认为给变量加上了 volatile，就好像是给函数加了 sychronized 关键字一样，不同的线程对于特定变量的访问会去加锁；</li><li>另一个是把 volatile 当成一种原子化的操作机制，认为加了 volatile 之后，对于一个变量的自增的操作就会变成原子性的了。</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 一种错误的理解，是把volatile关键词，当成是一个锁，可以把long/double这样的数的操作自动加锁</span>
<span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">long</span> synchronizedValue <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token comment">// 另一种错误的理解，是把volatile关键词，当成可以让整数自增的操作也变成原子性的</span>
<span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> atomicInt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
amoticInt<span class="token operator">++</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>事实上，<strong>这两种理解都是完全错误的</strong>。很多工程师容易把 volatile 关键字，当成和锁或者数据数据原子性相关的知识点。而实际上，<em>volatile 关键字的最核心知识点，要关系到 Java 内存模型（JMM，Java Memory Model）上</em>。</p><p>虽然 JMM 只是 Java 虚拟机这个进程级虚拟机里的一个内存模型，<em>但是这个内存模型，和计算机组成里的 CPU、高速缓存和主内存组合在一起的硬件体系非常相似</em>。理解了 JMM，可以让你很容易理解计算机组成里 CPU、高速缓存和主内存之间的关系。</p><h2 id="隐身-的变量" tabindex="-1"><a class="header-anchor" href="#隐身-的变量" aria-hidden="true">#</a> “隐身”的变量</h2>`,8),v={href:"http://xn--dzone-oq8h418ds34cfoiowb.com",target:"_blank",rel:"noopener noreferrer"},m=s(`<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VolatileTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> <span class="token constant">COUNTER</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">ChangeListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">ChangeMaker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ChangeListener</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> threadValue <span class="token operator">=</span> <span class="token constant">COUNTER</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span> threadValue <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span> threadValue<span class="token operator">!=</span> <span class="token constant">COUNTER</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Got Change for COUNTER : &quot;</span> <span class="token operator">+</span> <span class="token constant">COUNTER</span> <span class="token operator">+</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    threadValue<span class="token operator">=</span> <span class="token constant">COUNTER</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ChangeMaker</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> threadValue <span class="token operator">=</span> <span class="token constant">COUNTER</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token constant">COUNTER</span> <span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Incrementing COUNTER to : &quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>threadValue<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token constant">COUNTER</span> <span class="token operator">=</span> <span class="token operator">++</span>threadValue<span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span> e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们先来看看这个程序做了什么。在这个程序里，我们先定义了一个 volatile 的 int 类型的变量，COUNTER。</p><p>然后，我们分别启动了两个单独的线程，一个线程我们叫 ChangeListener。另一个线程，我们叫 ChangeMaker。</p><p>ChangeListener 这个线程运行的任务很简单。它先取到 COUNTER 当前的值，然后一直监听着这个 COUNTER 的值。一旦 COUNTER 的值发生了变化，就把新的值通过 println 打印出来。直到 COUNTER 的值达到 5 为止。这个监听的过程，通过一个永不停歇的 while 循环的忙等待来实现。</p><p>ChangeMaker 这个线程运行的任务同样很简单。它同样是取到 COUNTER 的值，在 COUNTER 小于 5 的时候，每隔 500 毫秒，就让 COUNTER 自增 1。在自增之前，通过 println 方法把自增后的值打印出来。</p><p>最后，在 main 函数里，我们分别启动这两个线程，来看一看这个程序的执行情况。程序的输出结果并不让人意外。ChangeMaker 函数会一次一次将 COUNTER 从 0 增加到 5。因为这个自增是每 500 毫秒一次，而 ChangeListener 去监听 COUNTER 是忙等待的，所以每一次自增都会被 ChangeListener 监听到，然后对应的结果就会被打印出来。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>Incrementing COUNTER to <span class="token operator">:</span> <span class="token number">1</span>
Got Change <span class="token keyword">for</span> COUNTER <span class="token operator">:</span> <span class="token number">1</span>
Incrementing COUNTER to <span class="token operator">:</span> <span class="token number">2</span>
Got Change <span class="token keyword">for</span> COUNTER <span class="token operator">:</span> <span class="token number">2</span>
Incrementing COUNTER to <span class="token operator">:</span> <span class="token number">3</span>
Got Change <span class="token keyword">for</span> COUNTER <span class="token operator">:</span> <span class="token number">3</span>
Incrementing COUNTER to <span class="token operator">:</span> <span class="token number">4</span>
Got Change <span class="token keyword">for</span> COUNTER <span class="token operator">:</span> <span class="token number">4</span>
Incrementing COUNTER to <span class="token operator">:</span> <span class="token number">5</span>
Got Change <span class="token keyword">for</span> COUNTER <span class="token operator">:</span> <span class="token number">5</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个时候，我们就可以来做一个很有意思的实验。如果我们把上面的程序小小地修改一行代码，把我们定义 COUNTER 这个变量的时候，设置的 volatile 关键字给去掉，会发生什么事情呢？你可以自己先试一试，看结果是否会让你大吃一惊。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token constant">COUNTER</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>没错，你会发现，我们的 ChangeMaker 还是能正常工作的，每隔 500ms 仍然能够对 COUNTER 自增 1。但是，奇怪的事情在 ChangeListener 上发生了，我们的 ChangeListener 不再工作了。在 ChangeListener 眼里，它似乎一直觉得 COUNTER 的值还是一开始的 0。似乎 COUNTER 的变化，对于我们的 ChangeListener 彻底“隐身”了。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>Incrementing COUNTER to <span class="token operator">:</span> <span class="token number">1</span>
Incrementing COUNTER to <span class="token operator">:</span> <span class="token number">2</span>
Incrementing COUNTER to <span class="token operator">:</span> <span class="token number">3</span>
Incrementing COUNTER to <span class="token operator">:</span> <span class="token number">4</span>
Incrementing COUNTER to <span class="token operator">:</span> <span class="token number">5</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个有意思的小程序还没有结束，我们可以再对程序做一些小小的修改。我们不再让 ChangeListener 进行完全的忙等待，而是在 while 循环里面，小小地等待上 5 毫秒，看看会发生什么情况。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ChangeListener</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> threadValue <span class="token operator">=</span> <span class="token constant">COUNTER</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span> threadValue <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span> threadValue<span class="token operator">!=</span> <span class="token constant">COUNTER</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Sleep 5ms, Got Change for COUNTER : &quot;</span> <span class="token operator">+</span> <span class="token constant">COUNTER</span> <span class="token operator">+</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                threadValue<span class="token operator">=</span> <span class="token constant">COUNTER</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span> e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>好了，不知道你有没有自己动手试一试呢？又一个令人惊奇的现象要发生了。虽然我们的 COUNTER 变量，仍然没有设置 volatile 这个关键字，但是我们的 ChangeListener 似乎“睡醒了”。在通过 Thread.sleep(5) 在每个循环里“睡上“5 毫秒之后，ChangeListener 又能够正常取到 COUNTER 的值了。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>Incrementing COUNTER to <span class="token operator">:</span> <span class="token number">1</span>
Sleep <span class="token number">5</span>ms<span class="token punctuation">,</span> Got Change <span class="token keyword">for</span> COUNTER <span class="token operator">:</span> <span class="token number">1</span>
Incrementing COUNTER to <span class="token operator">:</span> <span class="token number">2</span>
Sleep <span class="token number">5</span>ms<span class="token punctuation">,</span> Got Change <span class="token keyword">for</span> COUNTER <span class="token operator">:</span> <span class="token number">2</span>
Incrementing COUNTER to <span class="token operator">:</span> <span class="token number">3</span>
Sleep <span class="token number">5</span>ms<span class="token punctuation">,</span> Got Change <span class="token keyword">for</span> COUNTER <span class="token operator">:</span> <span class="token number">3</span>
Incrementing COUNTER to <span class="token operator">:</span> <span class="token number">4</span>
Sleep <span class="token number">5</span>ms<span class="token punctuation">,</span> Got Change <span class="token keyword">for</span> COUNTER <span class="token operator">:</span> <span class="token number">4</span>
Incrementing COUNTER to <span class="token operator">:</span> <span class="token number">5</span>
Sleep <span class="token number">5</span>ms<span class="token punctuation">,</span> Got Change <span class="token keyword">for</span> COUNTER <span class="token operator">:</span> <span class="token number">5</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些有意思的现象，其实来自于我们的 Java 内存模型以及关键字 volatile 的含义。**那 volatile 关键字究竟代表什么含义呢？<em>它会确保我们对于这个变量的读取和写入，都一定会同步到<code>主内存</code>里，而不是从 <code>Cache</code> 里面读取</em>。**该怎么理解这个解释呢？我们通过刚才的例子来进行分析。</p><p>刚刚第一个使用了 volatile 关键字的例子里，<strong>因为所有数据的读和写都来自主内存</strong>。那么自然地，我们的 ChangeMaker 和 ChangeListener 之间，看到的 COUNTER 值就是一样的。</p><p>到了第二段进行小小修改的时候，我们去掉了 volatile 关键字。这个时候，ChangeListener 又是一个忙等待的循环，它尝试不停地获取 COUNTER 的值，<strong>这样就会从当前线程的“Cache”里面获取</strong>。于是，这个线程就没有时间从主内存里面同步更新后的 COUNTER 值。这样，它就一直卡死在 COUNTER=0 的死循环上了。</p><p>而到了我们再次修改的第三段代码里面，虽然还是没有使用 volatile 关键字，但是短短 5ms 的 Thead.Sleep 给了这个线程喘息之机。<strong>既然这个线程没有这么忙了，它也就有机会把最新的数据从主内存同步到自己的高速缓存里面了</strong>。于是，ChangeListener 在下一次查看 COUNTER 值的时候，就能看到 ChangeMaker 造成的变化了。</p><p>虽然 Java 内存模型是一个隔离了硬件实现的虚拟机内的抽象模型，但是它给了我们一个很好的“<code>缓存同步</code>”问题的示例。<strong>也就是说，如果我们的数据，在不同的线程或者 CPU 核里面去更新，<em>因为不同的线程或 CPU 核有着自己各自的缓存</em>，很有可能在 A 线程的更新，到 B 线程里面是看不见的</strong>。</p><blockquote><p>volatile 关键字去掉，变量的更新是先从内存中把变量加载到自己的缓存， ChangeMaker 线程把变量COUNTER = 0 加载到自己的缓存，并在自己的缓存内更新。ChangeMaker 每次更新完成后，会进行sleep，此时回把更新的数据同步到内存中。而 ChangeListener 线程，也是先从内存中获取数据，因为他自己的缓存内没有该变量。ChangeListener 线程，第一次从内存中读取到的变量值是0，因为车此时 ChangeMaker 线程对变量的更新还没有同步到内存，ChangeListener 线程从内存读取到0，并把该值加载到缓存，之后进行循环，每次循环都是从自己的缓存中读取数据，所以ChangeListener线程从每次循环从缓存中获取的变量值是0；</p><p>ChangeListener 线程修改为在循环内Thread.sleep(5)。线程休眠结束后，每次休眠结束，线程都会在从内存中在读取一次数据，这时休眠时间为5秒，刚好ChangeMaker 线程每次更新也休眠5秒，这时，ChangeMaker线程对变量的更新，在同步到内存后，刚好被ChangeListener 线程读取到； 所以，能得出结论，sleep之后，线程有足够的时间将缓存同步到内存，如果没有sleep，线程一直在执行，就没有时间将缓存数据同步到内存，同时，每次sleep之后，线程都会从内存中在读取一次数据到缓存，而不是sleep之后，还是读取自己的缓存数据。</p></blockquote><h2 id="cpu-高速缓存的写入" tabindex="-1"><a class="header-anchor" href="#cpu-高速缓存的写入" aria-hidden="true">#</a> CPU 高速缓存的写入</h2><p>事实上，我们可以把 Java 内存模型和计算机组成里的 CPU 结构对照起来看。</p><p>我们现在用的 Intel CPU，通常都是多核的的。每一个 CPU 核里面，都有独立属于自己的 L1、L2 的 Cache，然后再有多个 CPU 核共用的 L3 的 Cache、主内存。</p><p>因为 CPU Cache 的访问速度要比主内存快很多，而在 CPU Cache 里面，L1/L2 的 Cache 也要比 L3 的 Cache 快。所以，上一讲我们可以看到，<strong>CPU 始终都是尽可能地从 CPU Cache 中去获取数据，而不是每一次都要从主内存里面去读取数据</strong>。</p><img src="`+i+'" alt="img" style="zoom:33%;"><p>这个层级结构，就好像我们在 <strong>Java 内存模型里面，每一个线程都有属于自己的线程栈</strong>。线程在读取 COUNTER 的数据的时候，<strong>其实是从<em>本地的线程栈的 Cache 副本</em>里面读取数据，而不是从<em>主内存</em>里面读取数据</strong>。如果我们对于数据仅仅只是读，问题还不大。我们在上一讲里，已经看到 Cache Line 的组成，以及如何从内存里面把对应的数据加载到 Cache 里。</p><p>但是，对于数据，我们不光要读，还要去写入修改。这个时候，有两个问题来了。</p><p>**第一个问题是，写入 Cache 的性能也比写入主内存要快，那我们写入的数据，<em>到底应该写到 Cache 里还是主内存呢</em>？如果我们直接写入到主内存里，Cache 里的数据是否会失效呢？**为了解决这些疑问，下面我要给你介绍两种写入策略。</p><h3 id="写直达-write-through" tabindex="-1"><a class="header-anchor" href="#写直达-write-through" aria-hidden="true">#</a> 写直达（Write-Through）</h3><img src="'+r+'" alt="img" style="zoom:33%;"><p>最简单的一种写入策略，叫作<mark>写直达</mark>（Write-Through）。在这个策略里，<strong>每一次数据都要写入到主内存里面。在写直达的策略里面</strong>，写入前，我们会先去判断数据是否已经在 Cache 里面了。<em>如果数据已经在 Cache 里面了</em>，我们先把数据写入更新到 Cache 里面，再写入到主内存里面；<em>如果数据不在 Cache 里</em>，我们就只更新主内存。</p><p>写直达的这个策略很直观，但是问题也很明显，<code>那就是这个策略很慢</code>。无论数据是不是在 Cache 里面，我们都需要把数据写到主内存里面。这个方式就有点儿像我们上面用 volatile 关键字，<code>始终都要把数据同步到主内存里面</code>。</p><h3 id="写回-write-back" tabindex="-1"><a class="header-anchor" href="#写回-write-back" aria-hidden="true">#</a> 写回（Write-Back）</h3><img src="'+u+'" alt="img" style="zoom:33%;"><p>这个时候，我们就想了，既然我们去读数据也是默认从 Cache 里面加载，能否不用把所有的写入都同步到主内存里呢？<strong>只写入 CPU Cache 里面</strong>是不是可以？</p><p>当然是可以的。在 CPU Cache 的写入策略里，还有一种策略就叫作<mark>写回</mark>（Write-Back）。这个策略里，我们不再是每次都把数据写入到主内存，<strong>而是只写到 CPU Cache 里。<em>只有当 CPU Cache 里面的数据要被“替换”的时候（已标记脏了）</em>，我们才把数据写入到主内存里面去</strong>。</p><p>写回策略的过程是这样的：<strong><em>如果发现我们要写入的数据，就在 CPU Cache 里面</em>，那么我们就只是更新 CPU Cache 里面的数据</strong>。同时，我们会标记 CPU Cache 里的这个 Block 是脏（Dirty）的。</p><blockquote><p>所谓脏的，就是指这个时候，我们的 CPU Cache 里面的这个 Block 的数据，和主内存是不一致的。</p></blockquote><p>如果我们发现，我们要写入的数据所对应的 Cache Block 里，放的是别的内存地址的数据，那么我们就要看一看，那个 Cache Block 里面的数据有没有被标记成脏的。</p><blockquote><p>多个 cache block 对应一个 cache line，cache block 是在内存里面的存储单位</p><p>反复看了几次写回策略，才看明白。主要是“如果我们发现，我们要写入的数据所对应的 Cache Block 里，放的是别的内存地址的数据”这句。同一个cache地址可能被多个进程使用，使用前需要确认是否是自己的数据，是的话，直接写，不是自己的而且被标记为脏数据，需要同步回主内存。老师，我理解的对吧？<br> 其他网友：别的内存地址的数据，并不是指别的进程，缓存是内存地址取模得到的，就同一个进程甚至同一个线程，都有可能遇到别的内存地址的数据啊，看过上一篇应该就很清楚。</p></blockquote><ol><li><em>如果是脏的话</em>，我们要先把这个 Cache Block 里面的数据，写入到主内存里面。<br> 然后，再把当前要写入的数据，写入到 Cache 里，同时把 Cache Block 标记成脏的。</li><li><em>如果 Block 里面的数据没有被标记成脏的</em>，那么我们直接把数据写入到 Cache 里面，<br> 然后再把 Cache Block 标记成脏的就好了。</li></ol><p>在用了写回这个策略之后，我们在加载内存数据到 Cache 里面的时候，<strong>也要多出一步同步脏 Cache 的动作</strong>。如果加载内存里面的数据到 Cache 的时候，发现 Cache Block 里面有脏标记，我们也要先把 Cache Block 里的数据写回到主内存，才能加载数据覆盖掉 Cache。</p><p>可以看到，在写回这个策略里，<code>如果我们大量的操作，都能够命中缓存</code>。那么大部分时间里，我们都不需要读写主内存，自然性能会比写直达的效果好很多。</p><h2 id="仍没有解决-缓存一致性问题" tabindex="-1"><a class="header-anchor" href="#仍没有解决-缓存一致性问题" aria-hidden="true">#</a> 仍没有解决：缓存一致性问题</h2><p>然而，无论是写回还是写直达，其实都还没有解决我们在上面 volatile 程序示例中遇到的问题，也就是<strong>多个线程，或者是多个 CPU 核的缓存一致性的问题。这也就是我们在写入修改缓存后，需要解决的第二个问题。</strong></p><p>要解决这个问题，我们需要引入一个新的方法，叫作 MESI 协议。这是一个维护缓存一致性协议。<em>这个协议不仅可以用在 CPU Cache 之间，也可以广泛用于各种需要使用缓存，同时缓存之间需要同步的场景下</em>。今天的内容差不多了，我们放在下一讲，仔细讲解缓存一致性问题。</p><h2 id="总结延伸" tabindex="-1"><a class="header-anchor" href="#总结延伸" aria-hidden="true">#</a> 总结延伸</h2><p>最后，我们一起来回顾一下这一讲的知识点。通过一个使用 Java 程序中使用 volatile 关键字程序，我们可以看到，<em>在有缓存的情况下会遇到一致性问题</em>。<code>volatile</code> 这个关键字可以<strong>保障我们对于数据的读写都会到达主内存</strong>。</p><p>进一步地，我们可以看到，<mark>Java 内存模型</mark>和 <mark>CPU、CPU Cache 以及主内存的组织结构</mark>非常相似。在 CPU Cache 里，对于数据的写入，我们也有写直达和写回这两种解决方案。<em>写直达</em>把所有的数据都直接写入到主内存里面，简单直观，但是性能就会受限于内存的访问速度。而<em>写回</em>则通常只更新缓存，只有在需要把缓存里面的脏数据交换出去的时候，才把数据同步到主内存里。在缓存经常会命中的情况下，性能更好。</p><p>但是，除了采用读写都直接访问主内存的办法之外，如何解决<strong>缓存一致性的问题</strong>，我们还是没有解答。这个问题的解决方案，我们放到下一讲来详细解说。</p><h2 id="推荐阅读" tabindex="-1"><a class="header-anchor" href="#推荐阅读" aria-hidden="true">#</a> 推荐阅读</h2><p>如果你是一个 Java 程序员，我推荐你去读一读 Fixing Java Memory Model 这篇文章。读完这些内容，相信你会对 Java 里的<mark>内存模型</mark>和<mark>多线程原理</mark>有更深入的了解，并且也能更好地和我们计算机底层的硬件架构联系起来。</p><p>对于计算机组成的 CPU 高速缓存的写操作处理，你也可以读一读《<code>计算机组成与设计：硬件 / 软件接口</code>》的 5.3.3 小节。</p><h2 id="课后思考" tabindex="-1"><a class="header-anchor" href="#课后思考" aria-hidden="true">#</a> 课后思考</h2><p>最后，给你留一道思考题。既然 volatile 关键字，会让所有的数据写入都要到主内存。你可以试着写一个小的程序，看看使用 volatile 关键字和不使用 volatile 关键字，在数据写入的性能上会不会有差异，以及这个差异到底会有多大。</p><p>欢迎把你写的程序分享到留言区。如果有困难，你也可以把这个问题分享给你朋友，拉上他一起讨论完成，并在留言区写下你们讨论后的结果。</p><blockquote><p>volatile关键字在用C语言编写嵌入式软件里面用得很多，不使用volatile关键字的代码比使用volatile关键字的代码效率要高一些，但就无法保证数据的一致性。volatile的本意是告诉编译器，此变量的值是易变的，每次读写该变量的值时务必从该变量的内存地址中读取或写入，不能为了效率使用对一个“临时”变量的读写来代替对该变量的直接读写。编译器看到了volatile关键字，就一定会生成内存访问指令，每次读写该变量就一定会执行内存访问指令直接读写该变量。若是没有volatile关键字，编译器为了效率，只会在循环开始前使用读内存指令将该变量读到寄存器中，之后在循环内都是用寄存器访问指令来操作这个“临时”变量，在循环结束后再使用内存写指令将这个寄存器中的“临时”变量写回内存。在这个过程中，如果内存中的这个变量被别的因素（其他线程、中断函数、信号处理函数、DMA控制器、其他硬件设备）所改变了，就产生数据不一致的问题。另外，寄存器访问指令的速度要比内存访问指令的速度快，这里说的内存也包括缓存，也就是说内存访问指令实际上也有可能访问的是缓存里的数据，但即便如此，还是不如访问寄存器快的。缓存对于编译器也是透明的，编译器使用内存读写指令时只会认为是在读写内存，内存和缓存间的数据同步由CPU保证。</p><p>记住，这里说的是C/C++中的volatile，和java中的volatile是有区别的。<br> 对于 <strong>C#/Java</strong> ，<code>volatile</code>告诉编译器永远不要缓存变量的值，因为变量的值可能会超出程序本身的范围。然后，如果变量“在其控制范围之外”更改，编译器将避免可能导致问题的任何优化。<br> 在<strong>C/C++</strong> 中，开发嵌入式系统或设备驱动程序(需要读取或写入内存映射的硬件设备)时需要<code>volatile</code>。特定设备寄存器的内容可以随时更改，因此您需要使用<code>volatile</code>关键字来确保编译器不会对此类访问进行优化。</p><p>L123缓存和寄存器不一样，寄存器是程序可以操作的，L123是对程序透明的，程序是访问不到的。所以编译器是如何通过关键字volatile来控制用不用L123缓存的呢？答案是内存屏障指令，在访问这个变量前后插入内存屏障指令，迫使cpu不使用L123缓存。</p><p>理解volatile 关键两点，1、软件只能控制cpu 寄存器值的是否更新 2、寄存器的值来源（缓存，内存）和去处（缓存，内存）由硬件控制，并且由硬件需要保证缓存一致性。</p><p>Java sleep 解释有问题，sleep 并不是说线程有时间去主内存中读取变量，而是 sleep 的线程会让出cpu，线程被唤醒后才会去重新加载变量。</p><p>简而言之，volatile变量就是禁用Cache</p><p>老师，这讲里对volatile的解释是完全错的，cache从CPU的角度来看，对程序员是透明的，从软件看过去不会存在不一致的情况，只有在多master访问的时候才会关心，比如DMA等。这里的不一致不是由cache造成的，而是编译器对变量优化造成的，忙等待中，如果没有volatile关键字，编译器认为这个变量不会被改变，分配一个临时变量，一般就是一个寄存器，每次访问都直接访问寄存器，而不去访问真实的地址造成的</p><p>volatile 关键字不管是从嵌入式C还是从Java里面讲，其核心就是为了去保证对共享数据的操作，能够写回内存，而不是快速的读取寄存器或缓存，导致数据不一致而产生的问题，个人觉得这里的解释并没有问题。对程序员来说，就算是C程序员，你能够操纵到的内存也只能到主内存，而CPU内部的寄存器 和 缓存，除非是CPU特定开放给你，否则你是看不见的。</p><p>不带valotile的关键字未更新，是java编译器，jit做的优化，jit会认为数据没有变更，优化成不再去跟cpu交互读取数据了，就是说没带valotile的变量，数据只读取了一次</p><hr><p>所以，能得出结论，sleep之后，线程有足够的时间将缓存同步到内存，如果没有sleep，线程一直在执行，就没有时间将缓存数据同步到内存，同时，每次sleep之后，线程都会从内存中在读取一次数据到缓存，而不是sleep之后，还是读取自己的缓存数据。<br> Java 内存模型是一个隔离了硬件实现的虚拟机内的抽象模型，不同的线程或 CPU 核有着自己各自的缓存，缓存会导致可见性问题，可见性是并发bug的源头之一。所以java引入volatile关键字，能解决缓存带来的线程之间可见性的问题。java内存模型中规定，一个线程对volatile修饰变量的写操作先发与另一线程对于该变量的读操作，也就是说，针对volatile修饰的变量，一个线程要想读取到别的线程更新后的数据，就必须从内存中读取，而一个线程的写操作要想被别的线程看到，就必须保证在更新完之后，同步到内存中。所以volatile关键字的作用，就是确保变量的读取和写入，一定会同步到主内存，而不基于cpu缓存中的数据进行读取和写入。<br> 要实现对volatile修饰的变量，每次的读取和写入，一定会同步到主内存。java的实现方案是利用内存屏障来实现，而内存屏障的实现，是基于cpu指令来实现的。经过volatile修饰的变量。在经过jvm解释器解释成机器码后，都会插入一写内存屏障的cpu指令，这些cpu指令的作用就是确保，每次对volatile修饰的变量的更新，都必须同步到内存，而每次读取volatile修饰的变量，都必须从内存中获取，而不是直接从cpu缓存获取。<br> 所以Java内存模型隔离了具体的硬件实现，这些内存屏障的指令都是jvm在解释执行的时候加上的，程序员只需要在代码中用volatile 修饰即可，至于volatile 底层的实现，都是基于 java 的内存模式实现的。</p></blockquote>',58);function h(C,b){const e=p("ExternalLinkIcon");return o(),c("div",null,[d,a("p",null,[n("我们先来一起看一段 Java 程序。这是一段经典的 volatile 代码，来自知名的 Java "),a("a",v,[n("开发者网站dzone.com"),l(e)]),n("，后续我们会修改这段代码来进行各种小实验。")]),m])}const T=t(k,[["render",h],["__file","F38-高速缓存（下）.html.vue"]]);export{T as default};
