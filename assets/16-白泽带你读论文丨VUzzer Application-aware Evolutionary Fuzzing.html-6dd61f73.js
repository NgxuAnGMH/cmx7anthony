import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o,c,a,b as e,e as n,d as s}from"./app-cdabc73c.js";const p="/assets/640-1691484666812-234-c338810c.jpeg",l="/assets/640-1691484666813-235-4ed3fab6.jpeg",z="/assets/640-1691484666813-236-d48ca0ef.jpeg",g="/assets/640-1691484666813-237-21e270b7.jpeg",d="/assets/640-1691484666813-238-49476b5c.jpeg",u="/assets/640-1691484666813-239-3ae8d2be.jpeg",h="/assets/640-1691484666813-240-2b47356e.jpeg",b={},_=a("h1",{id:"_16-白泽带你读论文丨vuzzer-application-aware-evolutionary-fuzzing",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#_16-白泽带你读论文丨vuzzer-application-aware-evolutionary-fuzzing","aria-hidden":"true"},"#"),e(" 16-白泽带你读论文丨VUzzer: Application-aware Evolutionary Fuzzing")],-1),f=a("p",null,"VUzzer: Application-aware Evolutionary Fuzzing",-1),m={href:"https://github.com/vusec/vuzzer",target:"_blank",rel:"noopener noreferrer"},y=s('<p>本文发表在<strong>NDSS 2017</strong>，第一作者是来自阿姆斯特丹自由大学的Sanjay Rawat。</p><h2 id="_1-主要内容" tabindex="-1"><a class="header-anchor" href="#_1-主要内容" aria-hidden="true">#</a> 1. 主要内容</h2><p>Fuzzing是一种自动漏洞测试技术，通过生成随机的输入来触发程序中的崩溃。评估fuzzer的好坏的一个重要标准就是在固定时间内能够触发crash的数量。为了触发更多crash，一个好的fuzzer需要对程序的逻辑有着一定理解，例如能够通过magic bytes比较、能够保留触发更深层逻辑的输入，尽可能过滤掉程序错误处理的部分等。而传统灰盒fuzzer例如AFL都较难解决这些问题。前人的工作如Driller使用了Concolic execution技术，可以在一定程度上解决magic bytes比较的问题，但是由于符号化执行路径爆炸等原因使得工具效率比较差。</p><p>针对这些问题，作者提出了VUzzer工具，使用了静态分析和动态污点分析的方法，在一定程度上解决了上述问题的同时尽可能少地引入额外开销。</p><h2 id="_2-问题定义" tabindex="-1"><a class="header-anchor" href="#_2-问题定义" aria-hidden="true">#</a> 2. 问题定义</h2><p>传统fuzzer例如AFL由于对程序了解不够，经常会面临以下几个问题：</p><figure><img src="'+p+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图1</p><p><strong>1) magic bytes比较问题：</strong></p><p>如上图第11行，由于AFL对程序缺乏了解，在遇到magic bytes比较时只能通过随机的方式进行爆破，大大降低了效率。进一步地，由于AFL是基于basic block覆盖进行反馈，如果AFL遇到了strcmp magic bytes比较，即使在随机突变过程中输入中的一个或多个bytes匹配上了magic bytes，但是只要没有全部匹配就不会覆盖到新的basic block。对于长度为4的magic bytes，AFL理论上需要随机突变256^4次才能匹配上，才能进一步触发更深的逻辑。</p><p><strong>2) 难以触发深层逻辑</strong></p><p>AFL的输入选择策略不能非常好地保留到达了更深层次逻辑的输入，使得生成的输入较难到达比较深的代码逻辑。</p><p><strong>3) 错误处理代码的解决</strong></p><p>如上图的14行，20-22行，25-27行。程序中的错误处理是非常常见的，但这部分代码往往没有太多的fuzz价值。另一方面，AFL随机生成的输入往往有非常大的概率触发错误处理分支，使得后续的fuzz都在这里面进行，因此在输入选择时最好能避免掉这部分输入。</p><p>为了解决这部分问题，作者使用了动态污点分析的方法，来找出输入中与magic bytes比较相关的部分，同时给basic block分配权重，从而能够保留触发深层逻辑的输入和避免触发错误处理代码。</p><h2 id="_3-设计与实现" tabindex="-1"><a class="header-anchor" href="#_3-设计与实现" aria-hidden="true">#</a> 3. 设计与实现</h2><p>VUzzer工具的工作流程图如下，与AFL相比主要区别在于fuzz前的静态分析阶段、输入选择时的加入的权重和fuzz时的动态污点分析，其中污点分析阶段中得到的信息会反馈给输入选择阶段，以改善输入选择和突变策略：</p><figure><img src="'+l+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图2</p><h3 id="_3-1-静态分析阶段" tabindex="-1"><a class="header-anchor" href="#_3-1-静态分析阶段" aria-hidden="true">#</a> 3.1 静态分析阶段</h3><p>静态分析阶段中，VUzzer首先构造程序的控制流图以拿到每个basic block的深度信息供输入选择阶段中为basic block分配权重。另一方面，VUzzer静态地找出所有的cmp和lea指令，以便动态运行时进行插桩。cmp指令用来找出magic bytes，lea指令用来判断输入的类型信息。</p><h3 id="_3-2-输入选择阶段" tabindex="-1"><a class="header-anchor" href="#_3-2-输入选择阶段" aria-hidden="true">#</a> 3.2 输入选择阶段</h3><p>为了能够保留优质输入，VUzzer为每个basic block分配了权重，并将一个输入的权重近似地定义为其经过的basic block的总权重。</p><p>首先，basic block的权重要体现到达它的难易程度。通过静态分析得到的深度信息，VUzzer计算了到达其的概率：以图3为例（与图1中的代码相对应），VUzzer认为经过每个分支的两个basic block都有50%的概率到达，以此类推一直向下计算，每个basic block的权重即为1/到达它的概率。</p><p>另外，VUzzer需要尽可能地过滤掉那些触发了错误处理分支的输入，因此需要给那些错误处理的basic block负权重。为了找出basic block，VUzzer通过生成完全随机的输入，来找到这些输入共同触发的，并且不会被正常输入触发的basic block，以此过滤掉一部分error handling block。这个过程是增量进行的，从而能够覆盖到更多的error handling block。</p><p>最后，在选择输入进行fuzz时，权重更高的输入会被优先考虑。</p><figure><img src="'+z+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图3</p><h3 id="_3-3-突变阶段" tabindex="-1"><a class="header-anchor" href="#_3-3-突变阶段" aria-hidden="true">#</a> 3.3 突变阶段</h3><p>VUzzer根据一组合法的输入，通过Crossover和Mutation两种策略对其进行突变。其中，Crossover是将两个输入在第5位进行交叉：</p><figure><img src="'+g+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>而Mutation则分为三步，一是随机修改非magic bytes的位置（magic bytes位置的判断在动态污点分析阶段），二是对于确定了类型为数字的位置（确定的过程在fuzz阶段）将其修改为一些特殊数字，例如0、MAX_UINT、负数等，三是对于magic bytes的位置，以一定几率将其改为magic bytes的真实值和进行随机修改。</p><h3 id="_3-4-fuzz阶段" tabindex="-1"><a class="header-anchor" href="#_3-4-fuzz阶段" aria-hidden="true">#</a> 3.4 Fuzz阶段</h3><p>VUzzer在fuzz时对输入进行了污点分析，在插桩的cmp指令处就可以拿到比较的位置和比较的内容，从而能够在突变时解决magic bytes的比较问题。对于lea指令，如果index操作数被taint，说明对应位置值的类型是int，就可以在突变阶段进行特殊处理。</p><h2 id="_4-评价" tabindex="-1"><a class="header-anchor" href="#_4-评价" aria-hidden="true">#</a> 4. 评价</h2><ol><li>对Darpa Cyber Grand Challenge进行了测试，并与AFL进行了对比，结果上能够通过生成更少的输入来触发更多的崩溃：</li></ol><figure><img src="'+d+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><ol start="2"><li>对LAVA测试集进行了测试，结果上对于其他fuzzer均能在同样的时间能得到更多的崩溃：</li></ol><figure><img src="'+u+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><ol start="3"><li>对真实程序进行了测试，并与AFL进行了对比，能够在更短的时间内生成更多崩溃：</li></ol><figure><img src="'+h+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>总体而言，VUzzer通过静态分析和动态污点分析技术增强了fuzzer的效率，是一个较早解决了magic bytes比较等问题的fuzzer，并且overhead比之前的工作都要小。在不足之处上，动态污点分析技术还是会给fuzzer带来一些效率上的降低，因此后面的一些工作都针对这个问题做出了改进。</p>',42);function x(V,k){const i=t("ExternalLinkIcon");return o(),c("div",null,[_,f,a("p",null,[e("开源项目地址: "),a("a",m,[e("https://github.com/vusec/vuzzer"),n(i)])]),y])}const F=r(b,[["render",x],["__file","16-白泽带你读论文丨VUzzer Application-aware Evolutionary Fuzzing.html.vue"]]);export{F as default};
