import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{r as c,o,c as l,a as s,b as n,e as t,d as p}from"./app-cdabc73c.js";const i="/assets/c2b86e79f19d811ce10774688fc0c093-ff1c1612.jpeg",r="/assets/ac043a08627b40b85e624477d937f3fd-b7809f91.jpeg",u="/assets/10381dbafe0f78d80beb87560a9506af-eac3efc5.jpeg",k={},d=p(`<h1 id="_15-调度-上-如何制定项目管理流程" tabindex="-1"><a class="header-anchor" href="#_15-调度-上-如何制定项目管理流程" aria-hidden="true">#</a> 15 | 调度（上）：如何制定项目管理流程？</h1><p>前几节，我们介绍了 task_struct 数据结构。它就像项目管理系统一样，可以帮项目经理维护项目运行过程中的各类信息，但这并不意味着项目管理工作就完事大吉了。task_struct 仅仅能够解决“<strong>看到</strong>”的问题，咱们还要解决如何制定流程，进行项目调度的问题，也就是“<strong>做到</strong>”的问题。</p><p>公司的人员总是有限的。无论接了多少项目，公司不可能短时间增加很多人手。有的项目比较紧急，应该先进行排期；有的项目可以缓缓，但是也不能让客户等太久。所以这个过程非常复杂，需要平衡。</p><p>对于操作系统来讲，它面对的 CPU 的数量是有限的，干活儿都是它们，但是进程数目远远超过 CPU 的数目，因而就需要进行进程的调度，有效地分配 CPU 的时间，既要保证进程的最快响应，也要保证进程之间的公平。这也是一个非常复杂的、需要平衡的事情。</p><h2 id="调度策略与调度类" tabindex="-1"><a class="header-anchor" href="#调度策略与调度类" aria-hidden="true">#</a> 调度策略与调度类</h2><p>在 Linux 里面，进程大概可以分成两种。</p><p>一种称为<strong>实时进程</strong>，也就是需要尽快执行返回结果的那种。这就好比我们是一家公司，接到的客户项目需求就会有很多种。有些客户的项目需求比较急，比如一定要在一两个月内完成的这种，客户会加急加钱，那这种客户的优先级就会比较高。</p><p>另一种是<strong>普通进程</strong>，大部分的进程其实都是这种。这就好比，大部分客户的项目都是普通的需求，可以按照正常流程完成，优先级就没实时进程这么高，但是人家肯定也有确定的交付日期。</p><p>那很显然，对于这两种进程，我们的调度策略肯定是不同的。</p><p>在 task_struct 中，有一个成员变量，我们叫<strong>调度策略</strong>。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">unsigned</span> <span class="token keyword">int</span> policy<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>它有以下几个定义：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SCHED_NORMAL</span>    <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SCHED_FIFO</span>    <span class="token expression"><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SCHED_RR</span>    <span class="token expression"><span class="token number">2</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SCHED_BATCH</span>    <span class="token expression"><span class="token number">3</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SCHED_IDLE</span>    <span class="token expression"><span class="token number">5</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SCHED_DEADLINE</span>    <span class="token expression"><span class="token number">6</span></span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配合调度策略的，还有我们刚才说的<strong>优先级</strong>，也在 task_struct 中。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> prio<span class="token punctuation">,</span> static_prio<span class="token punctuation">,</span> normal_prio<span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span> rt_priority<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>优先级其实就是一个数值，对于实时进程，优先级的范围是 0～99；对于普通进程，优先级的范围是 100～139。数值越小，优先级越高。从这里可以看出，所有的实时进程都比普通进程优先级要高。毕竟，谁让人家加钱了呢。</p><h2 id="实时调度策略" tabindex="-1"><a class="header-anchor" href="#实时调度策略" aria-hidden="true">#</a> 实时调度策略</h2><p>对于调度策略，其中 SCHED_FIFO、SCHED_RR、SCHED_DEADLINE 是实时进程的调度策略。</p><p>虽然大家都是加钱加急的项目，但是也不能乱来，还是需要有个办事流程才行。</p><p>例如，<strong>SCHED_FIFO</strong> 就是交了相同钱的，先来先服务，但是有的加钱多，可以分配更高的优先级，也就是说，高优先级的进程可以抢占低优先级的进程，而相同优先级的进程，我们遵循先来先得。</p><p>另外一种策略是，交了相同钱的，轮换着来，这就是 <strong>SCHED_RR 轮流调度算法</strong>，采用时间片，相同优先级的任务当用完时间片会被放到队列尾部，以保证公平性，而高优先级的任务也是可以抢占低优先级的任务。</p><p>还有一种新的策略是 <strong>SCHED_DEADLINE</strong>，是按照任务的 deadline 进行调度的。当产生一个调度点的时候，DL 调度器总是选择其 deadline 距离当前时间点最近的那个任务，并调度它执行。</p><h2 id="普通调度策略" tabindex="-1"><a class="header-anchor" href="#普通调度策略" aria-hidden="true">#</a> 普通调度策略</h2><p>对于普通进程的调度策略有，SCHED_NORMAL、SCHED_BATCH、SCHED_IDLE。</p><p>既然大家的项目都没有那么紧急，就应该按照普通的项目流程，公平地分配人员。</p><p>SCHED_NORMAL 是普通的进程，就相当于咱们公司接的普通项目。</p><p>SCHED_BATCH 是后台进程，几乎不需要和前端进行交互。这有点像公司在接项目同时，开发一些可以复用的模块，作为公司的技术积累，从而使得在之后接新项目的时候，能够减少工作量。这类项目可以默默执行，不要影响需要交互的进程，可以降低它的优先级。</p><p>SCHED_IDLE 是特别空闲的时候才跑的进程，相当于咱们学习训练类的项目，比如咱们公司很长时间没有接到外在项目了，可以弄几个这样的项目练练手。</p><p>上面无论是 policy 还是 priority，都设置了一个变量，变量仅仅表示了应该这样这样干，但事情总要有人去干，谁呢？在 task_struct 里面，还有这样的成员变量：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> <span class="token operator">*</span>sched_class<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>调度策略的执行逻辑，就封装在这里面，它是真正干活的那个。</p><p>sched_class 有几种实现：</p><ul><li>stop_sched_class 优先级最高的任务会使用这种策略，会中断所有其他线程，且不会被其他任务打断；</li><li>dl_sched_class 就对应上面的 deadline 调度策略；</li><li>rt_sched_class 就对应 RR 算法或者 FIFO 算法的调度策略，具体调度策略由进程的 task_struct-&gt;policy 指定；</li><li>fair_sched_class 就是普通进程的调度策略；</li><li>idle_sched_class 就是空闲进程的调度策略。</li></ul><p>这里实时进程的调度策略 RR 和 FIFO 相对简单一些，而且由于咱们平时常遇到的都是普通进程，在这里，咱们就重点分析普通进程的调度问题。普通进程使用的调度策略是 fair_sched_class，顾名思义，对于普通进程来讲，公平是最重要的。</p><h2 id="完全公平调度算法" tabindex="-1"><a class="header-anchor" href="#完全公平调度算法" aria-hidden="true">#</a> 完全公平调度算法</h2><p>在 Linux 里面，实现了一个基于 CFS 的调度算法。CFS 全称 Completely Fair Scheduling，叫完全公平调度。听起来很“公平”。那这个算法的原理是什么呢？我们来看看。</p><p>首先，你需要记录下进程的运行时间。CPU 会提供一个时钟，过一段时间就触发一个时钟中断。就像咱们的表滴答一下，这个我们叫 Tick。CFS 会为每一个进程安排一个虚拟运行时间 vruntime。如果一个进程在运行，随着时间的增长，也就是一个个 tick 的到来，进程的 vruntime 将不断增大。没有得到执行的进程 vruntime 不变。</p><p>显然，那些 vruntime 少的，原来受到了不公平的对待，需要给它补上，所以会优先运行这样的进程。</p><p>这有点像让你把一筐球平均分到 N 个口袋里面，你看着哪个少，就多放一些；哪个多了，就先不放。这样经过多轮，虽然不能保证球完全一样多，但是也差不多公平。</p><p>你可能会说，不还有优先级呢？如何给优先级高的进程多分时间呢？</p><p>这个简单，就相当于 N 个口袋，优先级高的袋子大，优先级低的袋子小。这样球就不能按照个数分配了，要按照比例来，大口袋的放了一半和小口袋放了一半，里面的球数目虽然差很多，也认为是公平的。</p><p>在更新进程运行的统计量的时候，我们其实就可以看出这个逻辑。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/*
 * Update the current task&#39;s runtime statistics.
 */</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">update_curr</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>curr <span class="token operator">=</span> cfs_rq<span class="token operator">-&gt;</span>curr<span class="token punctuation">;</span>
  u64 now <span class="token operator">=</span> <span class="token function">rq_clock_task</span><span class="token punctuation">(</span><span class="token function">rq_of</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  u64 delta_exec<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  delta_exec <span class="token operator">=</span> now <span class="token operator">-</span> curr<span class="token operator">-&gt;</span>exec_start<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  curr<span class="token operator">-&gt;</span>exec_start <span class="token operator">=</span> now<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  curr<span class="token operator">-&gt;</span>sum_exec_runtime <span class="token operator">+=</span> delta_exec<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  curr<span class="token operator">-&gt;</span>vruntime <span class="token operator">+=</span> <span class="token function">calc_delta_fair</span><span class="token punctuation">(</span>delta_exec<span class="token punctuation">,</span> curr<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">update_min_vruntime</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>


<span class="token comment">/*
 * delta /= w
 */</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> u64 <span class="token function">calc_delta_fair</span><span class="token punctuation">(</span>u64 delta<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>se<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>se<span class="token operator">-&gt;</span>load<span class="token punctuation">.</span>weight <span class="token operator">!=</span> NICE_0_LOAD<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment">/* delta_exec * weight / lw.weight */</span>
    delta <span class="token operator">=</span> <span class="token function">__calc_delta</span><span class="token punctuation">(</span>delta<span class="token punctuation">,</span> NICE_0_LOAD<span class="token punctuation">,</span> <span class="token operator">&amp;</span>se<span class="token operator">-&gt;</span>load<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> delta<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这里得到当前的时间，以及这次的时间片开始的时间，两者相减就是这次运行的时间 delta_exec ，但是得到的这个时间其实是实际运行的时间，需要做一定的转化才作为虚拟运行时间 vruntime。转化方法如下：</p><p><code>虚拟运行时间 vruntime += 实际运行时间 delta_exec * NICE_0_LOAD/ 权重</code></p><p>这就是说，同样的实际运行时间，给高权重的算少了，低权重的算多了，但是当选取下一个运行进程的时候，还是按照最小的 vruntime 来的，这样高权重的获得的实际运行时间自然就多了。这就相当于给一个体重 (权重)200 斤的胖子吃两个馒头，和给一个体重 100 斤的瘦子吃一个馒头，然后说，你们两个吃的是一样多。这样虽然总体胖子比瘦子多吃了一倍，但是还是公平的。</p><h2 id="调度队列与调度实体" tabindex="-1"><a class="header-anchor" href="#调度队列与调度实体" aria-hidden="true">#</a> 调度队列与调度实体</h2><p>看来 CFS 需要一个数据结构来对 vruntime 进行排序，找出最小的那个。这个能够排序的数据结构不但需要查询的时候，能够快速找到最小的，更新的时候也需要能够快速地调整排序，要知道 vruntime 可是经常在变的，变了再插入这个数据结构，就需要重新排序。</p><p>能够平衡查询和更新速度的是树，在这里使用的是红黑树。</p><p>红黑树的的节点是应该包括 vruntime 的，称为调度实体。</p><p>在 task_struct 中有这样的成员变量：</p><ul><li><p>struct sched_entity se;</p></li><li><p>struct sched_rt_entity rt;</p></li><li><p>struct sched_dl_entity dl;</p></li></ul><p>这里有实时调度实体 sched_rt_entity，Deadline 调度实体 sched_dl_entity，以及完全公平算法调度实体 sched_entity。</p><p>看来不光 CFS 调度策略需要有这样一个数据结构进行排序，其他的调度策略也同样有自己的数据结构进行排序，因为任何一个策略做调度的时候，都是要区分谁先运行谁后运行。</p><p>而进程根据自己是实时的，还是普通的类型，通过这个成员变量，将自己挂在某一个数据结构里面，和其他的进程排序，等待被调度。如果这个进程是个普通进程，则通过 sched_entity，将自己挂在这棵红黑树上。</p><p>对于普通进程的调度实体定义如下，这里面包含了 vruntime 和权重 load_weight，以及对于运行时间的统计。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">load_weight</span>    load<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">rb_node</span>      run_node<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">list_head</span>    group_node<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span>      on_rq<span class="token punctuation">;</span>
  u64        exec_start<span class="token punctuation">;</span>
  u64        sum_exec_runtime<span class="token punctuation">;</span>
  u64        vruntime<span class="token punctuation">;</span>
  u64        prev_sum_exec_runtime<span class="token punctuation">;</span>
  u64        nr_migrations<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">sched_statistics</span>    statistics<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下图是一个红黑树的例子。</p><img src="`+i+`" alt="img" style="zoom:25%;"><p>所有可运行的进程通过不断地插入操作最终都存储在以时间为顺序的红黑树中，vruntime 最小的在树的左侧，vruntime 最多的在树的右侧。 CFS 调度策略会选择红黑树最左边的叶子节点作为下一个将获得 CPU 的任务。</p><p>这棵红黑树放在哪里呢？就像每个软件工程师写代码的时候，会将任务排成队列，做完一个做下一个。</p><p>CPU 也是这样的，每个 CPU 都有自己的 struct rq 结构，其用于描述在此 CPU 上所运行的所有进程，其包括一个实时进程队列 rt_rq 和一个 CFS 运行队列 cfs_rq，在调度时，调度器首先会先去实时进程队列找是否有实时进程需要运行，如果没有才会去 CFS 运行队列找是否有进程需要运行。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token punctuation">{</span>
  <span class="token comment">/* runqueue lock: */</span>
  <span class="token class-name">raw_spinlock_t</span> lock<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> nr_running<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> cpu_load<span class="token punctuation">[</span>CPU_LOAD_IDX_MAX<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">struct</span> <span class="token class-name">load_weight</span> load<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> nr_load_updates<span class="token punctuation">;</span>
  u64 nr_switches<span class="token punctuation">;</span>


  <span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> cfs<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">rt_rq</span> rt<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">dl_rq</span> dl<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token operator">*</span>idle<span class="token punctuation">,</span> <span class="token operator">*</span>stop<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于普通进程公平队列 cfs_rq，定义如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/* CFS-related fields in a runqueue */</span>
<span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">load_weight</span> load<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> nr_running<span class="token punctuation">,</span> h_nr_running<span class="token punctuation">;</span>


  u64 exec_clock<span class="token punctuation">;</span>
  u64 min_vruntime<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">CONFIG_64BIT</span></span>
  u64 min_vruntime_copy<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
  <span class="token keyword">struct</span> <span class="token class-name">rb_root</span> tasks_timeline<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>rb_leftmost<span class="token punctuation">;</span>


  <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token operator">*</span>next<span class="token punctuation">,</span> <span class="token operator">*</span>last<span class="token punctuation">,</span> <span class="token operator">*</span>skip<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里面 rb_root 指向的就是红黑树的根节点，这个红黑树在 CPU 看起来就是一个队列，不断地取下一个应该运行的进程。rb_leftmost 指向的是最左面的节点。</p><p>到这里终于凑够数据结构了，上面这些数据结构的关系如下图：</p><img src="`+r+`" alt="img" style="zoom:25%;"><h2 id="调度类是如何工作的" tabindex="-1"><a class="header-anchor" href="#调度类是如何工作的" aria-hidden="true">#</a> 调度类是如何工作的？</h2><p>凑够了数据结构，接下来我们来看调度类是如何工作的。</p><p>调度类的定义如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">sched_class</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>


  <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>enqueue_task<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>dequeue_task<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>yield_task<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">bool</span> <span class="token punctuation">(</span><span class="token operator">*</span>yield_to_task<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> bool preempt<span class="token punctuation">)</span><span class="token punctuation">;</span>


  <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>check_preempt_curr<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>


  <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>pick_next_task<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span>
            <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev<span class="token punctuation">,</span>
            <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> <span class="token operator">*</span>rf<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>put_prev_task<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>


  <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>set_curr_task<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>task_tick<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> queued<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>task_fork<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>task_dead<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>


  <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>switched_from<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>this_rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>switched_to<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>this_rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>prio_changed<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>this_rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>task<span class="token punctuation">,</span> <span class="token keyword">int</span> oldprio<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>get_rr_interval<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span>
           <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>update_curr<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个结构定义了很多种方法，用于在队列上操作任务。这里请大家注意第一个成员变量，是一个指针，指向下一个调度类。</p><p>上面我们讲了，调度类分为下面这几种：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> stop_sched_class<span class="token punctuation">;</span>
<span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> dl_sched_class<span class="token punctuation">;</span>
<span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> rt_sched_class<span class="token punctuation">;</span>
<span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> fair_sched_class<span class="token punctuation">;</span>
<span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> idle_sched_class<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>它们其实是放在一个链表上的。这里我们以调度最常见的操作，<strong>取下一个任务</strong>为例，来解析一下。可以看到，这里面有一个 for_each_class 循环，沿着上面的顺序，依次调用每个调度类的方法。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/*
 * Pick up the highest-prio task:
 */</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>
<span class="token function">pick_next_task</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> <span class="token operator">*</span>rf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> <span class="token operator">*</span>class<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token function">for_each_class</span><span class="token punctuation">(</span>class<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    p <span class="token operator">=</span> class<span class="token operator">-&gt;</span><span class="token function">pick_next_task</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> rf<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>p <span class="token operator">==</span> RETRY_TASK<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">goto</span> again<span class="token punctuation">;</span>
      <span class="token keyword">return</span> p<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这就说明，调度的时候是从优先级最高的调度类到优先级低的调度类，依次执行。而对于每种调度类，有自己的实现，例如，CFS 就有 fair_sched_class。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> fair_sched_class <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span>next      <span class="token operator">=</span> <span class="token operator">&amp;</span>idle_sched_class<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>enqueue_task    <span class="token operator">=</span> enqueue_task_fair<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>dequeue_task    <span class="token operator">=</span> dequeue_task_fair<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>yield_task    <span class="token operator">=</span> yield_task_fair<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>yield_to_task    <span class="token operator">=</span> yield_to_task_fair<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>check_preempt_curr  <span class="token operator">=</span> check_preempt_wakeup<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>pick_next_task    <span class="token operator">=</span> pick_next_task_fair<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>put_prev_task    <span class="token operator">=</span> put_prev_task_fair<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>set_curr_task          <span class="token operator">=</span> set_curr_task_fair<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>task_tick    <span class="token operator">=</span> task_tick_fair<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>task_fork    <span class="token operator">=</span> task_fork_fair<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>prio_changed    <span class="token operator">=</span> prio_changed_fair<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>switched_from    <span class="token operator">=</span> switched_from_fair<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>switched_to    <span class="token operator">=</span> switched_to_fair<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>get_rr_interval  <span class="token operator">=</span> get_rr_interval_fair<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>update_curr    <span class="token operator">=</span> update_curr_fair<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于同样的 pick_next_task 选取下一个要运行的任务这个动作，不同的调度类有自己的实现。fair_sched_class 的实现是 pick_next_task_fair，rt_sched_class 的实现是 pick_next_task_rt。</p><p>我们会发现这两个函数是操作不同的队列，pick_next_task_rt 操作的是 rt_rq，pick_next_task_fair 操作的是 cfs_rq。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>
<span class="token function">pick_next_task_rt</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> <span class="token operator">*</span>rf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">rt_rq</span> <span class="token operator">*</span>rt_rq <span class="token operator">=</span> <span class="token operator">&amp;</span>rq<span class="token operator">-&gt;</span>rt<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>


<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>
<span class="token function">pick_next_task_fair</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> <span class="token operator">*</span>rf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq <span class="token operator">=</span> <span class="token operator">&amp;</span>rq<span class="token operator">-&gt;</span>cfs<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>se<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样整个运行的场景就串起来了，在每个 CPU 上都有一个队列 rq，这个队列里面包含多个子队列，例如 rt_rq 和 cfs_rq，不同的队列有不同的实现方式，cfs_rq 就是用红黑树实现的。</p><p>当有一天，某个 CPU 需要找下一个任务执行的时候，会按照优先级依次调用调度类，不同的调度类操作不同的队列。当然 rt_sched_class 先被调用，它会在 rt_rq 上找下一个任务，只有找不到的时候，才轮到 fair_sched_class 被调用，它会在 cfs_rq 上找下一个任务。这样保证了实时任务的优先级永远大于普通任务。</p><p>下面我们仔细看一下 sched_class 定义的与调度有关的函数。</p><ul><li>enqueue_task 向就绪队列中添加一个进程，当某个进程进入可运行状态时，调用这个函数；</li><li>dequeue_task 将一个进程从就绪队列中删除；</li><li>pick_next_task 选择接下来要运行的进程；</li><li>put_prev_task 用另一个进程代替当前运行的进程；</li><li>set_curr_task 用于修改调度策略；</li><li>task_tick 每次周期性时钟到的时候，这个函数被调用，可能触发调度。</li></ul><p>在这里面，我们重点看 fair_sched_class 对于 pick_next_task 的实现 pick_next_task_fair，获取下一个进程。调用路径如下：pick_next_task_fair-&gt;pick_next_entity-&gt;__pick_first_entity。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span><span class="token function">__pick_first_entity</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>left <span class="token operator">=</span> <span class="token function">rb_first_cached</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cfs_rq<span class="token operator">-&gt;</span>tasks_timeline<span class="token punctuation">)</span><span class="token punctuation">;</span>


  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>left<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>


  <span class="token keyword">return</span> <span class="token function">rb_entry</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span><span class="token punctuation">,</span> run_node<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从这个函数的实现可以看出，就是从红黑树里面取最左面的节点。</p><h2 id="总结时刻" tabindex="-1"><a class="header-anchor" href="#总结时刻" aria-hidden="true">#</a> 总结时刻</h2><p>好了，这一节我们讲了调度相关的数据结构，还是比较复杂的。一个 CPU 上有一个队列，CFS 的队列是一棵红黑树，树的每一个节点都是一个 sched_entity，每个 sched_entity 都属于一个 task_struct，task_struct 里面有指针指向这个进程属于哪个调度类。</p><p>在调度的时候，依次调用调度类的函数，从 CPU 的队列中取出下一个进程。上面图中的调度器、上下文切换这一节我们没有讲，下一节我们讲讲基于这些数据结构，如何实现调度。</p><img src="`+u+'" alt="img" style="zoom:25%;"><blockquote><ul><li>调度策略与调度类</li><li>进程包括两类: 实时进程(优先级高); 普通进程</li><li>两种进程调度策略不同: task_struct-&gt;policy 指明采用哪种调度策略(有6种策略) <ul><li>优先级配合调度策略, 实时进程(0-99); 普通进程(100-139)</li><li>实时调度策略, 高优先级可抢占低优先级进程</li><li>FIFO: 相同优先级进程先来先得</li><li>RR: 轮流调度策略, 采用时间片轮流调度相同优先级进程 <ul><li>Deadline: 在调度时, 选择 deadline 最近的进程</li></ul></li><li>普通调度策略</li><li>normal: 普通进程</li><li>batch: 后台进程, 可以降低优先级 <ul><li>idle: 空闲时才运行</li></ul></li><li>调度类: task_struct 中 * sched_class 指向封装了调度策略执行逻辑的类(有5种)</li><li>stop: 优先级最高. 将中断其他所有进程, 且不能被打断</li><li>dl: 实现 deadline 调度策略 <ul><li>rt: RR 或 FIFO, 具体策略由 task_struct-&gt;policy 指定</li><li>fair: 普通进程调度</li><li>idle: 空闲进程调度</li></ul></li></ul></li><li>普通进程的 fair 完全公平调度算法 CFS(Linux 实现)</li><li>记录进程运行时间( vruntime 虚拟运行时间)</li><li>优先调度 vruntime 小的进程 <ul><li>按照比例累计 vruntime, 使之考虑进优先级关系</li></ul></li><li>调度队列和调度实体</li><li>CFS 中需要对 vruntime 排序找最小, 不断查询更新, 因此利用红黑树实现调度队列</li><li>task_struct 中有 实时, deadline 和 cfs 三个调度实体, cfs 调度实体即红黑树节点 <ul><li>每个 CPU 都有 rq 结构体, 里面有 dl_rq, rt_rq 和 cfs_rq 三个调度队列以及其他信息; 队列描述该 CPU 所运行的所有进程</li><li>先在 rt_rq 中找进程运行, 若没有再到 cfs_rq 中找; cfs_rq 中 rb_root 指向红黑树根节点, rb_leftmost指向最左节点</li></ul></li><li>调度类如何工作</li><li>调度类中有一个成员指向下一个调度类(按优先级顺序串起来)</li><li>找下一个运行任务时, 按 stop-dl-rt-fair-idle 依次调用调度类, 不同调度类操作不同调度队列</li></ul></blockquote><h2 id="课堂练习" tabindex="-1"><a class="header-anchor" href="#课堂练习" aria-hidden="true">#</a> 课堂练习</h2><p>这里讲了进程调度的策略和算法，你知道如何通过 API 设置进程和线程的调度策略吗？你可以写个程序尝试一下。</p><p>欢迎留言和我分享你的疑惑和见解，也欢迎你收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习、进步。</p><h2 id="课后讨论" tabindex="-1"><a class="header-anchor" href="#课后讨论" aria-hidden="true">#</a> 课后讨论</h2><p><mark>如果优先队列一直有任务,普通队列的task一直得不到处理，操作系统会怎么做呢？</mark></p><p>我现在知道这个问题的答案了。这种现象叫做饿死。我当时想到这个问题时其实不知道这个概念。</p><p>为了防止这种现象的发生，操作系统在一定的时间周期会重置所有task的优先级，这样就保证了低优先级的task得以执行,而不被饿死。但是这个时间设置为多少合适？设置的短了会导致系统的频繁重置。设置的长了，又会使普通优先级的task切换太慢。这个时间一般是系统研究人员研究得到的，我觉得可能可以通过一些统计学上的方式来做。</p><p>为了解决task响应时间和完成时间的平衡，现代操作系统如Windows和Linux都依赖于Multi-Level Feedback Queue, 和文章讲的正好对应起来了。首先面对的情况是：</p><ol><li>操作系统无法知道每个task何时到来 ？</li><li>操作系统无法知道每个task运行完成实际需要多少时间 ？</li></ol><p>那么FIFO ShortJobFirst或者Short Time Completed First 算法，面对这两种场景将无从下手。</p><p>面对这样的问题，为了使交互性的TASK能够得到快速的响应，提升用户的的体验，同时缩短task 的完成时间。计算机科学家提出了Multi-Level Feedback Queue的解决方案。基本思想是通过优先级保证交互性的task，能够快速响应，同时通过统计task 对CPU的使用时间以期对TASK判断，有点类似于机器学习。</p><p>如果某个task 在其时间片里用完前释放CPU， 可以认为这是种交互式的task, 优先级保留。反之认为某个task是需要运行时间长的。同时基于对task 对cpu 时间使用的统计作为判断依据。这样经过一段时间运行后，长时间运行的队列会被逐渐降低优先级。</p><p>而快速响应的 task 能够优先使用CPU。但是这里面还有两个问题: 首先，如果优先级低的一直得不到cpu, 可能会出现饿死。其次，有人可能会利用这个漏洞编程的方式在使用完CPU时间片后释放CPU，从而控制CPU。 基于此，Multi-feedback-queue有以下5条规则：</p><ol><li>如果A的优先级大于B， 则A先运行。</li><li>如果A的优先级等于B， 则以RR算法交互运行。</li><li>新来的 Task 会被置于最高的优先级。</li><li>如果一个task 在其当前优先级运行完被分配的时间片后，会降低其优先级，重置其放弃使用CPU的次数。（这条规则修改过，是为了防止有人利于原有规则的漏洞控制CPU, 原来的规则是如果一个task 在其时间片用完前释放cpu, 则其优先级保持不变， 这个修正增加了对task 实际使用cpu 时间统计作为判断依据）。</li><li>系统每过时钟周期的倍数，会重置所有task 的优先级。（这条规则是为了防止task被饿死的，也是我之前所疑惑的）。</li></ol><hr><p>这里给大家分享几个文章，大家对背后的机制明白后，这些代码就很好理解了，这些文章涉及linux调度器的发展历史，O(n), O(1)调度器，到cfs。</p>',110),v={href:"http://www.wowotech.net/process_management/scheduler-history.html",target:"_blank",rel:"noopener noreferrer"},m={href:"https://www.ibm.com/developerworks/cn/linux/l-cn-scheduler/index.html",target:"_blank",rel:"noopener noreferrer"},_={href:"https://www.jianshu.com/p/673c9e4817a8",target:"_blank",rel:"noopener noreferrer"},b=p("<p>查看当前进程的调度策略<br><code>$ chrt -p 31636</code><br> pid 31636 的当前调度策略：SCHED_OTHER<br> pid 31636 的当前调度优先级：0</p><p>修改31636进程的调度策略为SCHED_FIFO，优先级为10<br><code>$ chrt -f -p 10 31636</code><br><code>$ chrt -p 31636</code><br> pid 31636 的当前调度策略：SCHED_FIFO<br> pid 31636 的当前调度优先级：10</p><p>本节讲的是进程的调度，那线程的调度是什么样的呢？Linux调度的基本单位是进程还是线程呢？<br> 作者回复: 进程和线程都是task，一起调度。一个task分配给一个cpu执行后，就不会再被其他cpu执行。一个task是不会出现在所有cpu的队列中的。</p><p>老师一个task绑定完一个cpu以后 还会解绑去然后交给其他cpu吗<br> 作者回复: 可以__migrate_task</p><p>一个task是不是永远只能绑定在一个CPU的rq上，不会在其他CPU上运行了？有没有 一个CPU比较闲，去其他比较忙的CPU那窃取点任务的机制？<br> 作者回复: 会调度到其他cpu的，但是当前的时间片没必要</p><p>Linux的最小调度单位是线程，每个进程又至少都有一个线程，当我们在谈Linux调度的时候为啥不说是线程调度？所谓的进程调度是说的也是调度的里面的线程吗？那是不是就没有所谓的进程调度了呢？<br> 作者回复: 是的，叫任务调度吧</p><p>感觉这个sched_class结构体类似面向对象中的基类啊,通过函数指针类型的成员指向不同的函数，实现了多态。<br> 作者回复: 是的</p><p>可以通过sched_setscheduler和pthread_setschedparam设置进程和线程的API<br> 作者回复: 赞</p><p>如果是新建的进程如何处理, 它 vruntime 总是最小的, 总被调度直到与其他进程相当.<br> 作者回复: 每次新进程创建完毕后，都会试图先让新的抢占一次</p><p>有个疑问，sched_class和rq这些结构，都存在内核态的哪里啊，也有一个进程负责维护他们吗，CPU怎么有他们的地址的。。抱歉问题比较多<br> 作者回复: 到了内核里面，就没有所谓进程不进程了，对于操作系统内核的代码，都是数据结构，随内核怎么操作都行。地址是初始化的时候，重要数据结构的起始地址都是能够找到的。</p>",10),h={href:"http://man7.org/linux/man-pages/man7/sched.7.html",target:"_blank",rel:"noopener noreferrer"},y={href:"http://man7.org/linux/man-pages/man7/pthreads.7.html",target:"_blank",rel:"noopener noreferrer"},w={href:"https://garlicspace.com/2019/07/16/linux-%e8%bf%9b%e7%a8%8b%ef%bc%8c%e7%ba%bf%e7%a8%8b%e7%9a%84%e8%b0%83%e5%ba%a6%e7%ad%96%e7%95%a5api/",target:"_blank",rel:"noopener noreferrer"},f=s("p",null,[n("讲的清晰明了，但是有个疑问，task_struct中为什么需要指向sched_class的指针呢？没想到有啥作用？"),s("br"),n(" 作者回复: 调度的时候要呀")],-1),g=s("p",null,[n("每个CPU上的任务队列是谁分配的？什么时候分配的？"),s("br"),n(" 作者回复: 启动的时候，其实只要初始化一个头就好了")],-1),q=s("p",null,"感觉跟分布式系统的负载均衡策略大同小异，设计模式就是：策略模式？",-1);function x(C,S){const a=c("ExternalLinkIcon");return o(),l("div",null,[d,s("ol",null,[s("li",null,[s("a",v,[n("http://www.wowotech.net/process_management/scheduler-history.html"),t(a)])]),s("li",null,[s("a",m,[n("https://www.ibm.com/developerworks/cn/linux/l-cn-scheduler/index.html"),t(a)])]),s("li",null,[s("a",_,[n("https://www.jianshu.com/p/673c9e4817a8"),t(a)])])]),b,s("p",null,[n("进程线程的API ： "),s("a",h,[n("http://man7.org/linux/man-pages/man7/sched.7.html"),t(a)]),n(", Posix Threads API "),s("a",y,[n("http://man7.org/linux/man-pages/man7/pthreads.7.html"),t(a)]),n(" , 实时调度策略可以设置优先级普通调度策略设置nice值。 线程要设置指定的调度策略， 主线程 PTHREAD_EXPLICIT_SCHED 否则默认集成主线程调度策略。 网上找了个例子验证了一下： "),s("a",w,[n("https://garlicspace.com/2019/07/16/linux-进程，线程的调度策略api/"),t(a)])]),f,g,q])}const F=e(k,[["render",x],["__file","H15-调度（上）.html.vue"]]);export{F as default};
