import{_ as s}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o as r,c as i,a,b as o,d as l,e as n}from"./app-063765ff.js";const p="/assets/ab5c3523af08e0bf2f689c1d6033ef77-8a45570a.png",c="/assets/5ee351091464de78eed75438b6f9183b-c127277f.png",d={},u=n(`<h1 id="√01-java代码是怎么运行的" tabindex="-1"><a class="header-anchor" href="#√01-java代码是怎么运行的" aria-hidden="true">#</a> √01 | Java代码是怎么运行的？</h1><p>我们学院的一位教授之前去美国开会，入境的时候海关官员就问他：既然你会计算机，那你说说你用的都是什么语言吧？</p><p>教授随口就答了个 Java。海关一看是懂行的，也就放行了，边敲章还边说他们上学那会学的是 C+。我还特意去查了下，真有叫 C+ 的语言，但是这里海关官员应该指的是 C++。</p><p>事后教授告诉我们，他当时差点就问海关，是否知道 Java 和 C++ 在运行方式上的区别。但是又担心海关官员拿他的问题来考别人，也就没问出口。那么，下次你去美国，不幸地被海关官员问这个问题，你懂得如何回答吗？</p><p>作为一名 Java 程序员，你应该知道，Java 代码有很多种不同的运行方式。</p><ol><li>比如说可以在开发工具中运行，</li><li>可以双击执行 jar 文件运行，</li><li>也可以在命令行中运行，</li><li>甚至可以在网页中运行。</li></ol><p>当然，这些执行方式都离不开 <mark>JRE</mark>，也就是 <mark>Java 运行时环境</mark>。</p><p>实际上，JRE 仅包含运行 Java 程序的必需组件，包括 Java 虚拟机以及 Java 核心类库等。我们 Java 程序员经常接触到的 ==JDK（Java 开发工具包）==同样包含了 JRE，并且还附带了一系列开发、诊断工具。</p><p>然而，<em>运行 C++ 代码则无需额外的运行时</em>。我们往往把这些代码直接编译成 CPU 所能理解的代码格式，也就是机器码。</p><p>比如下图的中间列，就是用 C 语言写的 Helloworld 程序的编译结果。可以看到，C 程序编译而成的机器码就是一个个的字节，它们是给机器读的。那么为了让开发人员也能够理解，我们可以用<em>反汇编器将其转换成汇编代码</em>（如下图的最右列所示）。</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>; 最左列是偏移；中间列是给机器读的机器码；最右列是给人读的汇编代码
0x00:  55                    push   rbp
0x01:  48 89 e5              mov    rbp,rsp
0x04:  48 83 ec 10           sub    rsp,0x10
0x08:  48 8d 3d 3b 00 00 00  lea    rdi,[rip+0x3b] 
                                    ; 加载&quot;Hello, World!\\n&quot;
0x0f:  c7 45 fc 00 00 00 00  mov    DWORD PTR [rbp-0x4],0x0
0x16:  b0 00                 mov    al,0x0
0x18:  e8 0d 00 00 00        call   0x12
                                    ; 调用printf方法
0x1d:  31 c9                 xor    ecx,ecx
0x1f:  89 45 f8              mov    DWORD PTR [rbp-0x8],eax
0x22:  89 c8                 mov    eax,ecx
0x24:  48 83 c4 10           add    rsp,0x10
0x28:  5d                    pop    rbp
0x29:  c3                    ret
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>既然 C++ 的运行方式如此成熟，那么你有没有想过，为什么 Java 要在虚拟机中运行呢，Java 虚拟机具体又是怎样运行 Java 代码的呢，它的运行效率又如何呢？</p><p>今天我便从这几个问题入手，和你探讨一下，Java 执行系统的主流实现以及设计决策。</p><h2 id="为什么-java-要在虚拟机里运行" tabindex="-1"><a class="header-anchor" href="#为什么-java-要在虚拟机里运行" aria-hidden="true">#</a> 为什么 Java 要在虚拟机里运行？</h2><p>Java 作为一门高级程序语言，它的语法非常复杂，抽象程度也很高。因此，直接在硬件上运行这种复杂的程序并不现实。所以呢，在运行 Java 程序之前，我们需要对其进行一番转换。</p><p>这个转换具体是怎么操作的呢？当前的主流思路是这样子的，</p><ol><li>设计一个面向 Java 语言特性的虚拟机，</li><li>并通过编译器将 Java 程序转换成该虚拟机所能识别的指令序列，也称 Java 字节码。</li><li>这里顺便说一句，之所以这么取名，是因为 Java 字节码指令的==操作码（opcode）==被固定为<em>一个字节byte</em>。</li></ol><p>举例来说，下图的中间列，正是用 Java 写的 Helloworld 程序编译而成的字节码。可以看到，它与 C 版本的编译结果一样，都是由一个个字节组成的。</p><p>并且，我们同样可以将其<em>反汇编为人类可读的代码格式</em>（如下图的最右列所示）。不同的是，Java 版本的编译结果相对精简一些。<strong>这是因为 Java 虚拟机相对于物理机而言，抽象程度更高</strong>。</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code># 最左列是偏移；中间列是给虚拟机读的机器码；最右列是给人读的代码
0x00:  b2 00 02         getstatic java.lang.System.out
0x03:  12 03            ldc &quot;Hello, World!&quot;
0x05:  b6 00 04         invokevirtual java.io.PrintStream.println
0x08:  b1               return
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Java 虚拟机可以由<u>硬件实现</u>[1]，但更为常见的是在各个现有平台（如 Windows_x64、Linux_aarch64）上提供<u>软件实现</u>。这么做的意义在于，一旦一个程序被转换成 <mark>Java 字节码</mark>，那么它便可以在不同平台上的虚拟机实现里运行。这也就是我们经常说的“一次编写，到处运行”。</p><p>虚拟机的另外一个好处是它带来了<mark>一个托管环境（Managed Runtime）</mark>。这个托管环境能够代替我们处理一些代码中冗长而且容易出错的部分。其中最广为人知的当属自动内存管理与垃圾回收，这部分内容甚至催生了一波垃圾回收调优的业务。</p><p>除此之外，托管环境还提供了诸如数组越界、动态类型、安全权限等等的<mark>动态检测</mark>，使我们免于书写这些无关业务逻辑的代码。</p><h2 id="java-虚拟机具体是怎样运行-java-字节码的" tabindex="-1"><a class="header-anchor" href="#java-虚拟机具体是怎样运行-java-字节码的" aria-hidden="true">#</a> Java 虚拟机具体是怎样运行 Java 字节码的？</h2><p>下面我将以标准 JDK 中的 HotSpot 虚拟机为例，从虚拟机以及底层硬件两个角度，给你讲一讲 Java 虚拟机具体是怎么运行 Java 字节码的。</p><p>从虚拟机视角来看，执行 Java 代码首先需要将它编译而成的 <mark>class 文件</mark>加载到 Java 虚拟机中。加载后的 <mark>Java 类</mark>会被存放于==方法区（Method Area）==中。实际运行时，虚拟机会执行方法区内的代码。</p><h3 id="java方法栈-本地方法栈" tabindex="-1"><a class="header-anchor" href="#java方法栈-本地方法栈" aria-hidden="true">#</a> Java方法栈 / 本地方法栈</h3><p>如果你熟悉 X86 的话，你会发现这和段式内存管理中的代码段类似。而且，Java 虚拟机同样也在内存中划分出<mark>堆</mark>和<mark>栈</mark>来存储运行时数据。</p><p>不同的是，Java 虚拟机会将栈细分为</p><ol><li>面向 Java 方法的 <em>Java 方法栈</em>，</li><li>面向本地方法（用 C++ 写的 native 方法）的<em>本地方法栈</em>，</li><li>以及存放各个线程执行位置的 PC 寄存器。</li></ol><figure><img src="`+p+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>在运行过程中，</p><ol><li>每当调用进入一个 Java 方法，Java 虚拟机会在当前线程的 Java 方法栈中生成一个栈帧，<br> 用以存放<mark>局部变量</mark>以及<mark>字节码的操作数</mark>。 <ol><li>这个栈帧的大小是提前计算好的，而且 Java 虚拟机<em>不要求</em>栈帧在内存空间里连续分布。</li></ol></li><li>当退出当前执行的方法时，不管是正常返回还是异常返回，<br> Java 虚拟机<strong>均会弹出</strong>当前线程的当前栈帧，<strong>并将之舍弃</strong>。</li></ol><h3 id="解释执行-即时编译" tabindex="-1"><a class="header-anchor" href="#解释执行-即时编译" aria-hidden="true">#</a> 解释执行 / 即时编译</h3><p>从硬件视角来看，Java 字节码无法直接执行。因此，Java 虚拟机需要将字节码翻译成<mark>机器码</mark>。</p><p>在 HotSpot 里面，上述翻译过程有两种形式：</p><ol><li>第一种是解释执行，即【<em>完整的代码</em>】逐条将字节码翻译成机器码并执行；</li><li>第二种是即时编译（Just-In-Time compilation，JIT），<br> 即将<em>一个方法中</em>包含的所有字节码编译成机器码后再执行。</li></ol><p>前者的优势在于无需等待编译，而后者的优势在于实际运行速度更快。HotSpot 默认采用混合模式，综合了解释执行和即时编译两者的优点。它会先解释执行字节码，而后将其中反复执行的热点代码，以方法为单位进行即时编译。</p><blockquote><p>解释执行 执行时才翻译成机器指令，无需保存不占内存。</p><p>但即时编译类似预编译，编译之后的指令需要保存在内存中，这种方式吃内存，</p><p>按照二八原则这种混合模式最恰当的，热点代码编译之后放入内存避免重复编译，而其他运行次数较少代码则解释执行，避免占用过多内存</p></blockquote><figure><img src="'+c+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="java-虚拟机的运行效率究竟是怎么样的" tabindex="-1"><a class="header-anchor" href="#java-虚拟机的运行效率究竟是怎么样的" aria-hidden="true">#</a> Java 虚拟机的运行效率究竟是怎么样的？</h2><p>HotSpot 采用了多种技术来提升启动性能以及峰值性能，刚刚提到的即时编译便是其中最重要的技术之一。</p><p>即时编译建立在程序符合二八定律的假设上，<em>也就是百分之二十的代码占据了百分之八十的计算资源</em>。</p><ol><li><strong>对于占据大部分的不常用的代码</strong>，我们无需耗费时间将其编译成机器码，而是采取<mark>解释执行</mark>的方式运行；</li><li>另一方面，<strong>对于仅占据小部分的热点代码</strong>，我们则可以将其【<mark>即时编译</mark>】编译成机器码，以达到理想的运行速度。</li></ol><p>理论上讲，即时编译后的 Java 程序的执行效率，是可能超过 C++ 程序的。<u>这是因为与静态编译相比，即时编译拥有<em>程序的运行时信息</em>，并且能够根据这个信息做出相应的优化</u>。</p><p>举个例子，我们知道虚方法是用来实现面向对象语言多态性的。对于一个虚方法调用，尽管它有很多个目标方法，但在实际运行过程中它可能只调用其中的一个。</p><p>这个信息便可以被即时编译器所利用，来规避虚方法调用的开销，从而达到比静态编译的 C++ 程序更高的性能。</p><p>为了满足不同用户场景的需要，HotSpot 内置了多个<u>即时编译器</u>：<mark>C1</mark>、<mark>C2</mark> 和 <mark>Graal</mark>。Graal 是 Java 10 正式引入的实验性即时编译器，在专栏的第四部分我会详细介绍，这里暂不做讨论。</p><p>之所以引入多个即时编译器，是为了在编译时间和生成代码的执行效率之间进行取舍。</p><h2 id="即时编译器-c1-c2-graal" tabindex="-1"><a class="header-anchor" href="#即时编译器-c1-c2-graal" aria-hidden="true">#</a> 即时编译器：C1 / C2 / Graal</h2><p>C1 又叫做 <mark>Client 编译器</mark>，面向的是对<em>启动性能</em>有要求的客户端 GUI 程序，采用的优化手段相对简单，因此编译时间较短。</p><p>C2 又叫做 <mark>Server 编译</mark>器，面向的是对<em>峰值性能</em>有要求的服务器端程序，采用的优化手段相对复杂，因此编译时间较长，但同时生成代码的执行效率较高。</p><h2 id="hotspot" tabindex="-1"><a class="header-anchor" href="#hotspot" aria-hidden="true">#</a> HotSpot</h2><p>从 Java 7 开始，HotSpot 默认采用<strong>分层编译的方式</strong>：</p><ol><li>热点方法首先会被 C1 编译，</li><li>而后热点方法中的热点会进一步被 C2 编译。</li></ol><p>为了不干扰应用的正常运行，HotSpot 的即时编译是放在<em>额外的编译线程</em>中进行的。</p><p>HotSpot 会根据 <em>CPU 的数量</em>设置编译线程的数目，并且按 1:2 的比例配置给 C1 及 C2 编译器。</p><p>在计算资源充足的情况下，字节码的解释执行和即时编译<em>可同时进行</em>。</p><p>编译完成后的机器码会在下次调用该方法时启用，<u>以替换原本的解释执行</u>。</p><h2 id="总结与实践" tabindex="-1"><a class="header-anchor" href="#总结与实践" aria-hidden="true">#</a> 总结与实践</h2><p>今天我简单介绍了 Java 代码为何在虚拟机中运行，以及如何在虚拟机中运行。</p><p>之所以要在虚拟机中运行，是因为它提供了可移植性。一旦 Java 代码被编译为 Java 字节码，便可以在不同平台上的 Java 虚拟机实现上运行。此外，虚拟机还提供了一个代码托管的环境，代替我们处理部分冗长而且容易出错的事务，例如内存管理。</p><p>Java 虚拟机将运行时内存区域划分为五个部分，分别为<mark>方法区</mark>、<mark>堆</mark>、<mark>PC 寄存器</mark>、<mark>Java 方法栈</mark>和<mark>本地方法栈</mark>。Java 程序编译而成的 class 文件，需要先加载至方法区中，方能在 Java 虚拟机中运行。</p><p>为了提高运行效率，标准 JDK 中的 HotSpot 虚拟机采用的是<em>一种混合执行的策略</em>。</p><p>它会解释执行 Java 字节码，然后会将其中<em>反复执行的热点代码，以方法为单位</em>进行<mark>即时编译</mark>，翻译成机器码后直接运行在底层硬件之上。</p><p>HotSpot 装载了<strong>多个不同的即时编译器</strong>，以便在编译时间和生成代码的执行效率之间做取舍。</p><h2 id="课后思考" tabindex="-1"><a class="header-anchor" href="#课后思考" aria-hidden="true">#</a> 课后思考</h2><p>下面我给你留一个小作业，通过观察两个条件判断语句的运行结果，来思考 Java 语言和 Java 虚拟机看待 boolean 类型的方式是否不同。</p><p>下载 asmtools.jar [2] ，并在命令行中运行下述指令（不包含提示符 $）：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token builtin class-name">echo</span> <span class="token string">&#39;
public class Foo {
 public static void main(String[] args) {
  boolean flag = true;
  if (flag) System.out.println(&quot;Hello, Java!&quot;);
  if (flag == true) System.out.println(&quot;Hello, JVM!&quot;);
 }
}&#39;</span> <span class="token operator">&gt;</span> Foo.java
$ javac Foo.java
$ <span class="token function">java</span> Foo
$ <span class="token function">java</span> <span class="token parameter variable">-cp</span> /path/to/asmtools.jar org.openjdk.asmtools.jdis.Main Foo.class <span class="token operator">&gt;</span> Foo.jasm.1
$ <span class="token function">awk</span> <span class="token string">&#39;NR==1,/iconst_1/{sub(/iconst_1/, &quot;iconst_2&quot;)} 1&#39;</span> Foo.jasm.1 <span class="token operator">&gt;</span> Foo.jasm
$ <span class="token function">java</span> <span class="token parameter variable">-cp</span> /path/to/asmtools.jar org.openjdk.asmtools.jasm.Main Foo.jasm
$ <span class="token function">java</span> Foo

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,70),h={href:"https://en.wikipedia.org/wiki/Java_processor",target:"_blank",rel:"noopener noreferrer"},v={href:"https://wiki.openjdk.java.net/display/CodeTools/asmtools",target:"_blank",rel:"noopener noreferrer"},m=a("p",null,"作者回复: awk就是一个文本处理修改工具，要用时查查man文档即可。 这一条awk指令相当于用记事本打开，搜索iconst1，替换为iconst2。你可以就在记事本这样的GUI程序里操作，也挺方便的。",-1),b=a("p",null,"作者回复: 那条awk命令是找到文本中第一条iconst1，替换成iconst2",-1),_=a("hr",null,null,-1),J=a("p",null,[o("jvm把boolean当做int来处理"),a("br"),o(" 作者回复: 字节码高手！")],-1),k=a("hr",null,null,-1),j=a("sub",null,"(≧▽≦)/",-1),g=a("br",null,null,-1),f=a("br",null,null,-1),C={href:"https://adopt-openjdk.ci.cloudbees.com/view/OpenJDK/job/asmtools/lastSuccessfulBuild/artifact/asmtools-6.0.tar.gz%EF%BC%9B",target:"_blank",rel:"noopener noreferrer"},x=a("br",null,null,-1),E={href:"https://zh.wikipedia.org/wiki/Awk%EF%BC%8CAWK%E6%98%AF%E4%B8%80%E7%A7%8D%E4%BC%98%E8%89%AF%E7%9A%84%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%EF%BC%8CLinux%E5%8F%8AUnix%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%8E%B0%E6%9C%89%E7%9A%84%E5%8A%9F%E8%83%BD%E6%9C%80%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%BC%95%E6%93%8E%E4%B9%8B%E4%B8%80,%E4%BA%8E%E6%98%AF%E8%BD%AC%E6%88%98Linux%EF%BC%8C",target:"_blank",rel:"noopener noreferrer"},w=a("br",null,null,-1),q=a("br",null,null,-1),A=a("br",null,null,-1),F=a("br",null,null,-1),B=a("br",null,null,-1),S=a("br",null,null,-1),H=a("br",null,null,-1),M=a("br",null,null,-1),V=a("br",null,null,-1),T=a("br",null,null,-1),D=a("br",null,null,-1),I=a("br",null,null,-1),P=a("br",null,null,-1),G=a("br",null,null,-1),y=a("br",null,null,-1),O=a("br",null,null,-1),U=n("<hr><p>在Windows使用不了awk工具（貌似有代替方案），所以结合其他小伙伴的答案和自己的思考，答案整理如下：<br> 小作业的过程是：<br> 1、写Java代码，生成java文件<br> 2、将java文件编译成class文件(字节码)<br> 3、执行字节码，输出两个Hello,world!<br> 4、使用asmtool工具将class文件生成jasm文件<br> 5、使用awt工具将jasm文件stackframe的flag改为iconst_2<br> 6、再次使用asmtool工具将jasm文件恢复成class文件<br> 7、执行字节码，输出一个Hello, world！<br> 由于Java虚拟机将boolean类型看成0或者1，在步骤5中将源代码中的flag修改成2，于是在步骤7中的运行过程中，if(2)，true,执行输出；if(2 == 1)，结果为false，不执行输出。</p><hr>",3),W={href:"https://wenjie.store/archives/ant-asmtools-awk",target:"_blank",rel:"noopener noreferrer"},R=a("hr",null,null,-1),K=a("p",null,"因为编译成class文件以后，true被编译成了1，在ams文件中展示的就是iconst_1。 而awk那句话的意思是将第一次出现的iconst_1修改为iconst_2，也就是将被编译成的1改成了2。 所以在转为class文件的时候，boolean值被修改成了2。而其他的没有改变。因为2!=0，所以只输出了 Hello，Java！",-1),L=a("h2",{id:"评论区",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#评论区","aria-hidden":"true"},"#"),o(" 评论区")],-1),z={href:"https://blog.csdn.net/jiaobuchong/article/details/83037467",target:"_blank",rel:"noopener noreferrer"},$=a("br",null,null,-1),N={href:"http://bbs.chinaunix.net/thread-4246512-1-1.html",target:"_blank",rel:"noopener noreferrer"},X=n("<hr><p>受益匪浅，多谢老师。 请教老师一个问题，网上我没有搜到。</p><p>服务器线程数爆满，使用jstack打印线程堆栈信息，想知道是哪类线程数太多，但是堆栈里全是一样的信息且没有任何关键信息，是哪个方法创建的，以及哪个线程池的都看不到。</p><p>如何更改打印线程堆栈信息的代码（动态）让其打印线程池信息呢？</p><p>其他网友：所以阿里的JAVA开发规范要求线程池必须要有名字。这样你就可以看到是那些线程比较多。<br> 其他网友：把堆dump下来，查看thread对象，看thread对象被那些线程池所引用即可<br> 其他网友：用arthas看下</p><hr><p>文中提到虚拟机会把部分热点代码编译成机器码，我有个疑问，为什么不把java代码全部编译成机器码？很多服务端应用发布频率不会太频繁，但是对运行时的性能和吞吐量要求较高。如果发布或启动时多花点时间编译，能够带来运行时的持久性能收益，不是很合适么？</p><p>作者回复: 问得好！事实上JVM确实有考虑做AOT (ahead of time compilation) 这种事情。AOT能够在线下将Java字节码编译成机器码，主要是用来解决启动性能不好的问题。</p><p>对于这种发布频率不频繁(也就是长时间运行吧？)的程序，其实选择线下编译和即时编译都一样，因为至多一两个小时后该即时编译的都已经编译完成了。另外，即时编译器因为有程序的运行时信息，优化效果更好，也就是说峰值性能更好。</p><p>其他网友：这样就相当于C++的静态编译了吧，就不能体现出即时编译时，利用程序的运行时信息，进行优化的好处了。</p><p>其他网友：还有一种方法就是预热，如果你预先知道某个方法会被反复执行，可以在程序启动的时候重复调用该方法，这样可以尽早触发JVM将该方法视为热点方法而不用等用户持续调用来触发，从而将其编译成机器码。</p><p>其他网友：cpu组成原理说机器码比字节码占更多内存，即时编译是对资源和执行效率的一种平衡；同时，如果预变异就跟c++一样，不会有即时编译提高执行速度。</p><p>其他网友：还有一点，有时候程序里代码并不一定会允许，尤其是第三方的包，这些代码就没有必要编译，更别说占用启动时间去编译了，会导致启动很慢。<br> 这个有点懒加载模式的设计思想</p><hr>",14),Q=a("br",null,null,-1),Y={href:"https://mp.weixin.qq.com/s/GO2fAeGgaB2jIC02gWp5Aw",target:"_blank",rel:"noopener noreferrer"},Z=a("br",null,null,-1),aa=a("br",null,null,-1),oa=a("hr",null,null,-1),ea=a("p",null,"在为什么Java要在虚拟机里执行这一节您提到，java语法复杂，抽象度高，直接通过硬件来执行不现实，但是同样作为高级语言为什么C++就可以呢？这个理由作为引入虚拟机这个中间层的原因不是很充分吧",-1),la=a("p",null,"作者回复: 多谢指出！这里的直接运行指的是不经过任何转换(编译)，直接在硬件上跑。即便是C++，也不可以直接运行。",-1),na=a("p",null,"C++的策略是直接编译成目标架构的机器码，Java的策略是编译成一个虚拟架构的机器码。这个虚拟架构可以有物理实现(可以搜Java processor)，也可以是软件实现，也就是我们经常接触到的JRE。",-1),sa=a("p",null,"另外，虚拟机上运行，还加上了内存动态分派和GC，可以提供编译过程的信息参照优化。",-1),ta=a("hr",null,null,-1),ra=a("p",null,[o("看到有人说热点代码的区别，在git里面涉及到的热点代码有两种算法，基于采样的热点探测和基于计数器的热点探测。一般采用的都是基于计数器的热点探测，两者的优缺点百度一下就知道了。基于计数器的热点探测又有两个计数器，方法调用计数器，回边计数器，他们在C1和C2又有不同的阈值。😂😂"),a("br"),o(" 作者回复: 谢谢！")],-1),ia=a("hr",null,null,-1),pa=a("br",null,null,-1),ca=a("br",null,null,-1),da=a("br",null,null,-1),ua=a("br",null,null,-1),ha=a("br",null,null,-1),va={href:"https://ci.adoptopenjdk.net/view/Dependencies/job/asmtools/lastSuccessfulBuild/",target:"_blank",rel:"noopener noreferrer"},ma=a("br",null,null,-1),ba=a("hr",null,null,-1),_a=a("p",null,"什么时候使用C1，什么时候使用C2，他是怎么区分热点方法的呢？",-1),Ja=a("p",null,[o("作者回复: 刚刚看到一个同学总结了。JVM会统计每个方法被调用了多少次，超过多少次，那就是热点方法。(还有个循环回边计数器，用来编译热循环的。)"),a("br"),o(" 默认的分层编译应该是达到两千调C1，达到一万五调C2。")],-1),ka=a("hr",null,null,-1),ja=a("p",null,[o("您好，我现在所在的项目经常堆外内存占用非常多，超过总内存的70%，请问一下有没有什么方法能观察一下堆外内存有什么内容？"),a("br"),o(" 作者回复: 堆外内存的话，就把JVM当成普通进程来查找内存泄漏。可以看下Google Performance Tools相关资料")],-1),ga=a("hr",null,null,-1),fa=a("br",null,null,-1),Ca=a("br",null,null,-1),xa={href:"http://hg.openjdk.java.net/code-tools/asmtools/archive/tip.zip",target:"_blank",rel:"noopener noreferrer"},Ea=n("<hr><p>解释执行是将字节码翻译为机器码，JIT也是将字节码翻译为机器码，为什么JIT就比解释执行要快这么多？<br> 如果说JIT检测到是热点代码并且进行优化，那么为什么解释执行不直接就用这种优化去解释字节码？<br> 一些比较浅的问题，希望老师能指点一二<br> 作者回复:<br> 1、就单条加法字节码而言，解释执行器需要识别字节码，然后将两个操作数从Java方法栈上读取出来并相加，最后将结果存入Java方法栈中。而JIT生成的机器码就只是一个CPU加法指令。<br> 2、因为JIT比较费时。如果字节码需要JIT后才跑，那么启动性能会很糟糕</p><hr><p>JIT程序重启之后还需要再来一遍吗？<br> 作者回复: 程序关闭后，即时编译的结果就没了，因此需要再来一遍。<br> 其他网友：这是因为都放在运行时的内存中吧？</p><hr><p>方法区和元空间是一个概念吧，能不能统一说法到jdk8之后的版本～<br> 其他网友：方法区是JVM规范，元数据区和永久代都是方法区的具体实现</p><hr><p>感觉看完后，解释执行和jit的区别还是有点没搞懂。解释执行的意思是:直接将整个字节码码文件转化成机器码，jit的意思是:用到哪段编译哪段?</p><p>作者回复: 反过来。解释执行相当于同声传译，你说一句我翻一句给观众(CPU)听。JIT是线下翻译，可以花时间精简掉你的口语话表达(做编译优化)。<br> 其他网友：这个比喻太棒了。解释执行立马展示运行结果的，所以没法太优化。jit则是检测对热点代码在另一个线程好好优化后得到的机器码，有足够的时间可以启用很多优化手段</p><hr><p>为啥是&quot;理论&quot;上比cpp快...这样看起来 如果都编译成机器码了 应该就是挺快的呀... 那干啥不像Go一样 直接编译成目标平台的机器码... 咋感觉绕了一圈..<br> 作者回复: 因为实际上会插入一些虚拟机相关的代码，稍微拉低了运行效率。</p><p>至于为什么不采用直接编译的方法，在峰值性能差不多的这个前提下，线下编译和即时编译就是两种选项，各有优缺点。JVM这样做，主要也是看重字节码的可移植性，而牺牲了启动性能。</p><p>另外呢，现代工程语言实现都是抄来抄去的。JVM也引入了AOT编译，在线下将Java代码编译成可链接库。</p><hr><p>理论上讲，即时编译后的 Java 程序的执行效率，是可能超过 C++ 程序的。<br> 我们导师当时是这么解释的，c是所有CPU指令集的交集，而jit可以根据当前的CPU进行优化，调用交集之外的CPU指令集，往往这部分指令集效率很高。<br> 作者如何看待这句话？<br> 作者回复: 这句话不准确。现代编译器一般都分为平台无关的前端和平台相关的后端。如果你要生成某个平台的代码，编译器会选择相应的后端。因此，无论是C编译器还是JIT编译器，都是基于目标CPU的指令集来做优化的。</p><hr><p>对不起，听了29篇文章了，至今不太清楚hotspot和openjdk两者之间的关系。<br> 作者回复: HotSpot是JVM里的引擎，可以理解为JDK中用C++写的部分。Oracle JDK/OpenJDK包括HotSpot。<br> 其他网友：查了查，jdk 分为 Oracle 的和 open 的，Oracle 的就是它自己公司写，open 的是有好几个公司 (apple、google 等公司)一起写。至于 hotspot 我感觉就是 JVM 里的核心。</p><hr><p>老师，对于jvm的即时编译，当方法里有很多if,elseif这样的判断，jvm也是整个方法进行编译，还是只部分编译？<br> 作者回复: JVM有两种编译方式，整个方法进行编译，或者对热循环进行编译。后面那种涉及到一个叫on stack replacement的技术。不论是那种，都要比if else的粒度大。</p><hr><p>老师，问一下这个asmtools是做什么用的<br> 作者回复: 就是Java字节码的反汇编器和汇编器。</p><hr><p>你好 我想问下 解释执行 Java 字节码后，再次执行到这里，还需要再次编译吗<br> 作者回复: 在即时编译器完成该方法的编译前，每次执行这里都需要解释执行。编译完成后，也有可能因为种种原因导致虚拟机抛弃这一编译结果。这时候就有可能触发再次编译</p><hr><p>即时编译生成的机器码一般是存到哪里的？<br> 其他网友：放在方法区内。</p><hr><p>Java虚拟机是如何执行Java字节码的？<br> 答:从虚拟机的视角看，执行Java代码首先会将它编译好的以.class结尾的字节码文件加载到虚拟机中并存放在方法区中，虚拟机实际执行的是方法区内的代码。虚拟会把栈细分为运行Java方法的Java方法区，运行本地代码的本地方法区和记录各个线程运行位置的PC寄存，当调用Java方法时，会在Java方法栈中创建一个栈桢，存放运行时的局部变量和字节码的操作数，Java虚拟机不要求栈桢是一个连续的内存结构。当程序结束，无论正常还是异常结束，虚拟机都会弹出栈桢元素，删除栈桢。<br> 从硬件角度来看，Java字节码并不能在硬件环境上执行，需要将字节码转换为机器码。有两种转换方式，一是解释执行，逐行解释并执行，二是即时编译，即把Java方法作为整天进行编译然后再执行，前者不需要等待编译后者运行效率高。hotspot采用了混合方式，即先把字节码逐行解释并执行，然后随遇一些热点代码在进行即时编译。</p><hr>",28),wa=a("br",null,null,-1),qa={href:"https://pan.baidu.com/s/1n8G2Hpbowd0soMIutnFWSw",target:"_blank",rel:"noopener noreferrer"},Aa=a("br",null,null,-1),Fa=a("hr",null,null,-1),Ba=a("br",null,null,-1),Sa={href:"https://github.com/eclipse/openj9/pull/1152",target:"_blank",rel:"noopener noreferrer"},Ha=a("br",null,null,-1),Ma={href:"https://ci.adoptopenjdk.net/view/Dependencies/job/asmtools/lastSuccessfulBuild/artifact/",target:"_blank",rel:"noopener noreferrer"},Va=n("<hr><p>两点∶<br> 1.无论是c1,c2,graal都只编译方法，不是整个类<br> 2.编译后的机器码放在内存<br> 疑惑：<br> 1.为什么不保存下来？<br> 2.如果说是因为虚函数导致每次都需要重新编译，那没有设计虚函数的方法是否能保存下来？</p><p>作者回复: 可以保存下来的，你可以查查jaotc这个工具的资料。第36篇也有部分介绍。</p><p>这样做的话，JVM需要确保你所执行的字节码和你编译后的机器码是否吻合。主要有两种情况会造成不吻合，一是换了库版本造成的代码本身不同，二是动态字节码注入造成实际运行的字节码和原字节码不同</p><hr><p>作者回复: 线程各自的栈空间是不共享的，但可以通过堆空间来共享数据。如果只有一个线程知道某个数据存放在堆的哪个位置，那也相当于不共享。注意不是等同于不共享，因为其它线程可以扫描整个堆，来找到这个位置。</p><hr><p>总结<br> 一、jvm能做什么？<br> ① 提供Java程序一次编译到处运行的平台；<br> ② 自动化管理内存；<br> ③ 程序编译成字节码后，虚拟机能够识别字节码程序，将字节码转换成机器码；</p><p>二、Jvm内存模型有那些部分？<br> ① 程序计数器（记录程序执行的下一条指令）<br> ② 方法区（主要存在类信息）<br> ③ 堆 （通一jvm内的所有线程共享，主要存储运行时产生的对象）<br> ④ 虚拟机栈 （线程独享，主要存储Java方法调用的局部变量）<br> ⑤ 本地方法栈</p><p>三、jvm翻译字节码成机器码的方式有那些？<br> ① 解释执行（将字节码逐条翻译成机器码并执行）<br> ② 及时编译（JIT，即将一个方法中的所有字节码编译成机器码，在执行）</p><p>四、 解释执行与及时编译有那些区别？<br> ① 及时编译能结合程序运行时的数据，做到最优，但是首次执行时需要等待编译；<br> ② 解释执行无需等待编译；</p><p>总结的不对的，希望老师与同学们多多指正！</p><hr><p>.class文件就是Java字节码文件，Java字节码相当于JVM的机器语言。</p><p>操作码（opcode）被固定为一个字节。一个字节8位，理论上最多支持256个操作码。java实际上使用了200左右的字节码。还有一些留给调试操作。</p><p>虚方法到目标方法的映射，解释执行可能要老老实实再找一遍，而即时编译后已经将目标方法编译好放在那里，无需再进行一次转换。</p><p>虚函数的开销之一是要使用函数指针来定位函数入口，比起直接获取函数入口来说，多了一次间接寻址，此时，CPU的指令缓存会被刷新，调用时程序跳转，再一次刷线缓存。 虚函数的另一个开销是，无法进行inline，是性能损失较大的地方，无法inline，就意味着每次函数调用，都得要建立和销毁一次函数栈帧，费时间又费空间。</p><hr>",18),Ta={href:"https://cmder.net/",target:"_blank",rel:"noopener noreferrer"},Da=a("hr",null,null,-1),Ia=a("p",null,[o("老师你好，我有个地方还是想不通，为什么java采用一次编译，到处运行的这种方式，而不是C++的不同平台都进行编译， java这样设计 加了中间层 反而执行效率降低，那这种设计的初衷是什么呢？"),a("br"),o(" 作者回复: 个人感觉应该是静态编译的各种语言中C++比较突出，一次编译到处运行的各种语言中Java比较典型。")],-1),Pa=a("p",null,"你可以用LLVM把C++编译成bitcode到处运行，也可以用AOT把Java编译成机器码。只不过不是那么”流行”",-1),Ga=a("hr",null,null,-1),ya=a("p",null,"即时编译器收集信息会不会产生额外的开销？这个开销会不会随着单位时间内访问次数的增大而增大？Java的动态编译和C++的静态编译都是转换成机器码，Java的优势在哪，运行期间的优化方案有哪些？",-1),Oa=a("p",null,[o("阅读完后我还有这些疑问，麻烦老师解答一下😃"),a("br"),o(" 作者回复: 可以直接看第16 17篇，你的问题基本上都覆盖到了")],-1),Ua=a("hr",null,null,-1);function Wa(Ra,Ka){const e=t("ExternalLinkIcon");return r(),i("div",null,[u,a("p",null,[o("[1] : "),a("a",h,[o("https://en.wikipedia.org/wiki/Java_processor"),l(e)])]),a("p",null,[o("[2] : "),a("a",v,[o("https://wiki.openjdk.java.net/display/CodeTools/asmtools"),l(e)])]),a("blockquote",null,[m,b,_,J,k,a("p",null,[o("作业终于做出来"),j,o("喜大普奔"),g,o(" asmtools下载地址："),f,a("a",C,[o("https://adopt-openjdk.ci.cloudbees.com/view/OpenJDK/job/asmtools/lastSuccessfulBuild/artifact/asmtools-6.0.tar.gz；"),l(e)]),x,o(" 先是在window环境里，awk不能使用，看"),a("a",E,[o("https://zh.wikipedia.org/wiki/Awk，AWK是一种优良的文本处理工具，Linux及Unix环境中现有的功能最强大的数据处理引擎之一,于是转战Linux，"),l(e)]),w,o(" [root@localhost cqq]# javac Foo.java"),q,o(" [root@localhost cqq]# java Foo"),A,o(" Hello,Java"),F,o(" Hello,JVM"),B,o(" [root@localhost cqq]# java -cp /cqq/asmtools.jar org.openjdk.asmtools.jdis.Main Foo.class>Foo.jasm.1"),S,o(" [root@localhost cqq]# ls"),H,o(" asmtools.jar Foo.class Foo.jasm.1 Foo.java"),M,o(" [root@localhost cqq]# vi Foo.jasm.1"),V,o(` [root@localhost cqq]# awk 'NR==1,/iconst_1/{sub(/iconst_1/,"iconst_2")} 1' Foo.jasm.1>Foo.jasm`),T,o(" [root@localhost cqq]# java -cp /cqq/asmtools.jar org.openjdk.asmtools.jasm.Main Foo.jasm"),D,o(" [root@localhost cqq]# java Foo"),I,o(" Hello,Java"),P,o(" 结果为啥是这个看点赞第一的高手；"),G,o(" 另外asmtools使用方式还可以这样子："),y,o(" java -jar asmtools.jar jdis Foo.class>Foo.jasm.1"),O,o(" java -jar asmtools.jar jasm Foo.jasm")]),U,a("p",null,[o("章尾的小作业，看这篇很有帮助 "),a("a",W,[o("https://wenjie.store/archives/ant-asmtools-awk"),l(e)])]),R,K]),L,a("blockquote",null,[a("p",null,[o("对老师写的那段 awk 不懂得可参考："),a("a",z,[o("https://blog.csdn.net/jiaobuchong/article/details/83037467"),l(e)]),$,o(" 其他网友："),a("a",N,[o("http://bbs.chinaunix.net/thread-4246512-1-1.html"),l(e)]),o(" 推荐这篇文章，讲得内容更加通俗易懂")]),X,a("p",null,[o("我想问下，JVM是怎么区别出热点代码和非热点代码的？"),Q,o(" 其它网友：使用“热点探测”技术统计的，HotSpot VM使用的是基于计数器的热点探测，可参考："),a("a",Y,[o("https://mp.weixin.qq.com/s/GO2fAeGgaB2jIC02gWp5Aw"),l(e)]),Z,o(" 其他网友：方法计数器就是干的这个活，需要运行之后jvm收集信息后才能知道。项目起来之后，方法调用及运行，就会进行计数。即项目部署完成运行之后，在一段时间内JVM收集每个方法的执行次数。"),aa,o(" 其他网友：我理解是：热点方法的识别是先运行起来，通过统计计算得知那个是热点执行区。然后通过及时编译器编译。编译好了下次执行该区域就使用机器码了。")]),oa,ea,la,na,sa,ta,ra,ia,a("p",null,[o("1.Java代码首先编译为class文件，然后通过java虚拟机加载到方法区。Java虚拟机是一个独立的进程，执行方法区的代码。"),pa,o(" 2.Java虚拟机把内存分为堆栈两种形式来存储运行时数据，包括线程共有的方法区和堆，以及线程私有的pc计数器，方法栈，naive方法栈"),ca,o(" 3.Java虚拟机将字节码翻译成机器码执行的方法有两种，一种是解释执行，即逐条将字节码翻译成机器码并执行；第二种是即时编译，即将一个方法包含的所有字节码编译成机器码后再执行"),da,o(" 4.解释执行的好处是无需等待编译，即时编译的好处是速度更快。这里编译的概念并不是代码编译为字节码，而是字节码编译为机器码，字节码编译为机器码是由java虚拟机在运行程序的时候才会去做的，所以是运行时的开销。热点代码会通过即时编译来执行。"),ua,o(" 5.HotSpot内置了多个即时编译器，包括C1、C2和Graal。"),ha,o(" 6.Asmtools.jar下载地址"),a("a",va,[o("https://ci.adoptopenjdk.net/view/Dependencies/job/asmtools/lastSuccessfulBuild/"),l(e)]),ma,o(" 7.JVM将Boolean类型看作是int类型，true就是1，false就是0，flag如果改成2第二个判1等式就不成立，所以只有第一个判0等式通过。")]),ba,_a,Ja,ka,ja,ga,a("p",null,[o("asmtools.jar 是在哪里下载的，怎么在给的链接页面没找到。"),fa,o(' 其他网友：我是下载了完整的代码，之后用ant在build.xml位置处运行"ant jar"弄出来的'),Ca,o(" 其他网友："),a("a",xa,[o("http://hg.openjdk.java.net/code-tools/asmtools/archive/tip.zip"),l(e)]),o(" 再用这位朋友说的办法使用ant构建 jar即可")]),Ea,a("p",null,[o("编译了一个 asmtools.jar 下面链接可取"),wa,a("a",qa,[o("https://pan.baidu.com/s/1n8G2Hpbowd0soMIutnFWSw"),l(e)]),Aa,o(" 提取码: 8fqv")]),Fa,a("p",null,[o("asmtools.jar 下载地址："),Ba,a("a",Sa,[o("https://github.com/eclipse/openj9/pull/1152"),l(e)]),Ha,a("a",Ma,[o("https://ci.adoptopenjdk.net/view/Dependencies/job/asmtools/lastSuccessfulBuild/artifact/"),l(e)])]),Va,a("p",null,[o("不想开虚拟机不想远程的可以使用 Cmder "),a("a",Ta,[o("https://cmder.net/"),l(e)])]),Da,Ia,Pa,Ga,ya,Oa,Ua])])}const $a=s(d,[["render",Wa],["__file","√A01-代码如何运行.html.vue"]]);export{$a as default};
