import{_ as p}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as t,c,a as e,b as a,e as n,d as r}from"./app-cdabc73c.js";const i="/assets/cd6fc0cb9f125242398bb98fde8c3ef3-5311b7e7.jpg",l="/assets/042yyb2c5b2fa5d3a6b575cb83e6235e-e8f8c602.jpg",d="/assets/0e1c5beddfbc483f91863d8396583466-e9a4b8ca.jpg",h="/assets/52b74e557b83abcd1b77eb2f90660bd9-6948ca8b.jpg",m="/assets/568526aeac098ca9290a39e539f27cb4-9c84e571.jpg",k="/assets/104ef1849ccc3c7yyc834b9a774ff974-728e651f.jpg",P="/assets/804bd3f0a0063bcfd4d1f8d8b13ef0a7-0914b507.jpg",g={},u=r('<h1 id="_36-从url到网卡-如何全局观察网络数据流动" tabindex="-1"><a class="header-anchor" href="#_36-从url到网卡-如何全局观察网络数据流动" aria-hidden="true">#</a> 36 | 从URL到网卡：如何全局观察网络数据流动？</h1><p>你好，我是 LMOS。</p><p>从这节课起，我们就要开始学习网络篇的内容了。网络是一个极其宏大的知识结构，我会通过五节课带你了解计算机网络的关键内容。</p><p>具体我们是这样安排的。</p><ol><li><p>作为网络篇的开始，今天这节课我会从一个面试中高频出现的问题切入，带你梳理从输入 URL 到网卡的网络数据流动过程中都发生了什么事。</p><ul><li>如果你真正理解了这个过程，相信你对整个网络架构的认知也会有质的飞跃。</li></ul></li><li><p>网络篇的第二节课，我会带你分析网络数据包在内核中如何流转；</p></li><li><p>第三节课，我们一起探讨互联网架构演进过程，并动手做一次协议栈移植；</p></li><li><p>最后两节课，我还是照例带你看看 Linux，让你理解套接字在 Linux 内核中怎样实现。</p></li></ol><h2 id="从一道经典面试题说起" tabindex="-1"><a class="header-anchor" href="#从一道经典面试题说起" aria-hidden="true">#</a> 从一道经典面试题说起</h2><p>下面我们一起来看看一个问题，估计你多多少少会觉得熟悉。</p><p>输入 URL，从一个请求到响应都发生了什么事？</p><p>没错，这是一道非常经典的面试题，你在网上随便一搜，也会找到各种各样的资料解答这道题。</p><p>不过啊，那些答案都有一些笼统，今天我会尽量详细地为你梳理一下这个过程。跟着我学完这节课，你就能明白，为什么面试官对这道题青睐有加了。</p><p>这里我先给你概括一下全过程，让你有个整体印象。</p><ul><li><p>\\1. 常规的网络交互过程是从客户端发起网络请求，==用户态的应用程序（浏览器）==会生成 HTTP 请求报文、并通过 DNS 协议查找到对应的远端 IP 地址。</p></li><li><p>\\2. 在套接字生成之后进入内核态，浏览器会委托操作系统内核协议栈中的上半部分，也就是 <mark>TCP/UDP 协议</mark>发起连接请求。</p></li><li><p>\\3. 然后经由协议栈下半部分的 <mark>IP 协议</mark>进行封装，使数据包具有远程定位能力。</p></li><li><p>\\4. 经过 <mark>MAC 层</mark>处理，找到接收方的目标 MAC 地址。</p></li><li><p>\\5. 最终数据包在经过<mark>网卡</mark>转化成<strong>电信号</strong>经过<mark>交换机</mark>、<mark>路由器</mark>发送到服务端，服务端经过处理拿到数据，再通过各种网络协议把数据响应给客户端。</p></li><li><p>\\6. 客户端拿到数据进行渲染。</p></li><li><p>\\7. 客户端和服务端之间反复交换数据，客户端的页面数据就会发生变化。</p></li></ul><p>你有没有发现，刚才的过程中，我们提到了多个层级和网络协议，那么网络为什么要分层呢？网络协议又是什么呢？请听我给你一一道来。</p><h2 id="前置知识-网络分层和网络协议" tabindex="-1"><a class="header-anchor" href="#前置知识-网络分层和网络协议" aria-hidden="true">#</a> 前置知识：网络分层和网络协议</h2><p>在计算机网络时代初期，各大厂商推出了不同的网络架构和标准，为统一标准，国际标准化组织 ISO 推出了统一的 OSI 参考模型。</p><p>当前网络主要遵循的 IEEE 802.3 标准，就是基于 OSI 模型提出的，主要定义的是<strong>物理层和数据链路层有线物理数据流传输的标准</strong>。</p><p>那么问题来了，网络为什么要分层呢？</p><p>我们都知道网络是复杂的。对于复杂的问题，我们自然要<strong>通过分层处理简化问题难度，降低复杂度</strong>，由于分层后的各层之间相互独立，我们可以把大问题分割成小问题。同样，分层也保证了网络的松耦合和相对的灵活，分层拆分后易于各层的实现和维护，也方便了各层的后续扩展。</p><p>网络分层解决了网络复杂的问题，在网络中传输数据中，我们对<strong>不同设备之间的传输数据的格式，需要定义一个数据标准，所以就有了网络协议。</strong></p><p>网络协议是双方通信的一种约定，以便双方都可以理解对方的信息。接下来我们就用 OSI 协议体系中广泛应用的 <strong>TCP/IP 层的体系结构</strong>来分析整个过程，你重点需要关注的是<strong>数据处理的过程和网络协议。</strong></p><img src="'+i+'" alt="img" style="zoom:15%;"><p>ISO_OSI通信流转</p><h2 id="发起请求阶段-应用层" tabindex="-1"><a class="header-anchor" href="#发起请求阶段-应用层" aria-hidden="true">#</a> 发起请求阶段（应用层）</h2><p>下面我们首先来看看网络应用层，它是最上层的，也是我们能直接接触到的。</p><p>我们的电脑或⼿机使⽤的<mark>应⽤软件</mark>都是在应⽤层实现，所以应⽤层只需要专注于为⽤户提供应⽤功能，不⽤去关⼼数据是如何传输的。你可以这样理解，应⽤层是⼯作在<strong>操作系统中的⽤户态</strong>。</p><p>我们依然从浏览器中输入 URL，开始了解网络应用层的工作流程。</p><h2 id="用户输入-在浏览器中输入-url" tabindex="-1"><a class="header-anchor" href="#用户输入-在浏览器中输入-url" aria-hidden="true">#</a> 用户输入：在浏览器中输入 URL</h2><p>我们在浏览器中输入 URL 的时候，浏览器已经开始工作了。浏览器会根据我们的输入内容，先匹配对应的 URL 以及关键词，给出输入建议，同时校验 URL 的合法性，并且会在 URL 前后补全 URL。</p>',28),I={href:"http://cosmos.com",target:"_blank",rel:"noopener noreferrer"},C={href:"http://www.cosmos.com",target:"_blank",rel:"noopener noreferrer"},b={href:"http://cosmos.com",target:"_blank",rel:"noopener noreferrer"},_=r(`<div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>URI <span class="token operator">=</span> scheme<span class="token operator">:</span><span class="token punctuation">[</span><span class="token comment">//authority]path[?query][#fragment]</span>

URI <span class="token operator">=</span> 方案<span class="token operator">:</span><span class="token punctuation">[</span><span class="token comment">//授权]路径[?查询][#片段ID]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接着，浏览器从 URL 中会提取出网络的地址，也叫做主机名（host），一般主机名可以为域名或 IP 地址，此处使用域名。</p><p>对 URL 进行解析之后，浏览器确定了服务器的主机名和请求路径，接下来就是根据这些信息来生成 HTTP 请求消息了，那么到现在为止，我们的 HTTP 请求是否已经发出了呢？并不是这样的，我们接着往下看。</p><h2 id="网络请求前-查看浏览器缓存" tabindex="-1"><a class="header-anchor" href="#网络请求前-查看浏览器缓存" aria-hidden="true">#</a> 网络请求前：查看浏览器缓存</h2><p>浏览器在 HTTP 报文生成完成后，它并不是马上就开始网络请求的。</p><p>在请求发出之前，浏览器首先会检查<mark>保存在本地计算机中的缓存</mark>，如果访问过当前的 URL，会先进入缓存中查询是否有要请求的文件。</p><p>此时存在的缓存有</p><ol><li>路由器缓存、</li><li>DNS 缓存、</li><li>浏览器缓存、</li><li>Service Worker、</li><li>Memory Cache、</li><li>Disk Cache、</li><li>Push Cache、</li><li>系统缓存等。</li></ol><p>在这里我们看一下系统缓存，如果在浏览器缓存里<strong>没有命中缓存</strong>，浏览器会做一个<strong>系统调用</strong>获得<mark>系统缓存中的记录</mark>，就是我们的 gethostbyname 方法，它的作用是通过域名获取 IP 地址。这个方法会返回如下结构。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">hostent</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char</span>    <span class="token operator">*</span>h_name<span class="token punctuation">;</span><span class="token comment">// 主机的别名.www.cosmos.com就是google他自己的别名  </span>
    <span class="token keyword">char</span>    <span class="token operator">*</span><span class="token operator">*</span>h_aliases<span class="token punctuation">;</span><span class="token comment">// 主机ip地址的类型，到底是ipv4(AF_INET)，还是pv6(AF_INET6)</span>
    <span class="token keyword">int</span>     h_addrtype<span class="token punctuation">;</span><span class="token comment">// 主机ip地址的长度</span>
    <span class="token keyword">int</span>     h_length<span class="token punctuation">;</span><span class="token comment">// 主机ip地址的长度</span>
    <span class="token keyword">char</span>    <span class="token operator">*</span><span class="token operator">*</span>h_addr_list<span class="token punctuation">;</span> <span class="token comment">// 主机的ip地址，注意，这个是以网络字节序存储的</span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">h_addr</span> <span class="token expression">h_addr_list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> 这个函数，是将类型为af的网络地址结构src，转换成主机序的字符串形式，存放在长度为cnt的字符串中。返回指向dst的一个指针。如果函数调用错误，返回值是<span class="token constant">NULL</span></span></span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果没有访问过当前的 URL，就会跳过缓存这一步，这时我们就会进入网络操作了。</p><h2 id="域名解析-dns" tabindex="-1"><a class="header-anchor" href="#域名解析-dns" aria-hidden="true">#</a> 域名解析：DNS</h2><p>接着上一小节在浏览器确认了输入的 URL 之前没有访问，浏览器就会生成对应的 HTTP 请求，这时浏览器需要委托操作系统将 HTTP 报文发送到对应的服务端。在发送消息之前，还有一个工作需要做，就是查找服务端的 IP 地址，因为操作系统在发送消息时，必须知道对方的 IP 地址才可以发送。</p><p>但是由于 IP 地址由一串数字组成，不够语义化，为方便你记忆，我们将 IP 地址映射为域名，于是就有这样一个服务，维护了 IP 和域名的映射关系，它就是非常重要的基础设施——<mark>DNS 服务器</mark>。DNS 服务器是<mark>一个分布式数据库</mark>，分布在世界各地。</p><p>为提高效率，DNS 是按照一定的结构进行组织的，不同层次之间按照英文句点. 来分割。</p>`,15),T={href:"http://cosmos.com",target:"_blank",rel:"noopener noreferrer"},f={href:"http://cosmos.com",target:"_blank",rel:"noopener noreferrer"},v={href:"http://xn--4gqva70yvt9d.com",target:"_blank",rel:"noopener noreferrer"},A=r(`<p>因为这是一个树形结构，所以客户端只要请求到一个 DNS 服务器，就可以一层层递归和迭代查找到所有的 DNS 服务器了。</p><p>按照由高到低的优先级，DNS 域名解析的过程排列如下。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>DNS解析<span class="token punctuation">(</span>发起<span class="token punctuation">)</span> <span class="token operator">&gt;</span> 浏览器DNS缓存 <span class="token operator">&gt;</span> hosts文件 <span class="token operator">&gt;</span> 本地DNS服务器 <span class="token operator">&gt;</span> ISP DNS服务器
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="操作系统协议栈-传输层和网络层" tabindex="-1"><a class="header-anchor" href="#操作系统协议栈-传输层和网络层" aria-hidden="true">#</a> 操作系统协议栈（传输层和网络层）</h2><p>现在我们已经根据 URL 拿到需要请求的唯一地址了，接下来就要委托操作系统将 HTTP 报文发送出去了，这个过程由<mark>操作系统中的协议栈</mark>负责处理。</p><p>TCP/IP 协议栈是现在使用最广泛的网络协议栈，Internet 就是建立在 TCP/IP 协议栈基础上的。除 TCP/IP 协议栈外，我们的操作系统内核可以支持多个不同的协议栈，如后续我们将会用到的 <code>LwIp</code>。</p><p>协议栈内部分为几部分，分别承担着不同的作用。</p><ol><li><p>协议栈的上半部分负责<strong>和<code>应用层</code>通过==套接字（Socket）==进行交互</strong>，它可以是 TCP 协议或 UDP 协议。</p><ul><li>应用层会委托协议栈的上部分<strong>完成收发数据的工作</strong>；</li></ul></li><li><p>而协议栈的下半部分则负责<strong>把<code>数据</code>发送给到<code>指定方的 IP 协议</code></strong>，由 IP 协议连接下层的<mark>网卡驱动(程序)</mark>。</p></li></ol><h2 id="可靠性传输-建立-tcp-连接" tabindex="-1"><a class="header-anchor" href="#可靠性传输-建立-tcp-连接" aria-hidden="true">#</a> 可靠性传输：建立 TCP 连接</h2><p>浏览器通过 DNS 解析拿到 Cosmos 的 IP 地址后， 浏览器取出 URL 的端口（HTTP 默认 80，HTTPS 默认 443）。随即浏览器会委托操作系统协议栈的上半部分创建新的套接字（Socket）向对应的 IP 发起 TCP 连接请求。</p><p>为了确保通信的可靠性，建立 TCP 首先会先进行三次握手的操作，我们可以结合后面的图示理解。</p><img src="`+l+'" alt="img" style="zoom:15%;"><p>TCP握手示意图</p><h3 id="tcp三次握手" tabindex="-1"><a class="header-anchor" href="#tcp三次握手" aria-hidden="true">#</a> TCP三次握手</h3><p>那么 TCP 的三次握手操作，是如何进行的呢？具体的操作步骤如下。</p><p>\\1. 首先浏览器作为客户端会发送一个小的 TCP 分组，这个分组设置了一个特殊的 SYN 标记，用来表示这是一条连接请求。同时设置初始序列号为 x 赋值给 Seq （这次捕获组的数据为: SYN=1, Seq=1）。</p><p>\\2. 服务器接受到客户端的 SYN 连接后，会选择服务器初始序号 y。同时向客户端发送含有连接确认（SYN+ACK）、Seq=0（本例中的服务器初始序号）、Ack=1（客户端的序号 x +1）等信息的 TCP 分组。</p><p>\\3. 客户端收到了服务器的确定字段后，向服务器发送带有 ACK=1、Seq=1 (x+1)、Ack=1 （服务器 Ack 信息的拷贝）等字段的 TCP 分组给服务器。</p><h3 id="tcp包头" tabindex="-1"><a class="header-anchor" href="#tcp包头" aria-hidden="true">#</a> TCP包头</h3><p>即使是发送一个 TCP 分组，也是一次网络通信，那么对于 TCP 层来说，<code>这一次通信的数据</code>前面就要包含<code>一个 TCP 包头</code>，向下层表明这是个 <mark>TCP 数据包</mark>。TCP 包头其实是一个数据结构，我为你准备了一幅图，以便理解。</p><p>下图就是 TCP 的包头，对于 TCP 头部来说，以下几个字段是很重要的，你要格外关注。</p><figure><img src="'+d+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>TCP包头</p><ol><li><p>首先，==源端口号（Source port）<mark>和</mark>目标端口号（Destinantion port）==是不可少的，如果没有这两个端口号，数据就不知道应该发给哪个应用。</p></li><li><p>其次，你需要注意的是一串有序数字 <code>Sequence</code> number，这个序号保证了 TCP 报文是有序被接受的，<strong>解决网络包的乱序问题</strong>。</p></li><li><p>之后的 <code>Acknowledgement</code> number 是确认号，只有对方确认收到，否则会一直重发，<strong>这个是防止数据包丢失的</strong>。</p></li><li><p>紧接着还有一些<mark>状态位</mark>，由于 TCP 是有状态的，是用于维护双方连接的状态，状态发生变更会更新双方的连接状态。</p></li><li><p>后面还有一个，窗口大小 <code>Window Size</code>，<strong>用于流量控制</strong>。</p></li></ol><p>TCP 层封装好了数据包，会将这个 TCP 数据包向下层发送，而 TCP 层的下层就是 <mark>IP 层</mark>，下面我们一起去瞧一瞧完成目的地定位的 IP 层。</p><h2 id="目的地定位-ip-层" tabindex="-1"><a class="header-anchor" href="#目的地定位-ip-层" aria-hidden="true">#</a> 目的地定位：IP 层</h2><p>TCP在维护状态的过程中，都需要委托 IP 层将数据封装，发送和处理网络数据包进入网络层。<strong>IP 协议是 TCP/IP 协议栈的核心</strong>，IP 协议中规定了在 Internet 上进行通信时应遵循的规则，包括 IP 数据包应如何构成、数据包的路由等，而 IP 层实现了网络上的点对点通信。</p><p>我们首先来看看 IP 层处理上层网络数据包的过程，网络数据包（无论输入数据包还是输出数据包）进入网络层后，IP 层协议的函数都要对网络数据包做后面这 5 步操作。</p><ul><li><p>\\1. 数据包校验和检验</p></li><li><p>\\2. 防火墙对数据包过滤</p></li><li><p>\\3. IP 选项处理</p></li><li><p>\\4. 数据分片和重组</p></li><li><p>\\5. 接收、发送和前送</p></li></ul><p>为了完成上述操作，IP 层被设计成三个部分，分别是 <strong>1 <code>IP 寻址</code>、2 <code>路由</code>、3 <code>分包组包</code></strong>。</p><p>现在我们并不关注这三个部分的具体实现，仅仅是熟悉这个流程就好了。</p><p>其实在网络通信的过程中，每个设备都必须拥有自己的 IP 地址才可以完成通信，我们的 IP 地址是以四组八位的组合进行约定，每组以. 号隔开，再转化为十进制的方式。这里要注意，<strong><code>IP 地址</code>并不是以<code>主机数目</code>进行配置的，而是根据<code>网卡数</code>来进行。</strong></p><p>有了 IP 地址，就可以通信了，但 IP 层仍然是一个软件实现的功能逻辑层，那它如何完成通信呢，答案是不能直接完成通信，它只是把 IP 地址及相关信息组装成一个 IP 头，把这个 IP 头放在网络数据的前面，形成了 <mark>IP 包</mark>，最后把这个 IP 包发送给 IP 层的下一层组件就行了，IP 头的格式如下所示。</p><h3 id="ip头" tabindex="-1"><a class="header-anchor" href="#ip头" aria-hidden="true">#</a> IP头</h3><img src="'+h+'" alt="img" style="zoom:15%;"><p>IP头部</p><p>有了 IP 头的网络数据，就有了发送目的地的信息，那么该如何才能将报文发送到目的地呢？这就要请 MAC 出场了，这个 MAC 层，就是 IP 层的下一层组件。下面我们一起进入 MAC 层。</p><h2 id="点对点传输-mac-链路层" tabindex="-1"><a class="header-anchor" href="#点对点传输-mac-链路层" aria-hidden="true">#</a> 点对点传输：MAC（链路层）</h2><p>我们经常听说<mark>网卡 MAC 地址</mark>，这个 MAC 地址指的就是计算机<mark>网卡的<strong>物理地址</strong>（Physical Address）</mark>，<strong>MAC 地址被固化到网卡中，用来标识一个网络设备</strong>。MAC 地址是<strong>唯一且无重复的</strong>，由国际标准化组织分配，用来确保网络中的<strong>每个网卡是唯一的</strong>。</p><p>网络数据在 IP 层中加上 IP 头后，形成了 IP 包，现在进入 MAC 层了，我们就需要对 IP 包加上 MAC 头，这个 MAC 头包括<strong>发送方的 MAC 头</strong>和<strong>接收方的 MAC 头</strong>，用于两个物理地址点对点的传输；此外还有一个头部字段为<strong>协议类型</strong>，在常规的 TCP/IP 协议中，MAC 头的协议类型只有 <code>IP</code> 和 <code>ARP</code> 两种。</p><h3 id="mac头" tabindex="-1"><a class="header-anchor" href="#mac头" aria-hidden="true">#</a> MAC头</h3><p>MAC 头格式如下所示。</p><img src="'+m+'" alt="img" style="zoom:15%;"><p>MAC头部</p><p>发送方的 MAC 头比较容易获取，读取当前设备网卡的 MAC 地址就可以获取，而接收方的 MAC 头则需要通过 ARP 协议在网络中携带 IP 地址，<strong>在一个网络中发送广播信息，这样就能获取这个网络中的 IP 地址对应的 MAC 地址</strong>，然后就能给我们的 IP 包加上 MAC 头了，最后这个加上 MAC 头的 IP 包，成为一个 MAC 数据包，就可以准备发送出去了。</p><p>下面我们一起进入最后的阶段，数据的发送，即网络层中的最低层——物理层。</p><h2 id="电信号的出口-网卡-物理层" tabindex="-1"><a class="header-anchor" href="#电信号的出口-网卡-物理层" aria-hidden="true">#</a> 电信号的出口：网卡（物理层）</h2><p>现在我们拿到了经过层层处理过的数据包，数据包只是一串二进制数据，然而我们都知道，网络上的数据传送，是依赖<mark>电信号</mark>的，所以我们现在需要将数据包转化为电信号，才能在物理的网线上面传输。</p><p>那么数据包是如何被转换电信号的呢，数据包通过网络协议栈的层层处理，最终得到了 <mark>MAC 数据包</mark>，这个 MAC 数据包会交给<mark>网卡驱动程序</mark>，而网卡驱动程序会将 MAC 数据包写入==<strong>网卡的缓冲区</strong>（网卡上的内存）==.</p><p>然后，网卡会在 MAC 数据包的起止位置加入<mark>起止帧</mark>和<mark>校验序列</mark>，最后<mark>网卡</mark>会负责将加入起止帧和校验序列的 <mark>MAC 数据包</mark>转化为<mark>电信号</mark>，发送出去。</p><h2 id="客户端服务端的持续数据交换-应用层" tabindex="-1"><a class="header-anchor" href="#客户端服务端的持续数据交换-应用层" aria-hidden="true">#</a> 客户端服务端的持续数据交换（应用层）</h2><p>现在，我们的数据终于通过网卡离开了计算机，进入到<strong>局域网</strong>，通过局域网中的<strong>设备，集线器、交换机和路由器等</strong>，数据会进入到互联网，最终到达目标服务器。</p><p>接着，服务器就会先取下数据包的 MAC 头部，查看是否匹配自己 MAC 地址。然后继续取下数据包的 IP 头，数据包中的目标 IP 地址和自己的 IP 地址匹配，再根据 IP 头中协议项，知道自己上层是 TCP 协议。</p><p>之后，还要继续取下数据包 TCP 的头。完成一系列的顺序校验和状态变更后，TCP 头部里面还有端口号，此时我们的 HTTP 的 server 正在监听这个端口号，就把数据包再发给对应的 HTTP 进程。</p><p>HTTP 进程从服务器中拿到对应的资源（HTML 文件），再交给操作系统对数据进行处理。然后再重复上面的过程，层层携带 TCP、IP、MAC 头部。</p><p>接下来数据从网卡出去，到达客户端，再重复刚才的过程拿到相应数据。<strong>客户端拿到对应的 HTML 资源，浏览器就可以开始解析渲染了</strong>，这步操作完成后，用户最终就能通过浏览器看到相应的页面。</p><h3 id="各层封装数据过程" tabindex="-1"><a class="header-anchor" href="#各层封装数据过程" aria-hidden="true">#</a> 各层封装数据过程</h3><p>我为你画了两幅图，来描述上述过程，第一幅是网络协议各层之间封装与拆封数据的过程，如下所示。</p><img src="'+k+'" alt="img" style="zoom:15%;"><p>TCP_IP协议栈</p><h3 id="客户端-服务器" tabindex="-1"><a class="header-anchor" href="#客户端-服务器" aria-hidden="true">#</a> 客户端/服务器</h3><p>下面的第二幅图，是描述客户端与服务器之间用网络协议连接通信的过程，如下所示。</p><img src="'+P+'" alt="img" style="zoom:15%;"><p>交互过程示意图</p><p>我们可以看到，此时客户端和服务端之间通过 TCP 协议维护了一个连接状态，如果客户端需要关闭网络，那么会进行四次挥手，两边的网络传输过程至此完成。</p><h2 id="重点回顾" tabindex="-1"><a class="header-anchor" href="#重点回顾" aria-hidden="true">#</a> 重点回顾</h2><p>好，这节课的内容告一段落了，我来给你梳理一下本节课的重点，如下所示。</p><p>\\1. 首先，常规的网络交互过程是从客户端发起网络请求，网络数据包经过各类网络协议的处理，为了约定一套不同设备都能理解的约定，我们引入了网络协议。</p><p>\\2. 然后，在不同的网络协议处理下，给我们的网络数据包加上了各种头部，这保证了网络数据在各层物理设备的流转下可以正确抵达目的地。收到处理后的网络数据包后，接受端再通过网络协议将头部字段去除，得到原始的网络数据。</p><p>\\3. 最后，这节课你需要重点理解<strong>网络协议对数据的处理过程，以及处理过程中的不同协议的数据结构和关键头部字段。</strong></p><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题" aria-hidden="true">#</a> 思考题</h2><p>我们这节课从宏观的角度分析了网络数据的运转，但是在内核中网络数据包怎么运转的呢？请你简单描述这个过程。</p><p>欢迎你在留言区跟我交流讨论，也欢迎你把这节课分享给你的同事、朋友。</p><p>我是 LMOS，我们下节课见！</p>',74);function M(S,x){const s=o("ExternalLinkIcon");return t(),c("div",null,[u,e("p",null,[a("为了帮你更好地理解，我给你举个例子说明。我们以输入 "),e("a",I,[a("cosmos.com"),n(s)]),a(" 为例，首先浏览器会判断出这是一个合法的 URL，并且会补全为 "),e("a",C,[a("http://www.cosmos.com"),n(s)]),a("。")]),e("p",null,[a("其中 http 为协议，"),e("a",b,[a("cosmos.com"),n(s)]),a(" 为网络地址，每个网络栏的地址都符合通用 URI 的语法。URI 一般语法由五个分层序列组成。后面的第一行内容我给你列了 URL 的格式，第二行做了行为说明。")]),_,e("p",null,[a("在域名中，我们的层级关系是按照从左到右、从低到高排列的，不同层级由低到高维护了一个树形结构，最高一级的根节点为 root 节点，就是我们所谓的根域名服务器，因此 "),e("a",T,[a("cosmos.com"),n(s)]),a(" 完整的域名应该是 "),e("a",f,[a("cosmos.com"),n(s)]),a(".，后面的 . 相当于.root。")]),e("p",null,[a("但是所有域名的顶级域名都一样，因此被省略；"),e("a",v,[a("再下一级.com"),n(s)]),a(" 为顶级域名；再下一级的 cosmos 为权威域名。")]),A])}const y=p(g,[["render",M],["__file","L36-从URL到网卡.html.vue"]]);export{y as default};
