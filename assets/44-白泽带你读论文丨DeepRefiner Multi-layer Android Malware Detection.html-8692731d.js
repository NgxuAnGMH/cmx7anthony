import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o as t,c as p,a as e,b as a,e as o,d as s}from"./app-cdabc73c.js";const d="/assets/640-1691464814632-147-3afee002.png",c="/assets/640-1691464814633-148-ef30404e.png",l="/assets/640-1691464814633-149-c9578212.png",f="/assets/640-1691464814633-150-b3b5cb4a.png",g="/assets/640-1691464814633-151-efbb8baa.png",h="/assets/640-1691464814633-152-ed1d4984.png",m="/assets/640-1691464814633-153-7484a1da.png",_="/assets/640-1691464814633-154-8f87a249.png",u={},x=e("h1",{id:"_44-白泽带你读论文丨deeprefiner-multi-layer-android-malware-detection",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_44-白泽带你读论文丨deeprefiner-multi-layer-android-malware-detection","aria-hidden":"true"},"#"),a(" 44-白泽带你读论文丨DeepRefiner: Multi-layer Android Malware Detection")],-1),D=e("p",null,[e("strong",null,"DeepRefiner: Multi-layer Android Malware Detection System Applying"),a(),e("strong",null,"Deep Neural Networks")],-1),b=e("p",null,"论文链接：",-1),R={href:"https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8406618",target:"_blank",rel:"noopener noreferrer"},y=s('<p>本文发表在2018 IEEE European Symposium on Security and Privacy (EuroS&amp;P)，第一作者是来自新加坡管理大学（SMU）的Ke Xu。</p><h2 id="主要内容" tabindex="-1"><a class="header-anchor" href="#主要内容" aria-hidden="true">#</a> <strong>主要内容</strong></h2><p>安卓恶意软件之间的恶意行为复杂，如何既快速又有效地检测恶意软件是当前面临的一个挑战。加上恶意行为的不断演化，通过人工选取检测特征费时费力，也难以跟上恶意软件的演化速度，如何自动化地提取特征也是一个挑战。</p><p>为了解决上述的两个挑战，本文提出了基于两个深度学习模型的DeepRefiner检测系统。使用基于语义的深度学习保证检测的有效性，具体来说，在<em>安卓应用的字节码</em>上使用含有语义结构的<mark>LSTM模型</mark>，捕获恶意软件的行为信息。为了保证检测的快速性，将<mark>多层感知机</mark>应用在<em>xml文件</em>上，能够快速地检测大部分恶意软件。作者在包含62915个恶意软件和47525个正常软件的数据集上进行了实验，实验表明DeepRefiner能够有效地检测恶意软件，准确率达到了97.74%，假阳性率为2.54%。作者还和先前的工作StormDroid以及10个基于签名的反病毒引擎进行了比较，实验结果表明，<strong>DeepRefiner性能更优</strong>。还评估了DeepRefiner在<u>抗混淆技术</u>和<u>抗对抗样本</u>方面的表现，表明DeepRefiner具有较好的鲁棒性。</p><h2 id="设计与实现" tabindex="-1"><a class="header-anchor" href="#设计与实现" aria-hidden="true">#</a> <strong>设计与实现</strong></h2><p>DeepRefiner检测系统包括两个深度学习模型，基于xml特征的多层感知机模型和基于字节码语义特征的LSTM模型，以保证检测的快速性和有效性。系统架构如下图。</p><figure><img src="'+d+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h3 id="第一层检测模型" tabindex="-1"><a class="header-anchor" href="#第一层检测模型" aria-hidden="true">#</a> 第一层检测模型</h3><p>基于xml特征的多层感知机模型是DeepRefiner的第一层检测模型，保证了检测的快速性。在这一层中，DeepRefiner根据xml文件中的特征可以可靠地检测出大部分的恶意软件，对于无法可靠检测的软件，标记为不确定的，然后交给下一层检测模型进行检测。具体的检测步骤如下：</p><p>(1) 提取安卓应用的xml文件，包括AndroidManifest.xml文件和位于/res/文件夹下的xml文件。</p><p>(2) 解析得到的所有xml文件，提取xml结构中的标签值和属性值作为检测特征，其中包括应用申请的权限、含有的组件和使用的字符串等信息。</p><p>(3) 将得到的所有字符串特征按照特定的顺序组织，如果一个应用中含有某一个特征，则将该特征对应位置的值置为1，否则为0，得到特征向量。</p><p>(4) 在训练阶段，根据训练集应用的特征向量训练多层感知机检测模型。在检测阶段，则将特征向量输入到训练好的多层感知机模型中，得到模型的预测值PMalicious和PBenign，并根据以下公式进行分类。</p><figure><img src="'+c+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h3 id="第二层检测模型" tabindex="-1"><a class="header-anchor" href="#第二层检测模型" aria-hidden="true">#</a> 第二层检测模型</h3><p>基于字节码语义特征的LSTM模型是DeepRefiner的第二层检测模型，保证检测的有效性。在这一层中，目的是检测第一层中标记为不确定的应用，使用bytecode2vec的方法将dex文件中的每一条字节码转换成向量表示，dex文件字节码序列则得到对应向量的序列，将该序列输入到LSTM模型中，完成对应用的检测。具体的检测步骤如下：</p><p>(1) 提取标记为不确定应用的dex文件，并对其反编译得到对应的字节码序列。</p><p>(2) 对dex字节码进行预处理，简化字节码序列。</p><p>(3) 利用bytecode2vec的嵌入算法，将简化后的字节码转换成向量表示，得到向量表示的序列，对应于带有语义信息的特征向量。</p><p>(4) 在训练阶段，根据训练集应用的特征向量训练LSTM模型。在检测阶段，则将特征向量输入到训练好的LSTM模型中，完成对应用的最终分类。</p><h3 id="自动化特征工程" tabindex="-1"><a class="header-anchor" href="#自动化特征工程" aria-hidden="true">#</a> 自动化特征工程</h3><p>在特征提取上，DeepRefiner整个过程是自动化完成的，并不需要专业的领域知识和大量的人力。对xml文件特征的提取是自动化地提取其中的标签值和属性值，然后表示成特征向量。对dex文件是利用bytecode2vec的方法将每一条字节码转换成向量表示，并把一个安卓应用程序表示成向量序列。</p><h2 id="实验与分析" tabindex="-1"><a class="header-anchor" href="#实验与分析" aria-hidden="true">#</a> <strong>实验与分析</strong></h2><h3 id="数据集" tabindex="-1"><a class="header-anchor" href="#数据集" aria-hidden="true">#</a> 数据集</h3><p>作者搜集了一个包含47525个正常软件和62915个恶意软件的数据集，其中正常软件来自于Google Play应用商店，恶意软件来自于VirusShare和一个先前工作的数据集MassVet，具体如下表。</p><figure><img src="'+l+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h3 id="实验" tabindex="-1"><a class="header-anchor" href="#实验" aria-hidden="true">#</a> 实验</h3><p>作者在实验中对DeepRefiner的检测效果、鲁棒性和运行开销进行了评估。</p><p>2.1 检测效果</p><p>在检测效果的评估上，评估了DeepRefiner每一层的检测效果。如下图展示了第一层模型的检测效果，结果表明，可以达到98.32%的准确率,在总共11万的数据集上，准确地检测出了8万应用，并标记出了将在第二层模型检测的2.9万不确定应用。</p><figure><img src="'+f+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>DeepRefiner第二层在第一层的基础上进行，对第一层标记为不确定的2.9万样本进行了检测，达到了96.14%的准确率。</p><p>DeepRefiner还和其他工作进行了比较，比较结果如下图，从中可以得到，DeepRefiner每一层的检测效果都优于StormDroid更好，而且也优于10款基于签名的反病毒引擎。</p><figure><img src="'+g+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><figure><img src="'+h+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>总的来说，实验结果表明，DeepRefiner检测系统对恶意软件达到了比较好的检测效果。</p><p>2.2 鲁棒性</p><p>作者评估了在11种常见混淆方式下的表现，包括重打包、重命名、数据加密和指令插入等方式，实验结果如图，可以得到，DeepRefiner的抗混淆能力较好。在抗对抗样本方面，DeepRefiner可以抗400%的花指令插入。</p><figure><img src="'+m+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>2.3 运行开销</p><p>作者在一个4核12G内存16G显存的系统上进行了评估，第一层模型检测一个app的耗时是0.22s，第二层模型检测一个app的耗时是2.4s。</p><figure><img src="'+_+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h2 id="总结评价" tabindex="-1"><a class="header-anchor" href="#总结评价" aria-hidden="true">#</a> <strong>总结评价</strong></h2><p>这篇论文的主要贡献在：</p><p>（1）提出了一个基于两个深度学习模型的DeepRefiner检测系统，能够完成对恶意软件的检测；</p><p>（2）在特征提取方面，整个过程是自动化完成的，并不需要专业的领域知识和大量的人力；</p><p>（3）在11万应用程序的数据集对DeepRefiner在检测效果、鲁棒性和运行开销方面进行了评估，表明了DeepRefiner检测系统具有不错的性能，能够快速有效地完成对恶意软件的检测。</p><p>但是这篇论文也存在一些不足之处。论文使用的是<em>静态分析方法</em>，对动态加载并实现恶意行为的恶意软件无法很好地检测，同时也继承了自动化特征工程的不足之处，特征的可解释性不够好。虽然提出自动化特征工程的方法，但是该方法在抗恶意软件演化方面存在一定的滞后性，首先需要收集一定量演化后的恶意软件，并且需要完成标注，这个过程需要耗费一定的时间和人力，在这个时间窗口上不能很好地检测演化后的恶意软件。</p>',48);function M(S,k){const r=n("ExternalLinkIcon");return t(),p("div",null,[x,D,b,e("p",null,[e("a",R,[a("https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8406618"),o(r)])]),y])}const E=i(u,[["render",M],["__file","44-白泽带你读论文丨DeepRefiner Multi-layer Android Malware Detection.html.vue"]]);export{E as default};
