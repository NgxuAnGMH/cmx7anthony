import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r,o as n,c as p,a as e,b as a,e as i,d as c}from"./app-cdabc73c.js";const s="/assets/640-1691476540425-12-cafcfba9.png",d="/assets/640-1691476540426-13-a04ef38a.png",l="/assets/640-1691476540426-14-f9e19e77.png",_="/assets/640-1691476540426-15-d2c0e6e2.png",h="/assets/640-1691476540427-16-9aa84fcc.png",f={},g=e("h1",{id:"_32-白泽带你读论文丨efficient-and-flexible-discovery-of-php-application",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_32-白泽带你读论文丨efficient-and-flexible-discovery-of-php-application","aria-hidden":"true"},"#"),a(" 32-白泽带你读论文丨Efficient and Flexible Discovery of PHP Application")],-1),u=e("p",null,[e("strong",null,"Efficient and Flexible Discovery of PHP Application Vulnerabilities")],-1),b=e("p",null,"论文链接：",-1),m={href:"https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=7961989",target:"_blank",rel:"noopener noreferrer"},x=e("p",null,"开源项目地址：",-1),P={href:"https://github.com/octopus-platform/joern",target:"_blank",rel:"noopener noreferrer"},E=c('<p>本文发表在2017 IEEE European Symposium on Security and Privacy(EuroS&amp;P ‘17)，第一作者是来自萨尔大学CISPA的Michael Backes</p><h2 id="_1-主要内容" tabindex="-1"><a class="header-anchor" href="#_1-主要内容" aria-hidden="true">#</a> <strong>1 主要内容</strong></h2><p>Web网站在当今大规模的普及，由于其语言的多样性导致其存在大量的攻击面，而本文聚焦于此，致力于高效且灵活的在大规模的php web应用程序上进行静态分析，快速寻找漏洞。</p><p>在本文中，作者基于Joern进行了拓展开发，将其延展于php，并拓展了Joern的功能，增加了Call Graph，使函数内的程序分析变得更加容易。同时作者使用了Neo4j图形数据库，使程序分析中图遍历变得更加容易和灵活。依托于PDG（数据依赖图）与CG（函数调用图）两种关系，可以高效的在大规模的web应用程序上进行漏洞挖掘。</p><p>根据实验评估，作者可用较短的时间在1854个php web应用程序中找到上百个漏洞。同时证明在千万级的代码量上可进行灵活高效的静态漏洞挖掘。</p><h2 id="_2-设计与实现" tabindex="-1"><a class="header-anchor" href="#_2-设计与实现" aria-hidden="true">#</a> <strong>2 设计与实现</strong></h2><p>在代码实现上，作者将工具分为主要的2步：</p><h3 id="_1-潜在关键函数定位" tabindex="-1"><a class="header-anchor" href="#_1-潜在关键函数定位" aria-hidden="true">#</a> （1）潜在关键函数定位</h3><p>对于潜在关键函数定位，作者首先对web漏洞按如下3步做了一个大致的建模：</p><p>(a)攻击者可控输入</p><p>作者将<code>$_GET、$_POST、$_COOKIE、$_REQUEST、$_SERVER、$_FILES</code>设定为low source，即攻击者可控参数low source。</p><p>(b)漏洞类型</p><p>在漏洞分析上，作者对漏洞进行分类，类别如下：SQL Injections、Command Injection、Code Injection、Arbitrary File Reads/Writes、Cross-Site Scripting (XSS)、Session Fixation。</p><p>(c)潜在关键函数表</p><p>针对每一种漏洞类型，作者指定了该类型的潜在关键函数和php内置的过滤函数，例如针对sql注入类型，作者规定了3种潜在关键函数mysql_query,pg_query,sqlite_query和php的内置过滤函数mysql_real_escape_string,pg_escape_string，sqlite_escape_string</p><p>建模后作者利用Neo4j的API快速定位代码中指定类型的所有潜在关键函数，例如XSS中，潜在关键函数为echo和print，作者使用Neo4j API进行快速定位：</p><figure><img src="'+s+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h3 id="_2-关键变量的验证" tabindex="-1"><a class="header-anchor" href="#_2-关键变量的验证" aria-hidden="true">#</a> （2）关键变量的验证</h3><p>在获取到潜在关键函数位置后，作者需要对其调用的参数进行验证，以判断其是否可被攻击者控制，且未经过过滤函数限制。因此作者在此选择了PDG与CG相结合的路径后向回溯方式。</p><p>如下图代码所示，以此来模拟作者回溯方式：</p><figure><img src="'+d+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>经过第一步潜在关键函数定位的操作，可以找到bar函数中的echo函数为潜在关键函数，而后找到其参数<code>$a</code>和<code>$c</code>。此时代码会利用PDG对变量<code>$a</code>和<code>$c</code>进行后向回溯。</p><p>先以<code>$c</code>为例，通过PDG图，可以找到<code>$c=$_GET[‘c’]</code>的赋值操作，而<code>$_GET</code>是建模中的low source，即攻击者可控参数，且回溯途中未经过xss过滤函数，因此该条路径被认定为可触发漏洞流，将会被返回。</p><p>再以<code>$a</code>为例，通过PDG图，可以找到其为bar函数的参数，此时根据CG图，可以找到bar函数的调用点，即foo函数内的<code>bar($a,$b)</code>，此时将继续利用PDG图在foo函数内进行后向回溯，找到<code>$a=$_GET[‘a’]</code>的赋值操作，且回溯途中未经过xss过滤函数，因此该条路径被认定为可触发漏洞流，将会被返回。</p><h2 id="_3-实验评估" tabindex="-1"><a class="header-anchor" href="#_3-实验评估" aria-hidden="true">#</a> <strong>3 实验评估</strong></h2><p>作者利用Github API随机爬取了1854个stars超过100的php web应用程序作为测试集，并发现1854个web应用程序中有4个是属于教育型应用程序，即故意内置漏洞，旨在帮助网络安全学习者对漏洞进行学习。作者并未将其删除，并将其归类于C，用于验证工具的完备性，剩下1850个应用程序归类于P。</p><figure><img src="'+l+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>以Command Injection漏洞为例，作者的工具在测试集上可用极短的时间在千万代码级上进行快速漏洞挖掘，并找到11个漏洞：</p><figure><img src="'+_+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><figure><img src="'+h+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>特别的，在测试中可以发现对于潜在关键函数eval的定位速度远快于shell_exec等潜在关键函数，原因是因为eval、xss、print、include、require等潜在关键函数拥有较为特殊的type，即AST_ECHO，AST_PRINT等，故此查询条件的限制更为容易且快速。</p><h2 id="_4-总结" tabindex="-1"><a class="header-anchor" href="#_4-总结" aria-hidden="true">#</a> <strong>4 总结</strong></h2><p>通过对PHPJoern的解析和Neo4j图像数据库的辅助，作者利用PDG和CG使高效的程序分析变的可行。但由于其缺乏CFG和数据库查询等约束，因此存在较多的漏报，并不能分析程序逻辑漏洞和一些二次攻击。</p><p>但总体来说，PHPJoern的出现，使php程序分析变得更加快捷高效。</p>',34);function y(S,$){const o=r("ExternalLinkIcon");return n(),p("div",null,[g,u,b,e("p",null,[e("a",m,[a("https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=7961989"),i(o)])]),x,e("p",null,[e("a",P,[a("https://github.com/octopus-platform/joern"),i(o)])]),E])}const I=t(f,[["render",y],["__file","32-白泽带你读论文丨Efficient and Flexible Discovery of PHP Application.html.vue"]]);export{I as default};
