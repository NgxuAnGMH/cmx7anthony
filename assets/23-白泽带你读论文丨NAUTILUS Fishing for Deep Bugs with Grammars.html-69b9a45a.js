import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o as s,c as n,a as e,b as a,e as o,d as u}from"./app-cdabc73c.js";const c="/assets/640-1691480205665-123-2ac32ba4.jpeg",f="/assets/640-1691480205665-124-6e5fd3f7.jpeg",g="/assets/640-1691480205665-125-f5161631.jpeg",h="/assets/640-1691480205665-126-27fe78d6.jpeg",d="/assets/640-1691480205666-127-61379fb1.jpeg",_="/assets/640-1691480205666-128-38e4ada8.jpeg",p={},l=e("h1",{id:"_23-白泽带你读论文丨nautilus-fishing-for-deep-bugs-with-grammars",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_23-白泽带你读论文丨nautilus-fishing-for-deep-bugs-with-grammars","aria-hidden":"true"},"#"),a(" 23-白泽带你读论文丨NAUTILUS: Fishing for Deep Bugs with Grammars")],-1),z=e("p",null,"NAUTILUS: Fishing for Deep Bugs with Grammars",-1),m={href:"https://github.com/RUB-SysSec/nautilus",target:"_blank",rel:"noopener noreferrer"},U=u('<p>本文发表在NDSS 2019，第一作者是来自波鸿大学的Cornelius Aschermann。</p><h2 id="_1-主要内容" tabindex="-1"><a class="header-anchor" href="#_1-主要内容" aria-hidden="true">#</a> 1. 主要内容</h2><p>Fuzzing那些需要有着复杂结构输入的程序，例如语言解释器，一直是学术界的一个难点。传统的基于突变的Fuzzer例如AFL，往往需要一个从互联网爬取的语料库，但这些语料库往往只包含了这些语言常用的语法，较难触发罕见的bug。而另一类基于生成的fuzzer则基于一定的模板或语法，往往能够生成结构性较强的输入，在fuzz语言解释器上取得了较好的效果。比较这两类fuzzer，作者认为前者使用了代码覆盖作为回馈，而后者能够生成高度结构化的输入，因此将这两种思路结合，提出了一个综合了语法和回馈的fuzzer——Nautilus。</p><h2 id="_2-背景" tabindex="-1"><a class="header-anchor" href="#_2-背景" aria-hidden="true">#</a> 2. 背景</h2><p><em>上下文无关文法</em>是编译原理中的一个重要的概念。几乎所有程序设计语言都是通过上下文无关文法来定义的。基于生成的fuzzer在fuzz这些语言的解释器时，往往就会利用这种语法来生成一串合法的输入。相对应地，突变也是以语法树上的节点为基础进行的，与AFL等传统fuzzer在字符串上进行突变不同。</p><figure><img src="'+c+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h2 id="_3-设计与实现" tabindex="-1"><a class="header-anchor" href="#_3-设计与实现" aria-hidden="true">#</a> 3. 设计与实现</h2><p>NAUTILUS工具的工作流程图如下，在传统的基于生成的fuzzer的基础上加入了插桩和回馈的步骤，即首先进行插桩，然后根据语法生成input，之后基于一些规则对input进行突变，最后将生成的input送入待测程序观察是否触发bug，根据插桩获得的反馈来判断有无到达新的路径，进而决定是否保留这个input进行下一轮的fuzz。</p><figure><img src="'+f+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h3 id="_3-1插桩阶段" tabindex="-1"><a class="header-anchor" href="#_3-1插桩阶段" aria-hidden="true">#</a> 3.1插桩阶段</h3><p>为了能够在fuzzing的过程中获得代码覆盖信息，从而能够得到反馈以指导fuzzer生成更好地输入，NAUTILUS在程序源代码上进行了插桩，其插桩方式与AFL相似。</p><h3 id="_3-2-fuzz阶段" tabindex="-1"><a class="header-anchor" href="#_3-2-fuzz阶段" aria-hidden="true">#</a> 3.2 Fuzz阶段</h3><p>在Fuzz阶段，NAUTILUS首先会根据给定的语法生成一定数量的input。在有多种规约规则的时（即语法书上一个子树有多种替换方案），NAUTILUS提出了两种方案来进行选择：随机选择或根据可能生成的子树的数量来尽可能选择可能生成更多子树的规则。在最后的评估中，作者对两种方案的效率进行了测试，发现在对输入进行去重后，两种方案的效率其实相差不多。之后，NAUTILUS会尝试对输入进行缩减，在保证相同代码覆盖率的同时尽可能地缩短输入，以节省测试时间。缩短完成后，NAUTILUS就会尝试对输入进行突变，大部分突变都是在语法树上进行的，例如随机替换一个节点、将节点按照规则规约，将规则里存在递归的部分重复一定次数，替换输入中的一个子树为另一个输入中的一个合法子树等，使这些输入在保证语法正确的前提下尝试探索新的程序路径。另外地，与AFL类似，NAUTILUS也会进行字节翻转、加减和替换等。如下图所示，这种突变可能会将语法树中一个合法的节点改掉，但同样也可能会触发程序的错误，达到fuzzer的目标。</p><figure><img src="'+g+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>最后，在把输入送入程序之前，NAUTILUS会将语法树转换为字符串并进行去重。程序运行之后，NAUTILUS会根据输入有无触发新的程序路径来决定是否保留该输入进行新一步的fuzz。如果这个输入触发了异常，NAUTILUS会将其记录下来。这些步骤都与AFL相似。</p><h2 id="_4-评价" tabindex="-1"><a class="header-anchor" href="#_4-评价" aria-hidden="true">#</a> 4. 评价</h2><ol><li>在四个真实应用上进行了测试，共发现了13个bug，其中在mruby上发现了6个CVE。</li></ol><figure><img src="'+h+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><ol start="2"><li>与AFL，IFuzzer两个fuzzer进行了对比，NAUTILUS的代码覆盖率有显著的优势。</li></ol><figure><img src="'+d+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><ol start="3"><li>对使用的突变方式对覆盖率的贡献度进行了评估，可以看到其中Splicing Mutaion（即切片）对于提高代码覆盖率的效果较好。</li></ol><figure><img src="'+_+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>总体而言，NAUTILUS在传统的基于生成的fuzzer的基础上加入了代码覆盖的信息作为回馈，提高了生成输入的效率，并在现实程序中找到了一些bug，具有一定的现实意义。</p>',23);function b(L,S){const i=t("ExternalLinkIcon");return s(),n("div",null,[l,z,e("p",null,[a("开源项目地址: "),e("a",m,[a("https://github.com/RUB-SysSec/nautilus"),o(i)])]),U])}const x=r(p,[["render",b],["__file","23-白泽带你读论文丨NAUTILUS Fishing for Deep Bugs with Grammars.html.vue"]]);export{x as default};
