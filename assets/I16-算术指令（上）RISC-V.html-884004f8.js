import{_ as s}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o as d,c as l,a as i,b as a,e as t,d as r}from"./app-cdabc73c.js";const c="/assets/b95d16b356f5102dd607ffe7aa9468dd-5c4902ce.jpg",p="/assets/b7d00c8a8cfb5c9b58096b4ac34ef754-4add5955.jpg",u="/assets/3f43d6e963728b21bfd08c9bc163e2dc-125e9e55.jpg",g="/assets/06546d200160722f354545c836869927-a7139952.jpg",m="/assets/aa949aecb51f43887efe64c028d9ef07-db7e31ac.jpg",o="/assets/35eyy14335aaf3ca16928246byy69b38-876672a3.jpg",v="/assets/ea91fdc0yy26203432e234f4fc1c3ca8-245eaa01.jpg",b="/assets/150bc142f1fb7d3cb254a43e1ac5239e-e1f87296.jpg",f="/assets/58b27beec7cd101e4851c55cb1454145-81e858e5.jpg",_="/assets/7591555613161c29edc73975f2e2503c-8a21ef00.jpg",x="/assets/e65638f1465db415bd8fb2d4045655e1-699807cc.jpg",h="/assets/2c8d62f82e806fde78497833fa446a29-7e71c048.jpg",j="/assets/c86feb04855a1a23e0aeae5146c505f9-ffc69187.jpg",y="/assets/4c8fa672020d3698f7678880a816ab87-0dadc7f6.jpg",C="/assets/866c202bbc80506f2fd20da047yy7493-de846ad3.jpg",z="/assets/7cf1e67300e0eaf23c4c2eb39yy9f501-589e2ead.jpg",S="/assets/28665141e5d0f3dae4b491f9f44e0c67-4985ae46.jpg",V="/assets/677af4b5ffe3b9d533495f455f5yyf0a-88f548ca.jpg",I="/assets/a9afc7d19330f7197970a5397de06517-dffd76f0.jpg",q="/assets/4a49ea167e93bb6a0dd67914a0ef06e2-2dd51184.jpg",R="/assets/d39d56635dfd0f62961cc1fc48167c37-40850512.jpg",k="/assets/d7fc42d9c557363aa4429da465410ed5-78deee59.jpg",F="/assets/7b55ea9d5d36a4ae1917f771b3ce0e91-691a4a1d.jpg",P={},U=i("h1",{id:"_16-risc-v指令精讲-一-算术指令实现与调试",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#_16-risc-v指令精讲-一-算术指令实现与调试","aria-hidden":"true"},"#"),a(" 16｜RISC-V指令精讲（一）：算术指令实现与调试")],-1),N=i("p",null,"你好，我是 LMOS。",-1),Q=i("p",null,"通过前面的学习，我们已经了解了在 C 语言编译器的“视角”下，C 语言的各种表达式是如何转换成各种机器汇编指令的。从这节课开始，我会带你进一步深入学习各种汇编指令的细节。",-1),T=i("p",null,"只要你耐心跟我学完这节课，对 RISC-V 的各种指令，你就能了如指掌了。这里我们将从 RV32I 的算术指令开始，先学习加减指令（add、sub），接着了解一下数值比较指令（slt）。这些指令都有两个版本，一个是立即数版本，一个是寄存器的版本。话不多说，我们开始吧。",-1),B={href:"https://gitee.com/lmos/Geek-time-computer-foundation/tree/master/lesson16~17",target:"_blank",rel:"noopener noreferrer"},E=r(`<h2 id="加减指令" tabindex="-1"><a class="header-anchor" href="#加减指令" aria-hidden="true">#</a> 加减指令</h2><p>上小学时我们都学过四则运算，最基础的是加减法，即一个数加上或者减去一个数，对应到 CPU 中就是一条加法指令和一条减法指令。</p><p>一个 CPU 要执行基本的数据处理计算，加减指令是少不了的，否则基础的数学计算和内存寻址操作都完成不了，用这样的 CPU 做出来的计算机将毫无用处。</p><p>不过想让 CPU 实现加减法，我们需要用到它能“理解”的语言格式，这样才能顺畅交流。所以，在研究指令之前，我们先来看看 RISC-V 指令的格式。</p><h3 id="risc-v-指令的格式" tabindex="-1"><a class="header-anchor" href="#risc-v-指令的格式" aria-hidden="true">#</a> RISC-V 指令的格式</h3><p>RISC-V 机器指令是一种三操作数指令，其对应的汇编语句格式如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>指令助记符 目标寄存器，源操作数1，源操作数2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>例如“add a0，a1，a2”，其中 add 就是指令助记符，表示各种指令，add 是加法指令；a0 是目标寄存器，目标寄存器可以是任何通用寄存器；a1，a2 是源操作数 1 与源操作数 2，源操作数 1 可以是任何通用寄存器，源操作数 2 可以是任何通用寄存器和立即数。立即数就是写指令中的常数，比如 0、1、100、1024 等。</p><h3 id="立即数加减法如何实现" tabindex="-1"><a class="header-anchor" href="#立即数加减法如何实现" aria-hidden="true">#</a> 立即数加减法如何实现</h3><p>我们先来看看加法指令，加法指令有两种形式。一种形式是一个寄存器和一个立即数相加，结果写入目标寄存器，我们称之为立即数加法指令。另一种形式是一个寄存器和另一个寄存器相加，结果写入目标寄存器，我们称之为寄存器加法指令。</p><p>我们先来看看立即数加法指令，形式如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>addi rd，rs1，imm
#addi 立即数加法指令
#rd 目标寄存器
#rs1 源寄存器1
#imm 立即数
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码 rd、rs1 可以是任何通用寄存器。 imm 立即数可以是 -2048~2047，其完成的操作是将 rs1 寄存器里的值加上立即数，计算得到的数值会写到 rd 寄存器当中，也就是 rd = rs1 + imm。</p><p>写代码验证之前，我们需要先明确代码应该写在哪里。而一个程序编译成二进制之后，运行的时候都是从 main 函数开始执行的。</p><p>所以，我们先构建一个 main.c 文件，在里面用 C 语言写上 main 函数，想让链接器工作这一步必不可少。接着，我们写一个汇编文件 addi.S，并在里面用汇编写上 <strong>addi_ins 函数。</strong></p><p>addi_ins 函数的代码如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>addi_ins:
    addi a0，a0，5          #a0 = a0+5，a0是参数，又是返回值，这样计算结果就返回了
    jr ra          #函数返回
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上节课我们提到过，C 函数的函数名对应到汇编语言中就是标号，这里加上一条“jr ra”返回指令，就构成了一个 C 语言中的函数。</p><p>这里 a0 寄存器里的数值即是 C 语言函数里的第一个参数，也是返回值。所以这个汇编函数完成的功能，就是把传递进来的参数加上 5，再把这个结果作为返回值返回。</p><p>下面我们在 C 语言的 main 函数中调用 addi_ins，然后打印一下结果，如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>#include &quot;stdio.h&quot;
int addi_ins(int x); //声明一下汇编语言中的函数：addi_ins
int main()
{
    int result = 0;
    result = addi_ins(4);    //result = 9 = 4 + 5
    printf(&quot;This result is:%d\\n&quot;, result);
    return 0;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你可以用 VSCode 打开工程目录，按下“F5”键调试一下，输出的结果为 9，因为 4+5 肯定等于 9。效果如下所示：</p><figure><img src="`+c+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>上图中是程序刚刚执行完 addi a0，a0，5 指令之后，执行 jr ra 指令之前的状态。可以看到 a0 寄存器中的值已经变成了 9，这说明运算的结果是正确的。</p><p>addi_ins 函数返回后，输出的结果如下图所示：</p><figure><img src="'+p+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>上图的结果已经证明了，addi 指令完成的功能和执行的结果符合我们的预期。</p><p>我们趁热打铁，在 addi.S 文件中再写一个函数，也就是 <strong>addi_ins2 函数</strong>，代码如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>.globl addi_ins2
addi_ins2:
    addi a0，a0，-2048       #a0 = a0-2048，a0是参数，又是返回值，这样计算结果就返回了
    jr ra                   #函数返回
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>addi_ins2 函数的指令和 addi_ins 函数一样，只不过立即数变成了负数。我们很清楚所谓减法就是加上一个负数，所以通过 addi_ins2 函数就实现了立即数减法指令。</p><p>同样地，我们在 main 函数中调用它，代码如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>#include &quot;stdio.h&quot;
int addi_ins(int x); //声明一下汇编语言中的函数：addi_ins
int addi_ins2(int x); //声明一下汇编语言中的函数：addi_ins2
int main()
{
    int result = 0;
    result = addi_ins(4);    //result = 9 = 4 + 5
    printf(&quot;This result is:%d\\n&quot;, result);
    result = addi_ins2(2048);    //result = 0 = 2048 - 2048
    printf(&quot;This result is:%d\\n&quot;, result);
    return 0;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接着我们再按下“F5”键调试一下，第二个 printf 输出的结果为 0，因为 2048-2048 肯定等于 0。如下所示：</p><figure><img src="`+u+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>和之前一样，上图中是刚刚执行完 addi a0，a0，-2048 指令之后，执行 jr ra 指令之前的状态。这时 a0 寄存器中的值已经变成了 0，这说明运算的结果正确。</p><p>addi_ins2 函数返回后，输出的结果如下图所示：</p><figure><img src="'+g+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>上图中已经证明了结果符合我们的预期，用 addi 指令完成了立即数的减法计算。这也是 RISC-V 指令集中没有立即数据减法指令的原因。为了保证这一特性，所有的立即数必须总是进行<strong>符号扩展</strong>，这样就可以用立即数表示负数，所以我们并不需要一个立即数版本的减法指令。</p><p>最后，为了进一步搞清楚这条指令的机器码数据，我们一起看看 addi_ins 函数和 addi_ins2 函数的二进制数据什么样。</p><p>让我们打开工程目录下的 addi.bin 文件，如下所示：</p><figure><img src="'+m+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>以上是四条指令数据，其中两个 0x00008067 数据为两个函数的返回指令，即：jr ra，0x00550513，它对应的汇编语句 addi a0，a0，5，0x80050513，对应汇编语句 addi a0，a0，-2048。</p><p>第五节课我们总体了解过 RISC-V 的指令格式，这里我们一起来详细拆分一下 addi 指令的各位段的数据，看看它是如何编码的。</p><figure><img src="'+o+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>对照上图，我们可以看到一条指令数据为 32 位，其中操作码占 7 位，目标寄存器和或者源寄存器各占 5 位。通过 5 位二进制数，正好可以编码 32 个通用寄存器。上图中寄存器编码对应 10，正好是 x10，也即 a0 寄存器，立即数占 12 位。由于 RISC-V 指令总是按有符号数编码，所以立即数只能表示 -2048~2047 的范围。</p><h3 id="寄存器版本的加减法如何实现" tabindex="-1"><a class="header-anchor" href="#寄存器版本的加减法如何实现" aria-hidden="true">#</a> 寄存器版本的加减法如何实现</h3><p>立即数的加减法已经搞定了，下面我们来看看寄存器版本的加减法如何实现。</p><p>寄存器版本的加法指令的形式如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>add rd，rs1，rs2
#add 加法指令
#rd 目标寄存器
#rs1 源寄存器1
#rs2 源寄存器2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>类似立即数加法指令，寄存器版本的加法指令也是两个源寄存器相加，结果放在目标寄存器中，代码中 rd、rs1、rs2 可以是任何通用寄存器，计算操作也和前面 addi 指令一样。</p><p>还是通过写代码来做个验证，我们写一个 addsub.S 文件，并在其中用汇编写上 add_ins 函数 ，如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>add_ins:
    add a0，a0，a1          #a0 = a0+a1，a0、a1是C语言调用者传递的参数，a0是返回值，这样计算结果就返回了
    jr ra                   #函数返回
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>a0，a1 是 C 语言函数调用的第一、二个参数，如果你想不明白，可以回顾一下之前我们讲的函数调用规范。</p><p>这里我们用 VSCode 打开工程目录，按下“F5”键调试一下，输出的结果为 2，因为 1+1 的结果肯定等于 2。</p><figure><img src="`+v+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>上图展示的是执行完 add a0，a0，a1 指令之后，执行 jr ra 指令之前的状态。这时 a0 寄存器中的值确实已经变成了 2，这说明运算的结果正确。</p><p>当 add_ins 函数返回后，输出的结果如下图所示：</p><figure><img src="'+b+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>这个结果证明了 add 指令执行的结果符合我们的预期。</p><p>好，我们加点速，一鼓作气把减法指令也拿下。在 addsub.S 文件中再写一个函数，也就是 sub_ins 函数，代码如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>sub_ins:
    sub a0，a0，a1          #a0 = a0-a1，a0、a1是C语言调用者传递的参数，a0是返回值，这样计算结果就返回了
    jr ra                   #函数返回
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码就是减法指令，和加法指令的模式一样，除了助记符是 sub，实现的操作是 a0 = a0 - a1。sub 指令后的目标寄存器、源寄存器可以是任何通用寄存器。</p><p>我们按下“F5”键调试一下，其结果应为 1，如下所示：</p><figure><img src="`+f+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>上图中依然是执行完 sub a0，a0，a1 指令之后，执行 jr ra 指令之前的状态。这时 a0 寄存器中的值确实已经变成 1 了，证明运算结果没问题。</p><p>当 sub_ins 函数返回后，就会输出下图所示的结果。</p><figure><img src="'+_+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>经过调试，sub 指令执行的结果也符合我们的预期了。</p><p>下面我们继续研究机器编码，来看看 add_ins 函数和 sub_ins 函数的二进制数据。打开工程目录下的 addsub.bin 文件，如下所示：</p><figure><img src="'+x+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>以上 4 个 32 位数据是四条指令，其中两个 0x00008067 数据是两个函数的返回指令即：jr ra，0x00b50533 为 add a0，a0，a1，0x40b50533 为 sub a0，a0，a1。</p><p>我们还是来拆分一下 add、sub 指令的各位段的数据，看看它们是如何编码的。如下所示：</p><figure><img src="'+h+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>从图里可以看到，操作码占了 7 位，目标寄存器和两个源寄存器它们各占 5 位。目标寄存器和源寄存器编码对应 10，正好是 x10，即 a0 寄存器。而源寄存器 2 编码对应 11，正好是 x11 也即是 a1。其它位段为功能编码，add、sub 指令就是用高段的功能码区分的。</p><h2 id="比较指令" tabindex="-1"><a class="header-anchor" href="#比较指令" aria-hidden="true">#</a> 比较指令</h2><p>加减指令我们就讲到这里，不过光能计算加减还不够，接下来我们看看比较指令。现在大多数处理器都会包含数据比较指令，用于判断数值大小，以便做进一步的处理。</p><h3 id="有无符号立即数版本-slti、sltiu-指令" tabindex="-1"><a class="header-anchor" href="#有无符号立即数版本-slti、sltiu-指令" aria-hidden="true">#</a> 有无符号立即数版本：slti、sltiu 指令</h3><p>RISC-V 指令集中有四条比较指令，这四条又分为有无符号立即数版本和有无符号寄存器版本，分别是 slti、sltiu、slt、sltu。</p><p>slti、sltiu 指令的形式如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>slti rd，rs1，imm
#slti 有符号立即数比较指令
#rd 目标寄存器
#rs1 源寄存器1（有符号数据）
#imm 有符号立即数(-2048~2047)
sltiu rd，rs1，imm
#sltiu 无符号立即数比较指令
#rd 目标寄存器
#rs1 源寄存器1（无符号数据）
#imm 有符号立即数(-2048~2047)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中 rd、rs1 可以是任何通用寄存器。有、无符号是指 rs1 寄存器中的数据，有符号立即数 imm 的数值范围是 -2048~2047。</p><p>slti、sltiu 完成的操作用伪代码描述如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>if(rs1 &lt; imm)
    rd = 1;
else
    rd = 0;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下一步又到了写代码验证的环节。我们建立一个 slti.S 文件，在其中用汇编写上 slti_ins、sltiu_ins 函数，然后写下这两个函数：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>.global slti_ins
slti_ins:
    slti a0, a0, -2048      #if(a0&lt;-2048) a0=1 else a0=0，a0是参数，又是返回值，这样计算结果就返回了
    jr ra                   #函数返回

.global sltiu_ins
sltiu_ins:
    sltiu a0，a0，2047      #if(a0&lt;2047) a0=1 else a0=0，a0是参数，又是返回值，这样计算结果就返回了
    jr ra                   #函数返回
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>slti_ins 与 sltiu_ins 函数我已经帮你写好了，分别执行了 slti 和 sltiu 指令，都是拿 a0 寄存器和一个立即数比较，如果 a0 小于立即数就把 1 写入 a0 寄存器。</p><p>下面我们在 C 语言的 main 函数中调用它，然后打印一下结果，用 VSCode 打开工程，按“F5”调试后的效果如图：</p><figure><img src="`+j+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>上图中是执行完 slti a0，a0，-2048 指令之后，执行 jr ra 指令之前的状态。如果看到 a0 寄存器中的值确实已经变成 1 了，就说明运算的结果是正确的。</p><p>当 slti_ins 函数返回后，输出的结果如下所示：</p><figure><img src="'+y+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>因为 -2049 比 -2048 确实要小，所以返回 1，这证明结果是正确的。</p><p>sltiu_ins 函数的调试方法也差不多。你不妨对照后面的图看一下。</p><figure><img src="'+C+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>上图中依然是执行完 sltiu a0，a0，2047 指令之后，执行 jr ra 指令之前的状态，我们已经看到 a0 寄存器中的值变成 0 了，这说明 a0 的数据不小于 2047。</p><p>当 sltiu_ins 函数返回后，输出的结果如下：</p><figure><img src="'+z+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>图里输出的结果 0，这和执行完 sltiu 指令后 a0 的值是一致的。看到这可能你就有疑问了，传递的参数是 -2048，它应该远小于 2047，为什么输出结果不是 1 呢？</p><p>别忘了 sltiu 指令的属性，它是无符号的比较指令，也就是说 sltiu 指令看到的数据是无符号的，</p><p>而 -2048 数据编码为 0xfffff800，如果把这个数据当成无符号数，则远大于 2047，所以返回 0。</p><h3 id="有无符号寄存器版本-slt、sltu-指令" tabindex="-1"><a class="header-anchor" href="#有无符号寄存器版本-slt、sltu-指令" aria-hidden="true">#</a> 有无符号寄存器版本：slt、sltu 指令</h3><p>接着我们再来看看 slt、sltu 指令，这是寄存器与寄存器的有无符号比较指令，它们的形式如下所示。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>slt rd，rs1，rs2
#slt 有符号比较指令
#rd 目标寄存器
#rs1 源寄存器1（有符号数据）
#rs2 源寄存器2（有符号数据）
sltu rd，rs1，rs2
#sltu 无符号比较指令
#rd 目标寄存器
#rs1 源寄存器1（无符号数据）
#rs2 源寄存器2（无符号数据）
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中 rd、rs1、rs2 可以是任何通用寄存器。有、无符号同样代表 rs1、rs2 寄存器中的数据。</p><p>我们先看看 slt、sltu 这两个指令完成的操作，用伪代码怎么描述：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>if(rs1 &lt; rs2)
    rd = 1;
else
    rd = 0;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们依然在 slti.S 文件中用汇编写上 slt_ins、sltu_ins 函数 ，如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>.globl slt_ins
slt_ins:
    slt a0, a0, a1          #if(a0&lt;a1) a0=1 else a0=0，a0，a1是参数，a0是返回值，这样计算结果就返回了
    jr ra                   #函数返回

.globl sltu_ins
sltu_ins:
    sltu a0, a0, a1         #if(a0&lt;a1) a0=1 else a0=0，a0，a1是参数，a0是返回值，这样计算结果就返回了
    jr ra                   #函数返回    
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里已经写好了 slt_ins 与 sltu_ins 函数，分别是执行 slt 和 sltu 指令，都是拿 a0 寄存器和 a1 寄存器比较，如果 a0 小于 a1 寄存器，就把 1 写入到 a0 寄存器，否则写入 0 到 a0 寄存器。</p><p>接下来的调试环节你应该很熟悉了。VSCode 当中按 F5 调试的效果如下：</p><figure><img src="`+S+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>上图中是执行完 slt a0，a0，a1 指令之后，执行 jr ra 指令之前的状态。对照截图可以看到，执行指令之后，a0 寄存器中的值确实已经变成 1 了，这说明比较运算的结果是正确的。</p><p>当 slt_ins 函数返回后，输出的结果如下：</p><figure><img src="'+V+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>因为 1 确实小于 2，所以结果返回 1，通过调试表明运算结果是正确的。</p><p>sltu_ins 函数的调试我们也如法炮制。</p><figure><img src="'+I+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>上图是执行完 sltu a0，a0，a1 指令之后，执行 jr ra 指令之前的状态。如果我们看到 a0 寄存器中的值变成 0，就说明 a0 的数据不小于 a1。</p><p>当 sltu_ins 函数返回后，输出的结果如下：</p><figure><img src="'+q+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>是不是有点困惑？结果是 0，可是传递的参数是 -2 和 1，-2 应该小于 1 啊？出现这个结果，是因为 sltu 指令所看到 a0 中的数据（-2），是<strong>无符号</strong>的。而 -2 的数据编码为 0xfffffffe，由于它是无符号数，所以远大于 1，返回 0 才是正确的。</p><p>调试工作告一段落，接下来我们再研究一下 slti_ins、sltiu_ins、slt_ins、sltu_ins 函数的二进制数据。打开工程目录下 slti.bin 文件，如下所示：</p><figure><img src="'+R+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>以上 8 个 32 位数据是八条指令，其中四个 0x00008067 数据是四个函数的返回指令即：jr ra，0x80052513 为 slti a0，a0，-2048，0x7ff53513 为 sltiu a0，a0，2047，0x00b52533 为 slt a0，a0，a1，0x00b53533 为 sltu a0，a0，a1。</p><p>同样地，我们也来拆分一下 slti、sltiu、slt、sltu 指令的各位段的数据，看看它们是如何编码的。</p><figure><img src="'+k+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>从上图可以发现，立即数版本和寄存器版本的指令格式不一样，操作码也不一样，而它们之间的有无符号是靠<strong>功能位段</strong>来区分的，而立即数位段和源寄存器与目标寄存器位段，和之前的指令是相同的。</p><p>到这里，四条比较指令我们就全部讲完了。建议你自己课后跟着课程练练手，加深印象。</p><h2 id="重点回顾" tabindex="-1"><a class="header-anchor" href="#重点回顾" aria-hidden="true">#</a> 重点回顾</h2><p>这节课我们一起学习了加减指令和比较指令，让我们一起来回顾一下。</p><p>加减指令是 CPU 里最基本的指令。addi、add、sub 这三条指令能对数据和寄存器进行加减运算，可以先把数据装入寄存器中，然后对寄存器与寄存器执行加减操作，也可以寄存器和立即数进行加减操作。</p><p>接着我们还学习了比较指令，比较指令能对数据进行比较操作，一共包括四条指令。按照有无符号立即数版本和有无符号寄存器版本划分，分别是 slti、sltiu、slt、sltu。这个有无符号是对应操作数中的寄存器的数据，立即数永远是有符号数据。</p><p>加减指令主要用于加减法运算，比较指令用于对数据比较，判断数值大小，再结合后面要学的跳转指令就可以实现 if-else 语句了。</p><figure><img src="'+F+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>下节课我们继续学习逻辑指令和移位指令，敬请期待。</p><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题" aria-hidden="true">#</a> 思考题</h2><p>请写出机器码 0x00000033 对应的指令。</p><p>欢迎把你的思考和想法分享在留言区。如果这节课对你有帮助，别忘了分享给身边的朋友，邀他一起学习。</p><blockquote><p>想问一下，浮点及不同数据类型转换，也是有对应的指令吧<br> 作者回复: 嗯嗯</p><hr><p>0x00000033解析为0000 0000 0011 0011<br> 由操作码011 0011和功能码都是0推出指令add(寄存器加法)<br> 再由第5课查表得知0表示寄存是zero，所以指令是add zero,zero,zero<br> 这个就是所谓的占位指令啦<br> 作者回复: 是的 你很厉害</p><hr><p>请教老师几个问题：<br> Q1：立即数最小只能是-2048，如果要减去更大的数，怎么办？<br> 同理，如果要加上比2048大的数，怎么办？<br> Q2：功能位有什么用？addi指令的功能位是3位，都是0，好像没有区别。<br> Q3：jr ra，这里的 ra 表示什么？<br> 作者回复: Q1用寄存器</p><hr><p>汇编语言中.globl是什么意思？为什么addi_ins没有加它？<br> 作者回复: 导出符号</p></blockquote>',139);function L(G,M){const e=n("ExternalLinkIcon");return d(),l("div",null,[U,N,Q,T,i("p",null,[i("a",B,[a("课程配套代码从这里下载"),t(e)]),a("。")]),E])}const A=s(P,[["render",L],["__file","I16-算术指令（上）RISC-V.html.vue"]]);export{A as default};
