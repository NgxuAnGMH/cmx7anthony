import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r as p,o as n,c as t,a,b as e,e as o,d as s}from"./app-cdabc73c.js";const l="/assets/640-1689740123323-98-fd2b117a.png",d="/assets/640-1689740123323-99-eb05a37c.png",c="/assets/640-1689740123323-100-eb71cb9d.png",h="/assets/640-1689740123323-101-e2661efe.png",g="/assets/640-1689740123323-102-6c30a466.png",A={},m=a("h1",{id:"_79-白泽带你读论文-alastor",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#_79-白泽带你读论文-alastor","aria-hidden":"true"},"#"),e(" 79-白泽带你读论文｜ALASTOR")],-1),u={href:"https://www.usenix.org/conference/usenixsecurity22/presentation/datta",target:"_blank",rel:"noopener noreferrer"},R=s('<p><strong>如需转载请注明出处，侵权必究。</strong></p><p><strong>论文题目：ALASTOR: Reconstructing the Provenance of Serverless Intrusions</strong></p><p><strong>发表会议：Security 22</strong></p><h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><p>无服务器计算减轻了开发人员管理平台和基础架构的负担，使得他们能够快速地设计原型和部署应用程序。然而，无服务器计算也带来了一些令人担忧的安全问题，其中之一是带来入侵调查方面的困难。在无服务器计算中，攻击者能够将传统应用程序分解为<mark>临时可重入函数</mark>，使恶意活动隐藏在合法的工作流程中，甚至能通过滥用容器重用策略来破坏因果路径，阻止根本原因分析。不幸的是，传统的系统审计方法和商业无服务器安全产品都无法提供所需的透明度，以准确跟踪这些新型威胁。</p><p>本文提出了ALASTOR，<em>一个基于溯源的审计框架</em>，可以精确跟踪无服务器应用程序中的可疑事件。ALASTOR记录系统和应用程序层的函数活动，以捕获每个函数实例行为的整体情况。然后，在无服务器平台内部的中央存储库中汇集不同函数的来源，将它们拼接在一起，形成复杂函数工作流的全局数据溯源图。ALASTOR既可以适用于不同类型的函数和语言，也可以很容易地集成到现有的无服务器平台中。本文还对ALASTOR进行了性能评估，证明了其性能开销相对较小（13.74％）的同时，相比于商业可用的监控工具取证能力显著提高。</p><h3 id="临时可重入函数" tabindex="-1"><a class="header-anchor" href="#临时可重入函数" aria-hidden="true">#</a> ###临时可重入函数？</h3><blockquote><p>临时可重入函数（Temporary Reentrant Function）是一种在多线程编程中使用的函数实现模式。可重入函数是指能够在同一时间被多个线程同时调用而不会发生冲突的函数。而临时可重入函数是一种针对某些特定情况的函数实现方式，它在特定的上下文中可以被视为是可重入的，但在其他上下文中可能不是。</p><p>通常情况下，<mark>可重入函数</mark>应当是线程安全的，即在多线程环境下能够正确处理共享的数据和资源，而不会导致数据竞争或不一致的状态。这需要在函数内部使用互斥锁、信号量或其他同步机制来确保数据的访问是安全的。</p><p>然而，在某些情况下，由于性能或其他因素的限制，完全遵循可重入的要求可能会变得困难或不切实际。<mark>临时可重入函数</mark>的概念应运而生。它指的是在特定上下文中，函数被设计成可以在多线程环境下安全调用的函数。</p><p>临时可重入函数通常会利用上下文限制了函数的使用场景，例如，只能在特定的线程或不重叠的时间段内调用。<em>在这种限制下</em>，临时可重入函数<em>可以放宽对线程安全性的要求，而不需要使用昂贵的同步机制</em>。</p><p>需要注意的是，临时可重入函数的使用必须非常谨慎，并且需要确保在实际应用中满足特定的上下文约束。否则，使用临时可重入函数可能会导致数据竞争和不确定的行为。因此，在多线程编程中，仍然建议尽量使用真正的可重入函数来保证程序的安全性和正确性。</p></blockquote><h2 id="背景" tabindex="-1"><a class="header-anchor" href="#背景" aria-hidden="true">#</a> 背景</h2><p>无服务器计算是一种<em>解放软件堆栈管理负担</em>的计算模式。它允许开发者将业务逻辑实现为<em>一组小型可重入函数</em>，这些函数连接成可以执行高级任务的工作流，以此来实现应用的快速原型化。为了保护平台，<strong>函数在隔离的容器中执行</strong>，以向每个无状态和短暂的函数提供调用的安全环境。因为这些函数的生命周期通常只有毫秒级别，传统的web漏洞更难被利用。然而，攻击者已经发现了进行攻击的新方法。攻击的两个主要策略是利用容器复用和通过函数工作流泄露数据：</p><ol><li><u>利用容器复用</u>：尽管函数的生命周期很短，但是容器被缓存起来，并在预先配置的超时窗口时间内被重新用于相同功能的调用。攻击者可以通过将恶意软件或工具写入内存分区（如/tmp）来实现持久性，然后迫使被破坏的功能实例留在缓存中。</li><li><u>通过函数工作流泄露数据</u>：简单地限制函数的网络访问并不奏效。攻击者可以通过下游授权功能和合法的平台API来清洗被盗数据，最终将数据转移到开放的互联网。</li></ol><p>除了上述两个主要攻击方式外，大量的第三方功能也创造了一个额外的攻击面，使应用暴露于潜在的恶意功能代码之下。</p><p>然而，现有方法都有一定的局限性。</p><ul><li>一方面，现有的系统级溯源技术局限于发生在单个计算机内部的事件，而无服务平台的攻击溯源要求具备分布式跟踪和审计机制。</li><li>另一方面，云提供商提供了执行跟踪、错误报告、警报和资源使用细分，但它们往往集中于单个函数； <ul><li>有一些第三方工具提供了额外的功能，但仅限于某些语言环境和平台，</li><li>并且无论是云提供商还是第三方都没有考虑更复杂的多函数攻击路径，也未考虑容器复用问题。</li></ul></li></ul><h2 id="威胁模型和假设" tabindex="-1"><a class="header-anchor" href="#威胁模型和假设" aria-hidden="true">#</a> 威胁模型和假设</h2><p>本文考虑了针对运行在==第三方公共计算云平台（如Amazon Lambda）==中的<em>无服务器应用程序</em>的攻击；</p><ol><li>考虑一个无服务器的云应用程序，远程攻击者的主要目标是数据外泄。</li><li>为此，攻击者可以利用各种传统技术和程序，比如二进制漏洞利用、命令注入、下载和执行渗透测试工具等；</li><li>攻击者还能够采用上章所述的无服务器特有攻击技术，在这个环境中实现持久化和渗出数据。</li><li>攻击者可以使用被攻击的函数来执行任何允许的系统流程来渗出数据，包括传输到外部网络，写到云中某处的持久性存储，甚至写到函数容器内的短暂性存储以便以后检索。</li><li>虽然攻击者实际上在被攻击的<mark>功能实例</mark>中拥有自由支配权，但我们假设攻击者没有对受害客户账户的管理权限。因此，他们无法启动自己的功能，修改容器镜像，或篡改访问控制策略。</li></ol><p>本文还做了如下的假设：</p><ul><li>第三方云平台是可信的，并且提供商将正确部署函数，不会与攻击者合作。</li><li>提供商提供的是基于容器的无服务环境，而不是基于语言的环境，因为容器可以支持多种语言和运行时环境。</li><li>客户的访问控制策略可能存在错误或不足。</li><li>云平台中存在用于处理来自公共互联网的外部请求的API网关。</li><li>所有的无服务函数都通过使用REST API调用或远程程序调用。</li><li>事件跟踪机制和事件日志在使用时是正确的，并且云平台提供了安全存储日志的机制。</li><li>不考虑云端通道。</li></ul><h2 id="挑战" tabindex="-1"><a class="header-anchor" href="#挑战" aria-hidden="true">#</a> 挑战</h2><p><strong>短暂的活动难以审计</strong></p><p>无服务函数的生命周期很短暂，而现有的取证技术并不支持审计已不存在或不对当前系统状态产生影响的系统实体：以LogGC为例，它将此类事件视为视为 &quot;垃圾&quot;，并建议将其从日志中删除。各种审计框架也同样对重复事件或因果路径进行了删减。这种做法很可能会破坏重要的攻击活动证据。</p><p><strong>漏洞的大量复制</strong></p><p>一个函数中如果存在的漏洞，它进而会影响到许多函数和容器的安全性，而这些函数和容器可能被复制到不同的物理机器上的许多实例中。因此追溯漏洞根源并评估它对整个应用程序的潜在影响存在困难。</p><p><strong>庞大的审计成本</strong></p><p>由于函数基础设施处于不断的重建和拆除状态，与典型Web请求相比，与函数调用相关的事件远远超出预期。因此，与无服务审计相关的开销可能会比传统服务器基础设施更大。</p><p>本文利用无服务器平台的一个关键设计——<mark>执行分区</mark>来应对上述挑战。在执行分区中，长期存在的流程被细分为独立的工作单元，这允许调查者在不跟踪不相关的输入的条件下，<em>从流程的输出追踪到相关的流程输入</em>。</p><h2 id="工作流程" tabindex="-1"><a class="header-anchor" href="#工作流程" aria-hidden="true">#</a> 工作流程</h2><p>本文提出了一个名为ALASTOR的无服务数据溯源框架来解决之前所提到的挑战。ALASTOR在每个容器中部署<mark>一个透明的网络代理</mark>以收集每个函数实例中的信息，并将其协调为<mark>一个综合图</mark>来表示无服务应用程序中各组件的互连和因果关系。该框架包括两个主要组件：溯源收集器和全局溯源构建服务。</p><ol><li><mark>溯源收集器</mark>在每个函数实例中收集跟踪信息，并将其解析为本地溯源图。</li><li><mark>全局数据溯源构建服务</mark>从所有函数实例中提取本地溯源图，并将其与平台服务日志中的一些元数据整合为全局图，以定义无服务应用程序的行为。</li></ol><figure><img src="'+l+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h3 id="组件一-溯源收集器" tabindex="-1"><a class="header-anchor" href="#组件一-溯源收集器" aria-hidden="true">#</a> 组件一：溯源收集器</h3><p>溯源收集器有四个任务：</p><ol><li>系统调用跟踪，通过<code>strace</code>记录进程、文件和网络相关的系统调用；</li><li>网络分析，通过在容器中部署<code>透明的网络代理</code>来监视所有进出容器的网络请求；</li><li>进程到网络请求的关联，通过<code>ss</code>映射进程到使用的TCP套接字端口号，使用<code>mitmproxy</code>计算网络请求的源端口号；</li><li>本地溯源图创建，将收集到的溯源信息转换为溯源图，包含<mark>系统主体（进程）<mark>和</mark>对象（文件、网络连接）<mark>以及</mark>它们之间的因果关系</mark>。每个因果事件可以是<mark>系统调用</mark>、<mark>REST API调用</mark>或<mark>网络请求</mark>，并带有<mark>时间戳</mark>和<mark>事件类型</mark>等信息。</li></ol><h3 id="组件二-全局溯源构建服务" tabindex="-1"><a class="header-anchor" href="#组件二-全局溯源构建服务" aria-hidden="true">#</a> 组件二：全局溯源构建服务</h3><p>全局溯源构建服务是与无服务器平台中的其他系统服务一起工作的，它实现了无服务器溯源技术的一个独特特点：无生命溯源。无生命溯源处理不再存在于环境中的对象（即无生命容器），并计算无生命对象过去引起的事件如何影响活动对象。</p><p>全局溯源构建服务分两个阶段进行操作：信息收集和全局溯源图创建。它查询平台服务以了解部署的功能、正在运行的容器和它们的描述，然后通过定期检索本地溯源图和记录的平台日志来创建全局溯源图。</p><h2 id="性能评估" tabindex="-1"><a class="header-anchor" href="#性能评估" aria-hidden="true">#</a> 性能评估</h2><p>作者评估了ALASTOR的性能开销，包括构建性能，运行时性能，CPU和内存利用率以及磁盘和网络利用率，并与标准的<mark>OpenFaaS</mark>进行比较。</p><figure><img src="'+d+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>Figure 3 (a)和(b)展示了ALASTOR构建镜像的大小和时间与标准OpenFaaS的比较。与Vanilla OpenFaaS相比，图像大小略有增加，这是由于额外的ALASTOR代码被编译到OpenFaaS的watchdog二进制文件中，以及追踪机制和代理证书的安装。构建时间的开销可归因于在图像构建期间安装系统调用跟踪和代理库。这些都是第一次构建镜像时产生的一次性成本。</p><figure><img src="'+c+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>Figure 4 (a)和(b)显示了每个函数的50次迭代的平均开销。从所有函数的平均值来看，ALASTOR的部署和拆除开销分别为3.2%和3.6%。</p><figure><img src="'+h+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>Figure 5显示了不同函数的响应延迟。作者指出，这些结果可能表明ALASTOR更适合于不执行大量文件I/O的事件驱动型应用程序。</p><figure><img src="'+g+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>Figure 8描述了执行product-purchase 工作流时生成的日志大小的比较。ALASTOR与其他系统审计框架有相似之处：虽然它以原始形式产生了大量的数据，但这些成本可以通过日志过滤和数据压缩技术的组合得到有效缓解。</p><p>Table 1展示了三个Hello,Retail!场景中的请求图的复杂度。作者将此归因于无服务器计算的短暂和事件驱动的性质；因为执行是短暂的和定义明确的，典型的图复杂性和依赖性爆炸问题不会出现在ALASTOR中。</p><p>结果表明，与标准的OpenFaaS相比，ALASTOR的性能开销在大多数情况下是可以接受的，尤其是在事件驱动的应用程序中。此外，该系统对于服务器的CPU和内存资源有一定的开销，但可以通过合理的扩展容器规模来解决。</p><h2 id="安全应用评估" tabindex="-1"><a class="header-anchor" href="#安全应用评估" aria-hidden="true">#</a> 安全应用评估</h2><p>本文对比了商用的无服务器工具<mark>Epsagon</mark>和ALASTOR的安全性优势，以“Hello,Retail!”应用为例进行了数据外泄和业务逻辑操纵攻击的探讨，并通过ALASTOR的溯源图分析，回答了以下3个问题：</p><p><strong>RQ1：输出结果是否表明应用程序偏离了其正常行为？</strong></p><p>Epsagon满足了RQ1，但这是一个弱的威胁指标，并不清楚具体异常原因。</p><p><strong>RQ2：能否够解释攻击者在应用程序中的行为？</strong></p><p>Epsagon记录了各种功能的元数据，但它没有记录与其他应用程序组件的连接，包括信用卡数据库，也没有记录与攻击者控制的远程服务器的连接。因此，Epsagon无法重构完整的攻击路径。</p><p><strong>RQ3：能否诊断特定于无服务器的攻击技术？</strong></p><p>Epsagon确实跟踪了一个相关的属性，cold_start，这表明存在容器重复使用。然而，容器重复使用本身并不是妥协的指标——它在任何应用程序中都是常见的情况。</p><p>而这些问题都能从ALASTOR生成的全局溯源图中得到判断。同时，本文还通过ALASTOR的日志数据进行了基于深度学习DeepLog的入侵检测实现，获得了很好的结果。</p><h2 id="讨论和分析" tabindex="-1"><a class="header-anchor" href="#讨论和分析" aria-hidden="true">#</a> 讨论和分析</h2><p>本文最后讨论了ALASTOR的可能限制和未来可能的工作方向：</p><p><strong>全局图的时间同步</strong></p><p>虽然在不同的函数实例中记录的两个系统调用之间可能会有微小的时间偏差，但ALASTOR保留API请求之间发生顺序的方式足够确保函数溯源图之间的因果关系是正确的。</p><p><strong>I/O密集型应用的适用性</strong></p><p>如果一个应用程序长期运行I/O密集型函数，可能需要修改ALASTOR以减少I/O日志记录的粒度。</p><p><strong>对其他无服务器平台的适用性</strong></p><p>ALASTOR可以扩展到如Cloudflare、Fastly和Faasm这样请求隔离的系统。在Faasm中，ALASTOR可以被用来检查敏感数据的泄露。此外，ALASTOR的日志可以被其他监控工具获取，用于威胁检测和其他分析。</p><p><strong>威胁模型</strong></p><p>ALASTOR的设计基于攻击者对受害者帐户的管理访问受到限制的假设。然而，完全破坏容器的攻击者可能会阻止未来的日志到达全局溯源构建服务，或者可以删除日志。因此可能需要扩展ALASTOR以增加日志传输的频率以限制攻击者可以访问的未受保护的日志数量。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>本文提出了一个名为ALASTOR的无服务应用溯源框架，通过监控不同层次上的信息来收集无服务应用的完整溯源信息，从而应对无服务环境中的攻击检测挑战。ALASTOR能够跟踪环境中的无生命实体，同时还能与现有的Serverless平台轻松集成，仅带来小部分的额外开销。本文还将ALASTOR与商业Serverless跟踪工具Epsagon进行比较，证明了ALASTOR重建攻击路径的能力的优越性。</p><h2 id="q-a" tabindex="-1"><a class="header-anchor" href="#q-a" aria-hidden="true">#</a> Q&amp;A</h2><p>Q1: 目前已有哪些 Serverless Computing 的安全防护方案？有哪些局限性？</p><p>目前的安全防护方案包括云提供商提供的运行时跟踪、错误报告、警报和资源使用情况的跟踪，第三方的可观测性工具，还有专门针对 serverless 的安全工具。但是，这些工具通常只提供对单个函数的视图，并且不考虑复杂的多功能攻击路径。</p><p>Q2: Epsagon在三个RQ上的评估结果是什么？</p><p>对于RQ1，Epsagon能做到，但应用程序偏离正常的行为是一个弱的威胁指标，因为异常的原因并不清楚。如果没有额外的支持性证据，该现象可能是一个性能错误，而不是一个复杂的入侵企图。</p><p>关于RQ2，尽管Epsagon记录了各种功能的元数据，但它没有记录与其他应用程序组件的连接，包括信用卡数据库，也没有记录与攻击者控制的远程服务器的连接。因此，Epsagon无法重构完整的攻击路径。</p><p>针对RQ3，Epsagon确实跟踪了一个相关的属性cold_start，代表容器重复使用。然而，容器重复使用本身并不意味着有攻击发生；事实上，它在任何应用程序中很常见。Epsagon无法检测到同一函数实例的重复使用之间的数据共享。</p><p>Q3: 在无服务器环境中实施溯源审计的挑战有哪些？ALASTOR是如何解决的？</p><p>主要挑战：</p><p>a.短暂的活动难以审计。由于无服务器函数生命周期是短暂的，因此无法通过传统的取证方式来支持审计系统实体，这就需要开发新的审计框架来支持无服务器环境。</p><p>b.易复制的易受攻击程序。由于许多函数和容器会在不同的物理机器上复制，一旦一个函数存在漏洞，那么就会涉及到许多其他函数和容器的安全问题。因此，需要开发方法来跟踪漏洞并评估其对整个应用程序的潜在影响。</p><p>c.繁琐的审计成本。在无服务器环境中，由于容器处于不断的启动和关闭状态，与传统服务器基础架构相比，与函数调用相关的事件要更多。因此，需要开发新的审计框架来适应这种高开销的情况，以确保无服务器环境下的安全审计成本可控。</p><p>解决方案：ALASTOR使用执行分区技术解决无法审计短暂的活动的挑战，该技术将长时间运行的进程分成独立的工作单元，这允许调查者在不跟踪不相关的输入的条件下，从流程的输出追踪到相关的流程输入。此外，由于无服务器环境的事件驱动特性，高扇出过程（高扇出过程是指在系统或软件架构中，一个模块或组件同时与许多其他模块或组件交互的过程。）很少发生，因此不需要额外的执行分区。ALASTOR首先使用溯源收集器来收集每个函数实例的信息；然后，通过将从不同函数中收集的信息汇总到平台的中央存储库中，并将发现的因果依赖关系转化到全局数据溯源图中来实现无服务器攻击审计。</p>',83);function S(f,O){const r=p("ExternalLinkIcon");return n(),t("div",null,[m,a("p",null,[a("a",u,[e("ALASTOR: Reconstructing the Provenance of Serverless Intrusions | USENIX"),o(r)]),e("。")]),R])}const T=i(A,[["render",S],["__file","79-白泽带你读论文｜ALASTOR.html.vue"]]);export{T as default};
