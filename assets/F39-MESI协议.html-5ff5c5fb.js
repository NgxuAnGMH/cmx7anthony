import{_ as c}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o as i,c as s,a as e,b as a,e as n,d as o}from"./app-cdabc73c.js";const d="/assets/0723f72f3016fede96b545e2898c0541-8c42f84c.jpeg",h="/assets/a6146ddd5c78f2cbc1af56b0ee3292da-988240aa.jpeg",p="/assets/fe0c449e71800c5ad2e4b84af0d6e46c-af626474.jpeg",l="/assets/4ed6d05049cbbc8603346f617206cd59-ad6419a3.jpeg",C="/assets/fa98835c78c879ab69fd1f29193e54d1-c625eba3.jpeg",m={},P=o('<h1 id="_39-mesi协议-如何让多核cpu的高速缓存保持一致" tabindex="-1"><a class="header-anchor" href="#_39-mesi协议-如何让多核cpu的高速缓存保持一致" aria-hidden="true">#</a> 39 | MESI协议：如何让多核CPU的高速缓存保持一致？</h1><p>你平时用的电脑，应该都是多核的 CPU。多核 CPU 有很多好处，其中最重要的一个就是，它使得我们在不能提升 CPU 的主频之后，找到了另一种提升 CPU 吞吐率的办法。</p><p>不知道上一讲的内容你还记得多少？上一节，我们讲到，多核 CPU 里的每一个 CPU 核，都有独立的属于自己的 L1 Cache 和 L2 Cache。多个 CPU 之间，只是共用 L3 Cache 和主内存。</p><p>我们说，<code>CPU Cache</code> 解决的是内存访问速度和 CPU 的速度差距太大的问题。<em>而多核 CPU 提供的是，在主频难以提升的时候，通过增加 CPU 核心来提升 CPU 的吞吐率的办法</em>。我们把多核和 CPU Cache 两者一结合，<strong>就给我们带来了一个新的挑战</strong>。因为 CPU 的每个核各有各的缓存，互相之间的操作又是各自独立的，就会带来**<code>缓存一致性</code>**（Cache Coherence）的问题。</p><img src="'+d+'" alt="img" style="zoom:25%;"><h2 id="缓存一致性问题" tabindex="-1"><a class="header-anchor" href="#缓存一致性问题" aria-hidden="true">#</a> 缓存一致性问题</h2><p>那什么是缓存一致性呢？我们拿一个有两个核心的 CPU，来看一下。你可以看这里这张图，我们结合图来说。</p><img src="'+h+'" alt="img" style="zoom:33%;"><p>在这两个 CPU 核心里，1 号核心要写一个数据到内存里。这个怎么理解呢？我拿一个例子来给你解释。</p><p>比方说，iPhone 降价了，我们要把 iPhone 最新的价格更新到内存里。为了性能问题，它采用了上一讲我们说的写回策略，先把数据写入到 L2 Cache 里面，然后把 Cache Block 标记成脏的。这个时候，数据其实并没有被同步到 L3 Cache 或者主内存里。1 号核心希望在这个 Cache Block 要被交换出去的时候，数据才写入到主内存里。</p><p>如果我们的 CPU 只有 1 号核心这一个 CPU 核，那这其实是没有问题的。不过，我们旁边还有一个 2 号核心呢！这个时候，2 号核心尝试从内存里面去读取 iPhone 的价格，结果读到的是一个错误的价格。这是因为，iPhone 的价格刚刚被 1 号核心更新过。但是这个更新的信息，只出现在 1 号核心的 L2 Cache 里，而没有出现在 2 号核心的 L2 Cache 或者主内存里面。<strong>这个问题，<code>就是所谓的缓存一致性问题</code>，1 号核心和 2 号核心的缓存，在这个时候是不一致的。</strong></p><p>为了解决这个缓存不一致的问题，我们就需要有<em>一种机制，来同步两个不同核心里面的缓存数据</em>。那这样的机制需要满足什么条件呢？我觉得能够做到下面两点就是合理的。</p><ol><li><p>第一点叫<strong>写传播</strong>（Write Propagation）。写传播是说，在一个 CPU 核心里，我们的 Cache 数据更新，必须能够传播到<em>其他的对应节点的 Cache Line</em> 里。</p></li><li><p>第二点叫<strong>事务的串行化</strong>（Transaction Serialization），事务串行化是说，我们在一个 CPU 核心里面的读取和写入，<em>在其他的节点看起来，顺序是一样的</em>。</p></li></ol><p>第一点写传播很容易理解。既然我们数据写完了，自然要同步到其他 CPU 核的 Cache 里。但是第二点事务的串行化，可能没那么好理解，我这里仔细解释一下。</p><h2 id="理解事务串行化" tabindex="-1"><a class="header-anchor" href="#理解事务串行化" aria-hidden="true">#</a> 理解事务串行化</h2><p>我们还拿刚才修改 iPhone 的价格来解释。这一次，我们找一个有 4 个核心的 CPU。1 号核心呢，先把 iPhone 的价格改成了 5000 块。差不多在同一个时间，2 号核心把 iPhone 的价格改成了 6000 块。这里两个修改，都会传播到 3 号核心和 4 号核心。</p><img src="'+p+'" alt="img" style="zoom:25%;"><p>然而这里有个问题，3 号核心先收到了 2 号核心的写传播，再收到 1 号核心的写传播。所以 3 号核心看到的 iPhone 价格是先变成了 6000 块，再变成了 5000 块。而 4 号核心呢，是反过来的，先看到变成了 5000 块，再变成 6000 块。<em>虽然写传播是做到了，但是各个 Cache 里面的数据，是不一致的</em>。</p><p>事实上，<em>我们需要的是</em>，从 1 号到 4 号核心，<em>都能看到<code>相同顺序的</code>数据变化</em>。比如说，都是先变成了 5000 块，再变成了 6000 块。这样，我们才能称之为实现了<mark>事务的串行化</mark>。</p><p>事务的串行化，不仅仅是缓存一致性中所必须的。比如，我们平时所用到的系统当中，最需要保障事务串行化的就是<strong>数据库</strong>。多个不同的连接去访问数据库的时候，我们必须保障事务的串行化，做不到事务的串行化的数据库，根本没法作为可靠的商业数据库来使用。</p><p>而在 CPU Cache 里做到事务串行化，需要做到两点，</p><ol><li>第一点是一个 CPU 核心对于数据的操作，<strong>需要同步通信给到其他 CPU 核心</strong>。</li><li>第二点是，如果两个 CPU 核心里有同一个数据的 Cache，那么对于这个 Cache 数据的更新，<strong>需要有一个“锁”的概念</strong>。只有拿到了对应 Cache Block 的“锁”之后，才能进行对应的数据更新。</li></ol><p>接下来，我们就看看实现了这两个机制的 MESI 协议。</p><h2 id="总线嗅探机制和-mesi-协议" tabindex="-1"><a class="header-anchor" href="#总线嗅探机制和-mesi-协议" aria-hidden="true">#</a> 总线嗅探机制和 MESI 协议</h2><p>要解决缓存一致性问题，首先要解决的是多个 CPU 核心之间的数据传播问题。最常见的一种解决方案呢，叫作**<code>总线嗅探</code>**（Bus Snooping）。这个名字听起来，你多半会很陌生，但是其实特很好理解。</p><p>这个策略，本质上就是把所有的读写请求都通过总线（Bus）<em>广播</em>给所有的 CPU 核心，然后让各个核心去“嗅探”这些请求，再根据本地的情况进行响应。</p><p><em>总线本身就是一个特别适合广播进行数据传输的机制</em>，所以总线嗅探这个办法也是我们日常使用的 Intel CPU 进行缓存一致性处理的解决方案。关于总线这个知识点，我们会放在后面的 I/O 部分更深入地进行讲解，这里你只需要了解就可以了。</p><p>基于总线嗅探机制，其实还可以分成很多种不同的缓存一致性协议。不过其中最常用的，就是今天我们要讲的 MESI 协议。和很多现代的 CPU 技术一样，MESI 协议也是在 Pentium 时代，被引入到 Intel CPU 中的。</p><h3 id="_1-写失效-写广播" tabindex="-1"><a class="header-anchor" href="#_1-写失效-写广播" aria-hidden="true">#</a> 1 写失效 写广播</h3><p>MESI 协议，是一种叫作<strong>写失效</strong>（Write Invalidate）的协议。在写失效协议里，只有一个 CPU 核心负责写入数据，其他的核心，只是同步读取到这个写入。在这个 CPU 核心写入 Cache 之后，它会去广播一个“失效”请求告诉所有其他的 CPU 核心。其他的 CPU 核心，只是去判断自己是否也有一个“失效”版本的 Cache Block，然后把这个也标记成失效的就好了。</p><p>相对于写失效协议，还有一种叫作<strong>写广播</strong>（Write Broadcast）的协议。在那个协议里，一个写入请求广播到所有的 CPU 核心，同时更新各个核心里的 Cache。</p><p>写广播在实现上自然很简单，但是写广播需要占用更多的总线带宽。</p><ol><li>写失效只需要告诉其他的 CPU 核心，<code>哪一个内存地址</code>的缓存失效了，</li><li>但是写广播*还需要把<code>对应的数据</code>*传输给其他 CPU 核心。</li></ol><img src="'+l+'" alt="img" style="zoom:25%;"><p>MESI 协议的由来呢，来自于我们对 Cache Line 的四个不同的标记，分别是：</p><ol><li><p>M：代表<strong>已修改</strong>（Modified）</p></li><li><p>E：代表<strong>独占</strong>（Exclusive）</p></li><li><p>S：代表<strong>共享</strong>（Shared）</p></li><li><p>I：代表<strong>已失效</strong>（Invalidated）</p></li></ol><h3 id="_2-已修改-已失效" tabindex="-1"><a class="header-anchor" href="#_2-已修改-已失效" aria-hidden="true">#</a> 2 已修改 / 已失效</h3><p>我们先来看看“已修改”和“已失效”，这两个状态比较容易理解。</p><ol><li>所谓的“<code>已修改</code>”，就是我们上一讲所说的“脏”的 Cache Block。Cache Block 里面的内容我们已经更新过了，但是还没有写回到主内存里面。</li><li>而所谓的“<code>已失效</code>“，自然是这个 Cache Block 里面的数据已经失效了，我们不可以相信这个 Cache Block 里面的数据。</li></ol><h3 id="_3-独占-共享" tabindex="-1"><a class="header-anchor" href="#_3-独占-共享" aria-hidden="true">#</a> 3 独占 / 共享</h3><p>然后，我们再来看“独占”和“共享”这两个状态。这就是 MESI 协议的精华所在了。<em>无论是<code>独占状态</code>还是<code>共享状态</code>，缓存里面的数据都是“干净”的</em>。这个“干净”，自然对应的是前面所说的“脏”的，也就是说，这个时候，Cache Block 里面的数据和主内存里面的<strong>数据是一致的</strong>。</p><p>那么“独占”和“共享”这两个状态的差别在哪里呢？这个差别就在于，<code>在独占状态下</code>，对应的 Cache Line 只加载到了当前 CPU 核所拥有的 Cache 里。其他的 CPU 核，并没有加载对应的数据到自己的 Cache 里。这个时候，如果要向独占的 Cache Block 写入数据，我们可以自由地写入数据，而不需要告知其他 CPU 核。</p><p>在独占状态下的数据，如果收到了一个来自于总线的读取对应缓存的请求，<code>它就会变成共享状态</code>。这个共享状态是因为，这个时候，另外一个 CPU 核心，也把对应的 Cache Block，从内存里面加载到了自己的 Cache 里来。</p><h3 id="_4-读写锁" tabindex="-1"><a class="header-anchor" href="#_4-读写锁" aria-hidden="true">#</a> 4 读写锁</h3><p><em><code>而在共享状态下</code>，因为同样的数据在多个 CPU 核心的 Cache 里都有</em>。所以，当我们想要更新 Cache 里面的数据的时候，不能直接修改，而是要先向所有的其他 CPU 核心广播一个请求，要求先把其他 CPU 核心里面的 Cache，<code>都变成无效的状态</code>，然后再更新当前 Cache 里面的数据。这个广播操作，一般叫作 RFO（Request For Ownership），也就是获取当前对应 Cache Block 数据的所有权。</p><p>有没有觉得这个操作有点儿像我们在多线程里面用到的<mark>读写锁</mark>。在共享状态下，大家都可以并行去<mark>读</mark>对应的数据。但是如果要<mark>写</mark>，我们就需要通过一个锁，获取当前写入位置的所有权。</p><h2 id="有限状态机图" tabindex="-1"><a class="header-anchor" href="#有限状态机图" aria-hidden="true">#</a> 有限状态机图</h2><p>整个 MESI 的状态，可以用一个有限状态机来表示它的状态流转。需要注意的是，对于不同状态触发的事件操作，可能来自于当前 CPU 核心，也可能来自总线里其他 CPU 核心广播出来的信号。我把对应的状态机流转图放在了下面，你可以对照着Wikipedia 里面 MESI 的内容，仔细研读一下。</p><img src="'+C+'" alt="img" style="zoom:25%;"><p>图片来源</p><h2 id="总结延伸" tabindex="-1"><a class="header-anchor" href="#总结延伸" aria-hidden="true">#</a> 总结延伸</h2><p>好了，关于 CPU Cache 的内容，我们介绍到这里就结束了。我们来总结一下。这一节，我们其实就讲了两块儿内容，一个是<strong>缓存一致性</strong>，另一个是 <strong>MESI 协议</strong>。</p><p>想要实现缓存一致性，关键是要满足两点。第一个是<mark>写传播</mark>，也就是在一个 CPU 核心写入的内容，需要传播到其他 CPU 核心里。更重要的是第二点，<mark>保障事务的串行化</mark>，才能保障我们的数据是真正一致的，我们的程序在各个不同的核心上运行的结果也是一致的。这个特性不仅在 CPU 的缓存层面很重要，在数据库层面更加重要。</p><p>之后，我介绍了基于总线嗅探机制的 MESI 协议。MESI 协议是一种基于<strong>写失效</strong>的缓存一致性协议。写失效的协议的好处是，我们不需要在总线上传输数据内容，而只需要传输操作信号和地址信号就好了，不会那么占总线带宽。</p><p>MESI 协议，是<mark>已修改</mark>、<mark>独占</mark>、<mark>共享</mark>以及<mark>已失效</mark>这四个缩写的合称。独占和共享状态，就好像我们在多线程应用开发里面的读写锁机制，确保了我们的缓存一致性。而整个 MESI 的状态变更，则是根据来自自己 CPU 核心的请求，以及来自其他 CPU 核心通过总线传输过来的操作信号和地址信息，进行状态流转的一个有限状态机。</p><h2 id="推荐阅读" tabindex="-1"><a class="header-anchor" href="#推荐阅读" aria-hidden="true">#</a> 推荐阅读</h2><p>大部分计算机组成或者体系结构的教科书都没有提到缓存一致性问题。不过，最近有一本国人写的计算机底层原理的书，《<code>大话计算机</code>》，里面的 6.9 章节比较详细地讲解了多核 CPU 的访问存储数据的一致性问题，很值得仔细读一读。</p><h2 id="课后思考" tabindex="-1"><a class="header-anchor" href="#课后思考" aria-hidden="true">#</a> 课后思考</h2><p>今天我们所讲的 MESI 缓存一致性协议，其实是对于 MSI 缓存一致性协议的一个优化。你可以通过搜索引擎研究一下，什么是 MSI 协议，以及 MESI 相对于 MSI 协议，究竟做了哪些优化？</p><p>欢迎把你研究的结果写在留言区和大家分享。如果有收获，也欢迎你把这篇文章分享给你的朋友，和他一起学习和进步。</p>',60),g=o(`<p>涉及到数据一致性的问题，cpu层，单机多线程内存层，分布式系统多台机器层，处理办法都差不多，原理是相通的</p><hr><p>Java中volatile变量修饰的共享变量在进行写操作时候会多出一行汇编</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>0x01a3de1d:movb $0×0，0×1104800（%esi）;0x01a3de24:lock addl $0×0,(%esp);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>lock前缀的指令在多核处理器下会:<br> 1、将当前处理器缓存行的数据写回到系统内存<br> 2、这个写回内存的操作会使其他CPU里缓存了改内存地址的数据无效<br> 多处理器总线嗅探:<br> 1、为了提高处理速度,处理器不直接和内存进行通信,而是先将系统内存的数据读到内部缓存后在进行操作,但<strong>写回操作</strong>不知道这个更改何时回写到内存<br> 2、但是对变量使用volatile进行写操作时,JVM就会向处理器发送一条lock前缀的指令,将这个变量所在的缓存行的数据写回到系统内存<br> 3、在多处理器中,为了保证各个处理器的缓存一致性,每个处理器通过嗅探在总线上传播的数据来检查自己的缓存值是不是过期了,如果处理器发现自己缓存行对应的内存地址被修改,就会将当前处理器的缓存行设置为无效状态,就相当于<strong>写回时发现状态标识为0失效</strong>,当这个处理器对数据进行修改操作时,会重新从系统内存中读取数据到CPU缓存中</p><hr><p>MSI 缓存一致性协议没有E这个状态，也就是没有独享的状态。如果块尚未被装入缓存(处于“I”状态)，则在装入该块之前，必须先要保证该地址的数据不会在其他缓存的缓存块中处于“M”状态。如果另一个缓存中有处于“M”状态的块，则它必须将数据写回后备存储，并回到“S”状态。<br> MESI 多了E状态（独享状态），如果当前写入的是E，则可直接写入，提高了性能。</p><p>老师好，问下：在多核cpu里边,某个cpu更新了数据，再去广播其他cpu。怎么保证其他cpu一定是操作成功的呢？<br> 作者回复: 这个是由“协议”来保证的。也就是其他CPU，在收到特定的广播消息，必须做什么样的特定操作。只要“协议”是正确的，其他CPU操作之后的特定结果就会一致。那么，这个协议就是我们这里的MESI协议，你可以对照着下面的状态流转图看一下。如果你问的是CPU在硬件层面，是否一个操作必定执行成功（好比你让程序算 1+1 = 2 是不是会算错），那这个是要在硬件的电路层面来保证的。在一个分层的软硬件体系下，这个不是MESI协议需要考虑的时间。</p>`,8),U={href:"https://blog.csdn.net/reliveIT/article/details/50450136",target:"_blank",rel:"noopener noreferrer"},_=e("p",null,"在看《Java并发编程实战》这门课的时候介绍到了并发编程的可见性问题，回过头来再看这篇文章加深理解。",-1);function k(u,b){const r=t("ExternalLinkIcon");return i(),s("div",null,[P,e("blockquote",null,[g,e("p",null,[a("看到了另一篇讲的不错的文章"),e("a",U,[a("https://blog.csdn.net/reliveIT/article/details/50450136"),n(r)])]),_])])}const S=c(m,[["render",k],["__file","F39-MESI协议.html.vue"]]);export{S as default};
