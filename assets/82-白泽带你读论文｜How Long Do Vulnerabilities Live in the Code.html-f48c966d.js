import{_ as r}from"./640-edc8dc9c.js";import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o,c as l,a as e,b as i,e as d,d as s}from"./app-cdabc73c.js";const h="/assets/640-1689735492710-1-9383599b.png",p="/assets/640-1689735492710-2-de70d769.png",c="/assets/640-1689735492710-3-6e9756ba.png",m="/assets/640-1689735492710-4-0a24110e.png",g="/assets/640-1689735492710-5-7bc46b6c.png",u="/assets/640-1689735492710-6-dc683ce1.png",f="/assets/640-1689735492710-7-4afb5b64.png",C="/assets/640-1689735492710-8-3b864730.png",b="/assets/640-1689735492710-9-6134d35c.png",_="/assets/640-1689735492710-10-d748ca1b.png",V={},x=e("h1",{id:"_82-白泽带你读论文-how-long-do-vulnerabilities-live-in-the-code",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_82-白泽带你读论文-how-long-do-vulnerabilities-live-in-the-code","aria-hidden":"true"},"#"),i(" 82-白泽带你读论文｜How Long Do Vulnerabilities Live in the Code?")],-1),k={href:"https://www.usenix.org/conference/usenixsecurity22/presentation/alexopoulos",target:"_blank",rel:"noopener noreferrer"},E=s('<p>如需转载请注明出处，侵权必究。</p><p>**论文题目：**How Long Do Vulnerabilities Live in the Code? A Large-Scale Empirical Measurement Study on FOSS Vulnerability Lifetimes</p><p>**发表会议：**Security 22</p><p>本文第一作者是来自德国达姆施塔特工业大学(Technical University of Darmstadt)的Nikolaos Alexopoulos博士后，其研究主要关注软件安全、匿名通信系统和去中心化计算领域中的测量问题。</p><h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><p>安全漏洞是可能被攻击者利用的软件缺陷，寻找现有漏洞并避免引入新的漏洞是安全从业者的主要目标之一。然而，<em>漏洞会在代码仓库中存在多久</em>？前人工作没有对这个问题进行足够深入的、大规模的研究，主要困难在于确定漏洞被引入的确切时间点。</p><p>以前，度量漏洞生命周期的方法主要有两种，</p><ol><li>一是通过手动映射漏洞贡献提交(Vulnerability contribute commit, VCC)到修复提交，但由于需要大量人工，所以研究规模有限；</li><li>二是使用启发式方法来估计漏洞生命周期的下限，然而这种方法存在较大误差，需要结合数据分析和建模才能实现精确估计。</li></ol><p>本文作者提出了一种新的<em>基于加权平均日期</em>的启发式方法，用于准确估计足够大规模的漏洞样本<em>在代码中的平均存在时间</em>。作者使用这种方法在开源软件中执行了一次大规模的测量，超越了之前研究中普遍使用的估计漏洞生命周期下限的方法，并得出了一些具有安全意义的统计结论。</p><h2 id="背景" tabindex="-1"><a class="header-anchor" href="#背景" aria-hidden="true">#</a> 背景</h2><figure><img src="'+r+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图 1</p><p>漏洞的生命周期是指从引入漏洞代码到修复漏洞代码的时间间隔。在版本控制系统（如git、SVN、mercurial）中，这些更改是提交的一部分，提交中包括多个更改的元数据(如，时间戳、作者)，可以用来追溯代码库的完整历史。<em>引入漏洞的提交</em>被称为<mark>漏洞贡献提交（VCC）</mark>，而用于<em>修复漏洞的提交</em>则称为<mark>修复提交</mark>。<code>一个漏洞可能有多个VCC和修复提交</code>。</p><p>图1展示了漏洞生命周期简单的阶段划分。漏洞的生命周期从<mark>引入漏洞代码</mark>开始，经历<mark>漏洞发现</mark>、<mark>公开披露</mark>、<mark>补丁发布</mark>和<mark>所有受影响的主机被修复</mark>四个阶段。但这并不是一种严格定义，各阶段或长或短，甚至某些阶段可能不存在。例如，如果安全研究人员在发现漏洞的同时向厂商进行披露，厂商就有机会可以同时公开漏洞和修复方案使第三阶段消失；对于某些严重的漏洞，可能需要静默修补，这意味着漏洞永远不会被公开披露。</p><h2 id="研究问题" tabindex="-1"><a class="header-anchor" href="#研究问题" aria-hidden="true">#</a> 研究问题</h2><p>漏洞在代码中存在多久？对于不同项目或不同漏洞类型，漏洞生命周期是否相同？漏洞生命随时间增加还是减少？软件质量是否有改善的迹象，软件是否随时间推移变得更安全？回答这些问题将帮助确定项目曝光窗口的持续时间，进而确定稳定冻结的持续时间。<em>稳定冻结即只对软件进行安全更新，不进行业务更新，以减少引入新漏洞的风险</em>。如果漏洞生命周期长，那么稳定冻结期也需要加长，确保修复所有关键问题。</p><h2 id="贡献" tabindex="-1"><a class="header-anchor" href="#贡献" aria-hidden="true">#</a> 贡献</h2><ol><li>作者提出加权平均的启发式方法精确估计漏洞生命周期，超出了在以前的工作中普遍使用的估计下限的方法。</li><li>作者构建了一个包含5,914个CVE的大型数据集，涵盖11个流行开源软件，这是迄今为止最大、最完整的CVE及其修复提交的映射数据集。</li><li>作者在该数据集上进行漏洞生命周期的测量，得到对于软件安全具有指导意义的一些统计发现。</li></ol><h2 id="工作流程" tabindex="-1"><a class="header-anchor" href="#工作流程" aria-hidden="true">#</a> 工作流程</h2><h3 id="数据集创建" tabindex="-1"><a class="header-anchor" href="#数据集创建" aria-hidden="true">#</a> 数据集创建</h3><h4 id="链接cve和vcc" tabindex="-1"><a class="header-anchor" href="#链接cve和vcc" aria-hidden="true">#</a> <strong>链接CVE和VCC</strong></h4><p>作者使用人工映射CVE到VCC的数据集作为Ground Truth，用于评估和验证估计漏洞生命周期的方法。主要的数据源包括<mark>Ubuntu CVE Tracker</mark>，该数据源提供了有关<em>Linux内核漏洞</em>的相关数据。此外，作者还从<mark>Vulnerability History Project</mark>获取了<em>Chromium</em>和<em>Apache HTTP Server</em>的数据。考虑到其他编程语言的数据较少，作者决定将研究范围限定在C/C++代码库。作者从这些高质量的来源获得了1,171个CVE与一个或多个VCC映射的数据集。</p><h4 id="构建项目样本" tabindex="-1"><a class="header-anchor" href="#构建项目样本" aria-hidden="true">#</a> <strong>构建项目样本</strong></h4><p>为了进行分析，作者需要选取一个大规模且具有代表性的<mark>FOSS</mark>（自由开源软件）项目样本，这些项目需要与Ground Truth数据集兼容，并提供足够的数据点供分析。为此，作者确定了以下选取原则：</p><p>(a) 项目必须是开源软件，<u>具有透明且一致的安全工作流程</u>。</p><p>(b) 项目应具有<u>相当数量的CVE记录</u>。为了能够对项目进行全面分析，作者只选择具有至少100个CVE的项目。</p><p>(c) 项目主要应<u>以C或C++编写</u>。作者没有足够的数据表明方法适用于其他编程语言，因此专注于C/C++。</p><p>(d) <em>项目的大部分CVE应与修复提交相关联，从而明确追踪到CVE与修复提交之前的关系</em>。基于这些选取原则，将能够确保所选项目与作者的分析目标相符，并提供充足的数据来支持研究。</p><h4 id="链接cve和修复提交" tabindex="-1"><a class="header-anchor" href="#链接cve和修复提交" aria-hidden="true">#</a> <strong>链接CVE和修复提交</strong></h4><p>为了分析漏洞的生命周期，作者采用了四种不同的方法将<mark>NVD中的漏洞条目</mark>与<mark>一个或多个修复提交</mark>关联起来。下面介绍这四种方法：</p><ol><li>使用自动化脚本收集修复提交中的CVE-ID，并人工分析删除无效的映射，添加未被识别的映射。</li><li>收集NVD引用中的指向版本控制系统提交的链接。</li><li>许多软件供应商在其开发过程中使用专用的bug跟踪系统。 <ol><li>每个提交对应一个使用特定语法在提交消息中标记的Bug ID。因此，大多数提交可以与特定的Bug ID关联起来。</li><li>另一方面，NVD条目可能包含对供应商bug跟踪系统的链接。<br> 使用正则表达式，可以从这些链接中提取Bug ID，然后将其与相应的修复提交进行匹配。</li></ol></li><li>使用可信第三方构建的映射数据集，作者主要采用三个第三方构建的数据集： <ol><li>(a) Linux内核CVE项目，</li><li>(b)由Piantadosi等人手动制作的映射，</li><li>(c)Debian安全跟踪器。</li></ol></li></ol><figure><img src="'+h+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图 2</p><p>最终，作者得到了一个包含来自11个项目的5,914个CVE及其修复提交的数据集。图2中列出了这些CVE及其修复提交的数量，分别显示了CVE总数、至少有一个修复提交的CVE数量、修复提交总数。</p><h3 id="从漏洞修复提交自动估计生命周期" tabindex="-1"><a class="header-anchor" href="#从漏洞修复提交自动估计生命周期" aria-hidden="true">#</a> 从漏洞修复提交自动估计生命周期</h3><h4 id="前人工作中采用的方法" tabindex="-1"><a class="header-anchor" href="#前人工作中采用的方法" aria-hidden="true">#</a> <strong>前人工作中采用的方法</strong></h4><p>找到漏洞的VCC（引入漏洞的提交）并不简单，之前使用的一种方法是人工识别VCC。虽然这种方法能得到最准确的结果，但它不适合大规模的研究。因此，研究人员又提出了一种自动化的方法，<strong>通过<em>git blame命令</em>找到更改特定代码行的提交，来追溯漏洞的起源</strong>。</p><p>具体做法为：对给定的修复提交的每个删除或修改的行运行该命令，在返回的多个候选VCC中选择最近的提交日期作为漏洞引入日期。这种方法具有较大误差，研究人员又提出了VCCFinder，在git blame命令的基础上，加入一个区分风险提交的分类器来指导VCC的选择。但是作者在Ground Truth数据集上评估了VCCFinder后，发现精确度仅有40%。</p><h4 id="加权平均的启发式方法" tabindex="-1"><a class="header-anchor" href="#加权平均的启发式方法" aria-hidden="true">#</a> <strong>加权平均的启发式方法</strong></h4><p>作者提出不需要将漏洞引入时间绑定到具体的某个VCC，只需要近似确定漏洞引入的时间点。由此，通过加权（根据提交频率分配权重）平均多个可能的漏洞引入日期来实现新方法。具体步骤为</p><ul><li>（1）使用<em>git blame -w命令</em>将修复提交中每个可疑更改映射到VCC，</li><li>（2）使用图3公式对所有可疑VCC进行加权平均后作为漏洞的引入日期，公式中n为提交数量，bi为可疑更改数量，di为日期。</li></ul><figure><img src="'+p+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图 3</p><h2 id="测量结果" tabindex="-1"><a class="header-anchor" href="#测量结果" aria-hidden="true">#</a> 测量结果</h2><h3 id="项目的漏洞生命周期" tabindex="-1"><a class="header-anchor" href="#项目的漏洞生命周期" aria-hidden="true">#</a> 项目的漏洞生命周期</h3><figure><img src="'+c+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图 4</p><p>图4显示了每个项目以及整个数据集的漏洞生命周期。总体而言，漏洞在代码中存在很长时间，平均超过1,900天。不同项目的生命周期存在很大的差异，TCPDump的平均生命周期是Chromium的4倍。有多种可能的解释导致这些差异，例如更好的安全协议、代码改动等。</p><h3 id="cve的漏洞生命周期" tabindex="-1"><a class="header-anchor" href="#cve的漏洞生命周期" aria-hidden="true">#</a> CVE的漏洞生命周期</h3><figure><img src="'+m+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图 5</p><figure><img src="'+g+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图 6</p><p>图5展示了所有CVE的生命周期分布以及指数拟合曲线。图6表明指数分布适合生命周期在约4,200天以内的数据。作者采用了前人工作中提到的Kolmogorov-Smirnov检验，来统计比较指数分布与其他候选分布的拟合优度，发现指数分布在统计上更好地拟合数据。</p><h3 id="生命周期随时间变化的趋势" tabindex="-1"><a class="header-anchor" href="#生命周期随时间变化的趋势" aria-hidden="true">#</a> 生命周期随时间变化的趋势</h3><figure><img src="'+u+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图 7</p><p>为了调查漏洞生命周期随时间的变化，作者按照修复年份（最后一次修复提交的年份）对CVE进行分组，并计算每年的平均生命周期。图7显示了整个数据集以及Firefox、Chromium和Linux的漏洞生命周期随年份变化的情况。</p><p>整体来看（图7a），<em>漏洞生命周期</em>随着年份的增加呈现出增加的趋势，对于整个数据集，平均漏洞生命周期每年增加42.78天。</p><p>对于Chromium（图7c）和Linux（图7d），可以观察到明显的增长趋势，而对于Firefox（图7b），漏洞生命周期是稳定的，甚至存在轻微的下降趋势。</p><h3 id="代码使用年龄" tabindex="-1"><a class="header-anchor" href="#代码使用年龄" aria-hidden="true">#</a> 代码使用年龄</h3><figure><img src="'+f+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图 8</p><p>为了计算项目在特定时间点的整体代码年龄，作者采用了以下方法：对每年7月1日时的代码库中的每一行进行git blame操作，获取最后一次更改该行的时间点，将最后一次更改和7月1日的时间跨度视为该行在该年的常规代码年龄。作者计算了有漏洞生命周期数据的每年的平均代码年龄，并在图8中绘制结果，包括Firefox、Chromium、Linux和Httpd。</p><p>观察到所有项目的平均代码年龄和平均漏洞生命周期之间存在密切的相关性。除了Firefox外，所有项目的这两个指标随时间呈现增长趋势，而Firefox则略微呈下降趋势。从而得出两个观察结果，</p><ul><li>（1）漏洞生命周期低于常规代码年龄，</li><li>（2）尽管对于大多数项目，漏洞生命周期和常规代码年龄之间的差距似乎随时间保持稳定，但对于某些项目（例如Chromium-图8b），差距在增加。</li></ul><h3 id="模糊测试工具对生命周期的影响" tabindex="-1"><a class="header-anchor" href="#模糊测试工具对生命周期的影响" aria-hidden="true">#</a> 模糊测试工具对生命周期的影响</h3><figure><img src="'+C+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图 9</p><p>作者调查了模糊测试工具对漏洞生命周期的影响。<em>内存相关的错误</em>是模糊测试的传统目标，作者将Linux内存相关的CVE与其他漏洞类型中的Linux CVE的趋势进行对比，如图10，显示这两组CVE的生命周期趋势没有显著差异，即模糊测试工具的引入并没有显著影响漏洞生命周期。</p><h2 id="讨论与发现" tabindex="-1"><a class="header-anchor" href="#讨论与发现" aria-hidden="true">#</a> 讨论与发现</h2><p><strong>RQ1：对于不同时间和不同项目，加权平均启发式方法是否具有泛化性？</strong></p><figure><img src="'+b+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图 10</p><figure><img src="'+_+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图 11</p><p>如图10，该方法的一个鲁棒性表现是<em>其误差在低均值周围近似对称，并且几乎符合正态分布</em>，这意味着错误会相互抵消，从而提高了方法的可靠性。另外，图11展示了加权平均的启发式方法在三个不同项目中的类似表现，证明了方法的一般适用性。</p><p><strong>RQ2：随着时间的推移，软件是否变得更加安全？</strong></p><p>根据作者的观察结果，可以得出以下结论：</p><ul><li>（1）没有证据支持引入并修复的新漏洞随着时间推移而减少。这意味着在软件开发过程中，即使修复了一些漏洞，仍然存在引入新漏洞的风险。因此，持续的安全更新和漏洞修复仍然是必要的。</li><li>（2）漏洞的平均生命周期略短于代码库的年龄。这意味着漏洞修复能够显著减少零日攻击的窗口期。通过快速修复漏洞，可以减少潜在的攻击面和暴露时间，增加系统的安全性。</li><li>（3）对于某些项目，漏洞的平均生命周期与代码库的年龄之间的差距随着时间的增加而增加。这表明这些软件项目逐渐进入成熟状态，漏洞的修复速度逐渐趋于稳定。</li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>在前人的研究中，确定漏洞引入具体时间的方法存在较大误差。为了解决这个问题，作者提出了一种加权平均的启发式方法来估计漏洞生命周期。作者构建了一个迄今为止最大的、最完整的CVE及其修复提交之间的映射数据集，并在此数据集上进行了大规模的测量，得出了一些重要的统计发现，这些发现对指导软件安全具有重要意义。</p>',82);function v(L,y){const a=t("ExternalLinkIcon");return o(),l("div",null,[x,e("p",null,[e("a",k,[i("How Long Do Vulnerabilities Live in the Code? A Large-Scale Empirical Measurement Study on FOSS Vulnerability Lifetimes | USENIX"),d(a)]),i("。")]),E])}const z=n(V,[["render",v],["__file","82-白泽带你读论文｜How Long Do Vulnerabilities Live in the Code.html.vue"]]);export{z as default};
