import{_ as s}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as a,c as i,a as e,b as r,e as t,d as c}from"./app-cdabc73c.js";const p="/assets/640-1691479867982-117-4abae784.png",d="/assets/640-1691479867982-118-60ea434b.png",l={},g=e("h1",{id:"_24-白泽带你读论文丨dr-checker-a-soundy-analysis-for-linux-kernel-drivers",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_24-白泽带你读论文丨dr-checker-a-soundy-analysis-for-linux-kernel-drivers","aria-hidden":"true"},"#"),r(" 24-白泽带你读论文丨DR. CHECKER: A Soundy Analysis for Linux Kernel Drivers")],-1),u=e("p",null,[e("strong",null,"DR. CHECKER: A Soundy Analysis for Linux Kernel Drivers")],-1),h=e("p",null,"论文链接：",-1),_={href:"https://www.usenix.org/system/files/conference/usenixsecurity17/sec17-machiry.pdf",target:"_blank",rel:"noopener noreferrer"},f=e("p",null,"开源项目地址:",-1),D={href:"https://github.com/ucsb-seclab/dr_checker",target:"_blank",rel:"noopener noreferrer"},m=c('<p>本文发表在the 26th USENIX Security Symposium (USENIX Security &#39;17)，第一作者是来自University of California的Aravind Machiry。</p><h2 id="_1-主要内容" tabindex="-1"><a class="header-anchor" href="#_1-主要内容" aria-hidden="true">#</a> <strong>1.</strong> <strong>主要内容</strong></h2><p>内核代码的bug往往会导致很危险的系统漏洞，严重危害整个计算机系统的安全。而<mark>驱动程序</mark>因为其拥有较高的权限以及较低的代码质量，一直以来都是内核中最容易出现bug的部分，例如在2016年，<em>安卓内核的上报bug中有85%来自于驱动程序</em>。但是目前可用于挖掘内核缺陷的工具无论在数量上还是在效率上都有很大的不足，其原因在于目前对于内核的动态分析技术<em>更倾向于做内核的监视器而不是代码验证</em>，并不适合在内核庞大的代码库中查找bug；而静态分析技术虽然适用于代码验证，但是由于内核本身对指针的大量使用<strong>等原因</strong>，给静态分析带来了很大的挑战。基于静态分析的缺陷挖掘工具往往需要权衡完备性(soundness)和精确性(precision)，</p><ol><li>一般来说高完备性的工具会带来大量误报，难以使用；</li><li>而高精确性的工具由于计算量过大，最终只能针对特定类型的bug进行检测。</li></ol><p>因此，在本文中作者设计了一款基于指向分析和污点分析的内核驱动通用bug检测工具Dr.checker。它通过将分析范围限制在内核最容易出现bug的驱动程序来克服对内核进行静态分析的一些限制，并且采用了模块化的设计实现了一种 “soundy” 的效果。“soundy” 是作者的自创词，文中给出的解释是 “mostly soundness” ，即在损失少量完备性的基础上实现较高的精确性，这样的做法使Dr.checker可以较为精确的检测多种类型的bug，相较于其它工具而言有更好的实用价值。</p><p>作者最后对4个厂商9个不同的安卓驱动程序进行了测试，从结果中共确认了158个零日漏洞。</p><h2 id="_2-设计与实现" tabindex="-1"><a class="header-anchor" href="#_2-设计与实现" aria-hidden="true">#</a> <strong>2.</strong> <strong>设计与实现</strong></h2><figure><img src="'+p+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>Dr.checker是基于LLVM实现的静态分析工具，其工作流程如上图所示：针对输入的驱动代码会对其进行一次完整的遍历，在遍历过程中如遇到一些特定的<em>IR指令</em>便会去调用指向分析和污点分析的客户端，二者共同维护一个全局状态表，每当状态表更新时便会调用各类漏洞检测器依据各自的规则从中识别并上报warning，然后经由人工鉴别从warning中识别出真正的bug。具体来说分为三个主要部分：</p><p><strong>(1) Soundy Driver Traversal:</strong> Dr.checker同时实现了指向分析和污点分析两类具体的分析模型，由于不同的模型分析的精确度不同，所以往往部分分析需要对CFG进行更多次的遍历才能够收敛（比如指向分析所需的遍历次数一般多于污点分析）。为了保证所有的分析模型都能达到较高的精确度，并且避免多次遍历整个驱动代码所带来的额外开销，这里需要选择一个与具体分析模型无关的方法来实现对整个代码的探索，并能够尽可能满足不同分析模型对CFG的最大遍历次数的需求。作者在这里选取了到达定值分析（reach-def analysis）作为基准，即对整个驱动程序的遍历满足到达定值分析收敛的遍历次数要求，这样可以覆盖所有直接写操作的指令。但同时，这可能在部分情况下导致不满足指向分析收敛的迭代次数要求而造成部分漏报。</p><p>由于整个内核的代码量很大，为了保证整个工具的效率，这里作者只对驱动程序内的函数调用进行过程间分析，而对驱动外的内核函数大部分不做处理，只对小部分效果比较简单的函数做了适配（比如memset）。</p><p><strong>(2) Analysis Clients:</strong> Dr.checker通过模块化的设计将具体的分析模型通过客户端的形式实现，以确保在对整个驱动代码进行一次遍历的同时能够进行多种具体的分析。目前工具已经实现了指向分析和污点分析两个分析客户端。</p><p>具体的分析客户端是针对特定的LLVM IR指令所实现的操作，具体包含以下5种可以更新状态的指令：Alloca(分配内存空间)，BinOp(二元操作，比如加减)，Load(读数据)，Store(存数据)，GetElementPtr(获取结构体或者数组成员的地址)。当Soundy Driver Traversal遇到这5种指令时会触发客户端的分析方法，客户端会依据各自的实现读取并更新全局状态表。</p><p><strong>(3) Vulnerability Detectors:</strong> 漏洞检测器是作为插件实现的，当全局状态表更新时，它会利用分析客户端的结果从中根据各自的规则来判断是否可能为bug。目前工具中实现了8种不同的漏洞检测器：</p><p>1）Improper Tainted-Data Use Detector (ITDUD): 检测被污染的数据是否被用于危险函数，例如<code>strc*</code>、<code>strt*</code>、<code>sscanf</code>。</p><p>2）Tainted Arithmetic Detector (TAD): 检测被污染的数据是否被用于可能导致上溢出或者下溢出的操作，例如加减操作。</p><p>3）Invalid Cast Detector (ICD): 追踪对象的分配大小，并检查是否将数据强制转换为不同大小的对象。</p><p>4）Tainted Loop Bound Detector (TLBD): 检测被污染的数据是否用于循环的边界。</p><p>5）Tainted Pointer Dereference Detector (TPDD): 检测指针是否被污染和是否被取消引用，当在内核结构体中使用用户指定的索引而没有进行检查时，就会上报warning。</p><p>6）Tainted Size Detector (TSD): 检测copy to以及copy from函数中是否使用了被污染的数据作为长度入参。</p><p>7）Uninit Leak Detector (ULD): 追踪对象的初始化，如果用户空间的复制数据的函数使用了未初始化的对象，则会上报warning。</p><p>8）Global Variable Race Detector (GVRD): 检测是否在未使用互斥锁的情况下使用全局变量。</p><h2 id="_3-实验评估" tabindex="-1"><a class="header-anchor" href="#_3-实验评估" aria-hidden="true">#</a> <strong>3.</strong> <strong>实验评估</strong></h2><p>作者依据芯片组的不同，选择了4个厂商，共9个内核做测试集，并设计了两个实验来测试整个工具的效果：</p><p><strong>(1)</strong> **针对准确率的测试：**在9款内核中，Dr.checker共上报了5071个warning，经过人工鉴别，其中3973个是正确的上报，占比78%，并从中识别出158个零日漏洞。</p><p>造成warning比真正的漏洞多的原因在于，因为漏洞检测器是无状态的，所以对于任何满足条件的判断结果都会上报warning，而不会识别两个warning间是否有关联，因此一个漏洞可能会上报多个warning。</p><p><strong>(2)</strong> **针对效率的测试：**作者共设计了两个实验组：一是放开对遍历的限制，让全部的分析模型都收敛(No API)；二是在一的基础上再对全部的内核函数都做过程间分析(Sound)。作者在测试集中选取了100个入口点进行测试，实验结果如下：</p><figure><img src="'+d+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>从结果中可以看出第一个实验组在4个小时内只完成了18个入口点的分析，并且平均用时远高于对照组；而第二个实验组虽然最终上报了474个warning比对照组210个多，但是其平均耗时和最大耗时是对照组的3倍多。由此可见，Dr.checker的设计虽然会对结果的完备性造成影响，但是对最终效率的提升有很明显的效果。</p><h2 id="_4-总结" tabindex="-1"><a class="header-anchor" href="#_4-总结" aria-hidden="true">#</a> <strong>4.</strong> <strong>总结</strong></h2><p>Dr.checker是一款针对linux内核的bug查找工具，他利用了模块化的设计实现了整个工具“soundy“的效果，即同时对多种不同类型的bug进行较高精确性的检测。并且因为漏洞检测器的插件化，很容易利用它实现的通用的分析流程实现新增新的bug检测方法。</p><p>从整体的设计上来看，Dr.checker并没有在设计中对驱动程序代码的分析做任何特殊的处理，如果放开Dr.checker对分析源码位置的配置以及对分析入口点的选择，那么它的整个分析流程其实是对整个内核代码都适用的。本文选择只分析驱动程序的目的应该是为了避免内核静态分析的路径爆炸问题，挑选最易出bug的部分进行分析以得到最好的效果。</p><p>总的来说，本文并没有提出全新的分析方法，<em>而是设计了一个框架对目前有效的静态分析方法进行组合，从而实现对多种类型bug的检测</em>。这种1+1&gt;2的想法也完全适用于其它领域的分析设计中。</p>',33);function b(y,k){const n=o("ExternalLinkIcon");return a(),i("div",null,[g,u,h,e("p",null,[e("a",_,[r("https://www.usenix.org/system/files/conference/usenixsecurity17/sec17-machiry.pdf"),t(n)])]),f,e("p",null,[e("a",D,[r("https://github.com/ucsb-seclab/dr_checker"),t(n)])]),m])}const w=s(l,[["render",b],["__file","24-白泽带你读论文丨DR. CHECKER A Soundy Analysis for Linux Kernel Drivers.html.vue"]]);export{w as default};
