import{_ as a}from"./640-edc8dc9c.js";import{_ as l}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as p,c as t,a as r,b as e,e as n,d}from"./app-cdabc73c.js";const s="/assets/640-1689478841966-1-ca3e684e.png",c="/assets/640-1689478841966-2-f7757b75.png",u="/assets/640-1689478841966-3-1c5cc9ab.png",z="/assets/640-1689478841966-4-8ced1e2f.png",h="/assets/640-1689478841966-5-0ae35d09.png",g="/assets/640-1689478841966-6-0a65aa19.png",m="/assets/640-1689478841966-7-38f0f5fe.png",f="/assets/640-1689478841966-8-d13af20c.png",A={},P=r("h1",{id:"_91-白泽带你读论文-apicraft",tabindex:"-1"},[r("a",{class:"header-anchor",href:"#_91-白泽带你读论文-apicraft","aria-hidden":"true"},"#"),e(" 91-白泽带你读论文｜APICraft")],-1),I={href:"https://www.usenix.org/conference/usenixsecurity21/presentation/zhang-cen",target:"_blank",rel:"noopener noreferrer"},k=d('<p>如需转载请注明出处，侵权必究。</p><p>**论文题目：**APICraft: Fuzz Driver Generation for Closed-source SDK Libraries</p><p><strong>发表会议：Security 2021</strong></p><p>本文作者是Cen Zhang，来自南洋理工大学的Liu Yang 教授团队，该团队在网络安全领域的主要研究方向是<em>恶意软件建模、检测、分类和生成等</em>。</p><h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><h3 id="fuzzer-driver" tabindex="-1"><a class="header-anchor" href="#fuzzer-driver" aria-hidden="true">#</a> ###Fuzzer Driver？</h3><blockquote><p>Fuzzer driver是一种用于进行模糊测试（Fuzzing）的软件组件或代码。在计算机安全领域，模糊测试是一种常用的安全测试方法，通过向目标程序或系统输入大量随机、异常或不合理的数据，来发现可能的漏洞或错误。</p><p>Fuzzer driver是模糊测试框架的关键部分，它负责自动化地生成和发送大量的模糊输入数据，以测试目标程序的稳定性和安全性。它可以是一个独立的程序，也可以是一个库或插件，用于集成到其他测试工具中。</p><p>Fuzzer driver通常具有以下功能：</p><ol><li>生成各种类型的模糊测试输入，包括随机数据、边界值、无效数据等。</li><li>维护输入队列，确保大量的测试数据被连续发送给目标程序。</li><li>监控目标程序的崩溃、异常行为或错误信息，并记录相应的测试结果。</li><li>提供错误报告和统计信息，帮助用户分析和理解测试的结果。</li></ol><p>总之，Fuzzer driver是用于执行模糊测试的关键组件，帮助安全研究人员和开发者发现和解决软件中的潜在问题。</p></blockquote><p>现有工作生成<mark>fuzzer driver</mark>依赖源代码提供接口信息，导致无法在<mark>闭源SDK</mark>上用它们进行漏洞挖掘。在闭源SDK上自动化生成fuzz driver主要面临两个挑战，</p><ol><li>只能从库中提取有限的信息；</li><li>API函数之间的语义关系复杂，需要保证语义关系的正确性。</li></ol><h3 id="依赖源代码提供接口信息" tabindex="-1"><a class="header-anchor" href="#依赖源代码提供接口信息" aria-hidden="true">#</a> ###依赖源代码提供接口信息？</h3><blockquote><p>当使用Fuzzer driver生成模糊测试输入时，通常需要了解目标程序或系统的接口信息。接口信息是指目标程序或系统暴露给外部调用的<em>函数、数据结构、API</em>等。</p><p>生成Fuzzer driver依赖源代码提供接口信息的原因有几个：</p><ol><li><p><em>定位和识别目标函数</em>：Fuzzer driver需要知道目标函数的<strong>名称、参数列表和返回类型</strong>等信息，才能正确地生成<strong>测试输入</strong>并调用目标函数。</p></li><li><p><em>生成有效的测试数据</em>：Fuzzer driver需要了解目标程序的<strong>数据结构和约束条件</strong>，才能生成有效的<strong>测试数据</strong>。例如，如果目标函数需要接收一个整数参数，并对其进行范围检查，Fuzzer driver需要知道这个范围，才能生成合法的输入。</p></li><li><p><em>错误检测和处理</em>：Fuzzer driver通过监视目标程序的<strong>崩溃、异常行为或错误信息</strong>来判断是否发现了<strong>潜在问题</strong>。为了正确地解释和处理这些问题，它需要理解和分析目标程序在接口层面上的行为。</p></li></ol><p>需要注意的是，如果目标程序的源代码不可用或不公开，那么生成Fuzzer driver可能会面临一些挑战。在这种情况下，<em>可以考虑使用<strong>静态分析工具</strong>来获取接口信息</em>，或者使用<mark>黑盒测试技术</mark>来进行模糊测试。</p><p>然而，对于许多情况来说，源代码提供接口信息是生成可靠、有效的Fuzzer driver的重要依赖。</p></blockquote><p>为了解决上述挑战，APICRAFT采用了“收集-整合”的策略。</p><ul><li>“收集”指用<mark>头文件、二进制文件</mark>、运行时追踪数据<strong>收集API的控制流和数据依赖</strong>。</li><li>“整合”则是指用“<mark>多目标遗传算法</mark>”在整合API的控制流和数据依赖的同时，<strong>生成高质量的fuzz driver</strong>。 <ul><li>作者实现APICraft后，用此工具发现了142个macOS系统库漏洞，并收获了54个Apple官方致谢。</li></ul></li></ul><h2 id="motivation" tabindex="-1"><a class="header-anchor" href="#motivation" aria-hidden="true">#</a> Motivation</h2><h3 id="程序模糊测试的流程步骤" tabindex="-1"><a class="header-anchor" href="#程序模糊测试的流程步骤" aria-hidden="true">#</a> ###程序模糊测试的流程步骤？</h3><blockquote><p>程序模糊测试的大致流程如下：</p><ol><li><p><mark>目标确定</mark>：选择待测试的目标程序或系统。这可以是一个已有的应用程序、操作系统、协议等，或者一个自己开发的软件。</p></li><li><p><mark>环境设置</mark>：配置测试环境，包括选择合适的操作系统、编译器和调试器，以及准备测试输入源和生成Fuzzer driver所需的接口信息。</p></li><li><p><mark>Fuzzing策略选择</mark>：选择合适的模糊测试策略和方法。常见的策略包括随机生成数据、变异现有输入、生成边界值和无效输入等。</p><ol><li><mark>接口分析</mark>：分析目标程序的接口信息，包括函数名称、参数列表、返回类型等。这些信息将被用于生成Fuzzer driver并执行模糊测试。</li></ol></li><li><p><mark>Fuzzer driver生成</mark>：（基于目标程序的接口信息）选定的Fuzzing策略，生成或选择合适的Fuzzer driver，这将负责自动化生成和发送大量的模糊测试输入。该Fuzzer driver可以是一个独立的程序，也可以是一个集成到测试工具中的模块。</p><ol><li><mark>输入生成</mark>：根据选定的模糊测试策略，生成各种模糊测试输入，包括随机数据、变异现有输入、边界值和不合理数据等。这些输入将被Fuzzer driver发送给目标程序。</li></ol></li><li><p><mark>执行模糊测试</mark>：启动Fuzzer driver并执行模糊测试。Fuzzer driver将不断生成各种模糊测试输入，并将其发送到目标程序或系统。Fuzzer driver会监视目标程序的响应，并记录任何崩溃、异常或错误行为。</p></li></ol><p>具体步骤如下：</p><ol><li><p>确定目标：选择要进行模糊测试的目标程序或系统，可以是一个特定的二进制文件、库文件、网络协议等。</p></li><li><p>确定测试目标和边界：分析目标程序的输入、API调用和边界条件。确定需要测试的函数、参数和边界值等。</p></li><li><p>生成测试输入：根据选定的模糊测试策略，生成各种模糊测试输入。常见的方法包括随机生成测试数据、变异现有输入以及生成有针对性的边界值和不合理数据。</p></li><li><p>发送测试输入：将生成的测试输入发送给目标程序或系统。这可以通过模拟用户输入、网络通信或其他适当的方式进行。</p></li><li><p>监控和分析：监控目标程序的响应，并记录任何崩溃、异常或错误行为。这可以包括观察程序运行时的内存错误、异常退出、资源泄漏等。</p></li><li><p>结果评估：根据测试结果评估目标程序的稳定性和安全性。分析测试覆盖率、发现的漏洞和错误等。</p></li><li><p>优化和迭代：根据测试结果进行优化和迭代。可以调整Fuzzing策略、增加测试输入的多样性，或者改进Fuzzer driver的性能和效率。</p></li><li><p>报告和修复：生成详细的错误报告，并与开发团队分享测试结果。发现的漏洞和问题应及时修复。</p></li></ol><p>在整个流程中，关键的要素是选择恰当的模糊测试策略和生成有效的模糊测试输入。同时，不断重复和优化测试步骤，以提高测试覆盖率和发现潜在漏洞的能力。</p></blockquote><p>与对传统的程序模糊测试不同，对一个库进行模糊测试需要<em>一个使用这个库的应用程序（即fuzz driver）来接收fuzzer的输出</em>。在实际漏洞挖掘工作中，fuzz driver往往是由技术能力强的安全分析人员花费大量时间手动编写完成，这使得<strong>自动化生成fuzz driver</strong>是一个很有价值的工作。</p><p>目前fuzz driver的自动化生成技术大多需要<em>使用库程序（称为Consumer Program）的源代码</em>，而在闭源SDK的漏洞挖掘工作中，由于闭源SDK的Consumer program往往也是闭源的，导致现有工作无法支持对闭源SDK进行漏洞挖掘。本文目标则是针对闭源SDK生成fuzz driver。</p><h2 id="example" tabindex="-1"><a class="header-anchor" href="#example" aria-hidden="true">#</a> Example</h2><p>那么针对闭源SDK是如何构建fuzz driver的呢？接下来将以macOS CoreText库为例介绍。如下图1所示，有两个Consumer Program ，它们一共使用了CoreText库的5个API，标号为1~5。</p><ul><li>图2（a）是对此简化的调用序列。</li><li>图2（b）是采用常用的交叉互换方式生成的调用序列，但这个交叉互换的效果不大，因为只是改变了创建font对象的方式，并没有改变font的使用方式。</li><li>图2（c）才是想要的调用序列，也是本工作的目标。</li></ul><figure><img src="'+a+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图1 使用CoreText的Consumer Program</p><figure><img src="'+s+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图2 简化的调用序列</p><h3 id="交叉互换方式生成调用序列" tabindex="-1"><a class="header-anchor" href="#交叉互换方式生成调用序列" aria-hidden="true">#</a> ###交叉互换方式生成调用序列？</h3><blockquote><p>交叉互换方式生成调用序列是一种常用的方法，用于生成程序API的调用序列，以进行程序模糊测试或其他测试目的。其原理建立在以下两个假设上：</p><ol><li><p>API调用的独立性：假设不同的API调用在执行时是相互独立的，即它们的执行和结果不受其他API调用的影响。</p></li><li><p>调用关系随机性：假设API调用的执行顺序是任意的，没有固定的顺序要求。</p></li></ol><p>基于这两个假设，交叉互换方式生成调用序列的原理如下：</p><ol><li><p>API调用收集：首先，收集目标程序或系统的API调用信息，包括函数名称、参数列表、参数类型和返回类型等。可以通过静态分析、代码审查或运行时监控等方式获得这些信息。</p></li><li><p>API调用序列生成：根据收集到的API调用信息，生成一个初始的API调用序列。可以随机选取一个API调用作为起始点，然后根据调用的返回类型和参数类型，选取其他API调用作为后续调用。这样逐步构建起一个基本的API调用序列。</p></li><li><p>交叉互换：在生成的初始调用序列上进行交叉互换操作。具体地，从调用序列中随机选择两个不同的API调用，交换它们的位置。这样就生成了一个新的调用序列。</p></li><li><p>重复步骤3：重复步骤3多次，每次都生成一个新的调用序列，直到达到预设的生成次数或其他终止条件。每次生成的序列都是通过交叉互换操作得到的。</p></li></ol><p>通过以上步骤，交叉互换方式生成调用序列能够帮助<em>生成各种不同的API调用序列，以增加测试的覆盖率和多样性</em>。这种方法可以在模糊测试中用于生成调用序列作为输入，<em>以测试目标程序对不同调用顺序的鲁棒性和稳定性</em>。</p></blockquote><h2 id="框架设计" tabindex="-1"><a class="header-anchor" href="#框架设计" aria-hidden="true">#</a> 框架设计</h2><p>为了针对闭源SDK自动化生成fuzz driver，作者提出了APICRAFT。核心思路是收集SDK的Consumer Program的<mark>运行时的trace</mark>，并<strong>基于此推导出 API 间的控制流和数据依赖</strong>，最后再采用“<u>多目标遗传算法</u>”生成高质量的fuzz driver。</p><p>图3是APICRAFT的流程图，包含三大阶段：</p><ol><li>预处理阶段：APICRAFT通过多种分析(*头文件分析、静态二进制分析、动态二进制分析)*从多个来源提取目标SDK的信息并进行分组。这一步将输出<mark>库的元数据</mark>和<mark>consumer program的动态trace记录</mark>。</li><li>33依赖提取：目的是收集数据依赖和控制依赖。 <ol><li><strong>数据依赖</strong>主要指API函数间的数据依赖。</li><li><strong>控制依赖</strong>则是与API错误处理相关的函数输出。</li></ol></li><li>生成fuzz driver：利用多目标遗传算法，将收集到的数据依赖和控制依赖组合成fuzz driver，同时使fuzz driver满足*“多样性”、“有效性”、“紧凑性”*。</li></ol><figure><img src="'+c+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图 3 APICRAFT流程图</p><h3 id="多目标遗传算法" tabindex="-1"><a class="header-anchor" href="#多目标遗传算法" aria-hidden="true">#</a> ###多目标遗传算法？</h3><blockquote><p>多目标遗传算法（Multi-Objective Genetic Algorithm，MOGA）是一种用于解决多目标优化问题的进化计算方法，它基于遗传算法的原理并针对多目标性质做了相应的改进和优化。</p><p>MOGA的原理和特点如下所示：</p><ol><li><p>多目标性质考虑：MOGA与传统的遗传算法的不同之处在于，它针对多目标优化问题，即在优化过程中需要同时考虑多个目标函数。这些目标函数往往相互矛盾，无法一次性达到全局最优解。MOGA试图在解空间中寻找一个解集，这个解集包含了多个不同的个体，每个个体都是一个可能的解。</p></li><li><p>多目标优化：MOGA的目标是通过优化种群中个体的适应度来找到一组最优解，这组解在多个目标函数上均能提供较好的性能。这些最优解通常形成一个帕累托前沿（Pareto front），即无法在一个目标上进一步改进而不损害其他目标。</p></li><li><p>多样性维持：MOGA具有维持个体多样性的特点，即通过种群中个体之间的遗传操作（交叉、变异）来产生新的个体，并保持原有个体的多样性。这有助于避免收敛到局部最优解，并提高搜寻空间的覆盖度。</p></li><li><p>Pareto支配关系：MOGA使用Pareto支配关系来比较个体之间的优劣。一个个体在目标函数上支配另一个个体，意味着它在至少一个目标上优于另一个个体而不劣于它在其他目标上的表现。根据Pareto支配关系，积极的支配关系和非支配排序等方法被用于选择个体和形成帕累托前沿。</p></li><li><p>前沿选择：MOGA通常通过选择其中一定数量的帕累托前沿个体来作为最终解集。这些解集代表了多个最优解之间的权衡和平衡，可以提供决策者在多目标优化问题中的选择。</p></li></ol><p>总结起来，MOGA是基于遗传算法的一种多目标优化方法，通过形成帕累托前沿来找到多个性能良好且相互独立的解。与单目标优化相比，MOGA在解决具有多个目标函数的优化问题方面更具优势，并能够保持解集中个体的多样性。</p></blockquote><h2 id="方法设计" tabindex="-1"><a class="header-anchor" href="#方法设计" aria-hidden="true">#</a> 方法设计</h2><p><strong>API依赖收集</strong></p><h3 id="收集api数据依赖" tabindex="-1"><a class="header-anchor" href="#收集api数据依赖" aria-hidden="true">#</a> 收集API数据依赖</h3><p>存在数据依赖的两个API，A和B之间的关系为：</p><ol><li>函数A的返回值（return value）被用做函数B的输入参数。</li><li>函数A的输出参数被用做函数B的输入参数。</li></ol><h3 id="函数的输出和返回值" tabindex="-1"><a class="header-anchor" href="#函数的输出和返回值" aria-hidden="true">#</a> ###函数的输出和返回值？</h3><blockquote><p>函数的输出和返回值并不完全是同一个意思，尽管它们有一定的关联。下面是它们的具体解释：</p><p>函数的输出：函数的输出是指函数在执行完成后，生成的结果或者产生的效果。它可以是函数的实际返回值，也可以是函数对外部环境产生的修改（例如，修改全局变量的值或者打印输出等）。函数的输出可以是多个，取决于函数的设计和实现。</p><p>返回值：返回值是指函数在执行完成后，通过 <code>return</code> 语句返回给调用者的值。返回值通常是函数的输出之一，用于传递函数内部计算的结果或者其他必要的信息。在大多数编程语言中，函数可以指定返回值的类型，并使用 <code>return</code> 关键字将结果返回给调用者。</p><p>尽管函数的输出和返回值可能是相同的，但是它们并不总是等价的。一个函数可以具有多个输出，但只有一个返回值。当函数有多个输出时，可以通过输入参数的方式来获取不同的输出结果。而返回值是函数提供给调用者的结果，用于使用或者进一步处理。</p><p>值得注意的是，某些编程语言中并不要求函数必须有返回值，或者允许函数返回 <code>void</code> 类型的值表示没有具体返回值。在这些情况下，函数的输出可能主要通过其他方式实现，例如全局变量的修改或者其他副作用。</p><p>总结来说，函数的输出是指函数完成后的结果或者效果，而返回值是函数通过 <code>return</code> 语句返回给调用者的值。它们在一些情况下是相同的，但在其他情况下可能存在差异。</p></blockquote><p>收集数据依赖方法核心是通过<em>匹配API函数参数/返回值的类型和值来实现</em>，</p><ul><li>首先从SDK头文件中提取类型信息，</li><li>接着对consumer program的API调用进行trace收集，</li><li>trace收集时会记录下API的参数。</li></ul><p>收集完数据依赖后，APICRAFT会推断数据依赖：</p><ul><li>R1：<strong>Dependency-based transition</strong>：假如函数A的输出是函数C的输入，函数A的输出是函数D的输入，函数B的输出是函数C的输入，那么函数B的输出是函数D的输入</li></ul><figure><img src="'+u+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图4 Dependency-based transition</p><h3 id="依赖关系传递" tabindex="-1"><a class="header-anchor" href="#依赖关系传递" aria-hidden="true">#</a> ###依赖关系传递？</h3><blockquote><p>这种推导过程可以基于依赖关系，使用依赖关系的传递性来进行推理。</p><p>原理是基于函数之间的输入和输出依赖关系。如果函数A的输出是函数C的输入，并且函数A的输出也是函数D的输入，那么可以得出函数C和函数D之间也存在输入和输出依赖关系。同样地，如果函数B的输出是函数C的输入，那么根据传递性，我们可以推断出函数B的输出也是函数D的输入。</p><p>这个原理是基于依赖关系传递的特性，当函数之间存在输入和输出的依赖关系时，这种依赖关系可以沿着链式传递下去，从而可以推断出更多函数之间的依赖关系。</p><p>因此，在给定的情况下，我们可以推断出函数B的输出是函数D的输入，基于函数A的输出是函数D的输入，以及函数B的输出是函数C的输入的依赖关系。</p></blockquote><ul><li>R2：<strong>Type-based transition</strong>：如果函数A的输出类型和函数B的输入类型一样，那么函数A的输出是函数B的输入</li></ul><figure><img src="'+z+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图5 Type-based transition</p><ul><li>R3：<strong>Inter-thread data flow dependency</strong>：假如在线程T1上执行的函数A与线程T2上执行的函数B满足数据依赖，且参数类型是指针，那么A与B存在依赖</li></ul><h3 id="收集api控制依赖" tabindex="-1"><a class="header-anchor" href="#收集api控制依赖" aria-hidden="true">#</a> 收集API控制依赖</h3><p>控制依赖用于fuzz driver的语法检查，获知<mark>API函数的输出</mark>是否需要<strong>进行错误处理</strong>以及<strong>产生错误的分支</strong>。</p><p>控制依赖的收集通过对不同类型的函数输出使用不同的策略来完成：</p><ul><li>如果API函数的输出参数或返回值的规范类型是指针，则生成的模糊驱动程序将始终检查输出值是否为NULL(如果为NULL则立即退出)。</li><li>如果类型是整数，APICRAFT将尝试定位consumer program错误检查的条件分支，并转储错误检查条件(假设consumer program在良性输入下不会执行错误分支)。</li></ul><h3 id="api依赖整合" tabindex="-1"><a class="header-anchor" href="#api依赖整合" aria-hidden="true">#</a> API依赖整合</h3><p>收集了API间的数据依赖和控制依赖后，接下来是整合依赖以生成高质量的fuzz driver。</p><p>APICRAFT 用三个关键指标衡量fuzz driver的质量：</p><blockquote><p>目标函数？</p></blockquote><ul><li>A. 多样性（Diversity）指fuzz driver能够调用足够多样的API使fuzz driver程序行为更丰富。</li><li>B. 有效性（Effectiveness）是这三个指标中的唯一一个需要动态反馈信息的指标，其目标是要让生成的fuzz driver的API调用更合法有效。</li><li>C. 紧凑性（Compactness）与fuzz driver的API数目相关，目的是去除冗余API调用。</li></ul><p>为了使生成的fuzz driver在整合依赖的同时满足上述三个关键指标，APICRAFT提出一个称为“<mark>多目标优化</mark>”的基于NSGA-II的遗传算法。在此算法中，一个基因代表<mark>一个数据依赖</mark>，一个染色体对应是<mark>一组链接的数据依赖</mark>。与经典遗传算法相比，此算法特别的是，其排序策略能够处理多个目标。假设现在只有三个目标，目标得分可以用来建立一个三维坐标系和染色体的点。在坐标系中，一个染色体在最外层意味着没有任何一个染色体在所有目标中都能有比它更高的得分。</p><p>算法排序策略分为两个阶段。</p><ul><li>第一个阶段通过反复选择最外层的染色体，来将染色体分成若干层（也称 帕累托边界）。</li><li>第二个阶段对每个染色体计算一个分数，并选择分数最高的染色体参加下一轮进化，每个染色体的分数等于其与相邻染色体在坐标系中的距离（成为拥挤度）。</li><li>当算法迭代到结束时，最后一轮进化的第一个帕累托边界上的所有染色体即是最优染色体。</li></ul><h2 id="方法实现" tabindex="-1"><a class="header-anchor" href="#方法实现" aria-hidden="true">#</a> 方法实现</h2><p>工具代码实现有两个关键处：</p><ol><li>仅关注外部程序对SDK API的调用：忽视SDK内部调用逻辑。</li><li><mark>轻量级动态trace框架</mark>：使用Type-II方式而不是Type-I方式的Hook，Type -II 类型的hook能提供精确的函数嵌套级别（图6）。除此之外，通过将hook的代码包装到一个与想要hook的API原型相同的函数中，并设置环境变量来配置操作系统的动态链接器，来实现运行时的轻量级开销。</li></ol><figure><img src="'+h+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图6 hook 类型</p><h3 id="轻量级trace框架" tabindex="-1"><a class="header-anchor" href="#轻量级trace框架" aria-hidden="true">#</a> ###轻量级trace框架</h3><blockquote><p>轻量级trace框架是一种用于在应用程序中捕获和记录调试信息的工具。它提供了一种简单而轻量级的方式来插入跟踪代码，从而在应用程序的不同部分收集有关执行的详细信息。</p><p>轻量级trace框架的主要作用是帮助开发人员快速诊断和修复代码中的问题。通过追踪程序执行路径、记录函数调用、输出变量值等信息，轻量级trace框架可以提供对程序行为的深入洞察，帮助开发人员快速定位错误、理解代码的执行过程，以及跟踪代码中的数据流。</p><p>轻量级trace框架的意义在于：</p><ol><li><p>调试和故障排除：通过追踪代码执行过程，开发人员可以更轻松地识别问题所在，定位和修复错误。它可以提供有关代码行为的详细信息，以帮助开发人员更好地理解程序的执行流程。</p></li><li><p>性能优化：使用轻量级trace框架可以帮助开发人员分析代码的性能瓶颈，并针对性地进行优化。通过追踪函数调用、记录执行时间等信息，可以发现代码中的潜在性能问题。</p></li><li><p>学习和理解代码：通过查看轻量级trace框架生成的跟踪日志，开发人员可以深入了解代码是如何执行的，并在阅读和理解代码时提供更多参考。这对于阅读他人的代码、学习新的代码库或进行代码审查非常有帮助。</p></li></ol><p>一些常见的轻量级trace框架包括：</p><ol><li><p><code>logging</code>模块：Python的标准库中自带的日志框架，提供了灵活的日志记录功能，并且可以方便地配置和集成到应用程序中。</p></li><li><p><code>trace</code>模块：Python的内置模块，允许追踪函数的调用和返回，可以用于对代码进行详细的分析和测试。</p></li><li><p><code>pysnooper</code>：一个用于Python的小型、可配置的调试器，可以通过装饰器直接应用于函数来追踪代码的执行过程，记录变量的值等。</p></li></ol><p>这些是一些常见的开源轻量级trace框架，但并不是唯一的选择。具体选择哪个框架取决于你的需求和好感，可以根据自己的项目需要进行调研和评估。</p></blockquote><h2 id="实验评估" tabindex="-1"><a class="header-anchor" href="#实验评估" aria-hidden="true">#</a> 实验评估</h2><p>APICRAFT对macOS上的5个攻击面进行漏洞挖掘，这5个攻击面分别是image，Font，PDF，Audio，RTF。它们对应的macOS consumer program包括Preview，Safari，Messages, Mail, Quicktime Player等。</p><p>下图展示了fuzz driver生成过程的中间结果：</p><figure><img src="'+g+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图7 fuzz driver 生成过程的中间结果</p><p>由此可以看出：</p><ul><li>APICRAFT 能够在<mark>复杂的GUI程序</mark>中跟踪数百个目标API函数</li><li>大部分攻击面含有上万的依赖项，<mark>组合依赖项</mark>面临着广阔的搜索空间</li><li>使用遗传算法生成的 Fuzz Driver 在期望的属性上有显著改进</li></ul><p>作者还将APICRAFT生成的fuzz driver与研究人员构造的fuzz driver进行对比。下图每个子图中的<em>紫色线</em>都是APICraft生成的fuzz driver在fuzzing时的覆盖率，<strong>浅色线</strong>则是人工构造的fuzz driver的覆盖率。这些结果表明，在大多数情况下，APICraft生成的fuzz driver明显优于手动编写的对应fuzzer driver。</p><figure><img src="'+m+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图8 APICraft 与人工编写的 fuzz driver 覆盖率对比</p><p>除了覆盖率指标，作者基于生成的fuzz driver进行漏洞挖掘，结果显示，一共发现了142处漏洞，并收到Apple 公司54个官方致谢，如下所示。</p><figure><img src="'+f+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>图9：real-world 实验结果</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>作者提出了APICRAFT，一种针对于闭源SDK自动化生成fuzz driver框架。APICRAFT首先通过动静态分析获取API的trace记录，接着基于trace记录获取API间的数据依赖和控制依赖，最后再使用多目标优化遗传算法生成满足“多样性”、“有效性”以及“紧凑性”的fuzz driver。在实验环节，作者使用APICRAFT发现了macOS上142处漏洞，获得了Apple公司54个官方致谢。</p>',88);function v(b,_){const i=o("ExternalLinkIcon");return p(),t("div",null,[P,r("p",null,[r("a",I,[e("https://www.usenix.org/conference/usenixsecurity21/presentation/zhang-cen"),n(i)])]),k])}const D=l(A,[["render",v],["__file","91-白泽带你读论文｜APICraft.html.vue"]]);export{D as default};
