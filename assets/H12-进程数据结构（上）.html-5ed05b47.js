import{_ as p}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o as c,c as i,a as n,b as s,e,d as o}from"./app-cdabc73c.js";const r="/assets/75c4d28a9d2daa4acc1107832be84e2d-acbef299.jpeg",d="/assets/e0019fcd11ff1ba33a3389e285b6a121-8d691b6e.jpg",l="/assets/e2fa348c67ce41ef730048ff9ca4c988-4ed53fa6.jpeg",k="/assets/016ae7fb63f8b3fd0ca072cb9964e3e8-6d2f0dad.jpeg",u={},m=o('<h1 id="_12-进程数据结构-上-项目多了就需要项目管理系统" tabindex="-1"><a class="header-anchor" href="#_12-进程数据结构-上-项目多了就需要项目管理系统" aria-hidden="true">#</a> 12 | 进程数据结构（上）：项目多了就需要项目管理系统</h1><p>前面两节，我们讲了如何使用系统调用，创建进程和线程。你是不是觉得进程和线程管理，还挺复杂的呢？如此复杂的体系，在内核里面应该如何管理呢？</p><p>有的进程只有一个线程，有的进程有多个线程，它们都需要由内核分配 CPU 来干活。可是 CPU 总共就这么几个，应该怎么管理，怎么调度呢？你是老板，这个事儿得你来操心。</p><p>首先，我们得明确，公司的项目售前售后人员，接来了这么多的项目，这是个好事儿。这些项目都通过办事大厅立了项的，有的需要整个项目组一起开发，有的是一个项目组分成多个小组并行开发。无论哪种模式，到你这个老板这里，都需要有一个项目管理体系，进行统一排期、统一管理和统一协调。这样，你才能对公司的业务了如指掌。</p><p>那具体应该怎么做呢？还记得咱们平时开发的时候，用的项目管理软件 Jira 吧？它的办法对我们来讲，就很有参考意义。</p><p>我们这么来看，其实，无论是一个大的项目组一起完成一个大的功能（单体应用模式），还是把一个大的功能拆成小的功能并行开发（微服务模式），这些都是开发组根据客户的需求来定的，项目经理没办法决定，但是从项目经理的角度来看，这些都是任务，需要同样关注进度、协调资源等等。</p><h2 id="内核-任务-task-struct" tabindex="-1"><a class="header-anchor" href="#内核-任务-task-struct" aria-hidden="true">#</a> 内核/任务/task_struct</h2><p>同样在 Linux 里面，无论是进程，还是线程，到了内核里面，我们统一都叫<mark>任务（Task）</mark>，由一个统一的结构 <strong><code>task_struct</code></strong> 进行管理。这个结构非常复杂，但你也不用怕，我们慢慢来解析。</p><img src="'+r+`" alt="img" style="zoom:25%;"><p>接下来，我们沿着建立项目管理体系的思路，设想一下，<strong>Linux 的任务管理都应该干些啥？</strong></p><p>首先，所有执行的项目应该有个项目列表吧，所以 Linux 内核也应该先弄一个**<mark>链表</mark>**，将所有的 task_struct 串起来。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">list_head</span>    tasks<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>接下来，我们来看每一个任务都应该包含哪些字段。</p><h2 id="任务-id" tabindex="-1"><a class="header-anchor" href="#任务-id" aria-hidden="true">#</a> 任务 ID</h2><p>每一个任务都应该有一个 ID，作为这个任务的唯一标识。到时候排期啊、下发任务啊等等，都按 ID 来，就不会产生歧义。</p><p>task_struct 里面涉及任务 ID 的，有下面几个：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>
<span class="token class-name">pid_t</span> tgid<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>group_leader<span class="token punctuation">;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="如何区分进程线程" tabindex="-1"><a class="header-anchor" href="#如何区分进程线程" aria-hidden="true">#</a> 如何区分进程线程?</h3><p>你可能觉得奇怪，既然是 ID，有一个就足以做唯一标识了，这个怎么看起来这么麻烦？这是因为，上面的进程和线程到了内核这里，统一变成了任务，这就带来两个问题。</p><p>第一个问题是，<strong>任务展示</strong>。</p><p>啥是任务展示呢？这么说吧，你作为老板，想了解的肯定是，公司都接了哪些项目，每个项目多少营收。什么项目执行是不是分了小组，每个小组是啥情况，这些细节，项目经理没必要全都展示给你看。</p><p>前面我们学习命令行的时候，知道 ps 命令可以展示出所有的进程。但是如果你是这个命令的实现者，到了内核，按照上面的任务列表把这些命令都显示出来，把所有的线程全都平摊开来显示给用户。用户肯定觉得既复杂又困惑。复杂在于，列表这么长；困惑在于，里面出现了很多并不是自己创建的线程。</p><p>第二个问题是，<strong>给任务下发指令</strong>。</p><p>如果客户突然给项目组提个新的需求，比如说，有的客户觉得项目已经完成，可以终止；再比如说，有的客户觉得项目做到一半没必要再进行下去了，可以中止，这时候应该给谁发指令？当然应该给整个项目组，而不是某个小组。我们不能让客户看到，不同的小组口径不一致。这就好比说，中止项目的指令到达一个小组，这个小组很开心就去休息了，同一个项目组的其他小组还干的热火朝天的。</p><p>Linux 也一样，前面我们学习命令行的时候，知道可以通过 kill 来给进程发信号，通知进程退出。如果发给了其中一个线程，我们就不能只退出这个线程，而是应该退出整个进程。当然，有时候，我们希望只给某个线程发信号。</p><h3 id="pid-tgid-group-leader" tabindex="-1"><a class="header-anchor" href="#pid-tgid-group-leader" aria-hidden="true">#</a> pid / tgid / group_leader</h3><p>所以在内核中，它们虽然都是任务，但是应该加以区分。其中，<code>pid</code> 是 process id，<code>tgid</code> 是 thread group ID。</p><ul><li><p>任何一个进程，如果只有主线程，那 pid 是自己，tgid 是自己，<code>group_leader</code> 指向的还是自己。</p></li><li><p>但是，如果一个进程创建了其他线程，那就会有所变化了。线程有自己的 pid，tgid 就是进程的主线程的 pid，<code>group_leader</code> 指向的就是进程的主线程。</p></li></ul><p>好了，有了 tgid，我们就知道 tast_struct 代表的是一个进程还是代表一个线程了。</p><h2 id="信号处理" tabindex="-1"><a class="header-anchor" href="#信号处理" aria-hidden="true">#</a> 信号处理</h2><p>这里既然提到了下发指令的问题，我就顺便提一下 task_struct 里面关于信号处理的字段。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/* Signal handlers: */</span>
<span class="token keyword">struct</span> <span class="token class-name">signal_struct</span>    <span class="token operator">*</span>signal<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">sighand_struct</span>    <span class="token operator">*</span>sighand<span class="token punctuation">;</span>
<span class="token class-name">sigset_t</span>      blocked<span class="token punctuation">;</span>
<span class="token class-name">sigset_t</span>      real_blocked<span class="token punctuation">;</span>
<span class="token class-name">sigset_t</span>      saved_sigmask<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">sigpending</span>    pending<span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span>      sas_ss_sp<span class="token punctuation">;</span>
<span class="token class-name">size_t</span>        sas_ss_size<span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span>      sas_ss_flags<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里定义了</p><ol><li>哪些信号<strong>被阻塞暂不处理</strong>（<code>blocked</code>），</li><li>哪些信号<strong>尚等待处理</strong>（<code>pending</code>），</li><li>哪些信号<strong>正在通过信号处理函数进行处理</strong>（<code>sighand</code>）。处理的结果可以是<code>忽略?</code>，可以是<code>结束进程?</code>等等。</li></ol><p><mark>信号处理函数</mark>默认使用<mark>用户态的函数栈</mark>，当然也可以<mark>开辟新的栈专门用于信号处理</mark>，这就是 sas_ss_xxx 这三个变量的作用。</p><h3 id="本任务的-线程组共享的" tabindex="-1"><a class="header-anchor" href="#本任务的-线程组共享的" aria-hidden="true">#</a> 本任务的 / 线程组共享的</h3><p>上面我说了<strong>下发信号的时候</strong>，需要区分进程和线程。从这里我们其实也能看出一些端倪。</p><p>task_struct 里面有一个 struct sigpending pending。如果我们进入 struct signal_struct *signal 去看的话，还有一个 struct sigpending shared_pending。它们一个是本任务的，一个是线程组共享的。</p><p>关于信号，你暂时了解到这里就够用了，后面我们会有单独的章节进行解读。</p><h2 id="任务状态" tabindex="-1"><a class="header-anchor" href="#任务状态" aria-hidden="true">#</a> 任务状态</h2><p>作为一个项目经理，另外一个需要关注的是项目当前的状态。例如，在 <code>Jira</code> 里面，任务的运行就可以分成下面的状态。</p><img src="`+d+`" alt="img" style="zoom:25%;"><p>在 task_struct 里面，涉及任务状态的是下面这几个变量：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code> <span class="token keyword">volatile</span> <span class="token keyword">long</span> state<span class="token punctuation">;</span>    <span class="token comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span>
 <span class="token keyword">int</span> exit_state<span class="token punctuation">;</span>
 <span class="token keyword">unsigned</span> <span class="token keyword">int</span> flags<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>state（状态）可以取的值定义在 include/linux/sched.h 头文件中。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/* Used in tsk-&gt;state: */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_RUNNING</span>                    <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_INTERRUPTIBLE</span>              <span class="token expression"><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_UNINTERRUPTIBLE</span>            <span class="token expression"><span class="token number">2</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__TASK_STOPPED</span>                  <span class="token expression"><span class="token number">4</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__TASK_TRACED</span>                   <span class="token expression"><span class="token number">8</span></span></span>
<span class="token comment">/* Used in tsk-&gt;exit_state: */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EXIT_DEAD</span>                       <span class="token expression"><span class="token number">16</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EXIT_ZOMBIE</span>                     <span class="token expression"><span class="token number">32</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EXIT_TRACE</span>                      <span class="token expression"><span class="token punctuation">(</span>EXIT_ZOMBIE <span class="token operator">|</span> EXIT_DEAD<span class="token punctuation">)</span></span></span>
<span class="token comment">/* Used in tsk-&gt;state again: */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_DEAD</span>                       <span class="token expression"><span class="token number">64</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_WAKEKILL</span>                   <span class="token expression"><span class="token number">128</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_WAKING</span>                     <span class="token expression"><span class="token number">256</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_PARKED</span>                     <span class="token expression"><span class="token number">512</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_NOLOAD</span>                     <span class="token expression"><span class="token number">1024</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_NEW</span>                        <span class="token expression"><span class="token number">2048</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_STATE_MAX</span>                  <span class="token expression"><span class="token number">4096</span></span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从定义的数值很容易看出来，state 是通过 bitset 的方式设置的，也就是说，当前是什么状态，哪一位就置一。</p><img src="`+l+`" alt="img" style="zoom:25%;"><h3 id="a-task-running-就绪-运行" tabindex="-1"><a class="header-anchor" href="#a-task-running-就绪-运行" aria-hidden="true">#</a> [A] TASK_RUNNING 就绪/运行</h3><p><code>TASK_RUNNING</code> 并不是说进程正在运行，而是表示进程在时刻准备运行的状态。当处于这个状态的进程获得时间片的时候，就是在运行中；如果没有获得时间片，就说明它被其他进程抢占了，在等待再次分配时间片。</p><h3 id="b-io操作-睡眠-等待" tabindex="-1"><a class="header-anchor" href="#b-io操作-睡眠-等待" aria-hidden="true">#</a> [B] IO操作 -&gt; 睡眠/等待</h3><p>在运行中的进程，一旦要进行一些 I/O 操作，需要等待 I/O 完毕，这个时候会释放 CPU，进入睡眠状态。</p><p>在 Linux 中，有两种睡眠状态。</p><h4 id="_1-可中断的睡眠状态" tabindex="-1"><a class="header-anchor" href="#_1-可中断的睡眠状态" aria-hidden="true">#</a> 1 可中断的睡眠状态</h4><p>一种是 <strong>TASK_INTERRUPTIBLE</strong>，<strong>可中断的睡眠状态</strong>。这是一种浅睡眠的状态，也就是说，虽然在睡眠，等待 I/O 完成，但是这个时候一个信号来的时候，进程还是要被唤醒。只不过唤醒后，不是继续刚才的操作，而是进行信号处理。当然程序员可以根据自己的意愿，来写信号处理函数，例如收到某些信号，就放弃等待这个 I/O 操作完成，直接退出；或者收到某些信息，继续等待。</p><h4 id="_2-不可中断的睡眠状态" tabindex="-1"><a class="header-anchor" href="#_2-不可中断的睡眠状态" aria-hidden="true">#</a> 2 不可中断的睡眠状态</h4><p>另一种睡眠是 <strong>TASK_UNINTERRUPTIBLE</strong>，<strong>不可中断的睡眠状态</strong>。这是一种深度睡眠状态，不可被信号唤醒，只能死等 I/O 操作完成。一旦 I/O 操作因为特殊原因不能完成，这个时候，谁也叫不醒这个进程了。你可能会说，我 kill 它呢？别忘了，kill 本身也是一个信号，既然这个状态不可被信号唤醒，kill 信号也被忽略了。除非重启电脑，没有其他办法。</p><p>因此，这其实是一个比较危险的事情，除非程序员极其有把握，不然还是不要设置成 TASK_UNINTERRUPTIBLE。</p><h4 id="_3-可以终止的新睡眠状态" tabindex="-1"><a class="header-anchor" href="#_3-可以终止的新睡眠状态" aria-hidden="true">#</a> 3 可以终止的新睡眠状态</h4><p>于是，我们就有了一种新的进程睡眠状态，<strong>TASK_KILLABLE，可以终止的新睡眠状态</strong>。进程处于这种状态中，它的运行原理类似 TASK_UNINTERRUPTIBLE，只不过可以响应致命信号。</p><p>从定义可以看出，TASK_WAKEKILL 用于在接收到致命信号时唤醒进程，而 TASK_KILLABLE 相当于这两位都设置了。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_KILLABLE</span>           <span class="token expression"><span class="token punctuation">(</span>TASK_WAKEKILL <span class="token operator">|</span> TASK_UNINTERRUPTIBLE<span class="token punctuation">)</span></span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="c-stopped-traced" tabindex="-1"><a class="header-anchor" href="#c-stopped-traced" aria-hidden="true">#</a> [C] STOPPED/TRACED</h3><p><code>TASK_STOPPED</code> 是在进程接收到 SIGSTOP、SIGTTIN、SIGTSTP 或者 SIGTTOU 信号之后进入该状态。</p><p><code>TASK_TRACED</code> 表示进程被 debugger 等进程监视，进程执行被调试程序所停止。当一个进程被另外的进程所监视，每一个信号都会让进程进入该状态。</p><h3 id="d-结束-exit-zombie-exit-dead" tabindex="-1"><a class="header-anchor" href="#d-结束-exit-zombie-exit-dead" aria-hidden="true">#</a> [D] 结束: EXIT_ZOMBIE/EXIT_DEAD</h3><p>一旦一个进程要结束，先进入的是 <code>EXIT_ZOMBIE</code> 状态，</p><ul><li><p>但是如果这个时候它的父进程还没有使用 wait() 等系统调用来获知它的终止信息，此时进程就成了<mark>僵尸进程</mark>。</p><blockquote><p>一个进程要终止, 是需要通知父进程的! 不然就成了僵尸进程.</p></blockquote></li></ul><p><code>EXIT_DEAD</code> 是进程的最终状态。</p><p>EXIT_ZOMBIE 和 EXIT_DEAD 也可以用于 exit_state。</p><h3 id="标志flags-pf-exiting-vcpu-forknoexec" tabindex="-1"><a class="header-anchor" href="#标志flags-pf-exiting-vcpu-forknoexec" aria-hidden="true">#</a> 标志flags PF: EXITING/VCPU/FORKNOEXEC</h3><p>上面的进程状态和进程的运行、调度有关系，还有其他的一些状态，我们称为<strong>标志</strong>。放在 flags 字段中，这些字段都被定义成为<strong>宏</strong>，以 PF 开头。我这里举几个例子。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PF_EXITING</span>    <span class="token expression"><span class="token number">0x00000004</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PF_VCPU</span>      <span class="token expression"><span class="token number">0x00000010</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PF_FORKNOEXEC</span>    <span class="token expression"><span class="token number">0x00000040</span></span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong><code>PF_EXITING</code></strong> 表示正在退出。当有这个 flag 的时候，在函数 find_alive_thread 中，找活着的线程，遇到有这个 flag 的，就直接跳过。</p><p><strong><code>PF_VCPU</code></strong> 表示进程运行在虚拟 CPU 上。在函数 account_system_time 中，统计进程的系统运行时间，如果有这个 flag，就调用 account_guest_time，按照客户机的时间进行统计。</p><p><strong><code>PF_FORKNOEXEC</code></strong> 表示 fork 完了，还没有 exec。在 _do_fork 函数里面调用 copy_process，这个时候把 flag 设置为 PF_FORKNOEXEC。当 exec 中调用了 load_elf_binary 的时候，又把这个 flag 去掉。</p><h2 id="进程调度" tabindex="-1"><a class="header-anchor" href="#进程调度" aria-hidden="true">#</a> 进程调度</h2><p>进程的状态切换往往涉及调度，下面这些字段都是用于调度的。为了让你理解 task_struct 进程管理的全貌，我先在这里列一下，咱们后面会有单独的章节讲解，这里你只要大概看一下里面的注释就好了。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//是否在运行队列上</span>
<span class="token keyword">int</span>        on_rq<span class="token punctuation">;</span>
<span class="token comment">//优先级</span>
<span class="token keyword">int</span>        prio<span class="token punctuation">;</span>
<span class="token keyword">int</span>        static_prio<span class="token punctuation">;</span>
<span class="token keyword">int</span>        normal_prio<span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span>      rt_priority<span class="token punctuation">;</span>
<span class="token comment">//调度器类</span>
<span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span>  <span class="token operator">*</span>sched_class<span class="token punctuation">;</span>
<span class="token comment">//调度实体</span>
<span class="token keyword">struct</span> <span class="token class-name">sched_entity</span>    se<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">sched_rt_entity</span>    rt<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">sched_dl_entity</span>    dl<span class="token punctuation">;</span>
<span class="token comment">//调度策略</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span>      policy<span class="token punctuation">;</span>
<span class="token comment">//可以使用哪些CPU</span>
<span class="token keyword">int</span>        nr_cpus_allowed<span class="token punctuation">;</span>
<span class="token class-name">cpumask_t</span>      cpus_allowed<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">sched_info</span>    sched_info<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="总结时刻" tabindex="-1"><a class="header-anchor" href="#总结时刻" aria-hidden="true">#</a> 总结时刻</h2><p>这一节，我们讲述了进程管理复杂的数据结构，我还是画一个图总结一下。这个图是进程管理 task_struct 的结构图。其中红色的部分是今天讲的部分，你可以对着这张图说出它们的含义。</p><blockquote><p>简洁地展示出了进程调度的流程。用<code>任务</code>来统一管理进程和线程的确是好的系统设计思想，其后用<code>pid</code>和<code>tgid</code>的变量再来区分<code>进程</code>和<code>线程</code>。我猜使用链表的原因是为了便于删除和加入，因为线程的更替操作会很多，因此如果用数组的话，O(n)操作将非常耗时。另外，数组连续存储，进程栈8192KB的空间将会不太够。</p><ol><li><p>进程的标示 <code>pid/tgid/group_leader</code> 是用来方便区分任务是<code>线程</code>还是<code>进程</code>，</p><p>而区分二者的需求来自远多维度的展示任务与向进程或者线程发送信号。</p></li><li><p>进程的状态设定同样来源于两个需求，<mark>监控统计</mark>任务的执行过程，以及<mark>调度</mark>任务。而任务的状态来自于处理任务的一般思路，</p><p>创建一个任务，准备处理任务，处理任务，任务被搁置，任务被解决，同时为了可以更加细粒度的<mark>监控进程</mark>引入 debug 的状态。</p></li></ol></blockquote><p>task成员包括<br> 1 任务标识<br> 2 任务状态<br> 3 运行统计<br> 4 调度信息<br> 5 亲缘关系<br> 6 权限信息<br> 7 信号处理<br> 8 内存管理<br> 9 文件相关<br> 10 内核栈</p><img src="`+k+'" alt="img" style="zoom:33%;"><blockquote><ul><li><p>内核中进程, 线程统一为<mark>任务</mark>, 由 <code>taks_struct</code> 表示</p></li><li><p>通过<code>链表</code>串起 task_struct</p></li><li><p>task_struct 中包含: <code>任务ID; 任务状态; 信号处理相关字段; 调度相关字段; 亲缘关系;</code></p><p><code>权限相关; 运行统计; 内存管理; 文件与文件系统; 内核栈;</code></p></li><li><p>任务 ID; 包含 pid, tgid 和 <code>group_leader</code></p></li><li><p><code>pid</code>(process id, 线程的id);</p><ul><li><p><code>tgid</code>(thread group id, 所属进程[主线程]的id);</p></li><li><p><code>group_leader</code> 指向 tgid 的结构体 的 [指针]</p></li><li><p>通过对比 pid 和 tgid 可判断是<code>进程</code>还是<code>线程</code><br> - tgid和threadleader都是进程的主线程，那这两个参数不就重复了么？有其他的含义么？</p><pre><code> 	作者回复: 一个是id，一个是指针，只知道ID，不得一个个找么。一个是`值`，一个是`指针`用于快速访问。\n</code></pre></li></ul></li><li><p>信号处理, 包含阻塞暂不处理; 等待处理; 正在处理的信号</p></li><li><p>信号处理函数默认使用用户态的函数栈, 也可以开辟新的栈专门用于信号处理, 由 sas_ss_xxx 指定</p><ul><li>通过 pending/shared_pending 区分进程和线程的信号</li></ul></li><li><p>任务状态; 包含 state; exit_state; flags</p></li><li><p>准备运行状态 TASK_RUNNING</p><ul><li>睡眠状态：可中断; 不可中断; 可杀</li><li>可中断 TASK_INTERRUPTIBLE, 收到信号要被唤醒 <ul><li>不可中断 TASK_UNINTERRUPTIBLE, 收到信号不会被唤醒, 不能被kill, 只能重启</li><li>可杀 TASK_KILLABLE, 可以响应致命信号, 由不可中断与 TASK_WAKEKILL 组合</li></ul></li><li>停止状态 TASK_STOPPED, 由信号 SIGSTOP, SIGTTIN, SIGTSTP 与 SIGTTOU 触发进入</li><li>调试跟踪 TASK_TRACED， 被 debugger 等进程监视时进入</li><li>结束状态(包含 exit_state)</li><li>EXIT_ZOMBIE, 父进程还没有 wait() <ul><li>EXIT_DEAD, 最终状态</li></ul></li><li>flags, 例如 PF_VCPU 表示运行在虚拟 CPU 上; PF_FORKNOEXEC _do_fork 函数里设置, exec 函数中清除</li></ul></li><li><p>进程调度; 包含 是否在运行队列; 优先级; 调度策略; 可以使用那些 CPU 等信息.</p></li></ul></blockquote><h2 id="课堂练习" tabindex="-1"><a class="header-anchor" href="#课堂练习" aria-hidden="true">#</a> 课堂练习</h2><p>这一节我们讲了任务的状态，你可以试着在代码里面搜索一下这些状态改变的地方是哪个函数，是什么时机，从而进一步理解任务的概念。</p><p>欢迎留言和我分享你的疑惑和见解，也欢迎你收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习、进步。</p><h2 id="课后讨论" tabindex="-1"><a class="header-anchor" href="#课后讨论" aria-hidden="true">#</a> 课后讨论</h2><p>有个问题一直纠结，<strong>信号处理函数</strong>到底是在哪个线程中运行的？<br> 作者回复: <strong>不在任何一个线程中</strong>，后面会详细解析信号处理的过程</p><p>如果进程创建了其他多个线程，那么tpid就是主线程id，pid就是其他线程id了，两者肯定不相等啊<br> 作者回复: 对的</p><p>tgid和threadleader都是进程的主线程，那这两个参数不就重复了么？有其他的含义么？<br> 作者回复: 一个是id，一个是指针，只知道ID，不得一个个找么。一个是<strong>值</strong>，一个是<strong>指针</strong>用于快速访问。</p><p>任何一个进程，如果只有主线程，那 pid 是自己，tgid 是自己，group_leader 指向的还是自己。但是有多个线程就不一样了，pid是这个子线程，tgid和group_leader都是指向主线程。 好奇，tgid与group_leader不就相同作用吗？在上面的二种情况下，为什么需要二个相同功能的域？<br> 作者回复: <strong>一个是id，一个是地址，有地址就能直接找到了</strong></p><p>举一反三一下，因为线程和进程都是task_struct表示的，所以有僵尸进程，那就有<mark>僵尸线程</mark><br> 作者回复: 对的pthread_join</p><p>看文章理解的task_struct 是 Thread 的一个链表？<br> 作者回复: <strong>进程和线程在一起的链表</strong></p><p>老师，请教一下，之前看书上说用户进程和内核线程是多对多的模型？这个怎么理解，我们常用的发行版又是什么样的模型？<br> 作者回复: 操作系统的理论是有多种模型的，多对一，一对一，多对多，Linux是<strong>一对一</strong>。</p><p>老师好，有个疑惑所有的task_struct为什么用<strong>链表</strong>串联起来而不是用数组<br> 作者回复: <strong>很多插入和删除</strong></p><p>源码是：<code>include/linux/sched.h</code> 老师把代码归纳了一下，方便理解</p><p>如果一个进程只有主线程，那么task_struct是一个还是两个？<br> 作者回复: 一个。这个task_struct<strong>既代表进程也代表主线程(内核只有任务这个概念)</strong></p><p>老师，可中断睡眠是不是对应软中断，不可中断睡眠对应硬中断，这几个对应关系能详细解释下嘛<br> 作者回复: <strong>不是的，和软硬中断没有关系，是信号到来的时候的处理机制问题</strong></p><p>那其实可以理解为linux内核调度的是task，而task可以是单线程的进程或者多线程进程的线程，我总感觉有点绕，为啥不能直接理解成linux调度的是thread.<br> 作者回复: 因为task还指向一些资源，我们一般说线程的时候，<code>不包括这些被进程管理的资源</code></p>',101),_={href:"https://garlicspace.com/2019/06/29/linux%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81%E5%AE%9A%E4%B9%89/",target:"_blank",rel:"noopener noreferrer"},h=n("br",null,null,-1),g=n("br",null,null,-1),v={href:"https://elixir.bootlin.com/linux/v4.13.16",target:"_blank",rel:"noopener noreferrer"},b=n("p",null,[s("task_struct是个描述每个任务的结构体，任务有个链表，结点就是每个任务的task_struct 是这个意思吗"),n("br"),s(" 作者回复: 是的")],-1);function T(x,E){const a=t("ExternalLinkIcon");return c(),i("div",null,[m,n("p",null,[s("目前理解的， 任务状态主要在TASK_RUNNING， TASK_INTERRUPTIBLE， TASK_UNINTERRUPTIBLE， TASK_KILLABLE间互相转换， 其他一些状态TASK_PARKED，TASK_NEW为了解决相关问题引入的。 学习笔记"),n("a",_,[s("https://garlicspace.com/2019/06/29/linux任务状态定义/"),e(a)]),h,s(" 作者回复: 赞")]),n("p",null,[s("要是老师把对应源码位置给出就好了，有时候找不到，可以么"),g,s(" 作者回复: 搜索函数名，很容易找到的，"),n("a",v,[s("https://elixir.bootlin.com/linux/v4.13.16"),e(a)])]),b])}const y=p(u,[["render",T],["__file","H12-进程数据结构（上）.html.vue"]]);export{y as default};
