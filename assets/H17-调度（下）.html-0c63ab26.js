import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as p,o as c,c as o,a as s,b as n,e as i,d as a}from"./app-cdabc73c.js";const u="/assets/93588d71abd7f007397979f0ba7def7f-8120d3ac.png",l={},r=a(`<h1 id="_17-调度-下-抢占式调度是如何发生的" tabindex="-1"><a class="header-anchor" href="#_17-调度-下-抢占式调度是如何发生的" aria-hidden="true">#</a> 17 | 调度（下）：抢占式调度是如何发生的？</h1><p>上一节，我们讲了主动调度，就是进程运行到一半，因为等待 I/O 等操作而主动让出 CPU，然后就进入了我们的“进程调度第一定律”。所有进程的调用最终都会走 __schedule 函数。那这个定律在这一节还是要继续起作用。</p><h2 id="抢占式调度" tabindex="-1"><a class="header-anchor" href="#抢占式调度" aria-hidden="true">#</a> 抢占式调度</h2><p>上一节我们讲的主动调度是第一种方式，第二种方式，就是抢占式调度。什么情况下会发生抢占呢？</p><p>最常见的现象就是<strong>一个进程执行时间太长了，是时候切换到另一个进程了</strong>。那怎么衡量一个进程的运行时间呢？在计算机里面有一个时钟，会过一段时间触发一次时钟中断，通知操作系统，时间又过去一个时钟周期，这是个很好的方式，可以查看是否是需要抢占的时间点。</p><p>时钟中断处理函数会调用 scheduler_tick()，它的代码如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">scheduler_tick</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> cpu <span class="token operator">=</span> <span class="token function">smp_processor_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq <span class="token operator">=</span> <span class="token function">cpu_rq</span><span class="token punctuation">(</span>cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>curr <span class="token operator">=</span> rq<span class="token operator">-&gt;</span>curr<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  curr<span class="token operator">-&gt;</span>sched_class<span class="token operator">-&gt;</span><span class="token function">task_tick</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> curr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">cpu_load_update_active</span><span class="token punctuation">(</span>rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">calc_global_load_tick</span><span class="token punctuation">(</span>rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个函数先取出当前 CPU 的运行队列，然后得到这个队列上当前正在运行中的进程的 task_struct，然后调用这个 task_struct 的调度类的 task_tick 函数，顾名思义这个函数就是来处理时钟事件的。</p><p>如果当前运行的进程是普通进程，调度类为 fair_sched_class，调用的处理时钟的函数为 task_tick_fair。我们来看一下它的实现。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">task_tick_fair</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token keyword">int</span> queued<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>se <span class="token operator">=</span> <span class="token operator">&amp;</span>curr<span class="token operator">-&gt;</span>se<span class="token punctuation">;</span>


  <span class="token function">for_each_sched_entity</span><span class="token punctuation">(</span>se<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cfs_rq <span class="token operator">=</span> <span class="token function">cfs_rq_of</span><span class="token punctuation">(</span>se<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">entity_tick</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> se<span class="token punctuation">,</span> queued<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>根据当前进程的 task_struct，找到对应的调度实体 sched_entity 和 cfs_rq 队列，调用 entity_tick。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">void</span>
<span class="token function">entity_tick</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token keyword">int</span> queued<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">update_curr</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">update_load_avg</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> UPDATE_TG<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">update_cfs_shares</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>cfs_rq<span class="token operator">-&gt;</span>nr_running <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token function">check_preempt_tick</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> curr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 entity_tick 里面，我们又见到了熟悉的 update_curr。它会更新当前进程的 vruntime，然后调用 check_preempt_tick。顾名思义就是，检查是否是时候被抢占了。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">check_preempt_tick</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>curr<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ideal_runtime<span class="token punctuation">,</span> delta_exec<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>se<span class="token punctuation">;</span>
  s64 delta<span class="token punctuation">;</span>


  ideal_runtime <span class="token operator">=</span> <span class="token function">sched_slice</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> curr<span class="token punctuation">)</span><span class="token punctuation">;</span>
  delta_exec <span class="token operator">=</span> curr<span class="token operator">-&gt;</span>sum_exec_runtime <span class="token operator">-</span> curr<span class="token operator">-&gt;</span>prev_sum_exec_runtime<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>delta_exec <span class="token operator">&gt;</span> ideal_runtime<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">resched_curr</span><span class="token punctuation">(</span><span class="token function">rq_of</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  se <span class="token operator">=</span> <span class="token function">__pick_first_entity</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
  delta <span class="token operator">=</span> curr<span class="token operator">-&gt;</span>vruntime <span class="token operator">-</span> se<span class="token operator">-&gt;</span>vruntime<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>delta <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>delta <span class="token operator">&gt;</span> ideal_runtime<span class="token punctuation">)</span>
    <span class="token function">resched_curr</span><span class="token punctuation">(</span><span class="token function">rq_of</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>check_preempt_tick 先是调用 sched_slice 函数计算出的 ideal_runtime。ideal_runtime 是一个调度周期中，该进程运行的实际时间。</p><p>sum_exec_runtime 指进程总共执行的实际时间，prev_sum_exec_runtime 指上次该进程被调度时已经占用的实际时间。每次在调度一个新的进程时都会把它的 se-&gt;prev_sum_exec_runtime = se-&gt;sum_exec_runtime，所以 sum_exec_runtime-prev_sum_exec_runtime 就是这次调度占用实际时间。如果这个时间大于 ideal_runtime，则应该被抢占了。</p><p>除了这个条件之外，还会通过 __pick_first_entity 取出红黑树中最小的进程。如果当前进程的 vruntime 大于红黑树中最小的进程的 vruntime，且差值大于 ideal_runtime，也应该被抢占了。</p><p>当发现当前进程应该被抢占，不能直接把它踢下来，而是把它标记为应该被抢占。为什么呢？因为进程调度第一定律呀，一定要等待正在运行的进程调用 __schedule 才行啊，所以这里只能先标记一下。</p><p>标记一个进程应该被抢占，都是调用 resched_curr，它会调用 set_tsk_need_resched，标记进程应该被抢占，但是此时此刻，并不真的抢占，而是打上一个标签 TIF_NEED_RESCHED。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">set_tsk_need_resched</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">set_tsk_thread_flag</span><span class="token punctuation">(</span>tsk<span class="token punctuation">,</span>TIF_NEED_RESCHED<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另外一个可能抢占的场景是<strong>当一个进程被唤醒的时候</strong>。</p><p>我们前面说过，当一个进程在等待一个 I/O 的时候，会主动放弃 CPU。但是当 I/O 到来的时候，进程往往会被唤醒。这个时候是一个时机。当被唤醒的进程优先级高于 CPU 上的当前进程，就会触发抢占。try_to_wake_up() 调用 ttwu_queue 将这个唤醒的任务添加到队列当中。ttwu_queue 再调用 ttwu_do_activate 激活这个任务。ttwu_do_activate 调用 ttwu_do_wakeup。这里面调用了 check_preempt_curr 检查是否应该发生抢占。如果应该发生抢占，也不是直接踢走当前进程，而是将当前进程标记为应该被抢占。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">ttwu_do_wakeup</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> wake_flags<span class="token punctuation">,</span>
         <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> <span class="token operator">*</span>rf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">check_preempt_curr</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> p<span class="token punctuation">,</span> wake_flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
  p<span class="token operator">-&gt;</span>state <span class="token operator">=</span> TASK_RUNNING<span class="token punctuation">;</span>
  <span class="token function">trace_sched_wakeup</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到这里，你会发现，抢占问题只做完了一半。就是标识当前运行中的进程应该被抢占了，但是真正的抢占动作并没有发生。</p><h2 id="抢占的时机" tabindex="-1"><a class="header-anchor" href="#抢占的时机" aria-hidden="true">#</a> 抢占的时机</h2><p>真正的抢占还需要时机，也就是需要那么一个时刻，让正在运行中的进程有机会调用一下 __schedule。</p><p>你可以想象，不可能某个进程代码运行着，突然要去调用 __schedule，代码里面不可能这么写，所以一定要规划几个时机，这个时机分为用户态和内核态。</p><h2 id="用户态的抢占时机" tabindex="-1"><a class="header-anchor" href="#用户态的抢占时机" aria-hidden="true">#</a> 用户态的抢占时机</h2><p>对于用户态的进程来讲，从系统调用中返回的那个时刻，是一个被抢占的时机。</p><p>前面讲系统调用的时候，64 位的系统调用的链路位 do_syscall_64-&gt;syscall_return_slowpath-&gt;prepare_exit_to_usermode-&gt;exit_to_usermode_loop，当时我们还没关注 exit_to_usermode_loop 这个函数，现在我们来看一下。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">exit_to_usermode_loop</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pt_regs</span> <span class="token operator">*</span>regs<span class="token punctuation">,</span> u32 cached_flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* We have work to do. */</span>
    <span class="token function">local_irq_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


    <span class="token keyword">if</span> <span class="token punctuation">(</span>cached_flags <span class="token operator">&amp;</span> _TIF_NEED_RESCHED<span class="token punctuation">)</span>
      <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在我们看到在 exit_to_usermode_loop 函数中，上面打的标记起了作用，如果被打了 _TIF_NEED_RESCHED，调用 schedule 进行调度，调用的过程和上一节解析的一样，会选择一个进程让出 CPU，做上下文切换。</p><p>对于用户态的进程来讲，从中断中返回的那个时刻，也是一个被抢占的时机。</p><p>在 arch/x86/entry/entry_64.S 中有中断的处理过程。又是一段汇编语言代码，你重点领会它的意思就行，不要纠结每一行都看懂。</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>common_interrupt:
        ASM_CLAC
        addq    $-0x80, (%rsp) 
        interrupt do_IRQ
ret_from_intr:
        popq    %rsp
        testb   $3, CS(%rsp)
        jz      retint_kernel
/* Interrupt came from user space */
GLOBAL(retint_user)
        mov     %rsp,%rdi
        call    prepare_exit_to_usermode
        TRACE_IRQS_IRETQ
        SWAPGS
        jmp     restore_regs_and_iret
/* Returning to kernel space */
retint_kernel:
#ifdef CONFIG_PREEMPT
        bt      $9, EFLAGS(%rsp)  
        jnc     1f
0:      cmpl    $0, PER_CPU_VAR(__preempt_count)
        jnz     1f
        call    preempt_schedule_irq
        jmp     0b
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>中断处理调用的是 do_IRQ 函数，中断完毕后分为两种情况，一个是返回用户态，一个是返回内核态。这个通过注释也能看出来。</p><p>咱们先来看返回用户态这一部分，先不管返回内核态的那部分代码，retint_user 会调用 prepare_exit_to_usermode，最终调用 exit_to_usermode_loop，和上面的逻辑一样，发现有标记则调用 schedule()。</p><h2 id="内核态的抢占时机" tabindex="-1"><a class="header-anchor" href="#内核态的抢占时机" aria-hidden="true">#</a> 内核态的抢占时机</h2><p>用户态的抢占时机讲完了，接下来我们看内核态的抢占时机。</p><p>对内核态的执行中，被抢占的时机一般发生在 preempt_enable() 中。</p><p>在内核态的执行中，有的操作是不能被中断的，所以在进行这些操作之前，总是先调用 preempt_disable() 关闭抢占，当再次打开的时候，就是一次内核态代码被抢占的机会。</p><p>就像下面代码中展示的一样，preempt_enable() 会调用 preempt_count_dec_and_test()，判断 preempt_count 和 TIF_NEED_RESCHED 是否可以被抢占。如果可以，就调用 preempt_schedule-&gt;preempt_schedule_common-&gt;__schedule 进行调度。还是满足进程调度第一定律的。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">preempt_enable</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> </span><span class="token punctuation">\\</span>
<span class="token expression"><span class="token keyword">do</span> <span class="token punctuation">{</span> </span><span class="token punctuation">\\</span>
  <span class="token expression"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token function">preempt_count_dec_and_test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> </span><span class="token punctuation">\\</span>
    <span class="token expression"><span class="token function">__preempt_schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </span><span class="token punctuation">\\</span>
<span class="token expression"><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>


<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">preempt_count_dec_and_test</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> </span><span class="token punctuation">\\</span>
  <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token function">preempt_count_sub</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">should_resched</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span></span></span>


<span class="token keyword">static</span> __always_inline bool <span class="token function">should_resched</span><span class="token punctuation">(</span><span class="token keyword">int</span> preempt_offset<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token function">preempt_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> preempt_offset <span class="token operator">&amp;&amp;</span>
      <span class="token function">tif_need_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">tif_need_resched</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">test_thread_flag</span><span class="token punctuation">(</span>TIF_NEED_RESCHED<span class="token punctuation">)</span></span></span>


<span class="token keyword">static</span> <span class="token keyword">void</span> __sched notrace <span class="token function">preempt_schedule_common</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">do</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">__schedule</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">need_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在内核态也会遇到中断的情况，当中断返回的时候，返回的仍然是内核态。这个时候也是一个执行抢占的时机，现在我们再来上面中断返回的代码中返回内核的那部分代码，调用的是 preempt_schedule_irq。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>asmlinkage __visible <span class="token keyword">void</span> __sched <span class="token function">preempt_schedule_irq</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">do</span> <span class="token punctuation">{</span>
    <span class="token function">preempt_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">local_irq_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">__schedule</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">local_irq_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sched_preempt_enable_no_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">need_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>preempt_schedule_irq 调用 __schedule 进行调度。还是满足进程调度第一定律的。</p><h2 id="总结时刻" tabindex="-1"><a class="header-anchor" href="#总结时刻" aria-hidden="true">#</a> 总结时刻</h2><p>好了，抢占式调度就讲到这里了。我这里画了一张脑图，将整个进程的调度体系都放在里面。</p><p>这个脑图里面第一条就是总结了进程调度第一定律的核心函数 __schedule 的执行过程，这是上一节讲的，因为要切换的东西比较多，需要你详细了解每一部分是如何切换的。</p><p>第二条总结了标记为可抢占的场景，第三条是所有的抢占发生的时机，这里是真正验证了进程调度第一定律的。</p><img src="`+u+'" alt="img" style="zoom:33%;"><blockquote><ul><li>抢占式调度</li><li>两种情况: 执行太久, 需切换到另一进程; 另一个高优先级进程被唤醒</li><li><code>执行太久</code>: 由时钟中断触发检测, 中断处理调用 scheduler_tick<br> - 取当前进程 task_struct-&gt;task_tick_fair()-&gt;取 sched_entity cfs_rq 调用 entity_tick()<br> - entity_tick() 调用 update_curr 更新当前进程 vruntime, 调用 check_preempt_tick 检测是否需要被抢占<br> - check_preempt_tick 中计算 ideal_runtime(一个调度周期中应该运行的实际时间), 若进程本次调度运行时间 &gt; ideal_runtime, 则应该被抢占<br> - 要被抢占, 则调用 resched_curr, 设置 TIF_NEED_RESCHED, 将其标记为应被抢占进程(因为要等待当前进程运行 <code>__schedule</code>) <ul><li><code>另一个高优先级进程被唤醒</code>: 当 I/O 完成, 进程被唤醒, 若优先级高于当前进程则触发抢占</li><li>try_to_wake_up()-&gt;ttwu_queue() 将唤醒任务加入队列 调用 ttwu_do_activate 激活任务 <ul><li>调用 tt_do_wakeup()-&gt;check_preempt_curr() 检查是否应该抢占, 若需抢占则标记</li></ul></li></ul></li><li>抢占时机: 让进程调用 <code>__schedule</code>, 分为用户态和内核态</li><li><mark>用户态进程</mark><br> - 时机-1: 从系统调用中返回, 返回过程中会调用 exit_to_usermode_loop, 检查 <code>_TIF_NEED_RESCHED</code>, 若打了标记, 则调用 schedule()<br> - 时机-2: 从中断中返回, 中断返回分为返回用户态和内核态(汇编代码: arch/x86/entry/entry_64.S), 返回用户态过程中会调用 exit_to_usermode_loop()-&gt;shcedule() <ul><li><mark>内核态进程</mark></li><li>时机-1: 发生在 preempt_enable() 中, 内核态进程有的操作不能被中断, 会调用 preempt_disable(), 在开启时(调用 preempt_enable) 时是一个抢占时机, 会调用 preempt_count_dec_and_test(), 检测 preempt_count 和标记, 若可抢占则最终调用 <code>__schedule</code><ul><li>时机-2: 发生在中断返回, 也会调用 <code>__schedule</code></li></ul></li></ul></li></ul></blockquote><h2 id="课堂练习" tabindex="-1"><a class="header-anchor" href="#课堂练习" aria-hidden="true">#</a> 课堂练习</h2><p>通过对于内核中进程调度的分析，我们知道，时间对于调度是很重要的，你知道 Linux 内核是如何管理和度量时间的吗？</p><p>欢迎留言和我分享你的疑惑和见解，也欢迎你收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习、进步。</p><h2 id="课后讨论" tabindex="-1"><a class="header-anchor" href="#课后讨论" aria-hidden="true">#</a> 课后讨论</h2>',56),d={href:"https://garlicspace.com/2019/08/04/linux%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E5%92%8C%E5%BA%A6%E9%87%8F%E6%97%B6%E9%97%B4/",target:"_blank",rel:"noopener noreferrer"},k=s("br",null,null,-1),_=a("<p>如果用户进程一直在用户态执行，没有发生系统调用和中断，就不会触发scheduler操作，那这个进程是不是一直占有CPU啊？<br> 作者回复: tick会中断他的</p><p>老师，想问一下，中断处理程序到底是由谁调用的，而且一切函数调用肯定需要栈，那中断在哪个栈上面执行，如果在一个单核的计算机上面，有一个进程处于用户态死循环，没有调用系统调用，如果这个时候发生了时间中断，内核是怎么处理的，怎么打断当前的进程，从而可能影响调度？<br> 作者回复: 后面有专门的节讲中断，到时候回来看，就对上了。中断的处理是在内核里面的，用不到进程的用户栈。当cpu收到中断的时候，就会停止当然指令的运行，去调用内核中的中断处理函数。应用再怎么死循环，内核里面说把他拿下来，不就拿下来了吗。</p><p>针对大部分留言说假如没有系统调用等，那岂不是会死循环这类问题。简单来说就是如果发生了中断，那么当前进程肯定会陷入内核态。所以可能会有标记步骤和真正的抢占步骤。详细点来说，当一个进程正在 CPU 上运行，如果发生时钟中断，那么需要去处理这个时钟中断，也就是会调用相应的中断处理函数，而相应的中断处理函数需要在内核态下执行，所以当前进程会陷入内核态，然后保存用户态的情况，然后判断是否需要进行标记。然后中断函数处理完之后，会返回用户态，这个时候又会发生抢占。<br> 作者回复: 对的</p><p>进程调度第一定律总结的太棒了。</p><p>另外有个问题想问下老师：我把整个调度系统想成一个进程，这个调度进程来实现task调度？ 如果是这样的，Linux如果跑在单CPU上，多进程是怎么调度的呢？<br> 作者回复: 不能把调度系统想象成一个进程，他是管家，不是干活的。不存在他和别人一起竞争的事情，他想把谁从cpu上拿下来，就能拿下来，他只要一改指令指针寄存器，就能拿下来</p><p>老师你讲得太好了，清楚易懂，我自己看了《Linux内核设计与实现》，然后接着看《深入Linux内核》，前前后后尝试看了几遍，但发现怎么也啃不下。看你的课，然后总结，有了总体思路后，再自己阅读内核代码，收获真的是太大了</p><p>“进程调度第一定律”，以及在内核中进程和线程统一用task_struct表示，让我想起了一个设计模式：组合模式（Composite Design Pattern）<br> 作者回复: 融会贯通</p><p>看了好几遍，感觉慢慢能串联起来，虽然不如经典的kernel书籍严谨和全面，但是更容易理解，讲的确实很不错，很受用，感谢老师！<br> 作者回复: 一句更容易理解胜过千言万语，谢谢</p><p>Linux内核通过时钟中断管理和度量时间.<br> Linux在初始化时会使用一个init_IRQ()函数设定定时周期(IRQ:Interrupt Request)，time_init()中调用setup_irq()设置时间中断向量irq 0；中断服务程序是timer_interrupt()，会调用另一个函数do_timer_interrupt(),do_timer_interrupt还会调用do_timer更新系统时间。do_timer中的工作包括，让全局变量jiffies增加1，并且调用update_process_times来更新进程的时间片以及修改进程的动态优先级...<br> 搜索的一点信息，期待老师的详细讲解</p><p>操作系统内核，最简化之后，其实就是一个大循环，通过各种中断，尤其是时钟的中断来推动内核的运行，直到收到退出信号为止。</p><p>今天对于“抢占式调度”，有了进一步的理解：“抢占”仍然是内核帮各个进程抢，而不是想获取CPU时间的进程自己抢的，想获取CPU时间的进程，只能采取把自己的进程优先级调高的方式，让自己排队靠前而已。说白了，内核只是用了一种更合理的方式，来更好的安排CPU运行时间，防止饥饿和霸占CPU资源。而这一切都是在内核里完成的，用户进程想获取CPU和让渡CPU都是要靠内核态。</p><p>物理内存统一管理 本身也是程序 他的内存如何管理<br> 作者回复: 物理内存的管理程序也是程序，也分代码部分和数据部分，代码部分当然在内核代码段里面了，系统启动的时候就加载了。数据部分大部分分配在直接映射区，也会分配页表，页表在哪里呢？页表的根在代码段的那个区域里面。</p><p>超哥 请教一个问题 对于单核看着上面的调度是灭有问题的 但是多核似乎有问题啊 这个多核cpu如何同步这个线程是否有调度呢？ 如果多核使用同一个调度队列他们是如何同步的呢<br> 作者回复: 对于操作系统看来，每个核是一个cpu</p><p>简单来说，调度就是解决什么时间调度，选哪个任务调度，怎么调度，换句话就是说CPU什么时候跑哪个任务，后两个问题对应老师导图的第一条，第一个对应老师导图的后两条，先得标记一下resched,然后在合适的时候进行调度<br> 作者回复: 谢谢夸奖，不敢不敢</p><p>请教一下，写一个死循环，循环里什么都不做，这个进程会被调度出去吗<br> 作者回复: 会，弄个高优先级的</p><p>老师好,如果一个进程开启特别多线程,线程执行内容都是死循环 循环体中执行sleep(3秒),如果内存足够大,会随着线程数增加,导致cpu使用率增加吗<br> 作者回复: 会呀</p><p>老师 发生调度就两种情况吗，主动让出，与被动调度?<br> 作者回复: 是的</p><p>管理的时间或者说度量的时间是否就是系统时钟，就像MCU中的时钟源一样呢？<br> 作者回复: 是的</p><p>task_struct中有指向调度类的指针，第15课调度（上）还有疑问不知道这个指针有什么用，在这一节找到了答案。</p><p>老师讲的比那些内核书上讲的好太多了。<br> 作者回复: 这样夸奖</p>",20);function v(m,b){const e=p("ExternalLinkIcon");return c(),o("div",null,[r,s("p",null,[n("linux内核依靠硬件定时电路特定时钟频率，tick rate，触发时钟中断，通过中断处理，实现系统时间更新， 定时器设置，延时处理， 学习笔记 "),s("a",d,[n("https://garlicspace.com/2019/08/04/linux如何管理和度量时间/"),i(e)]),k,n(" 作者回复: 赞，很牛")]),_])}const y=t(l,[["render",v],["__file","H17-调度（下）.html.vue"]]);export{y as default};
