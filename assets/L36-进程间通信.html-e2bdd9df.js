import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as a,d as e}from"./app-cdabc73c.js";const p="/assets/ed1fd2ede7a8fef5508c877e722345c9-8dec97e3.png",t="/assets/ac6ad6c9e7e3831f6d813113ae1c5ba4-e6e69038.png",o="/assets/df910e4383885b1aceaafb52b9bb5638-86da055d.png",c={},l=e('<h1 id="_36-进程间通信-遇到大项目需要项目组之间的合作才行" tabindex="-1"><a class="header-anchor" href="#_36-进程间通信-遇到大项目需要项目组之间的合作才行" aria-hidden="true">#</a> 36 | 进程间通信：遇到大项目需要项目组之间的合作才行</h1><p>前面咱们接项目的时候，主要强调项目之间的隔离性。这是因为，我们刚开始接的都是小项目。随着我们接的项目越来越多，就难免遇到大项目，这就需要多个项目组进行合作才能完成。</p><p>两个项目组应该通过什么样的方式进行沟通与合作呢？作为老板，你应该如何设计整个流程呢？</p><h2 id="管道模型" tabindex="-1"><a class="header-anchor" href="#管道模型" aria-hidden="true">#</a> <strong>管道模型</strong></h2><p>好在有这么多成熟的项目管理流程可以参考。最最传统的模型就是软件开发的<strong>瀑布模型</strong>（Waterfall Model）。所谓的瀑布模型，其实就是将整个软件开发过程分成多个阶段，往往是上一个阶段完全做完，才将输出结果交给下一个阶段。就像下面这张图展示的一样。</p><img src="'+p+`" alt="img" style="zoom:25%;"><p>这种模型类似进程间通信的**<code>管道模型</code>**。还记得咱们最初学 Linux 命令的时候，有下面这样一行命令：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>ps <span class="token operator">-</span>ef <span class="token operator">|</span> grep 关键字 <span class="token operator">|</span> awk <span class="token char">&#39;{print $2}&#39;</span> <span class="token operator">|</span> xargs kill <span class="token operator">-</span><span class="token number">9</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这里面的竖线“|”就是一个管道。它会将前一个命令的输出，作为后一个命令的输入。从管道的这个名称可以看出来，管道是一种单向传输数据的机制，它其实是一段缓存，里面的数据只能从一端写入，从另一端读出。如果想互相通信，我们需要创建两个管道才行。</p><p>管道分为两种类型，“|” 表示的管道称为<strong>匿名管道</strong>，意思就是这个类型的管道没有名字，用完了就销毁了。就像上面那个命令里面的一样，竖线代表的管道随着命令的执行自动创建、自动销毁。用户甚至都不知道自己在用管道这种技术，就已经解决了问题。所以这也是面试题里面经常会问的，到时候千万别说这是竖线，而要回答背后的机制，管道。</p><p>另外一种类型是<strong>命名管道</strong>。这个类型的管道需要通过 mkfifo 命令显式地创建。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>mkfifo hello
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>hello 就是这个管道的名称。管道以文件的形式存在，这也符合 Linux 里面一切皆文件的原则。这个时候，我们 ls 一下，可以看到，这个文件的类型是 p，就是 pipe 的意思。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">ls</span> <span class="token expression"><span class="token operator">-</span>l</span></span>
prw<span class="token operator">-</span>r<span class="token operator">--</span>r<span class="token operator">--</span>  <span class="token number">1</span> root root         <span class="token number">0</span> May <span class="token number">21</span> <span class="token number">23</span><span class="token operator">:</span><span class="token number">29</span> hello
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来，我们可以往管道里面写入东西。例如，写入一个字符串。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">echo</span> <span class="token string">&quot;hello world&quot;</span> <span class="token expression"><span class="token operator">&gt;</span> hello</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个时候，管道里面的内容没有被读出，这个命令就是停在这里的，这说明当一个项目组要把它的输出交接给另一个项目组做输入，当没有交接完毕的时候，前一个项目组是不能撒手不管的。</p><p>这个时候，我们就需要重新连接一个终端。在终端中，用下面的命令读取管道里面的内容：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">cat</span> <span class="token expression"><span class="token operator">&lt;</span> hello </span></span>
hello world
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>一方面，我们能够看到，管道里面的内容被读取出来，打印到了终端上；另一方面，echo 那个命令正常退出了，也即交接完毕，前一个项目组就完成了使命，可以解散了。</p><p>我们可以看出，瀑布模型的开发流程效率比较低下，因为团队之间无法频繁地沟通。而且，管道的使用模式，也不适合进程间频繁地交换数据。</p><p>于是，我们还得想其他的办法，例如我们是不是可以借鉴传统外企的沟通方式——邮件。邮件有一定的格式，例如抬头，正文，附件等，发送邮件可以建立收件人列表，所有在这个列表中的人，都可以反复地在此邮件基础上回复，达到频繁沟通的目的。</p><h2 id="消息队列模型" tabindex="-1"><a class="header-anchor" href="#消息队列模型" aria-hidden="true">#</a> <strong>消息队列模型</strong></h2><img src="`+t+`" alt="img" style="zoom:25%;"><p>这种模型类似进程间通信的消息队列模型。和管道将信息一股脑儿地从一个进程，倒给另一个进程不同，消息队列有点儿像邮件，发送数据时，会分成一个一个独立的数据单元，也就是消息体，每个消息体都是固定大小的存储块，在字节流上不连续。</p><p>这个消息结构的定义我写在下面了。这里面的类型 type 和正文 text 没有强制规定，只要消息的发送方和接收方约定好即可。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">msg_buffer</span> <span class="token punctuation">{</span>
    <span class="token keyword">long</span> mtype<span class="token punctuation">;</span>
    <span class="token keyword">char</span> mtext<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来，我们需要创建一个消息队列，使用 <strong>msgget 函数</strong>。这个函数需要有一个参数 key，这是消息队列的唯一标识，应该是唯一的。如何保持唯一性呢？这个还是和文件关联。</p><p>我们可以指定一个文件，ftok 会根据这个文件的 inode，生成一个近乎唯一的 key。只要在这个消息队列的生命周期内，这个文件不要被删除就可以了。只要不删除，无论什么时刻，再调用 ftok，也会得到同样的 key。这种 key 的使用方式在这一章会经常遇到，这是因为它们都属于 System V IPC 进程间通信机制体系中。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/msg.h&gt;</span></span>


<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> messagequeueid<span class="token punctuation">;</span>
  <span class="token class-name">key_t</span> key<span class="token punctuation">;</span>


  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>key <span class="token operator">=</span> <span class="token function">ftok</span><span class="token punctuation">(</span><span class="token string">&quot;/root/messagequeue/messagequeuekey&quot;</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
      <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">&quot;ftok error&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>


  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Message Queue key: %d.\\n&quot;</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>


  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>messagequeueid <span class="token operator">=</span> <span class="token function">msgget</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> IPC_CREAT<span class="token operator">|</span><span class="token number">0777</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
      <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">&quot;msgget error&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>


  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Message queue id: %d.\\n&quot;</span><span class="token punctuation">,</span> messagequeueid<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在运行上面这个程序之前，我们先使用命令 touch messagequeuekey，创建一个文件，然后多次执行的结果就会像下面这样：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code># <span class="token punctuation">.</span><span class="token operator">/</span>a<span class="token punctuation">.</span>out 
Message Queue key<span class="token operator">:</span> <span class="token number">92536.</span>
Message queue id<span class="token operator">:</span> <span class="token number">32768.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>System V IPC 体系有一个统一的命令行工具：ipcmk，ipcs 和 ipcrm 用于创建、查看和删除 IPC 对象。</p><p>例如，ipcs -q 就能看到上面我们创建的消息队列对象。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">ipcs</span> <span class="token expression"><span class="token operator">-</span>q</span></span>


<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> Message Queues <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
key        msqid      owner      perms      used<span class="token operator">-</span>bytes   messages    
<span class="token number">0x00016978</span> <span class="token number">32768</span>      root       <span class="token number">777</span>        <span class="token number">0</span>            <span class="token number">0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来，我们来看如何发送信息。发送消息主要调用 <strong><code>msgsnd 函数</code></strong>。第一个参数是 message queue 的 id，第二个参数是消息的结构体，第三个参数是消息的长度，最后一个参数是 flag。这里 IPC_NOWAIT 表示发送的时候不阻塞，直接返回。</p><p>下面的这段程序，getopt_long、do-while 循环以及 switch，是用来解析命令行参数的。命令行参数的格式定义在 long_options 里面。每一项的第一个成员“id”“type”“message”是参数选项的全称，第二个成员都为 1，表示参数选项后面要跟参数，最后一个成员’i’‘t’&#39;m’是参数选项的简称。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/msg.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;getopt.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>


<span class="token keyword">struct</span> <span class="token class-name">msg_buffer</span> <span class="token punctuation">{</span>
    <span class="token keyword">long</span> mtype<span class="token punctuation">;</span>
    <span class="token keyword">char</span> mtext<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> next_option<span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> short_options <span class="token operator">=</span> <span class="token string">&quot;i:t:m:&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">option</span> long_options<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">{</span> <span class="token string">&quot;id&quot;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token char">&#39;i&#39;</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span> <span class="token string">&quot;type&quot;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token char">&#39;t&#39;</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span> <span class="token string">&quot;message&quot;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token char">&#39;m&#39;</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  
  <span class="token keyword">int</span> messagequeueid <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">msg_buffer</span> buffer<span class="token punctuation">;</span>
  buffer<span class="token punctuation">.</span>mtype <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">char</span> <span class="token operator">*</span> message <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
  <span class="token keyword">do</span> <span class="token punctuation">{</span>
    next_option <span class="token operator">=</span> <span class="token function">getopt_long</span> <span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> short_options<span class="token punctuation">,</span> long_options<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>next_option<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      <span class="token keyword">case</span> <span class="token char">&#39;i&#39;</span><span class="token operator">:</span>
        messagequeueid <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>optarg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token keyword">case</span> <span class="token char">&#39;t&#39;</span><span class="token operator">:</span>
        buffer<span class="token punctuation">.</span>mtype <span class="token operator">=</span> <span class="token function">atol</span><span class="token punctuation">(</span>optarg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token keyword">case</span> <span class="token char">&#39;m&#39;</span><span class="token operator">:</span>
        message <span class="token operator">=</span> optarg<span class="token punctuation">;</span>
        len <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&gt;</span> <span class="token number">1024</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">&quot;message too long.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">memcpy</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span>mtext<span class="token punctuation">,</span> message<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token keyword">default</span><span class="token operator">:</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span>next_option <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


  <span class="token keyword">if</span><span class="token punctuation">(</span>messagequeueid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> buffer<span class="token punctuation">.</span>mtype <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> len <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> message <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">msgsnd</span><span class="token punctuation">(</span>messagequeueid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>buffer<span class="token punctuation">,</span> len<span class="token punctuation">,</span> IPC_NOWAIT<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">&quot;fail to send message.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">&quot;arguments error&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来，我们可以编译并运行这个发送程序。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>gcc <span class="token operator">-</span>o send sendmessage<span class="token punctuation">.</span>c
<span class="token punctuation">.</span><span class="token operator">/</span>send <span class="token operator">-</span>i <span class="token number">32768</span> <span class="token operator">-</span>t <span class="token number">123</span> <span class="token operator">-</span>m <span class="token string">&quot;hello world&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来，我们再来看如何收消息。收消息主要调用 <strong><code>msgrcv 函数</code></strong>，第一个参数是 message queue 的 id，第二个参数是消息的结构体，第三个参数是可接受的最大长度，第四个参数是消息类型, 最后一个参数是 flag，这里 IPC_NOWAIT 表示接收的时候不阻塞，直接返回。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/msg.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;getopt.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>


<span class="token keyword">struct</span> <span class="token class-name">msg_buffer</span> <span class="token punctuation">{</span>
    <span class="token keyword">long</span> mtype<span class="token punctuation">;</span>
    <span class="token keyword">char</span> mtext<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> next_option<span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> short_options <span class="token operator">=</span> <span class="token string">&quot;i:t:&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">option</span> long_options<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">{</span> <span class="token string">&quot;id&quot;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token char">&#39;i&#39;</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span> <span class="token string">&quot;type&quot;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token char">&#39;t&#39;</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  
  <span class="token keyword">int</span> messagequeueid <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">msg_buffer</span> buffer<span class="token punctuation">;</span>
  <span class="token keyword">long</span> type <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">do</span> <span class="token punctuation">{</span>
    next_option <span class="token operator">=</span> <span class="token function">getopt_long</span> <span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> short_options<span class="token punctuation">,</span> long_options<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>next_option<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      <span class="token keyword">case</span> <span class="token char">&#39;i&#39;</span><span class="token operator">:</span>
        messagequeueid <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>optarg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token keyword">case</span> <span class="token char">&#39;t&#39;</span><span class="token operator">:</span>
        type <span class="token operator">=</span> <span class="token function">atol</span><span class="token punctuation">(</span>optarg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token keyword">default</span><span class="token operator">:</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span>next_option <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


  <span class="token keyword">if</span><span class="token punctuation">(</span>messagequeueid <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> type <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">msgrcv</span><span class="token punctuation">(</span>messagequeueid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>buffer<span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">,</span> type<span class="token punctuation">,</span> IPC_NOWAIT<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">&quot;fail to recv message.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;received message type : %d, text: %s.&quot;</span><span class="token punctuation">,</span> buffer<span class="token punctuation">.</span>mtype<span class="token punctuation">,</span> buffer<span class="token punctuation">.</span>mtext<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">&quot;arguments error&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来，我们可以编译并运行这个发送程序。可以看到，如果有消息，可以正确地读到消息；如果没有，则返回没有消息。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code># <span class="token punctuation">.</span><span class="token operator">/</span>recv <span class="token operator">-</span>i <span class="token number">32768</span> <span class="token operator">-</span>t <span class="token number">123</span>
received message type <span class="token operator">:</span> <span class="token number">123</span><span class="token punctuation">,</span> text<span class="token operator">:</span> hello world<span class="token punctuation">.</span>
# <span class="token punctuation">.</span><span class="token operator">/</span>recv <span class="token operator">-</span>i <span class="token number">32768</span> <span class="token operator">-</span>t <span class="token number">123</span>
fail to recv message<span class="token punctuation">.</span><span class="token operator">:</span> No message of desired type
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有了消息这种模型，两个进程之间的通信就像咱们平时发邮件一样，你来一封，我回一封，可以频繁沟通了。</p><h2 id="共享内存模型" tabindex="-1"><a class="header-anchor" href="#共享内存模型" aria-hidden="true">#</a> <strong>共享内存模型</strong></h2><img src="`+o+`" alt="img" style="zoom:25%;"><p>但是有时候，项目组之间的沟通需要特别紧密，而且要分享一些比较大的数据。如果使用邮件，就发现，一方面邮件的来去不及时；另外一方面，附件大小也有限制，所以，这个时候，我们经常采取的方式就是，把两个项目组在需要合作的期间，拉到一个会议室进行合作开发，这样大家可以直接交流文档呀，架构图呀，直接在白板上画或者直接扔给对方，就可以直接看到。</p><p>可以看出来，共享会议室这种模型，类似进程间通信的<strong>共享内存模型</strong>。前面咱们讲内存管理的时候，知道每个进程都有自己独立的虚拟内存空间，不同的进程的虚拟内存空间映射到不同的物理内存中去。这个进程访问 A 地址和另一个进程访问 A 地址，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。</p><p>但是，咱们是不是可以变通一下，拿出一块虚拟地址空间来，映射到相同的物理内存中。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去。</p><p>共享内存也是 System V IPC 进程间通信机制体系中的，所以从它使用流程可以看到熟悉的面孔。</p><p>我们可以创建一个共享内存，调用 shmget。在这个体系中，创建一个 IPC 对象都是 xxxget，这里面第一个参数是 key，和 msgget 里面的 key 一样，都是唯一定位一个共享内存对象，也可以通过关联文件的方式实现唯一性。第二个参数是共享内存的大小。第三个参数如果是 IPC_CREAT，同样表示创建一个新的。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">shmget</span><span class="token punctuation">(</span><span class="token class-name">key_t</span> key<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>创建完毕之后，我们可以通过 ipcs 命令查看这个共享内存。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ipcs</span> <span class="token expression">­­<span class="token operator">--</span>shmems</span></span>


<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> Shared Memory Segments <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> ­­­­­­­­
key        shmid    owner perms    bytes nattch status
<span class="token number">0x00000000</span> <span class="token number">19398656</span> marc  <span class="token number">600</span>    <span class="token number">1048576</span> <span class="token number">2</span>      dest
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来，如果一个进程想要访问这一段共享内存，需要将这个内存加载到自己的虚拟地址空间的某个位置，通过 shmat 函数，就是 attach 的意思。其中 addr 就是要指定 attach 到这个地方。但是这个地址的设定难度比较大，除非对于内存布局非常熟悉，否则可能会 attach 到一个非法地址。所以，通常的做法是将 addr 设为 NULL，让内核选一个合适的地址。返回值就是真正被 attach 的地方。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">shmat</span><span class="token punctuation">(</span><span class="token keyword">int</span> shm_id<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果共享内存使用完毕，可以通过 shmdt 解除绑定，然后通过 shmctl，将 cmd 设置为 IPC_RMID，从而删除这个共享内存对象。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">shmdt</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>addr<span class="token punctuation">)</span><span class="token punctuation">;</span> 


<span class="token keyword">int</span> <span class="token function">shmctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> shm_id<span class="token punctuation">,</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">shmid_ds</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="信号量" tabindex="-1"><a class="header-anchor" href="#信号量" aria-hidden="true">#</a> <strong>信号量</strong></h2><p>这里你是不是有一个疑问，如果两个进程 attach 同一个共享内存，大家都往里面写东西，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。</p><p>所以，这里就需要一种保护机制，使得同一个共享的资源，同时只能被一个进程访问。在 System V IPC 进程间通信机制体系中，早就想好了应对办法，就是信号量（Semaphore）。因此，信号量和共享内存往往要配合使用。</p><p>信号量其实是一个计数器，主要用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</p><p>我们可以将信号量初始化为一个数值，来代表某种资源的总体数量。对于信号量来讲，会定义两种原子操作，一个是 <strong>P 操作</strong>，我们称为<strong>申请资源操作</strong>。这个操作会申请将信号量的数值减去 N，表示这些数量被他申请使用了，其他人不能用了。另一个是 <strong>V 操作</strong>，我们称为<strong>归还资源操作</strong>，这个操作会申请将信号量加上 M，表示这些数量已经还给信号量了，其他人可以使用了。</p><p>例如，你有 100 元钱，就可以将信号量设置为 100。其中 A 向你借 80 元，就会调用 P 操作，申请减去 80。如果同时 B 向你借 50 元，但是 B 的 P 操作比 A 晚，那就没有办法，只好等待 A 归还钱的时候，B 的 P 操作才能成功。之后，A 调用 V 操作，申请加上 30 元，也就是还给你 30 元，这个时候信号量有 50 元了，这时候 B 的 P 操作才能成功，才能借走这 50 元。</p><p>所谓<strong>原子操作</strong>（Atomic Operation），就是任何一块钱，都只能通过 P 操作借给一个人，不能同时借给两个人。也就是说，当 A 的 P 操作（借 80）和 B 的 P 操作（借 50），几乎同时到达的时候，不能因为大家都看到账户里有 100 就都成功，必须分个先来后到。</p><p>如果想创建一个信号量，我们可以通过 semget 函数。看，又是 xxxget，第一个参数 key 也是类似的，第二个参数 num_sems 不是指资源的数量，而是表示可以创建多少个信号量，形成一组信号量，也就是说，如果你有多种资源需要管理，可以创建一个信号量组。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code> <span class="token keyword">int</span> <span class="token function">semget</span><span class="token punctuation">(</span><span class="token class-name">key_t</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> num_sems<span class="token punctuation">,</span> <span class="token keyword">int</span> sem_flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>接下来，我们需要初始化信号量的总的资源数量。通过 semctl 函数，第一个参数 semid 是这个信号量组的 id，第二个参数 semnum 才是在这个信号量组中某个信号量的 id，第三个参数是命令，如果是初始化，则用 SETVAL，第四个参数是一个 union。如果初始化，应该用里面的 val 设置资源总量。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">semctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> semid<span class="token punctuation">,</span> <span class="token keyword">int</span> semnum<span class="token punctuation">,</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token keyword">union</span> semun args<span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token keyword">union</span> semun
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> val<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">semid_ds</span> <span class="token operator">*</span>buf<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">short</span> <span class="token keyword">int</span> <span class="token operator">*</span>array<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">seminfo</span> <span class="token operator">*</span>__buf<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>无论是 P 操作还是 V 操作，我们统一用 semop 函数。第一个参数还是信号量组的 id，一次可以操作多个信号量。第三个参数 numops 就是有多少个操作，第二个参数将这些操作放在一个数组中。</p><p>数组的每一项是一个 struct sembuf，里面的第一个成员是这个操作的对象是哪个信号量。</p><p>第二个成员就是要对这个信号量做多少改变。如果 sem_op &lt; 0，就请求 sem_op 的绝对值的资源。如果相应的资源数可以满足请求，则将该信号量的值减去 sem_op 的绝对值，函数成功返回。</p><p>当相应的资源数不能满足请求时，就要看 sem_flg 了。如果把 sem_flg 设置为 IPC_NOWAIT，也就是没有资源也不等待，则 semop 函数出错返回 EAGAIN。如果 sem_flg 没有指定 IPC_NOWAIT，则进程挂起，直到当相应的资源数可以满足请求。若 sem_op &gt; 0，表示进程归还相应的资源数，将 sem_op 的值加到信号量的值上。如果有进程正在休眠等待此信号量，则唤醒它们。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">semop</span><span class="token punctuation">(</span><span class="token keyword">int</span> semid<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sembuf</span> semoparray<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token class-name">size_t</span> numops<span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token keyword">struct</span> <span class="token class-name">sembuf</span> 
<span class="token punctuation">{</span>
  <span class="token keyword">short</span> sem_num<span class="token punctuation">;</span> <span class="token comment">// 信号量组中对应的序号，0～sem_nums-1</span>
  <span class="token keyword">short</span> sem_op<span class="token punctuation">;</span>  <span class="token comment">// 信号量值在一次操作中的改变量</span>
  <span class="token keyword">short</span> sem_flg<span class="token punctuation">;</span> <span class="token comment">// IPC_NOWAIT, SEM_UNDO</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>信号量和共享内存都比较复杂，两者还要结合起来用，就更加复杂，它们内核的机制就更加复杂。这一节我们先不讲，放到本章的最后一节重点讲解。</p></blockquote><h2 id="信号" tabindex="-1"><a class="header-anchor" href="#信号" aria-hidden="true">#</a> <strong>信号</strong></h2><p>上面讲的进程间通信的方式，都是常规状态下的工作模式，对应到咱们平时的工作交接，收发邮件、联合开发等，其实还有一种异常情况下的工作模式。</p><p>例如出现线上系统故障，这个时候，什么流程都来不及了，不可能发邮件，也来不及开会，所有的架构师、开发、运维都要被通知紧急出动。所以，7 乘 24 小时不间断执行的系统都需要有告警系统，一旦出事情，就要通知到人，哪怕是半夜，也要电话叫起来，处理故障。</p><p>对应到操作系统中，就是信号。信号没有特别复杂的数据结构，就是用一个代号一样的数字。Linux 提供了几十种信号，分别代表不同的意义。信号之间依靠它们的值来区分。这就像咱们看警匪片，对于紧急的行动，都是说，“1 号作战任务”开始执行，警察就开始行动了。情况紧急，不能啰里啰嗦了。</p><p>信号可以在任何时候发送给某一进程，进程需要为这个信号配置信号处理函数。当某个信号发生的时候，就默认执行这个函数就可以了。这就相当于咱们运维一个系统应急手册，当遇到什么情况，做什么事情，都事先准备好，出了事情照着做就可以了。</p><h2 id="总结时刻" tabindex="-1"><a class="header-anchor" href="#总结时刻" aria-hidden="true">#</a> <strong>总结时刻</strong></h2><p>这一节，我们整体讲解了一下进程间通信的各种模式。你现在还能记住多少？</p><ul><li>类似瀑布开发模式的<code>[管道/匿名管道/命名管道]</code></li><li>类似邮件模式的<code>[消息队列]</code></li><li>类似会议室联合开发的<code>[共享内存加信号量]</code></li><li>类似应急预案的<code>[信号/系统应急才会使用]</code></li></ul><p>当你自己使用的时候，可以根据不同的通信需要，选择不同的模式。</p><ul><li>管道，请你记住这是命令行中常用的模式，面试问到的话，不要忘了。</li><li>消息队列其实很少使用，因为有太多的用户级别(用户态/应用层)的消息队列，功能更强大。</li><li>共享内存加信号量是常用的模式。这个需要牢记，常见到一些知名的以 C 语言开发的开源软件都会用到它。</li><li>信号更加常用，机制也比较复杂。我们后面会有单独的一节来解析。</li></ul><h2 id="课堂练习" tabindex="-1"><a class="header-anchor" href="#课堂练习" aria-hidden="true">#</a> <strong>课堂练习</strong></h2><p>这节课的程序，请你务必自己编译通过，搞清楚参数解析是怎么做的，这个以后你自己写程序的时候，很有用，另外消息队列模型的 API 调用流程，也要搞清楚，要知道他们都属于 System V 系列，后面我们学共享内存和信号量，能看到完全类似的 API 调用流程。</p><p>欢迎留言和我分享你的疑惑和见解 ，也欢迎可以收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习和进步。</p><h2 id="课后讨论" tabindex="-1"><a class="header-anchor" href="#课后讨论" aria-hidden="true">#</a> 课后讨论</h2><p>正在刷第二遍的趣谈网络协议，也不知道为什么有一种冲动要表达一下自己的想法，虽然趣谈网络协议已经过去了很长时间，但在刷第二遍的时候从整个结构上看真的是太清晰了，层层的递进，感觉非常的棒。这次的操作系统这个系列我觉得也值得刷N遍，每次应该都会有不同的认识。<br> 作者回复: 想刷就刷呀，刷的漂亮</p><p>进程间还可以利用socket通信<br> 作者回复: 对的对的，还有sock文件。socket估计要单独开一节</p><p>system v这套api和文件操作那些api在形式上差别较大，所以现在用的多的是posix进程间通信那套东西。</p><p>System V IPC 这个是啥呀，怎么突然就冒出来啦。有没有大手子给解释一下的呀<br> 网友回复：IPC is an abbreviation for Interprocess Communication</p><p>&quot;消息队列其实很少使用，因为有太多的用户级别的消息队列，功能更强大&quot;</p><p>刘超刘老师好，<br> 网友问道：做后台服务器开发，有多个业务线程，我们都是用消息队列来通信，请问这边的很少使用更具体是因为什么原因呢？哪些应用场景下的哪些功能不足所以才导致需要用到更强大的用户级别的消息队列呢？<br> 作者回复：你用的不是内核提供的消息队列吧<br> 网友补充：服务器应用用C编写，进程内，不同模块分不同线程。使用的msgsnd，msgrcv这些系统调用，用的就是内核提供的消息队列呢<br> 路人提醒：刘老师说的是进程间通信的消息队列，你说的是同一进程内的…情况不一样，直接简单链表加互斥锁都可以做到。</p><p>Python 线程使用系统原生线程指的就是这里吧。我之前写过 Python 多线程下载的脚本，用到了信号量，队列。<br> 作者回复: 赞</p><p>老师 进程间通信的消息队列和kafka rabbit那些是一类吗<br> 网友回复：kafka那种是用户级别的消息队列，实际上是基于网络编程的。这个消息队列是系统中buffer的交互。</p><p>可以的之前只知道这个线叫管道命令，没想过管道命令是用完就消失的匿名管道，之前一直默认这是一种格式类似三元表达式之类的。</p><p>请教下老师，system v和posix两套区别是什么？为什么要搞两套？<br> 网友回复：历史原因</p><p>请问老师信号量仅仅是一个对资源数量的标识, 那怎么知道具体是哪个资源被申请和释放了呢, 如果不对具体的资源做标记, 不是还是可能引起冲突吗?<br> 作者回复: 是的，要不这种资源是相关性不大的，比如线程池，要不就是还需要一次锁来强某个资源</p><p>共享内存的确常用, Android 的 Ashmen 共享内存就是基于 Linux 的共享内存操作</p>`,102),i=[l];function u(r,k){return s(),a("div",null,i)}const v=n(c,[["render",u],["__file","L36-进程间通信.html.vue"]]);export{v as default};
