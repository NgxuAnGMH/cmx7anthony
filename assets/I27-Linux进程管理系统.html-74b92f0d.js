import{_ as s}from"./plugin-vue_export-helper-c27b6911.js";import{o as n,c as a,d as t}from"./app-cdabc73c.js";const p="/assets/9f6acf3a5b6f31a3aeb8743726a65286-84ddd833.jpg",e="/assets/00de9da1b13f6f3e975050a393782891-9131ed79.jpg",c="/assets/bb9f817b5db40106cb324b71b04ebed0-8a864a87.jpg",o="/assets/818313e87a4e1129470fb87bacee59f1-c20bea3d.jpg",l="/assets/bd82db725228db2b69cbbceef088a950-b13a3709.jpg",i={},u=t(`<h1 id="_27-瞧一瞧linux-linux如何实现进程与进程调度" tabindex="-1"><a class="header-anchor" href="#_27-瞧一瞧linux-linux如何实现进程与进程调度" aria-hidden="true">#</a> 27 | 瞧一瞧Linux：Linux如何实现进程与进程调度?</h1><p>你好，我是 LMOS。</p><p>在前面的课程中，我们已经写好了 Cosmos 的进程管理组件，实现了多进程调度运行，今天我们一起探索 Linux 如何表示进程以及如何进行多进程调度。</p><p>好了，话不多说，我们开始吧。</p><h2 id="linux-如何表示进程" tabindex="-1"><a class="header-anchor" href="#linux-如何表示进程" aria-hidden="true">#</a> Linux 如何表示进程</h2><p>在 Cosmos 中，我们设计了一个 thread_t 数据结构来代表一个进程，Linux 也同样是用一个数据结构表示一个进程。</p><p>下面我们先来研究 Linux 的进程数据结构，然后看看 Linux 进程的地址空间数据结构，最后再来理解 Linux 的文件表结构。</p><h2 id="linux-进程的数据结构-task-struct" tabindex="-1"><a class="header-anchor" href="#linux-进程的数据结构-task-struct" aria-hidden="true">#</a> Linux 进程的数据结构: task_struct</h2><p>Linux 系统下，把运行中的应用程序抽象成一个数据结构 <code>task_struct</code>，一个应用程序所需要的各种资源，如内存、文件等都包含在 task_struct 结构中。</p><p>因此，task_struct 结构是非常巨大的一个数据结构，代码如下。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">thread_info</span> thread_info<span class="token punctuation">;</span><span class="token comment">//处理器特有数据 </span>
    <span class="token keyword">volatile</span> <span class="token keyword">long</span>   state<span class="token punctuation">;</span>       <span class="token comment">//进程状态 </span>
    <span class="token keyword">void</span>            <span class="token operator">*</span>stack<span class="token punctuation">;</span>      <span class="token comment">//进程内核栈地址 </span>
    <span class="token class-name">refcount_t</span>      usage<span class="token punctuation">;</span>       <span class="token comment">//进程使用计数</span>
    <span class="token keyword">int</span>             on_rq<span class="token punctuation">;</span>       <span class="token comment">//进程是否在运行队列上</span>
    <span class="token keyword">int</span>             prio<span class="token punctuation">;</span>        <span class="token comment">//动态优先级</span>
    <span class="token keyword">int</span>             static_prio<span class="token punctuation">;</span> <span class="token comment">//静态优先级</span>
    <span class="token keyword">int</span>             normal_prio<span class="token punctuation">;</span> <span class="token comment">//取决于静态优先级和调度策略</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>    rt_priority<span class="token punctuation">;</span> <span class="token comment">//实时优先级</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span>    <span class="token operator">*</span>sched_class<span class="token punctuation">;</span><span class="token comment">//指向其所在的调度类</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span>         se<span class="token punctuation">;</span><span class="token comment">//普通进程的调度实体</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_rt_entity</span>      rt<span class="token punctuation">;</span><span class="token comment">//实时进程的调度实体</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_dl_entity</span>      dl<span class="token punctuation">;</span><span class="token comment">//采用EDF算法调度实时进程的调度实体</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_info</span>       sched_info<span class="token punctuation">;</span><span class="token comment">//用于调度器统计进程的运行信息 </span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>        tasks<span class="token punctuation">;</span><span class="token comment">//所有进程的链表</span>
    <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span>        <span class="token operator">*</span>mm<span class="token punctuation">;</span>  <span class="token comment">//指向进程内存结构</span>
    <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span>        <span class="token operator">*</span>active_mm<span class="token punctuation">;</span>
    <span class="token class-name">pid_t</span>               pid<span class="token punctuation">;</span>            <span class="token comment">//进程id</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> __rcu    <span class="token operator">*</span>parent<span class="token punctuation">;</span><span class="token comment">//指向其父进程</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>        children<span class="token punctuation">;</span> <span class="token comment">//链表中的所有元素都是它的子进程</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span>        sibling<span class="token punctuation">;</span>  <span class="token comment">//用于把当前进程插入到兄弟链表中</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span>      <span class="token operator">*</span>group_leader<span class="token punctuation">;</span><span class="token comment">//指向其所在进程组的领头进程</span>
    u64             utime<span class="token punctuation">;</span>   <span class="token comment">//用于记录进程在用户态下所经过的节拍数</span>
    u64             stime<span class="token punctuation">;</span>   <span class="token comment">//用于记录进程在内核态下所经过的节拍数</span>
    u64             gtime<span class="token punctuation">;</span>   <span class="token comment">//用于记录作为虚拟机进程所经过的节拍数</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>           min_flt<span class="token punctuation">;</span><span class="token comment">//缺页统计 </span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>           maj_flt<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">fs_struct</span>        <span class="token operator">*</span>fs<span class="token punctuation">;</span>    <span class="token comment">//进程相关的文件系统信息</span>
    <span class="token keyword">struct</span> <span class="token class-name">files_struct</span>     <span class="token operator">*</span>files<span class="token punctuation">;</span><span class="token comment">//进程打开的所有文件</span>
    <span class="token keyword">struct</span> <span class="token class-name">vm_struct</span>        <span class="token operator">*</span>stack_vm_area<span class="token punctuation">;</span><span class="token comment">//内核栈的内存区</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了帮你掌握核心思路，关于 task_struct 结构体，我省略了进程的权能、性能跟踪、信号、numa、cgroup 等相关的近 500 行内容，你若有兴趣可以自行阅读，这里你只需要明白，在内存中，<strong>一个 task_struct 结构体的实例变量代表一个 Linux 进程</strong>就行了。</p><h2 id="创建-task-struct-结构" tabindex="-1"><a class="header-anchor" href="#创建-task-struct-结构" aria-hidden="true">#</a> 创建 task_struct 结构</h2><p>Linux 创建 task_struct 结构体的实例变量，这里我们只关注早期和最新的创建方式。</p><p>Linux 早期是这样创建 task_struct 结构体的实例变量的：找伙伴内存管理系统，分配两个连续的页面（即 8KB），作为进程的内核栈，再把 task_struct 结构体的实例变量，放在这 8KB 内存空间的开始地址处。内核栈则是从上向下伸长的，task_struct 数据结构是从下向上伸长的。</p><p>我给你画幅图，你就明白了。</p><img src="`+p+`" alt="img" style="zoom:15%;"><p>进程内核栈</p><p>从图中不难发现，Linux 把 task_struct 结构和内核栈放在了一起 ，所以我们只要把 RSP 寄存器的值读取出来，然后将其低 13 位清零，就得到了当前 task_struct 结构体的地址。由于内核栈比较大，而且会向下伸长，覆盖掉 task_struct 结构体内容的概率就很小。</p><p>随着 Linux 版本的迭代，task_struct 结构体的体积越来越大，从前 task_struct 结构体和内核栈放在一起的方式就不合适了。最新的版本是分开放的，我们一起来看看后面的代码。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span><span class="token function">alloc_thread_stack_node</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">,</span> <span class="token keyword">int</span> node<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page <span class="token operator">=</span> <span class="token function">alloc_pages_node</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> THREADINFO_GFP<span class="token punctuation">,</span>
                         THREAD_SIZE_ORDER<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//分配两个页面</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        tsk<span class="token operator">-&gt;</span>stack <span class="token operator">=</span> <span class="token function">kasan_reset_tag</span><span class="token punctuation">(</span><span class="token function">page_address</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> tsk<span class="token operator">-&gt;</span>stack<span class="token punctuation">;</span><span class="token comment">//让task_struct结构的stack字段指向page的地址</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token function">alloc_task_struct_node</span><span class="token punctuation">(</span><span class="token keyword">int</span> node<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">kmem_cache_alloc_node</span><span class="token punctuation">(</span>task_struct_cachep<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//在task_struct_cachep内存对象中分配一个task_struct结构休对象 </span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token function">dup_task_struct</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>orig<span class="token punctuation">,</span> <span class="token keyword">int</span> node<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">;</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span>stack<span class="token punctuation">;</span>
    tsk <span class="token operator">=</span> <span class="token function">alloc_task_struct_node</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//分配task_struct结构体</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tsk<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    stack <span class="token operator">=</span> <span class="token function">alloc_thread_stack_node</span><span class="token punctuation">(</span>tsk<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//分配内核栈</span>
    tsk<span class="token operator">-&gt;</span>stack <span class="token operator">=</span> stack<span class="token punctuation">;</span>
    <span class="token keyword">return</span> tsk<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> __latent_entropy <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token function">copy_process</span><span class="token punctuation">(</span>
                    <span class="token keyword">struct</span> <span class="token class-name">pid</span> <span class="token operator">*</span>pid<span class="token punctuation">,</span> <span class="token keyword">int</span> trace<span class="token punctuation">,</span> <span class="token keyword">int</span> node<span class="token punctuation">,</span>
                    <span class="token keyword">struct</span> <span class="token class-name">kernel_clone_args</span> <span class="token operator">*</span>args<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> pidfd <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> retval<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
    <span class="token comment">//……</span>
    retval <span class="token operator">=</span> <span class="token operator">-</span>ENOMEM<span class="token punctuation">;</span>
    p <span class="token operator">=</span> <span class="token function">dup_task_struct</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//分配task_struct和内核栈</span>
    <span class="token comment">//……</span>
    <span class="token keyword">return</span> <span class="token function">ERR_PTR</span><span class="token punctuation">(</span>retval<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">pid_t</span> <span class="token function">kernel_clone</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kernel_clone_args</span> <span class="token operator">*</span>args<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    u64 clone_flags <span class="token operator">=</span> args<span class="token operator">-&gt;</span>flags<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
    <span class="token class-name">pid_t</span> nr<span class="token punctuation">;</span>
    <span class="token comment">//……</span>
    <span class="token comment">//复制进程</span>
    p <span class="token operator">=</span> <span class="token function">copy_process</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> trace<span class="token punctuation">,</span> NUMA_NO_NODE<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//……</span>
    <span class="token keyword">return</span> nr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//建立进程接口</span>
<span class="token function">SYSCALL_DEFINE0</span><span class="token punctuation">(</span>fork<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">kernel_clone_args</span> args <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span>exit_signal <span class="token operator">=</span> SIGCHLD<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">kernel_clone</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了直击重点，我们不会讨论 Linux 的 fork 函数，你只要知道，它负责建立一个与父进程相同的进程，也就是复制了父进程的一系列数据，这就够了。</p><p>要复制父进程的数据必须要分配内存，<strong>上面代码的流程完整展示了从 SLAB 中分配 task_struct 结构，以及从伙伴内存系统分配内核栈的过程，整个过程是怎么回事儿，才是你要领会的重点。</strong></p><h2 id="linux-进程地址空间-mm-struct" tabindex="-1"><a class="header-anchor" href="#linux-进程地址空间-mm-struct" aria-hidden="true">#</a> Linux 进程地址空间: mm_struct</h2><p>Linux 也是支持虚拟内存的操作系统内核，现在我们来看看 Linux 用于描述一个进程的地址空间的数据结构，它就是 <strong>mm_struct 结构</strong>，代码如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span>mmap<span class="token punctuation">;</span> <span class="token comment">//虚拟地址区间链表VMAs</span>
        <span class="token keyword">struct</span> <span class="token class-name">rb_root</span> mm_rb<span class="token punctuation">;</span>   <span class="token comment">//组织vm_area_struct结构的红黑树的根</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> task_size<span class="token punctuation">;</span>    <span class="token comment">//进程虚拟地址空间大小</span>
        <span class="token class-name">pgd_t</span> <span class="token operator">*</span> pgd<span class="token punctuation">;</span>        <span class="token comment">//指向MMU页表</span>
        <span class="token class-name">atomic_t</span> mm_users<span class="token punctuation">;</span> <span class="token comment">//多个进程共享这个mm_struct</span>
        <span class="token class-name">atomic_t</span> mm_count<span class="token punctuation">;</span> <span class="token comment">//mm_struct结构本身计数 </span>
        <span class="token class-name">atomic_long_t</span> pgtables_bytes<span class="token punctuation">;</span><span class="token comment">//页表占用了多个页</span>
        <span class="token keyword">int</span> map_count<span class="token punctuation">;</span>      <span class="token comment">//多少个VMA</span>
        <span class="token class-name">spinlock_t</span> page_table_lock<span class="token punctuation">;</span> <span class="token comment">//保护页表的自旋锁</span>
        <span class="token keyword">struct</span> <span class="token class-name">list_head</span> mmlist<span class="token punctuation">;</span> <span class="token comment">//挂入mm_struct结构的链表</span>
        <span class="token comment">//进程应用程序代码开始、结束地址，应用程序数据的开始、结束地址 </span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> start_code<span class="token punctuation">,</span> end_code<span class="token punctuation">,</span> start_data<span class="token punctuation">,</span> end_data<span class="token punctuation">;</span>
        <span class="token comment">//进程应用程序堆区的开始、当前地址、栈开始地址 </span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> start_brk<span class="token punctuation">,</span> brk<span class="token punctuation">,</span> start_stack<span class="token punctuation">;</span>
        <span class="token comment">//进程应用程序参数区开始、结束地址</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> arg_start<span class="token punctuation">,</span> arg_end<span class="token punctuation">,</span> env_start<span class="token punctuation">,</span> env_end<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同样的，mm_struct 结构，我也精减了很多内容。其中的 <strong>vm_area_struct 结构</strong>，相当于我们之前 Cosmos 的 kmvarsdsc_t 结构（可以回看第 20 节课），是用来描述一段虚拟地址空间的。mm_struct 结构中也包含了 MMU 页表相关的信息。</p><p>下面我们一起来看看，mm_struct 结构是如何建立对应的实例变量呢？代码如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//在mm_cachep内存对象中分配一个mm_struct结构休对象</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">allocate_mm</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token function">kmem_cache_alloc</span><span class="token punctuation">(</span>mm_cachep<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span><span class="token function">dup_mm</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">,</span>
                <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>oldmm<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>mm<span class="token punctuation">;</span>
    <span class="token comment">//分配mm_struct结构</span>
    mm <span class="token operator">=</span> <span class="token function">allocate_mm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>mm<span class="token punctuation">)</span>
        <span class="token keyword">goto</span> fail_nomem<span class="token punctuation">;</span>
    <span class="token comment">//复制mm_struct结构</span>
    <span class="token function">memcpy</span><span class="token punctuation">(</span>mm<span class="token punctuation">,</span> oldmm<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>mm<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//……</span>
    <span class="token keyword">return</span> mm<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">copy_mm</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> clone_flags<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>mm<span class="token punctuation">,</span> <span class="token operator">*</span>oldmm<span class="token punctuation">;</span>
    <span class="token keyword">int</span> retval<span class="token punctuation">;</span>
    tsk<span class="token operator">-&gt;</span>min_flt <span class="token operator">=</span> tsk<span class="token operator">-&gt;</span>maj_flt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    tsk<span class="token operator">-&gt;</span>nvcsw <span class="token operator">=</span> tsk<span class="token operator">-&gt;</span>nivcsw <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    retval <span class="token operator">=</span> <span class="token operator">-</span>ENOMEM<span class="token punctuation">;</span>
    mm <span class="token operator">=</span> <span class="token function">dup_mm</span><span class="token punctuation">(</span>tsk<span class="token punctuation">,</span> current<span class="token operator">-&gt;</span>mm<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//分配mm_struct结构的实例变量</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>mm<span class="token punctuation">)</span>
        <span class="token keyword">goto</span> fail_nomem<span class="token punctuation">;</span>
good_mm<span class="token operator">:</span>
    tsk<span class="token operator">-&gt;</span>mm <span class="token operator">=</span> mm<span class="token punctuation">;</span>
    tsk<span class="token operator">-&gt;</span>active_mm <span class="token operator">=</span> mm<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
fail_nomem<span class="token operator">:</span>
    <span class="token keyword">return</span> retval<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码的 copy_mm 函数正是在 copy_process 函数中被调用的， copy_mm 函数调用 dup_mm 函数，把当前进程的 mm_struct 结构复制到 allocate_mm 宏分配的一个 mm_struct 结构中。这样，一个新进程的 mm_struct 结构就建立了。</p><h2 id="linux-进程文件表-files-struct" tabindex="-1"><a class="header-anchor" href="#linux-进程文件表-files-struct" aria-hidden="true">#</a> Linux 进程文件表: files_struct</h2><p>在 Linux 系统中，可以说万物皆为文件，比如文件、设备文件、管道文件等。一个进程对一个文件进行读写操作之前，必须先打开文件，这个打开的文件就记录在进程的文件表中，它由 task_struct 结构中的 files 字段指向。这里指向的其实是个 <strong>files_struct 结构</strong>，代码如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">files_struct</span> <span class="token punctuation">{</span>
 
    <span class="token class-name">atomic_t</span> count<span class="token punctuation">;</span><span class="token comment">//自动计数</span>
    <span class="token keyword">struct</span> <span class="token class-name">fdtable</span> __rcu <span class="token operator">*</span>fdt<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">fdtable</span> fdtab<span class="token punctuation">;</span>
    <span class="token class-name">spinlock_t</span> file_lock<span class="token punctuation">;</span> <span class="token comment">//自旋锁</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> next_fd<span class="token punctuation">;</span><span class="token comment">//下一个文件句柄</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> close_on_exec_init<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//执行exec()时要关闭的文件句柄</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> open_fds_init<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> full_fds_bits_init<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">file</span> __rcu <span class="token operator">*</span> fd_array<span class="token punctuation">[</span>NR_OPEN_DEFAULT<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//默认情况下打开文件的指针数组</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上述代码中，可以推想出我们在应用软件中调用：int fd = open(&quot;/tmp/test.txt&quot;); 实际 Linux 会建立一个 struct file 结构体实例变量与文件对应，然后把 struct file 结构体实例变量的指针放入 fd_array 数组中。</p><p>那么 Linux 在建立一个新进程时，怎样给新进程建立一个 files_struct 结构呢？其实很简单，也是复制当前进程的 files_struct 结构，代码如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">copy_files</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> clone_flags<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">files_struct</span> <span class="token operator">*</span>oldf<span class="token punctuation">,</span> <span class="token operator">*</span>newf<span class="token punctuation">;</span>
    <span class="token keyword">int</span> error <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    oldf <span class="token operator">=</span> current<span class="token operator">-&gt;</span>files<span class="token punctuation">;</span><span class="token comment">//获取当前进程的files_struct的指针</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>oldf<span class="token punctuation">)</span>
        <span class="token keyword">goto</span> out<span class="token punctuation">;</span>


    <span class="token keyword">if</span> <span class="token punctuation">(</span>clone_flags <span class="token operator">&amp;</span> CLONE_FILES<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">atomic_inc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>oldf<span class="token operator">-&gt;</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> out<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//分配新files_struct结构的实例变量，并复制当前的files_struct结构</span>
    newf <span class="token operator">=</span> <span class="token function">dup_fd</span><span class="token punctuation">(</span>oldf<span class="token punctuation">,</span> NR_OPEN_MAX<span class="token punctuation">,</span> <span class="token operator">&amp;</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>newf<span class="token punctuation">)</span>
        <span class="token keyword">goto</span> out<span class="token punctuation">;</span>


    tsk<span class="token operator">-&gt;</span>files <span class="token operator">=</span> newf<span class="token punctuation">;</span><span class="token comment">//新进程的files_struct结构指针指向新的files_struct结构</span>
    error <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
out<span class="token operator">:</span>
    <span class="token keyword">return</span> error<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同样的，copy_files 函数由 copy_process 函数调用，copy_files 最终会复制当前进程的 files_struct 结构到一个新的 files_struct 结构实例变量中，并让新进程的 files 指针指向这个新的 files_struct 结构实例变量。</p><p>好了，关于进程的一些数据结构，我们就了解这么多，因为现在你还无需知道 Linux 进程的所有细节，对于一个庞大的系统，<strong>最大的误区是<code>陷入细节而不知全貌</code></strong>。这里，我们只需要知道 Linux 用什么代表一个进程就行了。</p><h2 id="linux-进程调度" tabindex="-1"><a class="header-anchor" href="#linux-进程调度" aria-hidden="true">#</a> Linux 进程调度</h2><p>Linux 支持多 CPU 上运行多进程，这就要说到多进程调度了。Linux 进程调度支持多种调度算法，有基于优先级的调度算法，有实时调度算法，有完全公平调度算法（CFQ）。</p><p>下面我们以 CFQ 为例进行探讨，我们先了解一下 CFQ 相关的数据结构，随后探讨 CFQ 算法要怎样实现。</p><h2 id="进程调度实体-sched-entity" tabindex="-1"><a class="header-anchor" href="#进程调度实体-sched-entity" aria-hidden="true">#</a> 进程调度实体: sched_entity</h2><p>我们先来看看什么是进程调度实体，它是干什么的呢？</p><p>它其实是 Linux 进程调度系统的一部分，被嵌入到了 Linux 进程数据结构中，与调度器进行关联，能间接地访问进程，<strong>这种高内聚低耦合的方式，保证了进程数据结构和调度数据结构相互独立</strong>，我们后面可以分别做改进、优化，这是一种高明的软件设计思想。我们来看看这个结构，代码如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">load_weight</span> load<span class="token punctuation">;</span><span class="token comment">//表示当前调度实体的权重</span>
    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> run_node<span class="token punctuation">;</span><span class="token comment">//红黑树的数据节点</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> group_node<span class="token punctuation">;</span><span class="token comment">// 链表节点，被链接到 percpu 的 rq-&gt;cfs_tasks</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> on_rq<span class="token punctuation">;</span> <span class="token comment">//当前调度实体是否在就绪队列上</span>
    u64 exec_start<span class="token punctuation">;</span><span class="token comment">//当前实体上次被调度执行的时间</span>
    u64 sum_exec_runtime<span class="token punctuation">;</span><span class="token comment">//当前实体总执行时间</span>
    u64 prev_sum_exec_runtime<span class="token punctuation">;</span><span class="token comment">//截止到上次统计，进程执行的时间</span>
    u64 vruntime<span class="token punctuation">;</span><span class="token comment">//当前实体的虚拟时间</span>
    u64 nr_migrations<span class="token punctuation">;</span><span class="token comment">//实体执行迁移的次数 </span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_statistics</span> statistics<span class="token punctuation">;</span><span class="token comment">//统计信息包含进程的睡眠统计、等待延迟统计、CPU迁移统计、唤醒统计等。</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_FAIR_GROUP_SCHED</span></span>
    <span class="token keyword">int</span> depth<span class="token punctuation">;</span><span class="token comment">// 表示当前实体处于调度组中的深度</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>parent<span class="token punctuation">;</span><span class="token comment">//指向父级调度实体</span>
    <span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq<span class="token punctuation">;</span><span class="token comment">//当前调度实体属于的 cfs_rq.</span>
    <span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>my_q<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_SMP</span></span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_avg</span> avg <span class="token punctuation">;</span><span class="token comment">// 记录当前实体对于CPU的负载</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码的信息量很多，但是我们现在不急于搞清楚所有的信息，我们现在需要知道的是<strong>在 task_struct 结构中，会包含至少一个 sched_entity 结构的变量</strong>，如下图所示。</p><img src="`+e+`" alt="img" style="zoom:15%;"><p>调度实体在进程结构中的位置</p><p>结合图示，我们只要通过 sched_entity 结构变量的地址，减去它在 task_struct 结构中的偏移（由编译器自动计算），就能获取到 task_struct 结构的地址。这样就能达到通过 sched_entity 结构，访问 task_struct 结构的目的了。</p><h2 id="进程运行队列" tabindex="-1"><a class="header-anchor" href="#进程运行队列" aria-hidden="true">#</a> 进程运行队列</h2><p>那么，在 Linux 中，又是怎样组织众多调度实体，进而组织众多进程，方便进程调度器找到调度实体呢？</p><p>首先，Linux 定义了一个进程运行队列结构，每个 CPU 分配一个这样的进程运行队列结构实例变量，进程运行队列结构的代码如下。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token punctuation">{</span>
    <span class="token class-name">raw_spinlock_t</span>      lock<span class="token punctuation">;</span><span class="token comment">//自旋锁</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>        nr_running<span class="token punctuation">;</span><span class="token comment">//多个就绪运行进程</span>
    <span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span>       cfs<span class="token punctuation">;</span> <span class="token comment">//作用于完全公平调度算法的运行队列</span>
    <span class="token keyword">struct</span> <span class="token class-name">rt_rq</span>        rt<span class="token punctuation">;</span><span class="token comment">//作用于实时调度算法的运行队列</span>
    <span class="token keyword">struct</span> <span class="token class-name">dl_rq</span>        dl<span class="token punctuation">;</span><span class="token comment">//作用于EDF调度算法的运行队列</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> __rcu    <span class="token operator">*</span>curr<span class="token punctuation">;</span><span class="token comment">//这个运行队列当前正在运行的进程</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span>  <span class="token operator">*</span>idle<span class="token punctuation">;</span><span class="token comment">//这个运行队列的空转进程</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span>  <span class="token operator">*</span>stop<span class="token punctuation">;</span><span class="token comment">//这个运行队列的停止进程</span>
    <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span>    <span class="token operator">*</span>prev_mm<span class="token punctuation">;</span><span class="token comment">//这个运行队列上一次运行进程的mm_struct</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>        clock_update_flags<span class="token punctuation">;</span><span class="token comment">//时钟更新标志</span>
    u64         clock<span class="token punctuation">;</span> <span class="token comment">//运行队列的时间 </span>
    <span class="token comment">//后面的代码省略</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上这个 rq 结构结构中，很多我们不需要关注的字段我已经省略了。你要重点理解的是，其中 task_struct 结构指针是为了快速访问特殊进程，而 rq 结构并不直接关联调度实体，而是包含了 cfs_rq、rt_rq、dl_rq，通过它们来关联调度实体。</p><p>有三个不同的运行队列，是因为作用于三种不同的调度算法。我们这里只需要关注 cfs_rq，代码我列在了后面。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">rb_root_cached</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">rb_root</span> rb_root<span class="token punctuation">;</span>   <span class="token comment">//红黑树的根</span>
    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>rb_leftmost<span class="token punctuation">;</span><span class="token comment">//红黑树最左子节点</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">load_weight</span>  load<span class="token punctuation">;</span><span class="token comment">//cfs_rq上所有调度实体的负载总和</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> nr_running<span class="token punctuation">;</span><span class="token comment">//cfs_rq上所有的调度实体不含调度组中的调度实体</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> h_nr_running<span class="token punctuation">;</span><span class="token comment">//cfs_rq上所有的调度实体包含调度组中所有调度实体</span>
    u64         exec_clock<span class="token punctuation">;</span><span class="token comment">//当前 cfs_rq 上执行的时间 </span>
    u64         min_vruntime<span class="token punctuation">;</span><span class="token comment">//最小虚拟运行时间</span>
    <span class="token keyword">struct</span> <span class="token class-name">rb_root_cached</span>   tasks_timeline<span class="token punctuation">;</span><span class="token comment">//所有调度实体的根</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>curr<span class="token punctuation">;</span><span class="token comment">//当前调度实体</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token comment">//下一个调度实体</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>last<span class="token punctuation">;</span><span class="token comment">//上次执行过的调度实体</span>
    <span class="token comment">//省略不关注的代码</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了简化问题，上述代码中我省略了调度组和负载相关的内容。你也许已经看出来了，其中 <strong>load、exec_clock、min_vruntime、tasks_timeline 字段是 CFS 调度算法得以实现的关键</strong>，你甚至可以猜出所有的调度实体，都是通过红黑树组织起来的，即 cfs_rq 结构中的 tasks_timeline 字段。</p><h2 id="调度实体和运行队列的关系" tabindex="-1"><a class="header-anchor" href="#调度实体和运行队列的关系" aria-hidden="true">#</a> 调度实体和运行队列的关系</h2><p>相信我，作为初学者，<strong>了解数据结构之间的组织关系，这远比了解一个数据结构所有字段的作用和细节重要得多。</strong></p><p>通过前面的学习，我们已经了解了 rq、cfs_rq、rb_root_cached、sched_entity、task_struct 等数据结构，下面我们来看看它的组织关系，我特意为你准备了后面这幅图。</p><img src="`+c+`" alt="img" style="zoom:25%;"><p>运行队列框架示意图</p><p>结合图片我们发现，task_struct 结构中包含了 sched_entity 结构。sched_entity 结构是通过红黑树组织起来的，红黑树的根在 cfs_rq 结构中，cfs_rq 结构又被包含在 rq 结构，每个 CPU 对应一个 rq 结构。这样，我们就把所有运行的进程组织起来了。</p><h2 id="调度器类-sched-class" tabindex="-1"><a class="header-anchor" href="#调度器类-sched-class" aria-hidden="true">#</a> 调度器类: sched_class</h2><p>从前面的 rq 数据结构中，你已经发现了，Linux 是同时支持多个进程调度器的，不同的进程挂载到不同的运行队列中，如 rq 结构中的 cfs、rt、dl，然后针对它们这些结构，使用不同的调度器。</p><p>为了支持不同的调度器，Linux 定义了调度器类数据结构，它定义了一个调度器要实现哪些函数，代码如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">sched_class</span> <span class="token punctuation">{</span>
    <span class="token comment">//向运行队列中添加一个进程，入队</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>enqueue_task<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//向运行队列中删除一个进程，出队</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>dequeue_task<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//检查当前进程是否可抢占</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>check_preempt_curr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//从运行队列中返回可以投入运行的一个进程</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>pick_next_task<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个 sched_class 结构定义了一组函数指针，为了让你抓住重点，这里我删除了调度组和负载均衡相关的函数指针。Linux 系统一共定义了五个 sched_class 结构的实例变量，这五个 sched_class 结构紧靠在一起，形成了 sched_class 结构数组。</p><p>为了找到相应的 sched_class 结构实例，可以用以下代码遍历所有的 sched_class 结构实例变量。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//定义在链接脚本文件中</span>
<span class="token keyword">extern</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> __begin_sched_classes<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">extern</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> __end_sched_classes<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">sched_class_highest</span> <span class="token expression"><span class="token punctuation">(</span>__end_sched_classes <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">sched_class_lowest</span>  <span class="token expression"><span class="token punctuation">(</span>__begin_sched_classes <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">for_class_range</span><span class="token expression"><span class="token punctuation">(</span>class<span class="token punctuation">,</span> _from<span class="token punctuation">,</span> _to<span class="token punctuation">)</span> </span><span class="token punctuation">\\</span>
    <span class="token expression"><span class="token keyword">for</span> <span class="token punctuation">(</span>class <span class="token operator">=</span> <span class="token punctuation">(</span>_from<span class="token punctuation">)</span><span class="token punctuation">;</span> class <span class="token operator">!=</span> <span class="token punctuation">(</span>_to<span class="token punctuation">)</span><span class="token punctuation">;</span> class<span class="token operator">--</span><span class="token punctuation">)</span></span></span>
<span class="token comment">//遍历每个调度类</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">for_each_class</span><span class="token expression"><span class="token punctuation">(</span>class<span class="token punctuation">)</span> </span><span class="token punctuation">\\</span>
    <span class="token expression"><span class="token function">for_class_range</span><span class="token punctuation">(</span>class<span class="token punctuation">,</span> sched_class_highest<span class="token punctuation">,</span> sched_class_lowest<span class="token punctuation">)</span></span></span>

<span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> stop_sched_class<span class="token punctuation">;</span><span class="token comment">//停止调度类</span>
<span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> dl_sched_class<span class="token punctuation">;</span><span class="token comment">//Deadline调度类</span>
<span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> rt_sched_class<span class="token punctuation">;</span><span class="token comment">//实时调度类</span>
<span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> fair_sched_class<span class="token punctuation">;</span><span class="token comment">//CFS调度类</span>
<span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> idle_sched_class<span class="token punctuation">;</span><span class="token comment">//空转调度类</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些类是有优先级的，它们的优先级是：stop_sched_class &gt; dl_sched_class &gt; rt_sched_class &gt; fair_sched_class &gt; idle_sched_class。</p><p>下面我们观察一下，CFS 调度器（这个调度器我们稍后讨论）所需要的 fair_sched_class，代码如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> fair_sched_class
    <span class="token function">__section</span><span class="token punctuation">(</span><span class="token string">&quot;__fair_sched_class&quot;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span>enqueue_task       <span class="token operator">=</span> enqueue_task_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>dequeue_task       <span class="token operator">=</span> dequeue_task_fair<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>check_preempt_curr <span class="token operator">=</span> check_preempt_wakeup<span class="token punctuation">,</span>
    <span class="token punctuation">.</span>pick_next_task     <span class="token operator">=</span> __pick_next_task_fair<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们看到这些函数指针字段都对应到了具体的函数。其实，实现一个新的调度器，就是实现这些对应的函数。好了，我们清楚了调度器类，它就是一组函数指针，不知道你发现没有，这难道不是 C 语言下的面向对象吗？下面，我们接着研究 CFS 调度器。</p><h2 id="linux-的-cfs-调度器" tabindex="-1"><a class="header-anchor" href="#linux-的-cfs-调度器" aria-hidden="true">#</a> Linux 的 CFS 调度器</h2><p>Linux 支持多种不同的进程调度器，比如 RT 调度器、Deadline 调度器、CFS 调度器以及 Idle 调度器。不过，这里我们仅仅讨论一下 CFS 调度器，也就是完全公平调度器，CFS 的设计理念是在有限的真实硬件平台上模拟实现理想的、精确的多任务 CPU。现在你不懂也不要紧，我们后面会讨论的。</p><p>在了解 CFS 核心算法之前，你需要先掌握几个核心概念。</p><h2 id="普通进程的权重" tabindex="-1"><a class="header-anchor" href="#普通进程的权重" aria-hidden="true">#</a> 普通进程的权重</h2><p>Linux 会使用 CFS 调度器调度普通进程，CFS 调度器与其它进程调度器的不同之处在于没有时间片的概念，它是分配 CPU 使用时间的比例。比如，4 个相同优先级的进程在一个 CPU 上运行，那么每个进程都将会分配 25% 的 CPU 运行时间。这就是进程要的公平。</p><p>然而事有轻重缓急，对进程来说也是一样，有些进程的优先级就需要很高。那么 CFS 调度器是如何在公平之下，实现“不公平”的呢？</p><p>首先，CFS 调度器下不叫优先级，而是叫<strong>权重</strong>，权重表示进程的优先级，各个进程按权重的比例分配 CPU 时间。</p><p>举个例子，现在有 A、B 两个进程。进程 A 的权重是 1024，进程 B 的权重是 2048。那么进程 A 获得 CPU 的时间比例是 1024/(1024+2048) = 33.3%。进程 B 获得的 CPU 时间比例是 2048/(1024+2048)=66.7%。</p><p>因此，权重越大，分配的时间比例越大，就相当于进程的优先级越高。</p><p>有了权重之后，分配给进程的时间计算公式如下：</p><p><strong>进程的时间 = CPU 总时间 * 进程的权重 / 就绪队列所有进程权重之和</strong></p><p>但是进程对外的编程接口中使用的是一个 <strong>nice 值</strong>，大小范围是（-20～19），数值越小优先级越大，意味着权重值越大，nice 值和权重之间可以转换的。Linux 提供了后面这个数组，用于转换 nice 值和权重。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">const</span> <span class="token keyword">int</span> sched_prio_to_weight<span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
 <span class="token comment">/* -20 */</span>     <span class="token number">88761</span><span class="token punctuation">,</span>     <span class="token number">71755</span><span class="token punctuation">,</span>     <span class="token number">56483</span><span class="token punctuation">,</span>     <span class="token number">46273</span><span class="token punctuation">,</span>     <span class="token number">36291</span><span class="token punctuation">,</span>
 <span class="token comment">/* -15 */</span>     <span class="token number">29154</span><span class="token punctuation">,</span>     <span class="token number">23254</span><span class="token punctuation">,</span>     <span class="token number">18705</span><span class="token punctuation">,</span>     <span class="token number">14949</span><span class="token punctuation">,</span>     <span class="token number">11916</span><span class="token punctuation">,</span>
 <span class="token comment">/* -10 */</span>      <span class="token number">9548</span><span class="token punctuation">,</span>      <span class="token number">7620</span><span class="token punctuation">,</span>      <span class="token number">6100</span><span class="token punctuation">,</span>      <span class="token number">4904</span><span class="token punctuation">,</span>      <span class="token number">3906</span><span class="token punctuation">,</span>
 <span class="token comment">/*  -5 */</span>      <span class="token number">3121</span><span class="token punctuation">,</span>      <span class="token number">2501</span><span class="token punctuation">,</span>      <span class="token number">1991</span><span class="token punctuation">,</span>      <span class="token number">1586</span><span class="token punctuation">,</span>      <span class="token number">1277</span><span class="token punctuation">,</span>
 <span class="token comment">/*   0 */</span>      <span class="token number">1024</span><span class="token punctuation">,</span>       <span class="token number">820</span><span class="token punctuation">,</span>       <span class="token number">655</span><span class="token punctuation">,</span>       <span class="token number">526</span><span class="token punctuation">,</span>       <span class="token number">423</span><span class="token punctuation">,</span>
 <span class="token comment">/*   5 */</span>       <span class="token number">335</span><span class="token punctuation">,</span>       <span class="token number">272</span><span class="token punctuation">,</span>       <span class="token number">215</span><span class="token punctuation">,</span>       <span class="token number">172</span><span class="token punctuation">,</span>       <span class="token number">137</span><span class="token punctuation">,</span>
 <span class="token comment">/*  10 */</span>       <span class="token number">110</span><span class="token punctuation">,</span>        <span class="token number">87</span><span class="token punctuation">,</span>        <span class="token number">70</span><span class="token punctuation">,</span>        <span class="token number">56</span><span class="token punctuation">,</span>        <span class="token number">45</span><span class="token punctuation">,</span>
 <span class="token comment">/*  15 */</span>        <span class="token number">36</span><span class="token punctuation">,</span>        <span class="token number">29</span><span class="token punctuation">,</span>        <span class="token number">23</span><span class="token punctuation">,</span>        <span class="token number">18</span><span class="token punctuation">,</span>        <span class="token number">15</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个进程每降低一个 nice 值，就能多获得 10% 的 CPU 时间。1024 权重对应 nice 值为 0，被称为 NICE_0_LOAD。默认情况下，大多数进程的权重都是 NICE_0_LOAD。</p><h2 id="进程调度延迟" tabindex="-1"><a class="header-anchor" href="#进程调度延迟" aria-hidden="true">#</a> 进程调度延迟</h2><p>了解了进程权重，现在我们看看进程调度延迟，什么是调度延迟？其实就是保证每一个可运行的进程，都至少运行一次的<strong>时间间隔</strong>。</p><p>我们结合实例理解，系统中有 3 个可运行进程，每个进程都运行 10ms，那么调度延迟就是 30ms；如果有 10 个进程，那么调度延迟就是 100ms；如果现在保证调度延迟不变，固定是 30ms；如果系统中有 3 个进程，则每个进程可运行 10ms；如果有 10 个进程，则每个进程可运行 3ms。</p><p>随着进程的增加，每个进程分配的时间在减少，进程调度次数会增加，调度器占用的时间就会增加。因此，CFS 调度器的调度延迟时间的设定<strong>并不是固定的</strong>。</p><p>当运行进程少于 8 个的时候，调度延迟是固定的 6ms 不变。当运行进程个数超过 8 个时，就要保证每个进程至少运行一段时间，才被调度。这个“至少一段时间”叫作<strong>最小调度粒度时间</strong>。</p><p>在 CFS 默认设置中，最小调度粒度时间是 0.75ms，用变量 sysctl_sched_min_granularity 记录。由 __sched_period 函数负责计算，如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">unsigned</span> <span class="token keyword">int</span> sysctl_sched_min_granularity           <span class="token operator">=</span> <span class="token number">750000ULL</span><span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> normalized_sysctl_sched_min_granularity <span class="token operator">=</span> <span class="token number">750000ULL</span><span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> sched_nr_latency <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
<span class="token keyword">static</span> u64 <span class="token function">__sched_period</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> nr_running<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>nr_running <span class="token operator">&gt;</span> sched_nr_latency<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> nr_running <span class="token operator">*</span> sysctl_sched_min_granularity<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> sysctl_sched_latency<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中，参数 nr_running 是 Linux 系统中可运行的进程数量，当超过 sched_nr_latency 时，我们无法保证调度延迟，因此转为保证最小调度粒度。</p><h2 id="虚拟时间" tabindex="-1"><a class="header-anchor" href="#虚拟时间" aria-hidden="true">#</a> 虚拟时间</h2><p>你是否还记得调度实体中的 vruntime 么？它就是用来表示虚拟时间的，我们先按下不表，来看一个例子。</p><p>假设幼儿园只有一个秋千，所有孩子都想玩，身为老师的你该怎么处理呢？你一定会想每个孩子玩一段时间，然后就让给别的孩子，依次类推。CFS 调度器也是这样做的，它记录了每个进程的执行时间，为保证每个进程运行时间的公平，哪个进程运行的时间最少，就会让哪个进程运行。</p><img src="`+o+`" alt="img" style="zoom:25%;"><p>CFS调度器原理</p><p>例如，调度延迟是 10ms，系统一共 2 个相同优先级的进程，那么各进程都将在 10ms 的时间内各运行 5ms。</p><p>现在进程 A 和进程 B 他们的权重分别是 1024 和 820（nice 值分别是 0 和 1）。进程 A 获得的运行时间是 10x1024/(1024+820)=5.6ms，进程 B 获得的执行时间是 10x820/(1024+820)=4.4ms。进程 A 的 cpu 使用比例是 5.6/10x100%=56%，进程 B 的 cpu 使用比例是 4.4/10x100%=44%。</p><p>很明显，这两个进程的实际执行时间是不等的，但 CFS 调度器想保证每个进程的运行时间相等。因此 CFS 调度器引入了虚拟时间，也就是说，上面的 5.6ms 和 4.4ms 经过一个公式，转换成相同的值，这个转换后的值就叫虚拟时间。这样的话，CFS 只需要保证每个进程运行的虚拟时间是相等的。</p><p>虚拟时间 vruntime 和实际时间（wtime）转换公式如下：</p><p>vruntime = wtime*( NICE_0_LOAD/weight)</p><p>根据上面的公式，可以发现 nice 值为 0 的进程，这种进程的虚拟时间和实际时间是相等的，那么进程 A 的虚拟时间为：5.6*(1024/1024)=5.6，进程 B 的虚拟时间为：4.4*(1024/820)=5.6。虽然进程 A 和进程 B 的权重不一样，但是计算得到的虚拟时间是一样的。</p><p>所以，CFS 调度主要保证每个进程运行的虚拟时间一致即可。在选择下一个即将运行的进程时，只需要找到虚拟时间最小的进程就行了。这个计算过程由 calc_delta_fair 函数完成，如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> u64 <span class="token function">__calc_delta</span><span class="token punctuation">(</span>u64 delta_exec<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> weight<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">load_weight</span> <span class="token operator">*</span>lw<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    u64 fact <span class="token operator">=</span> <span class="token function">scale_load_down</span><span class="token punctuation">(</span>weight<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> shift <span class="token operator">=</span> WMULT_SHIFT<span class="token punctuation">;</span>
    <span class="token function">__update_inv_weight</span><span class="token punctuation">(</span>lw<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>fact <span class="token operator">&gt;&gt;</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>fact <span class="token operator">&gt;&gt;</span> <span class="token number">32</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            fact <span class="token operator">&gt;&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            shift<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//为了避免使用浮点计算</span>
    fact <span class="token operator">=</span> <span class="token function">mul_u32_u32</span><span class="token punctuation">(</span>fact<span class="token punctuation">,</span> lw<span class="token operator">-&gt;</span>inv_weight<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>fact <span class="token operator">&gt;&gt;</span> <span class="token number">32</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        fact <span class="token operator">&gt;&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        shift<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">mul_u64_u32_shr</span><span class="token punctuation">(</span>delta_exec<span class="token punctuation">,</span> fact<span class="token punctuation">,</span> shift<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> u64 <span class="token function">calc_delta_fair</span><span class="token punctuation">(</span>u64 delta<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>se<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>se<span class="token operator">-&gt;</span>load<span class="token punctuation">.</span>weight <span class="token operator">!=</span> NICE_0_LOAD<span class="token punctuation">)</span><span class="token punctuation">)</span>
        delta <span class="token operator">=</span> <span class="token function">__calc_delta</span><span class="token punctuation">(</span>delta<span class="token punctuation">,</span> NICE_0_LOAD<span class="token punctuation">,</span> <span class="token operator">&amp;</span>se<span class="token operator">-&gt;</span>load<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> delta<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>按照上面的理论，调用 __calc_delta 函数的时候，传递的 weight 参数是 NICE_0_LOAD，lw 参数正是调度实体中的 load_weight 结构体。</p><p><strong>到这里，我要公开一个问题，在运行队列中用红黑树结构组织进程的调度实体，这里进程虚拟时间正是红黑树的 key，这样进程就以进程的虚拟时间被红黑树组织起来了。红黑树的最左子节点，就是虚拟时间最小的进程，随着时间的推移进程会从红黑树的左边跑到右，然后从右边跑到左边，就像舞蹈一样优美。</strong></p><h2 id="cfs-调度进程" tabindex="-1"><a class="header-anchor" href="#cfs-调度进程" aria-hidden="true">#</a> CFS 调度进程</h2><p>根据前面的内容，我们得知 CFS 调度器就是要维持各个可运行进程的虚拟时间相等，不相等就需要被调度运行。如果一个进程比其它进程的虚拟时间小，它就应该运行达到和其它进程的虚拟时间持平，直到它的虚拟时间超过其它进程，这时就要停下来，这样其它进程才能被调度运行。</p><h2 id="定时周期调度" tabindex="-1"><a class="header-anchor" href="#定时周期调度" aria-hidden="true">#</a> 定时周期调度</h2><p>前面虚拟时间的方案还存在问题，你发现了么？</p><p>没错，虚拟时间就是一个数据，如果没有任何机制对它进行更新，就会导致一个进程永远运行下去，因为那个进程的虚拟时间没有更新，虚拟时间永远最小，这当然不行。</p><p>因此定时周期调度机制应运而生。Linux 启动会启动定时器，这个定时器每 1/1000、1/250、1/100 秒（根据配置不同选取其一），产生一个时钟中断，在中断处理函数中最终会调用一个 scheduler_tick 函数，代码如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">update_curr</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>curr <span class="token operator">=</span> cfs_rq<span class="token operator">-&gt;</span>curr<span class="token punctuation">;</span>
    u64 now <span class="token operator">=</span> <span class="token function">rq_clock_task</span><span class="token punctuation">(</span><span class="token function">rq_of</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取当前时间 </span>
    u64 delta_exec<span class="token punctuation">;</span>
    delta_exec <span class="token operator">=</span> now <span class="token operator">-</span> curr<span class="token operator">-&gt;</span>exec_start<span class="token punctuation">;</span><span class="token comment">//间隔时间 </span>
    curr<span class="token operator">-&gt;</span>exec_start <span class="token operator">=</span> now<span class="token punctuation">;</span>
    curr<span class="token operator">-&gt;</span>sum_exec_runtime <span class="token operator">+=</span> delta_exec<span class="token punctuation">;</span><span class="token comment">//累计运行时间 </span>
    curr<span class="token operator">-&gt;</span>vruntime <span class="token operator">+=</span> <span class="token function">calc_delta_fair</span><span class="token punctuation">(</span>delta_exec<span class="token punctuation">,</span> curr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//计算进程的虚拟时间 </span>
    <span class="token function">update_min_vruntime</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//更新运行队列中的最小虚拟时间，这是新建进程的虚拟时间，避免一个新建进程因为虚拟时间太小而长时间占用CPU</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">entity_tick</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token keyword">int</span> queued<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">update_curr</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//更新当前运行进程和运行队列相关的时间</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cfs_rq<span class="token operator">-&gt;</span>nr_running <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//当运行进程数量大于1就检查是否可抢占</span>
        <span class="token function">check_preempt_tick</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> curr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">for_each_sched_entity</span><span class="token expression"><span class="token punctuation">(</span>se<span class="token punctuation">)</span> </span><span class="token punctuation">\\</span>
        <span class="token expression"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> se<span class="token punctuation">;</span> se <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span></span></span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">task_tick_fair</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>curr<span class="token punctuation">,</span> <span class="token keyword">int</span> queued<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>se <span class="token operator">=</span> <span class="token operator">&amp;</span>curr<span class="token operator">-&gt;</span>se<span class="token punctuation">;</span><span class="token comment">//获取当前进程的调度实体 </span>
    <span class="token function">for_each_sched_entity</span><span class="token punctuation">(</span>se<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//仅对当前进程的调度实体</span>
        cfs_rq <span class="token operator">=</span> <span class="token function">cfs_rq_of</span><span class="token punctuation">(</span>se<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取当前进程的调度实体对应运行队列</span>
        <span class="token function">entity_tick</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> se<span class="token punctuation">,</span> queued<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">scheduler_tick</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> cpu <span class="token operator">=</span> <span class="token function">smp_processor_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq <span class="token operator">=</span> <span class="token function">cpu_rq</span><span class="token punctuation">(</span>cpu<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取运行CPU运行进程队列</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>curr <span class="token operator">=</span> rq<span class="token operator">-&gt;</span>curr<span class="token punctuation">;</span><span class="token comment">//获取当进程</span>
    <span class="token function">update_rq_clock</span><span class="token punctuation">(</span>rq<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//更新运行队列的时间等数据</span>
    curr<span class="token operator">-&gt;</span>sched_class<span class="token operator">-&gt;</span><span class="token function">task_tick</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> curr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//更新当前时间的虚拟时间</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中，scheduler_tick 函数会调用进程调度类的 task_tick 函数，对于 CFS 调度器就是 task_tick_fair 函数。但是真正做事的是 <strong>entity_tick 函数</strong>，entity_tick 函数中调用了 update_curr 函数更新当前进程虚拟时间，这个函数我们在之前讨论过了，还更新了运行队列的相关数据。</p><p>entity_tick 函数的最后，调用了 check_preempt_tick 函数，用来检查是否可以抢占调度，代码如下。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">check_preempt_tick</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>curr<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> ideal_runtime<span class="token punctuation">,</span> delta_exec<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>se<span class="token punctuation">;</span>
    s64 delta<span class="token punctuation">;</span>
    <span class="token comment">//计算当前进程在本次调度中分配的运行时间</span>
    ideal_runtime <span class="token operator">=</span> <span class="token function">sched_slice</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> curr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//当前进程已经运行的实际时间</span>
    delta_exec <span class="token operator">=</span> curr<span class="token operator">-&gt;</span>sum_exec_runtime <span class="token operator">-</span> curr<span class="token operator">-&gt;</span>prev_sum_exec_runtime<span class="token punctuation">;</span>
    <span class="token comment">//如果实际运行时间已经超过分配给进程的运行时间，就需要抢占当前进程。设置进程的TIF_NEED_RESCHED抢占标志。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>delta_exec <span class="token operator">&gt;</span> ideal_runtime<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">resched_curr</span><span class="token punctuation">(</span><span class="token function">rq_of</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//因此如果进程运行时间小于最小调度粒度时间，不应该抢占</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>delta_exec <span class="token operator">&lt;</span> sysctl_sched_min_granularity<span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token comment">//从红黑树中找到虚拟时间最小的调度实体</span>
    se <span class="token operator">=</span> <span class="token function">__pick_first_entity</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
    delta <span class="token operator">=</span> curr<span class="token operator">-&gt;</span>vruntime <span class="token operator">-</span> se<span class="token operator">-&gt;</span>vruntime<span class="token punctuation">;</span>
    <span class="token comment">//如果当前进程的虚拟时间仍然比红黑树中最左边调度实体虚拟时间小，也不应该发生调度</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>delta <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>刚才的代码你可以这样理解，如果需要抢占就会调用 resched_curr 函数设置进程的抢占标志，但是这个函数本身不会调用进程调度器函数，而是在进程从中断或者系统调用返回到用户态空间时，检查当前进程的调度标志，然后根据需要调用进程调度器函数。</p><h2 id="调度器入口" tabindex="-1"><a class="header-anchor" href="#调度器入口" aria-hidden="true">#</a> 调度器入口</h2><p>如果设计需要进行进程抢占调度，Linux 就会在适当的时机进行进程调度，进程调度就是调用进程调度器入口函数，该函数会选择一个最合适投入运行的进程，然后切换到该进程上运行。</p><p>我们先来看看，进程调度器入口函数的代码长什么样。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">void</span> __sched notrace <span class="token function">__schedule</span><span class="token punctuation">(</span>bool preempt<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev<span class="token punctuation">,</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span>switch_count<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> prev_state<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> rf<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">;</span>
    <span class="token keyword">int</span> cpu<span class="token punctuation">;</span>
    cpu <span class="token operator">=</span> <span class="token function">smp_processor_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    rq <span class="token operator">=</span> <span class="token function">cpu_rq</span><span class="token punctuation">(</span>cpu<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取当前CPU的运行队列</span>
    prev <span class="token operator">=</span> rq<span class="token operator">-&gt;</span>curr<span class="token punctuation">;</span> <span class="token comment">//获取当前进程 </span>
    <span class="token function">rq_lock</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//运行队列加锁</span>
    <span class="token function">update_rq_clock</span><span class="token punctuation">(</span>rq<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//更新运行队列时钟</span>
    switch_count <span class="token operator">=</span> <span class="token operator">&amp;</span>prev<span class="token operator">-&gt;</span>nivcsw<span class="token punctuation">;</span>
    next <span class="token operator">=</span> <span class="token function">pick_next_task</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取下一个投入运行的进程</span>
    <span class="token function">clear_tsk_need_resched</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//清除抢占标志</span>
    <span class="token function">clear_preempt_need_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>prev <span class="token operator">!=</span> next<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//当前运行进程和下一个运行进程不同，就要进程切换</span>
        rq<span class="token operator">-&gt;</span>nr_switches<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//切换计数统计</span>
        <span class="token operator">++</span><span class="token operator">*</span>switch_count<span class="token punctuation">;</span>
        rq <span class="token operator">=</span> <span class="token function">context_switch</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> next<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//进程机器上下文切换</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        rq<span class="token operator">-&gt;</span>clock_update_flags <span class="token operator">&amp;=</span> <span class="token operator">~</span><span class="token punctuation">(</span>RQCF_ACT_SKIP<span class="token operator">|</span>RQCF_REQ_SKIP<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">rq_unlock_irq</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//解锁运行队列</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk <span class="token operator">=</span> current<span class="token punctuation">;</span><span class="token comment">//获取当前进程</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        <span class="token function">preempt_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//关闭内核抢占</span>
        <span class="token function">__schedule</span><span class="token punctuation">(</span>false<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//进程调用</span>
        <span class="token function">sched_preempt_enable_no_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//开启内核抢占</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">need_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//是否需要再次重新调用</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>之所以在循环中调用 __schedule 函数执行真正的进程调度，是因为在执行调度的过程中，有些更高优先级的进程进入了可运行状态，因此它就要抢占当前进程。</p><p>__schedule 函数中会更新一些统计数据，然后调用 pick_next_task 函数挑选出下一个进程投入运行。最后，如果当前进程和下一个要运行的进程不同，就要进行进程机器上下文切换，其中会切换地址空间和 CPU 寄存器。</p><h2 id="挑选下一个进程" tabindex="-1"><a class="header-anchor" href="#挑选下一个进程" aria-hidden="true">#</a> 挑选下一个进程</h2><p>在 __schedule 函数中，获取了正在运行的进程，更新了运行队列的时钟，下面就要挑选出下一个投入运行的进程。显然，不是随便挑选一个，我们这就来看看调度器是如何挑选的。</p><p>挑选下一个运行进程这个过程，是在 pick_next_task 函数中完成的，如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token function">pick_next_task</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> <span class="token operator">*</span>rf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sched_class</span> <span class="token operator">*</span>class<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
    <span class="token comment">//这是对CFS的一种优化处理，因为大部分进程属于CFS管理</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>prev<span class="token operator">-&gt;</span>sched_class <span class="token operator">&lt;=</span> <span class="token operator">&amp;</span>fair_sched_class <span class="token operator">&amp;&amp;</span>
           rq<span class="token operator">-&gt;</span>nr_running <span class="token operator">==</span> rq<span class="token operator">-&gt;</span>cfs<span class="token punctuation">.</span>h_nr_running<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        p <span class="token operator">=</span> <span class="token function">pick_next_task_fair</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> rf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用CFS的对应的函数</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>p <span class="token operator">==</span> RETRY_TASK<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">goto</span> restart<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//如果没有获取到运行进程</span>
            <span class="token function">put_prev_task</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> prev<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将上一个进程放回运行队列中</span>
            p <span class="token operator">=</span> <span class="token function">pick_next_task_idle</span><span class="token punctuation">(</span>rq<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取空转进程</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> p<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
restart<span class="token operator">:</span>
    <span class="token function">for_each_class</span><span class="token punctuation">(</span>class<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//依次从最高优先级的调度类开始遍历</span>
        p <span class="token operator">=</span> class<span class="token operator">-&gt;</span><span class="token function">pick_next_task</span><span class="token punctuation">(</span>rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token comment">//如果在一个调度类所管理的运行队列中挑选到一个进程，立即返回</span>
            <span class="token keyword">return</span> p<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">BUG</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//出错</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你看，pick_next_task 函数只是个框架函数，它的逻辑也很清楚，会依照优先级调用具体调度器类的函数完成工作，对于 CFS 则会调用 pick_next_task_fair 函数，代码如下所示。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token function">pick_next_task_fair</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rq</span> <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>prev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rq_flags</span> <span class="token operator">*</span>rf<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq <span class="token operator">=</span> <span class="token operator">&amp;</span>rq<span class="token operator">-&gt;</span>cfs<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>se<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>prev<span class="token punctuation">)</span>
        <span class="token function">put_prev_task</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> prev<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//把上一个进程放回运行队列</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        se <span class="token operator">=</span> <span class="token function">pick_next_entity</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//选择最适合运行的调度实体</span>
        <span class="token function">set_next_entity</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> se<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//对选择的调度实体进行一些处理</span>
        cfs_rq <span class="token operator">=</span> <span class="token function">group_cfs_rq</span><span class="token punctuation">(</span>se<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//在没有调度组的情况下，循环一次就结束了</span>
    p <span class="token operator">=</span> <span class="token function">task_of</span><span class="token punctuation">(</span>se<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//通过se获取包含se的进程task_struct</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中调用 pick_next_entity 函数选择虚拟时间最小的调度实体，然后调用 set_next_entity 函数，对选择的调度实体进行一些必要的处理，主要是将这调度实体从运行队列中拿出来。</p><p>pick_next_entity 函数具体要怎么工作呢？</p><p>首先，它调用了相关函数，从运行队列上的红黑树中查找虚拟时间最少的调度实体，然后处理要跳过调度的情况，最后决定挑选的调度实体是否可以抢占并返回它。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span><span class="token function">__pick_first_entity</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>left <span class="token operator">=</span> <span class="token function">rb_first_cached</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cfs_rq<span class="token operator">-&gt;</span>tasks_timeline<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//先读取在tasks_timeline中rb_node指针</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>left<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">//如果为空直接返回NULL</span>
    <span class="token comment">//通过红黑树结点指针取得包含它的调度实体结构地址</span>
    <span class="token keyword">return</span> <span class="token function">rb_entry</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span><span class="token punctuation">,</span> run_node<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span><span class="token function">__pick_next_entity</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>se<span class="token punctuation">)</span>
<span class="token punctuation">{</span>    <span class="token comment">//获取当前红黑树节点的下一个结点</span>
    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>next <span class="token operator">=</span> <span class="token function">rb_next</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>se<span class="token operator">-&gt;</span>run_node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>next<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">//如果为空直接返回NULL</span>
    <span class="token keyword">return</span> <span class="token function">rb_entry</span><span class="token punctuation">(</span>next<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span><span class="token punctuation">,</span> run_node<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span><span class="token function">pick_next_entity</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cfs_rq</span> <span class="token operator">*</span>cfs_rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>curr<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">//获取Cfs_rq中的红黑树上最左节点上调度实体，虚拟时间最小</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>left <span class="token operator">=</span> <span class="token function">__pick_first_entity</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>se<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>left <span class="token operator">||</span> <span class="token punctuation">(</span>curr <span class="token operator">&amp;&amp;</span> <span class="token function">entity_before</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> left<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        left <span class="token operator">=</span> curr<span class="token punctuation">;</span><span class="token comment">//可能当前进程主动放弃CPU，它的虚拟时间比红黑树上的还小，所以left指向当前进程调度实体</span>
    se <span class="token operator">=</span> left<span class="token punctuation">;</span> 
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cfs_rq<span class="token operator">-&gt;</span>skip <span class="token operator">==</span> se<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//如果选择的调度实体是要跳过的调度实体</span>
        <span class="token keyword">struct</span> <span class="token class-name">sched_entity</span> <span class="token operator">*</span>second<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>se <span class="token operator">==</span> curr<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//如果是当前调度实体</span>
            second <span class="token operator">=</span> <span class="token function">__pick_first_entity</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//选择运行队列中虚拟时间最小的调度实体</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">//否则选择红黑树上第二左的进程节点</span>
            second <span class="token operator">=</span> <span class="token function">__pick_next_entity</span><span class="token punctuation">(</span>se<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//如果次优的调度实体的虚拟时间，还是比当前的调度实体的虚拟时间大</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>second <span class="token operator">||</span> <span class="token punctuation">(</span>curr <span class="token operator">&amp;&amp;</span> <span class="token function">entity_before</span><span class="token punctuation">(</span>curr<span class="token punctuation">,</span> second<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                second <span class="token operator">=</span> curr<span class="token punctuation">;</span><span class="token comment">//让次优的调度实体也指向当前调度实体</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//判断left和second的虚拟时间的差距是否小于sysctl_sched_wakeup_granularity</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>second <span class="token operator">&amp;&amp;</span> <span class="token function">wakeup_preempt_entity</span><span class="token punctuation">(</span>second<span class="token punctuation">,</span> left<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span>
            se <span class="token operator">=</span> second<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cfs_rq<span class="token operator">-&gt;</span>next <span class="token operator">&amp;&amp;</span> <span class="token function">wakeup_preempt_entity</span><span class="token punctuation">(</span>cfs_rq<span class="token operator">-&gt;</span>next<span class="token punctuation">,</span> left<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        se <span class="token operator">=</span> cfs_rq<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cfs_rq<span class="token operator">-&gt;</span>last <span class="token operator">&amp;&amp;</span> <span class="token function">wakeup_preempt_entity</span><span class="token punctuation">(</span>cfs_rq<span class="token operator">-&gt;</span>last<span class="token punctuation">,</span> left<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
             se <span class="token operator">=</span> cfs_rq<span class="token operator">-&gt;</span>last<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">clear_buddies</span><span class="token punctuation">(</span>cfs_rq<span class="token punctuation">,</span> se<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//需要清除掉last、next、skip指针</span>
    <span class="token keyword">return</span> se<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码的调用路径最终会返回到 __schedule 函数中，这个函数中就是上一个运行的进程和将要投入运行的下一个进程，最后调用 context_switch 函数，完成两个进程的地址空间和机器上下文的切换，一次进程调度工作结束。这个机制和我们的 Cosmos 的 <strong>save_to_new_context 函数</strong>类似，不再赘述。</p><p>至此 CFS 调度器的基本概念与数据结构，还有算法实现，我们就搞清楚了，核心就是<strong>让虚拟时间最小的进程最先运行， 一旦进程运行虚拟时间就会增加，最后尽量保证所有进程的虚拟时间相等，谁小了就要多运行，谁大了就要暂停运行。</strong></p><h2 id="重点回顾" tabindex="-1"><a class="header-anchor" href="#重点回顾" aria-hidden="true">#</a> 重点回顾</h2><p>Linux 如何表示一个进程以及如何进行多个进程调度，我们已经搞清楚了。我们来总结一下。</p><img src="`+l+'" alt="img" style="zoom:25%;"><p>你可能在想。为什么要用红黑树来组织调度实体？这是因为要维护虚拟时间的顺序，又要从中频繁的删除和插入调度实体，这种情况下红黑树这种结构无疑是非常好，如果你有更好的选择，可以向 Linux 社区提交补丁。</p><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题" aria-hidden="true">#</a> 思考题</h2><p>想一想，Linux 进程的优先级和 Linux 调度类的优先级是一回事儿吗？</p><p>欢迎你在留言区记录你的学习经验或者个我交流讨论，也欢迎你把这节课转发给需要的朋友。</p><p>好，我是 LMOS，我们下节课见！</p>',148),r=[u];function k(d,m){return n(),a("div",null,r)}const b=s(i,[["render",k],["__file","I27-Linux进程管理系统.html.vue"]]);export{b as default};
