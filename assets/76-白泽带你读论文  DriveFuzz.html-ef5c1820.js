import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o as t,c as o,a as e,b as i,e as s,d as l}from"./app-cdabc73c.js";const p="/assets/640-1691113275847-24-0c87104b.png",d="/assets/640-1691113275847-25-24412bc9.png",g="/assets/640-1691113275847-26-7ebb5f9d.png",u="/assets/640-1691113275847-27-f9cb3d2b.png",c={},h=e("h1",{id:"_76-白泽带你读论文-drivefuzz",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_76-白泽带你读论文-drivefuzz","aria-hidden":"true"},"#"),i(" 76-白泽带你读论文 | DriveFuzz")],-1),z={href:"https://arxiv.org/pdf/2211.01829.pdf",target:"_blank",rel:"noopener noreferrer"},f=l('<p><strong>如需转载请注明出处，侵权必究。</strong></p><p>本文发表于CCS 22，第一作者是来自佐治亚理工学院的Seulbae Kim博士。</p><p>论文提出了一个将自动驾驶系统（ADS）作为整体进行模糊测试的框架——DriveFuzz，它不关注ADS中单层的细节，而是关注在驾驶环境中不断变化的车辆状态。DriveFuzz通过变换多种因素自动生成驾驶场景，在驾驶模拟器上进行测试，同时依据基于交通规则的测试标准来检测错误行为，通过驾驶质量分数引导fuzzer触发错误行为，进而发现ADS存在的bug。从实验结果来看，DriveFuzz在Autoware和Behavior Agent这两个ADS以及CARLA模拟器中共发现了30个新bug。</p><h2 id="背景" tabindex="-1"><a class="header-anchor" href="#背景" aria-hidden="true">#</a> 背景</h2><p>现有工作大多关注ADS单个层中的bug，虽然这些工作大大提高了单个层的安全性，但是由于ADS系统具有多层结构，不同的层以级联方式协同工作，针对某一层的单独测试可能无法检测到某些bug。例如，某一层的bug在单独测试时不会造成可见的影响，但会引起其他层的不当行为。只有将所有层作为一个整体进行测试，才能检测到此类bug。</p><figure><img src="'+p+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>上图展示了通用的ADS框架，包括sensing, perception, planning, actuation四层结构，这些层以级联的方式一起工作，即每一层从前一层获取输入，产生的输出被下一层消耗。每一层的功能如下：</p><ol><li><strong>sensing</strong>：使用各种传感器获取周围环境的原始数据；</li><li><strong>perception</strong>：融合捕获的传感器数据，以理解当前的位置和车辆周围的环境；</li><li><strong>planning</strong>：根据感知到的状态，为给定的地图和目的地制定路径规划；</li><li><strong>actuation</strong>：根据路径规划，建立一个具体的运动计划，包括方向盘角度、速度等，并将相应指令发送给车辆实现自动驾驶。</li></ol><h2 id="挑战" tabindex="-1"><a class="header-anchor" href="#挑战" aria-hidden="true">#</a> 挑战</h2><p>设计一个针对ADS整体的反馈引导的模糊测试框架需要解决以下三个挑战：</p><ol><li>测试ADS的输入是什么？</li><li>如何确定系统触发了bug？</li><li>用什么作为反馈引导的指标？</li></ol><h2 id="系统架构设计" tabindex="-1"><a class="header-anchor" href="#系统架构设计" aria-hidden="true">#</a> 系统架构设计</h2><p>下图是DriveFuzz的概述，下面将对该框架的工作流程和主要模块进行介绍。</p><figure><img src="'+d+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h2 id="工作流程" tabindex="-1"><a class="header-anchor" href="#工作流程" aria-hidden="true">#</a> 工作流程</h2><p>根据提供的输入驾驶场景，Mutation engine生成并变异与任务、天气、参与者、水坑相关的各个方面。Test executor启动待测试的ADS，协调驾驶模拟器，为突变的驾驶场景做准备，并将任务分配给ego车。当ego车执行任务时，Misbehavior detector利用交通法规来检测错误行为。如果ego车在没有任何错误行为的情况下完成了任务，那么Driving quality feedback engine将通过分析车辆状态来量化整体驾驶质量，从而引导进一步的突变，产生驾驶质量降低的场景。</p><h2 id="mutation-engine" tabindex="-1"><a class="header-anchor" href="#mutation-engine" aria-hidden="true">#</a> Mutation engine</h2><p>输入的驾驶场景包括一个预定义的3D地图、一个由起始位置和目标位置定义的任务、其他车辆与行人组成的参与者、无形水坑和天气条件。Mutation engine通过突变任务、参与者、水坑和天气，模拟真实世界中可能出现的场景。具体来讲，通过在给定地图上随机选择初始点和目标点产生任务；通过随机选择参与者的类型、初始位置和目的地、导航方法、目标速度和轨迹产生参与者；通过随机选择位置、大小和摩擦力产生水坑；通过改变雨、云、风、雾、湿度、水坑、太阳方位角和太阳高度八个方面产生天气条件。</p><p>同时，作者提出了以下几种变异策略，它们既可以单独使用，也可以在每一轮fuzzing结束后进行更换。</p><ol><li><strong>Adversarial maneuver-based</strong>：只引入并改变相邻参与者的移动，迫使与目标系统交互，例如，参与者车辆突然通过切换车道拦截ego车。</li><li><strong>Congestion-based</strong>：只引入自动驾驶的参与者，使目标ADS在越来越拥挤但合法的情况下驱动。</li><li><strong>Entropy-based</strong>：只引入一个线性或不移动的参与者，测试目标系统在鲁莽司机和非法行人周围安全驾驶的能力。</li><li><strong>Instability-based</strong>：只插入一个不同大小和摩擦的水坑，测试运动控制器的鲁棒性。</li></ol><h2 id="test-executor" tabindex="-1"><a class="header-anchor" href="#test-executor" aria-hidden="true">#</a> Test executor</h2><p>Test executor利用驾驶模拟器，在给定的驾驶场景下运行目标ADS，同时为模糊过程收集各种车辆状态。</p><h2 id="misbehavior-detector" tabindex="-1"><a class="header-anchor" href="#misbehavior-detector" aria-hidden="true">#</a> Misbehavior detector</h2><p>Misbehavior detector根据现实世界的交通法规检测自动驾驶过程中存在的错误行为，具体包括以下几种事件：碰撞、违规行为（包括超速、车道入侵、闯红灯）、非法停车。在检测到错误行为后，将生成bug报告，并在记录所有的车辆状态以进行后续检查后立即终止模拟过程。</p><h2 id="driving-quality-feedback-engine" tabindex="-1"><a class="header-anchor" href="#driving-quality-feedback-engine" aria-hidden="true">#</a> Driving quality feedback engine</h2><p>如果没有检测到错误行为，Driving quality feedback engine会对本次模拟的驾驶质量进行打分。作者参考了美国国家公路交通安全管理局运输部调查交通事故原因的报告和汽车保险公司的数据，确定了引发交通事故的几种主要的鲁莽驾驶行为，具体包括硬加速、硬刹车、硬转弯、转向过度和转向不足。DriveFuzz基于这些行为出现的次数，以及与其他参与者的最小距离来衡量驾驶质量。驾驶质量分数会作为反馈提供给Mutation engine，以引导下次突变产生更容易导致错误行为的输入场景。</p><h2 id="实验评估" tabindex="-1"><a class="header-anchor" href="#实验评估" aria-hidden="true">#</a> 实验评估</h2><h3 id="漏洞挖掘能力" tabindex="-1"><a class="header-anchor" href="#漏洞挖掘能力" aria-hidden="true">#</a> <strong>漏洞挖掘能力</strong></h3><p>DriveFuzz共发现了34个bug，其中，在Autoware中发现了17个新bug和1个已知问题；在Behavior Agent中发现了13个bug；在CARLA中检测到3个模拟器错误。下图展示了DriveFuzz发现的所有新bug、它们所在的组件、每个错误的影响和根本原因。作者对这些bug进行了深入分析，根据bug产生的根本原因将其分为四类：ADS跨层错误、ADS逻辑错误、ADS功能缺失、模拟器错误。</p><figure><img src="'+g+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h3 id="对比最先进的测试方法" tabindex="-1"><a class="header-anchor" href="#对比最先进的测试方法" aria-hidden="true">#</a> <strong>对比最先进的测试方法</strong></h3><p>作者从定量和定性两个角度分析了DriveFuzz在漏洞发掘方面的能力优于最先进的ADS测试方法——AV-Fuzzer。首先，从定量角度分析，AV-Fuzzer的输入空间是DriveFuzz的一个子集，覆盖的输入场景数量远不如DriveFuzz；而且，AV-fuzzer只能检测碰撞，DriveFuzz还可以检测违反交规的行为。其次，从定性角度分析，DriveFuzz提供的反馈质量高于AV-Fuzzer，DriveFuzz考虑了车辆的物理状态，提供对鲁莽行为的细粒度反馈，而AV-Fuzzer只关注了车辆互相接近的情况，没考虑车辆的物理状态。</p><h3 id="驾驶质量评估的正确性与有效性" tabindex="-1"><a class="header-anchor" href="#驾驶质量评估的正确性与有效性" aria-hidden="true">#</a> <strong>驾驶质量评估的正确性与有效性</strong></h3><p>在相同条件下运行具有驾驶质量反馈和没有驾驶质量反馈的两种fuzzer，结果如下图，具有驾驶质量反馈的fuzzer在相同时间内能够发现更多错误行为，证明了驾驶质量反馈的有效性。</p><figure><img src="'+u+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>本文提出了一个端到端的模糊框架，它将ADS的所有层作为整体进行测试，并提出了驾驶质量的概念以引导fuzzer的突变，从而检测ADS所有层中容易被攻击者利用的bug。从实验结果来看，DriveFuzz发现了两个ADS中的30个新漏洞以及CARLA模拟器中的3个漏洞，证明了该工具在漏洞挖掘方面的有效性，为提高ADS的整体安全性做出了贡献。</p><p><strong>Q&amp;A</strong></p><p><strong>Q1. 突变过程中施加的约束及目的是什么？</strong></p><p>包括空间约束和时间约束，它们的目的是排除不切实际的场景，避免其引发错误行为导致的假阳性。具体来讲，空间约束通过规定不同参与者之间的最小距离实现，时间约束通过规定参与者的最大速度实现。</p><p><strong>Q2. 为什么用驾驶质量作为反馈，而不用传统的代码覆盖度作反馈？</strong></p><p>因为代码覆盖度主要应用于软件模糊测试，在这一场景下，代码覆盖度的提高确实能帮助发现更多的bug，而对ADS的模糊测试，目的是发现由bug引发的错误行为，错误行为不依赖于代码覆盖度，而是与驾驶过程中的鲁莽行为密切相关。驾驶质量综合考虑了几种容易引发事故的鲁莽行为，用其作反馈可以生成更容易触发错误行为的输入，有助于发现更多bug。</p><p><strong>Q3. 驾驶质量反馈机制的主要贡献是什么？</strong></p><ol><li><em>使用车辆的物理状态，可以量化驾驶过程中的鲁莽行为，而不需要代码分析</em>。</li><li>提供了细粒度的反馈机制，为驾驶场景的生成提供了有效的指导，有利于检测到实际的错误行为。</li></ol><p><strong>Q4. 如何识别错误行为的根本原因？</strong></p><p>通过重放触发错误行为的数据进行组件级的数据流和控制流分析，具体包括分析sensing层是否准确地读取了环境信息、perception层是否正确解释了传感器捕获的数据、planning层是否找到了一条可行的路径、actuation层是否发出了恰当的控制命令。</p><p><strong>Q5. 本文工作存在哪些不足？</strong></p><ol><li>反馈驱动的fuzzer存在局部最优问题，可能导致遗漏了与feedback关系较小的其他潜在错误。</li><li>可能存在不影响驾驶质量评分，但仍会导致错误行为的攻击。比如攻击者在一条直道上伪造一个弯曲车道，并引导车辆行驶在这条虚假车道上，车辆的驾驶质量评分很好，但会导致车道入侵等错误行为。</li></ol><blockquote><p>学习程序模糊测试可以从以下指南和参考资料入手：</p><ol><li><p>书籍：《自动化软件测试：模糊测试与安全测试导论》(Automated Software Testing: Introduction, Management, and Performance) 是一本关于模糊测试和安全测试的经典教材，提供了对模糊测试的详细介绍和实践指导。</p></li><li><p>学术论文和研究文章：阅读相关学术论文和研究文章可以了解当前程序模糊测试领域的最新研究成果和技术进展。可以在学术会议（如IEEE S&amp;P、USENIX Security等）和期刊上查找相关文章，例如《ACM Transactions on Software Engineering and Methodology》、《IEEE Transactions on Software Engineering》等。</p></li><li><p>开源工具文档和社区：许多程序模糊测试工具（如AFL、Peach Fuzzer、Radamsa等）提供了官方文档和社区支持，通过阅读这些文档和参与讨论可以学习实际的模糊测试技术和工具使用。</p></li></ol><p>程序模糊测试的知识结构包括以下几个核心要点：</p><ol><li><p>基本概念和原理：了解模糊测试的基本概念、原理和基本流程，包括输入模型设计、测试用例生成、输入变异、错误检测等。对模糊测试的基本概念有清晰的理解是理解后续的技术和方法的基础。</p></li><li><p>输入生成技术：掌握不同类型的输入生成技术，包括随机生成、基于语法的生成、基于输入格式的生成等。学习如何选择和设计合适的输入生成技术以生成有效的测试用例。</p></li><li><p>输入变异和演化算法：了解输入变异技术和基于演化算法的优化方法，用于改进生成的测试用例的覆盖率和多样性。学习如何使用变异和演化算法来改进模糊测试的效果。</p></li><li><p>错误检测和覆盖率评估：熟悉错误检测技术和覆盖率评估方法，用于判断测试用例是否触发了潜在的漏洞或错误。学习如何定义和计算程序的覆盖率，以及如何有效地检测错误。</p></li><li><p>模糊测试工具和框架：了解常见的模糊测试工具和框架，如AFL、Peach Fuzzer、Radamsa等。学习如何使用这些工具和框架进行模糊测试，包括配置参数、选择目标和解释结果等。</p></li></ol><p>在学习程序模糊测试之前，建议具备以下前置知识：</p><ol><li><p>编程语言：对于目标应用程序使用的编程语言有一定的了解，熟悉基本的语法和编程原理。</p></li><li><p>软件测试基础：了解软件测试的基本概念、测试方法和技术，包括白盒测试、黑盒测试、单元测试、集成测试等。</p></li><li><p>编程和调试技能：具备基本的编程和调试技能，能够编写简单的程序并调试代码，以便理解和修复潜在的错误。</p></li></ol><p>通过深入学习上述资源和前置知识，可以打下坚实的程序模糊测试基础，进一步探索和应用模糊测试技术。</p></blockquote>',49);function b(A,D){const a=n("ExternalLinkIcon");return t(),o("div",null,[h,e("p",null,[e("a",z,[i("arxiv.org/pdf/2211.01829.pdf"),s(a)]),i("。")]),f])}const m=r(c,[["render",b],["__file","76-白泽带你读论文  DriveFuzz.html.vue"]]);export{m as default};
