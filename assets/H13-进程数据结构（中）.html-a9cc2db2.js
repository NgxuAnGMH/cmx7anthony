import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as p,o as i,c as o,a,b as s,e,d as c}from"./app-cdabc73c.js";const l="/assets/92711107d8dcdf2c19e8fe4ee3965304-366a3910.jpeg",r="/assets/c4688c36afd90f933727483c56500ff7-56d72557.jpeg",d="/assets/1c91956b52574b62a4418a7c6993d8bc-a961b132.jpeg",u={},m=c(`<h1 id="_13-进程数据结构-中-项目多了就需要项目管理系统" tabindex="-1"><a class="header-anchor" href="#_13-进程数据结构-中-项目多了就需要项目管理系统" aria-hidden="true">#</a> 13 | 进程数据结构（中）：项目多了就需要项目管理系统</h1><p>上一节我们讲了，task_struct 这个结构非常长。由此我们可以看出，Linux 内核的任务管理是非常复杂的。上一节，我们只是讲了一部分，今天我们接着来解析剩下的部分。</p><h2 id="运行统计信息" tabindex="-1"><a class="header-anchor" href="#运行统计信息" aria-hidden="true">#</a> 运行统计信息</h2><p>作为项目经理，你肯定需要了解项目的运行情况。例如，有的员工很长时间都在做一个任务，这个时候你就需要特别关注一下；再如，有的员工的琐碎任务太多，这会大大影响他的工作效率。</p><p>那如何才能知道这些员工的工作情况呢？在进程的运行过程中，会有一些统计量，具体你可以看下面的列表。这里面有<code>进程在用户态和内核态消耗的时间、上下文切换的次数</code>等等。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>u64        utime<span class="token punctuation">;</span><span class="token comment">//用户态消耗的CPU时间</span>
u64        stime<span class="token punctuation">;</span><span class="token comment">//内核态消耗的CPU时间</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span>      nvcsw<span class="token punctuation">;</span><span class="token comment">//自愿(voluntary)上下文切换计数</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span>      nivcsw<span class="token punctuation">;</span><span class="token comment">//非自愿(involuntary)上下文切换计数</span>
u64        start_time<span class="token punctuation">;</span><span class="token comment">//进程启动时间，不包含睡眠时间</span>
u64        real_start_time<span class="token punctuation">;</span><span class="token comment">//进程启动时间，包含睡眠时间</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="进程亲缘关系" tabindex="-1"><a class="header-anchor" href="#进程亲缘关系" aria-hidden="true">#</a> 进程亲缘关系</h2><p>从我们之前讲的创建进程的过程，可以看出，<code>任何一个进程都有父进程</code>。</p><p>所以，整个进程其实就是一棵进程树。而拥有同一父进程的所有进程都具有兄弟关系。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> __rcu <span class="token operator">*</span>real_parent<span class="token punctuation">;</span> <span class="token comment">/* real parent process */</span>
<span class="token keyword">struct</span> <span class="token class-name">task_struct</span> __rcu <span class="token operator">*</span>parent<span class="token punctuation">;</span> <span class="token comment">/* recipient of SIGCHLD, wait4() reports */</span>
<span class="token keyword">struct</span> <span class="token class-name">list_head</span> children<span class="token punctuation">;</span>      <span class="token comment">/* list of my children */</span>
<span class="token keyword">struct</span> <span class="token class-name">list_head</span> sibling<span class="token punctuation">;</span>       <span class="token comment">/* linkage in my parent&#39;s children list */</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>parent</code> 指向其父进程。<strong>当它终止时</strong>，必须向它的父进程发送信号。</li><li><code>children</code> 表示链表的头部。<strong>链表中的所有元素</strong>都是它的子进程。</li><li><code>sibling</code> 用于把当前进程<strong>插入到</strong>兄弟链表中。</li></ul><img src="`+l+`" alt="img" style="zoom:25%;"><p>通常情况下，real_parent 和 parent 是一样的，但是也会有另外的情况存在。例如，bash 创建一个进程，那进程的 parent 和 real_parent 就都是 bash。如果在 bash 上使用 GDB 来 debug 一个进程，这个时候 GDB 是 parent，bash 是这个进程的 real_parent。</p><blockquote><p>文中说“如果在 bash 上使用 GDB 来 debug 一个进程，这个时候 GDB 是 real_parent，bash 是这个进程的 parent。” 根据copy_process里对PT_PTRACED标志位处理的流程来看，应该是 bash 是 real_parent，GDB 是这个进程的 parent 吧？<br> 作者回复: 谢谢，果真弄反了</p></blockquote><blockquote><p>各个进程的进程亲缘关系所依赖的数据结构不就是<code>B+树</code>嘛，这样子就一下子把数据结构和操作系统连起来了，果然哪里都离不开数据结构</p></blockquote><h2 id="进程权限-cred-rcu" tabindex="-1"><a class="header-anchor" href="#进程权限-cred-rcu" aria-hidden="true">#</a> 进程权限 cred __rcu</h2><p>了解了运行统计信息，接下来，我们需要关注一下项目组权限的控制。什么是项目组权限控制呢？这么说吧，我这个项目组能否访问某个文件，能否访问其他的项目组，以及我这个项目组能否被其他项目组访问等等，这都是项目组权限的控制范畴。</p><p>在 Linux 里面，对于进程权限的定义如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/* Objective and real subjective task credentials (COW): */</span>
<span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">cred</span> __rcu         <span class="token operator">*</span>real_cred<span class="token punctuation">;</span>
<span class="token comment">/* Effective (overridable) subjective task credentials (COW): */</span>
<span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">cred</span> __rcu         <span class="token operator">*</span>cred<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个结构的注释里，有两个名词比较拗口，Objective 和 Subjective。事实上，所谓的权限，就是我能操纵谁，谁能操纵我。</p><blockquote><p>请问一下老师这句代码中的, <code>__rcu</code>是什么意思? 起到的作用是啥? 在网上好像没搜到. <code>const struct cred __rcu *real_cred</code>;<br> 作者回复: <code>RCU(Read-Copy Update)</code>，是 Linux 中比较重要的一种同步机制。顾名思义就是“读，拷贝更新”，再直白点是“随意读，但更新数据的时候，需要先复制一份副本，在副本上完成修改，再一次性地替换旧数据”。这是 Linux 内核实现的一种针对“<code>读多写少</code>”的<mark>共享数据</mark>的<code>同步机制</code>。</p></blockquote><h3 id="谁能操作我real-cred-我能操纵谁cred" tabindex="-1"><a class="header-anchor" href="#谁能操作我real-cred-我能操纵谁cred" aria-hidden="true">#</a> 谁能操作我real_cred/我能操纵谁cred</h3><ul><li>“谁能操作我”，很显然，这个时候我就是被操作的对象，就是 Objective，那个想操作我的就是 Subjective。</li><li>“我能操作谁”，这个时候我就是 Subjective，那个要被我操作的就是 Objectvie。</li></ul><p>“操作”，就是一个对象对另一个对象进行某些动作。当动作要实施的时候，就要审核权限，<strong><code>当两边的权限匹配上了</code></strong>，就可以实施操作。</p><ul><li>其中，<code>real_cred</code> 就是说明<code>谁能操作我这个进程</code>，</li><li>而 <code>cred</code> 就是说明<code>我这个进程能够操作谁</code>。</li></ul><p>这里 cred 的定义如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">cred</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token class-name">kuid_t</span>          uid<span class="token punctuation">;</span>            <span class="token comment">/* real UID of the task */</span>
        <span class="token class-name">kgid_t</span>          gid<span class="token punctuation">;</span>            <span class="token comment">/* real GID of the task */</span>
        <span class="token class-name">kuid_t</span>          suid<span class="token punctuation">;</span>           <span class="token comment">/* saved UID of the task */</span>
        <span class="token class-name">kgid_t</span>          sgid<span class="token punctuation">;</span>           <span class="token comment">/* saved GID of the task */</span>
        <span class="token class-name">kuid_t</span>          euid<span class="token punctuation">;</span>           <span class="token comment">/* effective UID of the task */</span>
        <span class="token class-name">kgid_t</span>          egid<span class="token punctuation">;</span>           <span class="token comment">/* effective GID of the task */</span>
        <span class="token class-name">kuid_t</span>          fsuid<span class="token punctuation">;</span>          <span class="token comment">/* UID for VFS ops */</span>
        <span class="token class-name">kgid_t</span>          fsgid<span class="token punctuation">;</span>          <span class="token comment">/* GID for VFS ops */</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token class-name">kernel_cap_t</span>    cap_inheritable<span class="token punctuation">;</span> <span class="token comment">/* caps our children can inherit */</span>
        <span class="token class-name">kernel_cap_t</span>    cap_permitted<span class="token punctuation">;</span>  <span class="token comment">/* caps we&#39;re permitted */</span>
        <span class="token class-name">kernel_cap_t</span>    cap_effective<span class="token punctuation">;</span>  <span class="token comment">/* caps we can actually use */</span>
        <span class="token class-name">kernel_cap_t</span>    cap_bset<span class="token punctuation">;</span>       <span class="token comment">/* capability bounding set */</span>
        <span class="token class-name">kernel_cap_t</span>    cap_ambient<span class="token punctuation">;</span>    <span class="token comment">/* Ambient capability set */</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span> __randomize_layout<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="以user-group的方式" tabindex="-1"><a class="header-anchor" href="#以user-group的方式" aria-hidden="true">#</a> 以user/group的方式</h3><p>从这里的定义可以看出，大部分是关于<strong>用户和用户所属的用户组信息</strong>。</p><h3 id="_1-real-id" tabindex="-1"><a class="header-anchor" href="#_1-real-id" aria-hidden="true">#</a> 1 real id</h3><p>第一个是 <code>uid</code> 和 <code>gid</code>，注释是 real user/group id。一般情况下，谁启动的进程，就是谁的 ID。但是权限审核的时候，往往不比较这两个，也就是说不大起作用。</p><h3 id="_2-effective-id" tabindex="-1"><a class="header-anchor" href="#_2-effective-id" aria-hidden="true">#</a> 2 effective id</h3><p>第二个是 <code>euid</code> 和 <code>egid</code>，注释是 effective user/group id。一看这个名字，就知道这个是起“作用”的。当这个进程要操作消息队列、共享内存、信号量等对象的时候，其实就是在比较这个用户和组是否有权限。</p><h3 id="_3-filesystem-id" tabindex="-1"><a class="header-anchor" href="#_3-filesystem-id" aria-hidden="true">#</a> 3 filesystem id</h3><p>第三个是 <code>fsuid</code> 和 <code>fsgid</code>，也就是 filesystem user/group id。这个是对文件操作会审核的权限。</p><h3 id="为何做如此区分" tabindex="-1"><a class="header-anchor" href="#为何做如此区分" aria-hidden="true">#</a> 为何做如此区分</h3><blockquote><p>一般说来，fsuid、euid，和 uid 是一样的，fsgid、egid，和 gid 也是一样的。</p><p>因为谁启动的进程，就应该审核启动的用户到底有没有这个权限。</p></blockquote><p>但是也有特殊的情况。</p><img src="`+r+`" alt="img" style="zoom:25%;"><blockquote><p>例如，用户 A 想玩一个游戏，这个游戏的程序是用户 B 安装的。游戏这个程序文件的权限为 rwxr–r--。A 是没有权限运行这个程序的，所以用户 B 要给用户 A 权限才行。用户 B 说没问题，都是朋友嘛，于是用户 B 就给这个程序设定了所有的用户都能执行的权限 rwxr-xr-x，说兄弟你玩吧。</p><p>于是，用户 A 就获得了运行这个游戏的权限。当游戏运行起来之后，游戏进程的 uid、euid、fsuid 都是用户 A。看起来没有问题，玩得很开心。</p><p>用户 A 好不容易通过一关，想保留通关数据的时候，发现坏了，这个游戏的玩家数据是保存在另一个文件里面的。这个文件权限 rw-------，只给用户 B 开了写入权限，而游戏进程的 euid 和 fsuid 都是用户 A，当然写不进去了。完了，这一局白玩儿了。</p><p>那怎么解决这个问题呢？我们可以通过 chmod u+s program 命令，给这个游戏程序设置 set-user-ID 的标识位，把游戏的权限变成 rwsr-xr-x。这个时候，用户 A 再启动这个游戏的时候，创建的进程 uid 当然还是用户 A，但是 euid 和 fsuid 就不是用户 A 了，因为看到了 set-user-id 标识，就改为文件的所有者的 ID，也就是说，euid 和 fsuid 都改成用户 B 了，这样就能够将通关结果保存下来。</p></blockquote><p>在 Linux 里面，一个进程可以随时通过 setuid 设置用户 ID，所以，游戏程序的用户 B 的 ID 还会保存在一个地方，这就是 suid 和 sgid，也就是 saved uid 和 save gid。这样就可以很方便地使用 setuid，通过设置 uid 或者 suid 来改变权限。</p><h3 id="capabilities-更细粒度划分操作权限" tabindex="-1"><a class="header-anchor" href="#capabilities-更细粒度划分操作权限" aria-hidden="true">#</a> capabilities 更细粒度划分操作权限</h3><p>除了以用户和用户组控制权限，Linux 还有另一个机制就是 <strong>capabilities</strong>。</p><p>原来控制进程的权限，要么是高权限的 root 用户，要么是一般权限的普通用户，这时候的问题是，root 用户权限太大，而普通用户权限太小。有时候一个普通用户想做一点高权限的事情，必须给他整个 root 的权限。这个太不安全了。</p><p>于是，我们引入新的机制 capabilities，用位图表示权限，在 capability.h 可以找到定义的权限。我这里列举几个。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CAP_CHOWN</span>            <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CAP_KILL</span>             <span class="token expression"><span class="token number">5</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CAP_NET_BIND_SERVICE</span> <span class="token expression"><span class="token number">10</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CAP_NET_RAW</span>          <span class="token expression"><span class="token number">13</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CAP_SYS_MODULE</span>       <span class="token expression"><span class="token number">16</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CAP_SYS_RAWIO</span>        <span class="token expression"><span class="token number">17</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CAP_SYS_BOOT</span>         <span class="token expression"><span class="token number">22</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CAP_SYS_TIME</span>         <span class="token expression"><span class="token number">25</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CAP_AUDIT_READ</span>          <span class="token expression"><span class="token number">37</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CAP_LAST_CAP</span>         <span class="token expression">CAP_AUDIT_READ</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于普通用户运行的进程，当有这个权限的时候，就能做这些操作；没有的时候，就不能做，这样粒度要小很多。</p><ul><li><p>cap_permitted 表示进程能够使用的权限。但是真正起作用的是 cap_effective。<br> cap_permitted 中可以包含 cap_effective 中没有的权限。<br> 一个进程可以在必要的时候，放弃自己的某些权限，这样更加安全。假设自己因为代码漏洞被攻破了，但是如果啥也干不了，就没办法进一步突破。</p></li><li><p>cap_inheritable 表示当可执行文件的扩展属性设置了 inheritable 位时，调用 exec 执行该程序会继承调用者的 inheritable 集合，并将其加入到 permitted 集合。但在非 root 用户下执行 exec 时，通常不会保留 inheritable 集合，但是往往又是非 root 用户，才想保留权限，所以非常鸡肋。</p></li><li><p>cap_bset，也就是 capability bounding set，是系统中所有进程允许保留的权限。<br> 如果这个集合中不存在某个权限，那么系统中的所有进程都没有这个权限。</p><ul><li><p>即使以超级用户权限执行的进程，也是一样的。</p></li><li><p>这样有很多好处。例如，系统启动以后，将加载内核模块的权限去掉，那所有进程都不能加载内核模块。<br> 这样，即便这台机器被攻破，也做不了太多有害的事情。</p></li></ul></li><li><p>cap_ambient 是比较新加入内核的，就是为了解决 cap_inheritable 鸡肋的状况，也就是，非 root 用户进程使用 exec 执行一个程序的时候，如何保留权限的问题。当执行 exec 的时候，cap_ambient 会被添加到 cap_permitted 中，同时设置到 cap_effective 中。</p></li></ul><h2 id="内存管理-mm-struct" tabindex="-1"><a class="header-anchor" href="#内存管理-mm-struct" aria-hidden="true">#</a> 内存管理 mm_struct</h2><p>每个进程都有自己独立的虚拟内存空间，这需要有一个数据结构来表示，就是 <code>mm_struct</code>。这个我们在内存管理那一节详细讲述。这里你先有个印象。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">mm_struct</span>                <span class="token operator">*</span>mm<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">mm_struct</span>                <span class="token operator">*</span>active_mm<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="文件系统fs-struct-文件files-struct" tabindex="-1"><a class="header-anchor" href="#文件系统fs-struct-文件files-struct" aria-hidden="true">#</a> 文件系统fs_struct / 文件files_struct</h2><p>每个进程有一个<mark>文件系统</mark>的数据结构，还有一个<mark>打开文件</mark>的数据结构。这个我们放到文件系统那一节详细讲述。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">/* Filesystem information: */</span>
<span class="token keyword">struct</span> <span class="token class-name">fs_struct</span>                <span class="token operator">*</span>fs<span class="token punctuation">;</span>
<span class="token comment">/* Open file information: */</span>
<span class="token keyword">struct</span> <span class="token class-name">files_struct</span>             <span class="token operator">*</span>files<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="总结时刻" tabindex="-1"><a class="header-anchor" href="#总结时刻" aria-hidden="true">#</a> 总结时刻</h2><p>这一节，我们终于把进程管理复杂的数据结构基本讲完了，请你重点记住以下两点：</p><ul><li>进程亲缘关系维护的数据结构，是一种很有参考价值的实现方式，在内核中会多个地方出现类似的结构；</li><li>进程权限中 setuid 的原理，这一点比较难理解，但是很重要，面试经常会考。</li></ul><p>你可以对着下面这张图，看看自己是否真的理解了，进程树是如何组织的，以及如何控制进程的权限的。</p><img src="`+d+`" alt="img" style="zoom:33%;"><blockquote><ul><li><p>运行统计信息, 包含用户/内核态运行时间; 上/下文切换次数; 启动时间等;</p></li><li><p>进程亲缘关系</p></li><li><p>拥有同一父进程的所有进程具有兄弟关系</p></li></ul><pre><code>- 包含: 指向 parent; 指向 real_parent; 子进程双向链表头结点; 兄弟进程双向链表头结点

- parent 指向的父进程接收进程结束信号

- real_parent 和 parent 通常一样; 但在 bash 中用 GDB 调试程序时, GDB 是 real_parent, bash 是 parent

- &gt;   文中说“如果在 bash 上使用 GDB 来 debug 一个进程，这个时候 GDB 是 real_parent，bash 是这个进程的 parent。” 根据copy_process里对PT_PTRACED标志位处理的流程来看，应该是 bash 是 real_parent，GDB 是这个进程的 parent 吧？

	&gt;   作者回复: 谢谢，果真弄反了
</code></pre><ul><li><p>进程权限, 包含 real_cred 指针(谁能操作我); cred 指针(我能操作谁)</p></li><li><p>cred 结构体中标明多组用户和用户组 id</p><ul><li>uid/gid(哪个用户的进程启动我)</li><li>euid/egid(按照哪个用户审核权限, 操作消息队列, 共享内存等)</li><li>fsuid/fsgid(文件操作时审核)</li><li>这三组 id 一般一样</li><li>通过 chmod u+s program, 给程序设置 set-user-id 标识位, 运行时程序将进程 euid/fsuid 改为程序文件所有者 id</li><li>suid/sgid 可以用来保存 id, 进程可以通过 setuid 更改 uid</li><li>capability 机制, 以细粒度赋予普通用户部分高权限 (capability.h 列出了权限)</li><li>cap_permitted 表示进程的权限 <ul><li>cap_effective 实际起作用的权限, cap_permitted 范围可大于 cap_effective</li><li>cap_inheritable 若权限可被继承, 在 exec 执行时继承的权限集合, 并加入 cap_permitted 中(但非 root 用户不会保留 cap_inheritable 集合)</li><li>cap_bset 所有进程保留的权限(限制只用一次的功能)</li><li>cap_ambient exec 时, 并入 cap_permitted 和 cap_effective 中</li></ul></li></ul></li><li><p>内存管理: mm_struct</p></li><li><p>文件与文件系统: 进程与 / 打开的文件相关files_struct / 文件系统相关fs_struct</p></li></ul></blockquote><h2 id="课堂练习" tabindex="-1"><a class="header-anchor" href="#课堂练习" aria-hidden="true">#</a> 课堂练习</h2><p>通过这一节的学习，你会发现，一个进程的运行竟然要保存这么多信息，这些信息都可以通过命令行取出来，所以今天的练习题就是，对于一个正在运行的进程，通过命令行找到上述进程运行的所有信息。</p><p>欢迎留言和我分享你的疑惑和见解，也欢迎你收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习、进步。</p><h2 id="课后讨论" tabindex="-1"><a class="header-anchor" href="#课后讨论" aria-hidden="true">#</a> 课后讨论</h2><ul><li>进程的相关信息可以通过ps 获取，</li><li>依赖关系通过pstree获取，</li><li>文件相关通过lsof，fuser，</li><li>capabilities相关通过capsh，getcap获取，</li></ul>`,65),k={href:"https://garlicspace.com/2019/07/03/%E8%8E%B7%E5%8F%96%E8%BF%9B%E7%A8%8B%E4%BF%A1%E6%81%AF%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/",target:"_blank",rel:"noopener noreferrer"},b=c("<p>①这节内容解决了关于上节task_struct为什么要用链表结构，是为了维护多个task之间的关系。一个task节点的parent指针指向其父进程task，children指针指向子进程所有task的头部，然后又靠 sibling指针来维护统一级兄弟task！</p><p>②setUid是一个权限的特殊标志位，带有这个标志位可以对文件执行等同root的权限！比如，Linux下修改密码的指令passwd，我们ls去查看时发现其权限就有s标志，这个就是之所以能修改密码的原因。如果去掉这个权限，再以普通用户身份去修改密码则会提示没有权限！这个例子和老师的玩游戏可以说是异曲同工，但它更具有普遍性，大家也更熟悉！</p><p>③capabilities听了感觉云里雾里还是一知半解，老师着重讲了概念，但还是不知道怎么用？？？希望老师结合实际使用例子讲一下就更好了！！！</p><p>作者回复: capabilities在容器那一节会用到</p><p>通过<code>cat /proc/pid/status</code>可以看到进程的所属的各种id<br> 作者回复: 建议大家多看<code>cat /proc/pid</code>下的相关信息 / <code>cat /proc</code>下的信息比较全</p><p><code>u64 real_start_time;</code>// 进程启动时间，包含睡眠时间 感觉不好理解是不是启动时长?<br> 作者回复: <code>CLOCK_MONOTONIC</code>是monotonic time，随着进程的运行不断加，<br> 而<code>CLOCK_REALTIME</code>是wall time，墙上的时间，实际时间，系统管理员可以调整的时间</p><p>学习linux最好的地方在于，通过命令行阅读内核，是非常好的反馈</p><p><code>ps -o pid,euid,ruid,suid,egid,rgid,sgid,cmd</code> 可以查看到不少进程数据，</p><p>时不时还会用 <code>htop</code>和<code>pidstat</code>，进行辅助查看进程信息。？是使用<code>strace -p</code> 进程号 来获取进程的信息么</p><p>请问老师，同一级的所有进程的sibling是指向同一块内存地址吗？<br> 作者回复: 不是啊，在一串链表上</p><p>setuid倒是好理解，进程树相关的程序结构不好消化<br> 作者回复: 就是指针指来指去</p>",11),v=a("br",null,null,-1),h={href:"https://elixir.bootlin.com/linux/v4.14.13",target:"_blank",rel:"noopener noreferrer"};function _(f,g){const n=p("ExternalLinkIcon");return i(),o("div",null,[m,a("p",null,[s("学习笔记"),a("a",k,[s("https://garlicspace.com/2019/07/03/获取进程信息相关命令/"),e(n)])]),b,a("p",null,[s("老师可以提供一下课程内容讲解的内核代码，直接链接么？看网页kernel.org还有GitHub，没有找到课程讲述的。"),v,s(" 作者回复: "),a("a",h,[s("https://elixir.bootlin.com/linux/v4.14.13"),e(n)])])])}const w=t(u,[["render",_],["__file","H13-进程数据结构（中）.html.vue"]]);export{w as default};
