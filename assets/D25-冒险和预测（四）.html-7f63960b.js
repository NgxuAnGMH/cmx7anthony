import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o,c,a as n,b as s,e as i,d as a}from"./app-cdabc73c.js";const l="/assets/b439cebb2d85496ad6eef2f61071aefa-b36b575f.jpeg",r="/assets/39d114b3e37fe7fbad98ef0322b876c3-36ea4487.jpeg",u="/assets/2f83d82e417f1d37cb9ddb253a0b6cd8-a00ba568.png",k="/assets/ea82f279b48c10ad95027c91ed62ab5d-a59d1329.jpeg",d="/assets/69c0cb32d5b7139e0f993855104e55a5-f4460a2d.jpeg",m={},g=a('<h1 id="_25-冒险和预测-四-今天下雨了-明天还会下雨么" tabindex="-1"><a class="header-anchor" href="#_25-冒险和预测-四-今天下雨了-明天还会下雨么" aria-hidden="true">#</a> 25 | 冒险和预测（四）：今天下雨了，明天还会下雨么？</h1><p>过去三讲，我主要为你介绍了结构冒险和数据冒险，以及<mark>增加资源</mark>、<mark>流水线停顿</mark>、<mark>操作数前推</mark>、<mark>乱序执行</mark>，这些解决各种“冒险”的技术方案。</p><p>在结构冒险和数据冒险中，你会发现，所有的流水线停顿操作都要从<strong>指令执行阶段</strong>开始。流水线的前两个阶段，也就是<mark>取指令</mark>（IF）和<mark>指令译码</mark>（ID）的阶段，是不需要停顿的。CPU 会在流水线里面直接去取下一条指令，然后进行译码。</p><p>取指令和指令译码不会需要遇到任何停顿，这是基于一个假设。这个假设就是，<em>所有的指令代码都是顺序加载执行的</em>。不过这个假设，在执行的代码中，<em>一旦遇到 if…else 这样的条件分支，或者 for/while 循环，<code>就会不成立</code></em>。</p><figure><img src="'+l+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>回顾一下第 6 讲的条件跳转流程</p><p>我们先来回顾一下，第 6 讲里讲的 cmp 比较指令、jmp 和 jle 这样的条件跳转指令。可以看到，在 jmp 指令发生的时候，CPU 可能会跳转去执行其他指令。jmp 后的那一条指令是否应该顺序加载执行，在流水线里面进行取指令的时候，我们没法知道。要等 jmp 指令执行完成，去更新了 PC 寄存器之后，我们才能知道，是否执行下一条指令，还是跳转到另外一个内存地址，去取别的指令。</p><p>这种为了确保能取到正确的指令，而不得不进行等待延迟的情况，就是今天我们要讲的<strong>控制冒险</strong>（Control Harzard）。这也是流水线设计里最后一种冒险。</p><h2 id="分支预测-今天下雨了-明天还会继续下雨么" tabindex="-1"><a class="header-anchor" href="#分支预测-今天下雨了-明天还会继续下雨么" aria-hidden="true">#</a> 分支预测：今天下雨了，明天还会继续下雨么？</h2><p>在遇到了控制冒险之后，我们的 CPU 具体会怎么应对呢？除了流水线停顿，等待前面的 jmp 指令执行完成之后，再去取最新的指令，还有什么好办法吗？当然是有的。我们一起来看一看。</p><h3 id="缩短分支延迟" tabindex="-1"><a class="header-anchor" href="#缩短分支延迟" aria-hidden="true">#</a> 缩短分支延迟</h3><p>第一个办法，叫作<strong>缩短分支延迟</strong>。回想一下我们的条件跳转指令，条件跳转指令其实进行了两种电路操作。</p><ol><li>第一种，是进行条件比较。这个条件比较，需要的输入是，根据指令的 opcode，就能确认的条件码寄存器。</li><li>第二种，是进行实际的跳转，也就是把要跳转的地址信息写入到 PC 寄存器。无论是 opcode，还是对应的条件码寄存器，还是我们跳转的地址，都是在指令译码（ID）的阶段就能获得的。而对应的条件码比较的电路，只要是简单的逻辑门电路就可以了，并不需要一个完整而复杂的 ALU。</li></ol><p>所以，我们可以将条件判断、地址跳转，<em>都提前到指令译码阶段进行</em>，而不需要放在指令执行阶段。对应的，我们也要在 CPU 里面<em>设计对应的旁路，在指令译码阶段，就提供对应的判断比较的电路</em>。</p><p>这种方式，本质上和前面数据冒险的操作数前推的解决方案类似，<em>就是在硬件电路层面</em>，把一些计算结果更早地反馈到流水线中。这样反馈变得更快了，后面的指令需要等待的时间就变短了。</p><p>不过只是改造硬件，<em>并不能彻底解决问题</em>。跳转指令的比较结果，仍然要在指令执行的时候才能知道。在流水线里，第一条指令进行指令译码的时钟周期里，我们其实就要去取下一条指令了。这个时候，我们其实还没有开始指令执行阶段，<em>自然也就不知道比较的结果</em>。</p><h3 id="静态分支预测" tabindex="-1"><a class="header-anchor" href="#静态分支预测" aria-hidden="true">#</a> 静态分支预测</h3><p>所以，这个时候，我们就引入了一个新的解决方案，叫作<strong>分支预测</strong>（Branch Prediction）技术，也就是说，让我们的 CPU 来猜一猜，条件跳转后执行的指令，应该是哪一条。</p><p>最简单的分支预测技术，叫作“<strong>假装分支不发生</strong>”。顾名思义，自然就是仍然按照顺序，把指令往下执行。其实就是 CPU 预测，<em>条件跳转一定不发生</em>。这样的预测方法，其实也是一种<strong>静态预测</strong>技术。<em>就好像猜硬币的时候</em>，你一直猜正面，会有 50% 的正确率。</p><p>如果分支预测是正确的，我们自然赚到了。这个意味着，我们节省下来本来需要停顿下来等待的时间。如果分支预测失败了呢？那我们就把后面已经取出指令已经执行的部分，给丢弃掉。这个丢弃的操作，在流水线里面，叫作 <code>Zap</code> 或者 <code>Flush</code>。CPU 不仅要执行后面的指令，对于这些已经在流水线里面执行到一半的指令，我们还需要做对应的清除操作。比如，清空已经使用的寄存器里面的数据等等，这些清除操作，也有一定的开销。</p><p>所以，CPU 需要提供对应的丢弃指令的功能，通过控制信号清除掉已经在流水线中执行的指令。<em>只要对应的清除开销不要太大</em>，我们就是划得来的。</p><figure><img src="'+r+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="动态分支预测" tabindex="-1"><a class="header-anchor" href="#动态分支预测" aria-hidden="true">#</a> 动态分支预测</h3><p>第三个办法，叫作<strong>动态分支预测</strong>。</p><p>上面的静态预测策略，看起来比较简单，预测的准确率也许有 50%。但是如果运气不好，可能就会特别差。于是，工程师们就开始思考，我们有没有更好的办法呢？比如，<em>根据之前条件跳转的比较结果来预测</em>，是不是会更准一点？</p><p>我们日常生活里，最经常会遇到的预测就是天气预报。如果没有气象台给你天气预报，你想要猜一猜明天是不是下雨，你会怎么办？</p><p>有一个简单的策略，就是完全根据今天的天气来猜。如果今天下雨，我们就预测明天下雨。如果今天天晴，就预测明天也不会下雨。这是一个很符合我们日常生活经验的预测。因为一般下雨天，都是连着下几天，不断地间隔地发生“天晴 - 下雨 - 天晴 - 下雨”的情况并不多见。</p><p>那么，把这样的实践拿到生活中来是不是有效呢？我在这里给了一张 2019 年 1 月上海的天气情况的表格。</p><figure><img src="'+u+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>我们用前一天的是不是下雨，直接来预测后一天会不会下雨。这个表格里一共有 31 天，那我们就可以预测 30 次。你可以数一数，按照这种预测方式，我们可以预测正确 23 次，正确率是 76.7%，比随机预测的 50% 要好上不少。</p><p>而同样的策略，我们一样可以放在分支预测上。这种策略，我们叫<strong>一级分支预测</strong>（One Level Branch Prediction），或者叫 <strong>1 比特饱和计数</strong>（1-bit saturating counter）。这个方法，<em>其实就是用一个比特</em>，去记录当前分支的比较情况，<em>直接用当前分支的比较情况</em>，来预测下一次分支时候的比较情况。</p><p>只用一天下雨，就预测第二天下雨，这个方法还是有些“草率”，<em>我们可以用更多的信息</em>，而不只是一次的分支信息来进行预测。于是，我们可以引入一个<strong>状态机</strong>（State Machine）来做这个事情。</p><p>如果连续发生下雨的情况，我们就认为更有可能下雨。之后如果只有一天放晴了，我们仍然认为会下雨。在连续下雨之后，要连续两天放晴，我们才会认为之后会放晴。整个状态机的流转，可以参考我在文稿里放的图。</p><figure><img src="'+k+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>这个状态机里，我们一共有 4 个状态，所以我们需要 2 个比特来记录对应的状态。这样这整个策略，就可以叫作 <strong>2 比特饱和计数</strong>，或者叫<strong>双模态预测器</strong>（Bimodal Predictor）。</p><p>好了，现在你可以用这个策略，再去对照一下上面的天气情况。如果天气的初始状态我们放在“多半放晴”的状态下，我们预测的结果的正确率会是 22 次，也就是 73.3% 的正确率。可以看到，并不是更复杂的算法，效果一定就更好。<em>实际的预测效果，和实际执行的指令高度相关</em>。</p><p>如果想对各种分支预测技术有所了解，Wikipedia里面有更详细的内容和更多的分支预测算法，你可以看看。</p><h2 id="为什么循环嵌套的改变会影响性能" tabindex="-1"><a class="header-anchor" href="#为什么循环嵌套的改变会影响性能" aria-hidden="true">#</a> 为什么循环嵌套的改变会影响性能？</h2><p>说完了分支预测，现在我们先来看一个 Java 程序。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BranchPrediction</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        
        <span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span><span class="token number">1000</span><span class="token punctuation">;</span> j <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">long</span> end <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Time spent is &quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                
        start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span><span class="token number">1000</span><span class="token punctuation">;</span> j <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        end <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Time spent is &quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;ms&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这是一个简单的三重循环，里面没有任何逻辑代码。我们用两种不同的循环顺序各跑一次。第一次，最外重循环循环了 100 次，第二重循环 1000 次，最内层的循环了 10000 次。第二次，我们把顺序倒过来，最外重循环 10000 次，第二重还是 1000 次，最内层 100 次。</p><p>事实上，这段代码在这个专栏一开始的几讲里面，就有同学来提问，想要弄明白这里面的关窍。</p><p>你可以先猜一猜，这样两次运行，花费的时间是一样的么？结果应该会让你大吃一惊。我们可以看看对应的命令行输出。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Time spent in first loop is 5ms
Time spent in second loop is 15ms
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>同样循环了十亿次，第一段程序只花了 5 毫秒，而第二段程序则花了 15 毫秒，足足多了 2 倍。</p><p><em>这个差异就来自我们上面说的分支预测</em>。我们在前面讲过，循环其实也是利用 cmp 和 jle 这样先比较后跳转的指令来实现的。如果对 for 循环的汇编代码或者机器代码的实现不太清楚，你可以回头去复习一下第 6 讲。</p><p>这里的代码，每一次循环都有一个 cmp 和 jle 指令。每一个 jle 就意味着，<em>要比较条件码寄存器的状态</em>，决定是顺序执行代码，还是要跳转到另外一个地址。也就是说，<em>在每一次循环发生的时候，都会有一次“分支”</em>。</p><figure><img src="`+d+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>分支预测策略最简单的一个方式，自然是“<strong>假定分支不发生</strong>”。对应到上面的循环代码，就是循环始终会进行下去。</p><p>在这样的情况下，上面的第一段循环，也就是内层 k 循环 10000 次的代码。每隔 10000 次，才会发生一次预测上的错误。而这样的错误，在第二层 j 的循环发生的次数，是 1000 次。</p><p>最外层的 i 的循环是 100 次。每个外层循环一次里面，都会发生 1000 次最内层 k 的循环的预测错误，所以一共会发生 100 × 1000 = 10 万次预测错误。</p><p>上面的第二段循环，也就是内存 k 的循环 100 次的代码，则是每 100 次循环，就会发生一次预测错误。这样的错误，在第二层 j 的循环发生的次数，还是 1000 次。最外层 i 的循环是 10000 次，所以一共会发生 1000 × 10000 = 1000 万次预测错误。</p><p>到这里，相信你能猜到为什么同样空转次数相同的循环代码，第一段代码运行的时间要少得多了。<em>因为第一段代码发生“分支预测”错误的情况比较少，更多的计算机指令，在流水线里顺序运行下去了</em>，而不需要把运行到一半的指令丢弃掉，再去重新加载新的指令执行。</p><h2 id="总结延伸" tabindex="-1"><a class="header-anchor" href="#总结延伸" aria-hidden="true">#</a> 总结延伸</h2><p>好了，这一讲，我给你讲解了什么是控制冒险，以及应对控制冒险的三个方式。</p><p>第一种方案，类似我们的操作数前推，<em>其实是在改造我们的 CPU 功能，<code>通过增加对应的电路的方式</code>，来缩短分支带来的延迟</em>。另外两种解决方案，无论是“<em><code>假装分支不发生</code></em>”，还是“<em><code>动态分支预测</code></em>”，其实都是在进行“分支预测”。只是，“假装分支不发生”是一种简单的静态预测方案而已。</p><p>在动态分支预测技术里，我给你介绍了一级分支预测，或者叫 1 比特饱和计数的方法。其实就是认为，预测结果和上一次的条件跳转是一致的。在此基础上，我还介绍了利用更多信息的，就是 2 比特饱和计数，或者叫双模态预测器的方法。这个方法其实也只是通过一个状态机，多看了一步过去的跳转比较结果。</p><p>这个方法虽然简单，但是却非常有效。在 SPEC 89 版本的测试当中，使用这样的饱和计数方法，预测的准确率能够高达 93.5%。Intel 的 CPU，一直到 Pentium 时代，在还没有使用 MMX 指令集的时候，用的就是这种分支预测方式。</p><p>这一讲的最后，我给你看了一个有意思的例子。通过交换内外循环的顺序，我们体验了一把控制冒险导致的性能差异。虽然执行的指令数是一样的，但是分支预测失败得多的程序，性能就要差上几倍。</p><h2 id="推荐阅读" tabindex="-1"><a class="header-anchor" href="#推荐阅读" aria-hidden="true">#</a> 推荐阅读</h2><p>想要进一步了解控制冒险和分支预测技术，可以去读一读《<code>计算机组成与设计：硬件 / 软件接口</code>》的 4.8 章节。</p><p>如果想对各种分支预测技术有所了解，Wikipedia里面有更详细的内容和更多的分支预测算法。</p><h2 id="课后思考" tabindex="-1"><a class="header-anchor" href="#课后思考" aria-hidden="true">#</a> 课后思考</h2><p>我在上面用一个三重循环的 Java 程序，验证了“分支预测”出错会对程序带来的性能影响。你可以用你自己惯用的语言来试一试，看一看是否会有同样的效果。如果没有的话，原因是什么呢？</p><p>欢迎留言和我分享你的疑惑和见解。你也可以把今天的内容，分享给你的朋友，和他一起学习和进步。</p>',65),b=a("<p>这个for循环的原理是对的，但是例子可能不恰当，因为这个例子耗时最长的不是cpu分支冒险，<em>而是最后一层循环的临时变量创建次数，属于栈的问题</em>，如果要测试分支预测，需要int i，j，k在循环外初始化好，但是这样的话目前100，1000，10000次的循环是几乎看不到差异的，甚至得出的结果会相反，在最大的循环扩充到1000万次(总量为10万亿次，才能感受到冒险的差异)。希望老师能看到，顺便改下例子</p><p>网友回复：因为采用了for(int..)这种类型的定义，for里面定义的变量的生存周期只有外部的一次循环，于是情况1：i生成1次，j生成100次，k生成100*1000=100000次，对于情况2：i生成1次，j生成10000次，k生成10000*1000=10000000次，临时变量都是存在栈中，确实情况2的出入栈次数要高得多</p><p>网友回复：先给题主说明的例子解释下为什么这里是临时变量次数起的作用而不是分支预测，下面很多人没明白。（是你没有理解题主的意思，i循环100次，那么j就要创建 100次临时变量，k就要创建1000次临时变量，总共创建 100*1000次 如果i,j,k反方向，那么创建临时变量数就是10000*1000次） 接下来在回答一下题主说的分支预测只有数量大的时候才能体现出来，我的理解是，理论上第一种循环预测错误次数少于第二种100倍，但是实际上，流水线深度就10几，FU单元也不会很多，导致实际预测错误很快就能改正过来，那么就不会达到理论上的 100 倍，这样实际运行结果基本就看不到差异，如果把循环次数在增加，使得理论上预测错误次数增加到 100000 倍，那么此时我觉得实际跑程序时，真实预测错误次数也就10000倍，那么这个时候运行时间上就会看出来点差异了。 结论：我觉得分之预测在这个例子当中起的作用很少，实际中需要大数据情况才会有看到所差异</p><p>网友回复：是你没有理解题主的意思，i循环100次，那么j就要创建 100次临时变量，k就要创建1000次临时变量，总共创建 100*1000次 如果i,j,k反方向，那么创建临时变量数就是10000*1000次</p><hr><p>实验结果，首先是根据与“鱼向北游”同学的一致，把i j k放在循环外面，必须增大一万倍才有明显的性能差距（10倍左右）；<br> 其次是那个循环的解释，我理解是，最内层的错误预测是一次，但是“底层循环”因为中层执行了1000次，所以是1000次错误判断，而中层的错误判断是一次，但是因为最外层循环导致“中层循环”执行了100次，所以是100次错误判断。</p><hr><p>”在这样的情况下，上面的第一段循环，也就是内层 k 循环 10000 次的代码。每隔 10000 次，才会发生一次预测上的错误。而这样的错误，在第二层 j 的循环发生的次数，是 1000 次。” 求老师和各位大佬指点下，这句没太看明白，为啥每隔10000次才出现一次预测错误<br> 作者回复: 你好，最内层的循环，要执行10000次，前面的9999次都是继续执行下一次循环指令，最后一次是结束循环。预测的话，前面9999次都会预测会继续执行指令，到最后一次的预测会出错。</p>",8),h={href:"https://coolshell.cn/articles/10249.html",target:"_blank",rel:"noopener noreferrer"},f=n("p",null,"用Java来解释分支预测是不是不太合适，中间有一层虚拟机，和机器码完全对不上，影响性能的可能根本不是分支预测。",-1);function v(_,j){const p=t("ExternalLinkIcon");return o(),c("div",null,[g,n("blockquote",null,[b,n("p",null,[s("可以对比陈皓博客里面CPU cache这篇文章一起理解一下："),n("a",h,[s("https://coolshell.cn/articles/10249.html"),i(p)])]),f])])}const w=e(m,[["render",v],["__file","D25-冒险和预测（四）.html.vue"]]);export{w as default};
