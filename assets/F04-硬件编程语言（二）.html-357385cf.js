import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as l,c,a as n,b as s,e,d as p}from"./app-cdabc73c.js";const i="/assets/f621c24fcd2295dd7637d7e4920c8c71-1db152b9.jpg",r="/assets/9a5f496eb4d1afc872a64c7e28bcc97b-90ec00f4.jpg",u="/assets/d06a02f93369fa342800cb593953248f-4bdeef5f.jpg",d="/assets/1409db9d4ee9967ff2a5f1bf3d39697b-8e2628ac.jpg",k={},v=p(`<h1 id="_04-硬件语言筑基-二-代码是怎么生成具体电路的" tabindex="-1"><a class="header-anchor" href="#_04-硬件语言筑基-二-代码是怎么生成具体电路的" aria-hidden="true">#</a> 04｜硬件语言筑基（二）: 代码是怎么生成具体电路的？</h1><p>你好，我是 LMOS。</p><p>上节课，我们学习了硬件描述语言 Verilog 的基础知识。今天我会带你一起用 Verilog 设计一个简单的电路模块。通过这节课，你不但能复习巩固上节课学到的硬件语言知识，还能在动手实践中体会代码是怎么生成具体电路的。</p><h2 id="verilog-代码编写" tabindex="-1"><a class="header-anchor" href="#verilog-代码编写" aria-hidden="true">#</a> Verilog 代码编写</h2><p>如果你学过计算机组成原理的课程或图书，应该对 ALU 并不陌生。<mark>算术逻辑单元</mark>（Arithmetic&amp;logical Unit，ALU）是 CPU 的执行单元，是所有中央处理器的核心组成部分。</p><p>利用 Verilog，我们可以设计一个包含加、减、与、或、非等功能的简单 ALU 模块，代码如下：</p><div class="language-verilog line-numbers-mode" data-ext="verilog"><pre class="language-verilog"><code><span class="token keyword">module</span> <span class="token function">alu</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> cin<span class="token punctuation">,</span> sel<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>
  <span class="token keyword">input</span> cin<span class="token punctuation">;</span>
  <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> sel<span class="token punctuation">;</span>
  <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> y<span class="token punctuation">;</span>
  <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> y<span class="token punctuation">;</span>
  <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> arithval<span class="token punctuation">;</span>
  <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> logicval<span class="token punctuation">;</span>
  <span class="token comment">// 算术执行单元</span>
  <span class="token important">always @</span><span class="token punctuation">(</span>a <span class="token keyword">or</span> b <span class="token keyword">or</span> cin <span class="token keyword">or</span> sel<span class="token punctuation">)</span> <span class="token keyword">begin</span>
    <span class="token keyword">case</span> <span class="token punctuation">(</span>sel<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
      <span class="token number">3&#39;b000</span>  <span class="token punctuation">:</span> arithval <span class="token operator">=</span> a<span class="token punctuation">;</span>
      <span class="token number">3&#39;b001</span>  <span class="token punctuation">:</span> arithval <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
      <span class="token number">3&#39;b010</span>  <span class="token punctuation">:</span> arithval <span class="token operator">=</span> a <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
      <span class="token number">3&#39;b011</span>  <span class="token punctuation">:</span> arithval <span class="token operator">=</span> b<span class="token punctuation">;</span>
      <span class="token number">3&#39;b100</span>  <span class="token punctuation">:</span> arithval <span class="token operator">=</span> b <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
      <span class="token number">3&#39;b101</span>  <span class="token punctuation">:</span> arithval <span class="token operator">=</span> b <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
      <span class="token number">3&#39;b110</span>  <span class="token punctuation">:</span> arithval <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
      <span class="token keyword">default</span> <span class="token punctuation">:</span> arithval <span class="token operator">=</span> a <span class="token operator">+</span> b <span class="token operator">+</span> cin<span class="token punctuation">;</span>
    <span class="token keyword">endcase</span>
  <span class="token keyword">end</span>
  <span class="token comment">// 逻辑处理单元</span>
  <span class="token important">always @</span><span class="token punctuation">(</span>a <span class="token keyword">or</span> b <span class="token keyword">or</span> sel<span class="token punctuation">)</span> <span class="token keyword">begin</span>
    <span class="token keyword">case</span> <span class="token punctuation">(</span>sel<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
      <span class="token number">3&#39;b000</span>  <span class="token punctuation">:</span> logicval <span class="token operator">=</span>  <span class="token operator">~</span>a<span class="token punctuation">;</span>
      <span class="token number">3&#39;b001</span>  <span class="token punctuation">:</span> logicval <span class="token operator">=</span>  <span class="token operator">~</span>b<span class="token punctuation">;</span>
      <span class="token number">3&#39;b010</span>  <span class="token punctuation">:</span> logicval <span class="token operator">=</span> a <span class="token operator">&amp;</span> b<span class="token punctuation">;</span>
      <span class="token number">3&#39;b011</span>  <span class="token punctuation">:</span> logicval <span class="token operator">=</span> a <span class="token operator">|</span> b<span class="token punctuation">;</span>
      <span class="token number">3&#39;b100</span>  <span class="token punctuation">:</span> logicval <span class="token operator">=</span>  <span class="token operator">~</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a <span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token number">3&#39;b101</span>  <span class="token punctuation">:</span> logicval <span class="token operator">=</span>  <span class="token operator">~</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a <span class="token operator">|</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token number">3&#39;b110</span>  <span class="token punctuation">:</span> logicval <span class="token operator">=</span> a <span class="token operator">^</span> b<span class="token punctuation">;</span>
      <span class="token keyword">default</span> <span class="token punctuation">:</span> logicval <span class="token operator">=</span>  <span class="token operator">~</span><span class="token punctuation">(</span>a <span class="token operator">^</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">endcase</span>
  <span class="token keyword">end</span>
  <span class="token comment">// 输出选择单元</span>
  <span class="token important">always @</span><span class="token punctuation">(</span>arithval <span class="token keyword">or</span> logicval <span class="token keyword">or</span> sel<span class="token punctuation">)</span> <span class="token keyword">begin</span>
    <span class="token keyword">case</span> <span class="token punctuation">(</span>sel<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
      <span class="token number">1&#39;b0</span>    <span class="token punctuation">:</span> y <span class="token operator">=</span> arithval<span class="token punctuation">;</span>
      <span class="token keyword">default</span> <span class="token punctuation">:</span> y <span class="token operator">=</span> logicval<span class="token punctuation">;</span>
    <span class="token keyword">endcase</span>
  <span class="token keyword">end</span>
<span class="token keyword">endmodule</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过上面的代码，我们实现了一个 8 位二进制的简单运算模块。其中，a 和 b 是输入的两个 8 位二进制数，cin 是 a 和 b 做加法运算时输入的进位值，4bit 位宽的 sel[3:0] 则是 CPU 中通常所说的指令操作码。</p><h3 id="模块中的一些组成单元" tabindex="-1"><a class="header-anchor" href="#模块中的一些组成单元" aria-hidden="true">#</a> 模块中的一些组成单元</h3><p>在这个 ALU 模块中，逻辑功能代码我们把它分成三个部分，分别是<mark>运算单元</mark>、<mark>逻辑处理单元</mark>和<mark>输出选择单元</mark>。运算单元是根据输入指令的低三位 sel[2:0]，来选择执行加减等运算。同理，逻辑处理单元执行与或非门等操作。最后，根据指令的最高位 sel[3]，来选择 Y 输出的是加减运算单元结果，还是逻辑处理的结果。</p><p>你还记得上节课的例子么？当时我们一起研究了一个 4 位 10 进制的计算器，里面用到了时钟设计。也就是说，这个计算器是通过时序逻辑实现的，所以 always 块中的赋值语言使用了非阻塞赋值“&lt;=”。</p><div class="language-verilog line-numbers-mode" data-ext="verilog"><pre class="language-verilog"><code><span class="token important">always@</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> reset_n<span class="token punctuation">)</span> <span class="token keyword">begin</span>
  <span class="token function">if</span><span class="token punctuation">(</span><span class="token operator">!</span>reset_n<span class="token punctuation">)</span> <span class="token keyword">begin</span>                  <span class="token comment">//复位时，计时归0</span>
      cnt_r        <span class="token operator">&lt;=</span> <span class="token number">4&#39;b0000</span> <span class="token punctuation">;</span>
    <span class="token keyword">end</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而今天我们实现的 ALU 模块，用到的是组合逻辑，所以 always 块中使用阻塞赋值“=”。</p><h3 id="阻塞赋值-非阻塞赋值" tabindex="-1"><a class="header-anchor" href="#阻塞赋值-非阻塞赋值" aria-hidden="true">#</a> 阻塞赋值/非阻塞赋值</h3><blockquote><p>同步和异步</p></blockquote><p><em>怎么区分阻塞赋值和非阻塞赋值呢</em>？</p><ul><li>阻塞赋值对应的电路结构往往与触发沿没有关系，只与输入电平的变化有关；</li><li>而非阻塞赋值对应的电路结构往往与触发沿有关系，只有在触发沿时，才有可能发生赋值的情况。</li></ul><p>另外，在前面 8 位二进制的代码里，算术执行单元和逻辑处理单元的两个 always 块是<strong>并行执行</strong>的。所以它们的运算结果几乎是同时出来，这里值得你好好理解一下。如果你没有发现两个块并行，可以暂停下来回顾一下。</p><h2 id="如何通过仿真验证代码" tabindex="-1"><a class="header-anchor" href="#如何通过仿真验证代码" aria-hidden="true">#</a> 如何通过仿真验证代码</h2><p>就像我们开发软件，需要代码编译器和模拟器一样，Verilog 这种硬件语言的代码，也需要运行验证。那怎么来运行验证呢？现在很多企业采用的是 <code>VCS—verilog 仿真器</code>或者是 <code>NC-verilog 仿真器</code>，这些工具都需要花重金去购买才能使用，普通人用起来成本太高了。</p><h3 id="仿真器工具" tabindex="-1"><a class="header-anchor" href="#仿真器工具" aria-hidden="true">#</a> 仿真器工具</h3><p>除了重金购买这些 EDA 工具之外，我们还有更节约成本、也更容易学习入门的选择。<strong>我给你推荐两个轻量级开源软件，分别是 <code>Iverilog</code> 和 <code>GTKWave</code></strong>。</p><ul><li>Iverilog 是一个对 Verilog 进行<code>编译和仿真</code>的工具，</li><li>而 GTKWave 是一个<code>查看仿真数据波形</code>的工具。</li></ul><p>Iverilog 运行于终端模式下，安装完成之后，我们就能通过 Iverilog 对 verilog 执行编译，再对生成的文件通过 vvp 命令执行仿真，配合 GTKWave 即可显示和查看图形化的波形。</p><p>在 Linux 系统下安装 Iverilog 和 GTKWave 非常简单。以 Ubuntu 为例，我们通过 apt-get 就可以直接安装。</p><ul><li>安装 Iverilog：sudo apt-get install iverilog</li><li>安装 GTKWave：sudo apt-get install gtkwave</li></ul><p>安装完成之后，我们需要使用 which 命令查看安装路径，确认是否安装成功。</p><ul><li>which iverilog</li><li>which vvp</li><li>which gtkwave</li></ul><h3 id="顶层-仿真激励文件" tabindex="-1"><a class="header-anchor" href="#顶层-仿真激励文件" aria-hidden="true">#</a> 顶层：仿真激励文件</h3><p>有了软件和 Verilog 代码。在运行仿真前，我们还需要设计一个重要的文件，即<mark>仿真激励文件</mark>，也就是 <mark>TestBench</mark>。在仿真时，要把 TestBench 放在所设计模块的顶层，<em>以便对模块进行系统性的例化调用</em>。</p><p>我们把 TestBench 放在设计模块的顶层，以便对模块进行系统性的例化，调用所设计的各个模块并对其进行仿真。</p><p>针对上面的 ALU 模块，设计了一个给 ALU 产生运算指令和数据的 TestBench，并且把 ALU 的运算结果打印出来，TestBench 的代码如下：</p><div class="language-verilog line-numbers-mode" data-ext="verilog"><pre class="language-verilog"><code><span class="token constant">\`timescale</span> <span class="token number">1</span> ns <span class="token operator">/</span> <span class="token number">1</span> ns
<span class="token keyword">module</span> alu_tb<span class="token punctuation">;</span>
  <span class="token keyword">reg</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>
  <span class="token keyword">reg</span> cin<span class="token punctuation">;</span>
  <span class="token keyword">reg</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> sel<span class="token punctuation">;</span>
  <span class="token keyword">wire</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> y<span class="token punctuation">;</span>
  <span class="token keyword">integer</span> idx<span class="token punctuation">;</span>
  <span class="token comment">//对alu模块进行例化，类似于软件程序中的函数调用</span>
  alu <span class="token function">u_alu</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">a</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token function">b</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token function">cin</span><span class="token punctuation">(</span>cin<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token function">sel</span><span class="token punctuation">(</span>sel<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token function">y</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">initial</span> 
  <span class="token keyword">begin</span>
    <span class="token comment">//给 a 和 b 赋初值</span>
    a <span class="token operator">=</span> <span class="token number">8&#39;h93</span><span class="token punctuation">;</span>
    b <span class="token operator">=</span> <span class="token number">8&#39;hA7</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  idx <span class="token operator">&lt;=</span> <span class="token number">15</span><span class="token punctuation">;</span>  idx <span class="token operator">=</span> idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> 
    <span class="token keyword">begin</span>
      <span class="token comment">// 循环产生运算指令 sel 的值</span>
      sel <span class="token operator">=</span> idx<span class="token punctuation">;</span>
      <span class="token comment">// 当指令 sel = 7 时是加法操作，设定进位值cin=1</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">==</span> <span class="token number">7</span><span class="token punctuation">)</span>
        cin <span class="token operator">=</span> <span class="token number">1&#39;b1</span><span class="token punctuation">;</span>
      <span class="token keyword">else</span>
        cin <span class="token operator">=</span> <span class="token number">1&#39;b0</span><span class="token punctuation">;</span>
      <span class="token comment">//每产生一个指令延时10ns</span>
      <span class="token number">#10</span>
      <span class="token comment">// 延时之后打印出运算结果</span>
      <span class="token kernel-function property">$display</span><span class="token punctuation">(</span><span class="token string">&quot;%t: a=%h, b=%h, cin=%b, sel=%h, y=%h&quot;</span><span class="token punctuation">,</span> <span class="token kernel-function property">$time</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> cin<span class="token punctuation">,</span> sel<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">end</span> 
  <span class="token keyword">end</span>
  
<span class="token keyword">initial</span>
<span class="token keyword">begin</span>
  <span class="token kernel-function property">$dumpfile</span><span class="token punctuation">(</span><span class="token string">&quot;wave.vcd&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//生成波形文件vcd的名称</span>
  <span class="token kernel-function property">$dumpvars</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> alu_tb<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//tb模块名称</span>
<span class="token keyword">end</span>
<span class="token keyword">endmodule</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我要说明一下，TestBench 是不可以综合成具体电路的，只用于<em>仿真验证</em>，但和上一节课介绍的可综合的 Verilog 代码语法类似。</p><h3 id="跑仿真-查看仿真" tabindex="-1"><a class="header-anchor" href="#跑仿真-查看仿真" aria-hidden="true">#</a> 跑仿真 &amp; 查看仿真</h3><p>设计工作告一段落。我们终于可以打开终端开始跑仿真了。你需要在 Verilog 代码所在的文件目录下执行以下指令：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>iverilog -o wave -y ./ alu_tb.v alu.v 
vvp -n wave -lxt2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，运行结果输出如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>LXT2 info: dumpfile wave.vcd opened for output.
​         10: a=93, b=a7, cin=0, sel=0, y=93		// 指令 0：y = a;
​         20: a=93, b=a7, cin=0, sel=1, y=94		// 指令 1：y = a + 1;
​         30: a=93, b=a7, cin=0, sel=2, y=92		// 指令 2：y = a - 1;
​         40: a=93, b=a7, cin=0, sel=3, y=a7		// 指令 3：y = b;
​         50: a=93, b=a7, cin=0, sel=4, y=a8		// 指令 4：y = b + 1;
​         60: a=93, b=a7, cin=0, sel=5, y=a6		// 指令 5：y = b - 1;
​         70: a=93, b=a7, cin=0, sel=6, y=3a		// 指令 6：y = a + b;
​         80: a=93, b=a7, cin=1, sel=7, y=3b		// 指令 7：y = a + b + cin;
​         90: a=93, b=a7, cin=0, sel=8, y=6c		// 指令 8：y = ~a;
​         100: a=93, b=a7, cin=0, sel=9, y=58		// 指令 9：y = ~b;
​         110: a=93, b=a7, cin=0, sel=a, y=83		// 指令 10：y = a &amp; b;
​         120: a=93, b=a7, cin=0, sel=b, y=b7		// 指令 11：y = a | b;
​         130: a=93, b=a7, cin=0, sel=c, y=7c		// 指令 12：y = ~(a &amp; b);
​         140: a=93, b=a7, cin=0, sel=d, y=48		// 指令 13：y = ~(a | b);
​         150: a=93, b=a7, cin=0, sel=e, y=34		// 指令 14：y = a ^ b;
​         160: a=93, b=a7, cin=0, sel=f, y=cb		// 指令 15：y = ~(a ^ b);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有了运行结果，我们就可以打开 GTKWave 查看仿真波形了，这里需要在终端执行如下指令：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>gtkwave wave.vcd
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+i+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>从打开的波形可以到，ALU 模块输出的信号 Y，这是根据输入指令 sel 和输入的数据 a、b 和 cin 的值，经过加减运算或者逻辑运算得到的。</p><h2 id="代码是如何生成具体电路的" tabindex="-1"><a class="header-anchor" href="#代码是如何生成具体电路的" aria-hidden="true">#</a> 代码是如何生成具体电路的？</h2><p>经过上面的仿真，从打印的结果上已经看到了我们设计的模块功能。而通过查看仿真波形，我们同样也能知道各个信号的跳变关系。</p><p>但是，你可能还有个疑惑，不是说设计的 Verilog 语句，基本都会对应一份电路吗？<em>怎样才能看到 Verilog 对应了哪些电路呢</em>？</p><p>别急，这就是我马上要讲的逻辑综合。<em>通过逻辑综合</em>，我们就能完成从 Verilog 代码到门级电路的转换。而逻辑综合的结果，<em>就是把设计的 Verilog 代码，翻译成门级网表 Netlist</em>。</p><h3 id="逻辑综合工具" tabindex="-1"><a class="header-anchor" href="#逻辑综合工具" aria-hidden="true">#</a> 逻辑综合工具</h3><p>逻辑综合需要*<code>基于特定的综合库，不同的库中</code>，门电路基本标准单元（Standard Cell）的面积、时序参数是不一样的*。所以，选用的综合库不一样，综合出来的电路在时序、面积上也不同。因此，哪怕采用同样的设计，选用<mark>台湾的台积电（TSMC）工艺</mark>和<mark>上海的中芯国际（SMIC）的工艺</mark>，最后生产出来的芯片性能也是有差异的。</p><p>通常，工业界使用的==<strong>逻辑综合工具</strong>==有 Synopsys 的 <code>Design Compiler（DC）</code>，Cadence 的 <code>RTL Compiler</code>，Synplicity 的 <code>Synplify</code> 等。然而，<em>这些 EDA 工具都被国外垄断了，且需要收取高昂的授权费用</em>。</p><p>为了降低学习门槛和费用，这里我们选择 <code>Yosys</code>，它是一个轻量级开源综合工具。虽然功能上还达不到工业级的 EDA 工具，但是对于我们这门课的学习已经完全够用了。</p><img src="'+r+'" alt="img" style="zoom:15%;"><p>如上图所示，利用 Yosys 软件，可以帮助我们把 RTL 代码层次的设计转换为逻辑门级的电路。</p><p>好，我先大致带你了解下，这个软件怎么安装和使用。在 Ubuntu 中安装 Yosys 非常简单，在终端中依次执行以下命令即可：</p><ul><li>sudo add-apt-repository ppa:saltmakrell/ppa</li><li>sudo apt-get update</li><li>sudo apt-get install yosys</li></ul><p>完成了安装，我们就能使用 Yosys，对上面设计的 ALU 模块做简单的综合了。</p><h3 id="逻辑综合步骤" tabindex="-1"><a class="header-anchor" href="#逻辑综合步骤" aria-hidden="true">#</a> 逻辑综合步骤</h3><p>直接在终端输入“yosys”，启动 Yosys 软件。启动成功后，我们通过后面这五条指令，就能得到到 ALU 的逻辑电路图文件了。</p><p><code>第一步</code>，在 Yosys 中读取 Verilog 文件。</p><ul><li>read_verilog alu.v</li></ul><p><code>第二步</code>，使用后面的命令，检查模块例化结构。</p><ul><li>hierarchy -check</li></ul><p><code>接着是第三步</code>，执行下一条命令，来完成高层次的逻辑综合。</p><ul><li>proc; opt; opt; fsm; memory; opt</li></ul><p><code>到了第四步</code>，我们就可以用 write_verilog 生成网表文件。</p><ul><li>write_verilog alu_synth.v</li></ul><p><code>最后</code>，我们再用下方的命令，输出综合后的逻辑图。</p><ul><li>show -format dot -prefix ./alu</li></ul><p>这一套动作完成后，我们终于迎来了收获成果的时刻。打开生成的 alu.dot 文件，我们就可以看到 ALU 模块的门级电路图了，如下所示：</p><img src="'+u+'" alt="img" style="zoom:25%;"><p>可以看到，这张图是由基本的 and、or、not、add、sub、cmp、mux 等电路单元组成。如果你还想进一步了解它们底层电路结构，可以自行查阅大学里学过的《<code>数电</code>》《<code>模电</code>》。</p>',71),b={href:"https://yosyshq.net/yosys",target:"_blank",rel:"noopener noreferrer"},m=p('<p>到这里，类似于 CPU 里面的核心单元 ALU 电路，我们就设计完成了。</p><h2 id="总结回顾" tabindex="-1"><a class="header-anchor" href="#总结回顾" aria-hidden="true">#</a> 总结回顾</h2><p>今天我们一起了解了怎么把 Verilog 代码变为具体的电路。<em>为了实现代码编写、验证和仿真的“一站式”体验</em>。我还向你推荐了几个开源软件。我们来回顾一下这节课的重点。</p><p>首先，我们用 Verilog 编写了一个类似 CPU 内部的 ALU 模块，该模块实现了加、减、与、或、非等基本运算功能。</p><p>针对上面的 ALU 模块，我们还设计了一个用于产生运算指令和数据的 TestBench，并且把 ALU 的运算结果打印出来。利用这个 TestBench，可以验证 ALU 模块的功能是否正确。</p><p>接下来，我们还用到了两个轻量级开源软件，分别是 <code>Iverilog</code> 和 <code>GTKWave</code>。Iverilog 是一个对 Verilog 进行编译和仿真的工具，GTKWave 可以查看仿真数据波形的工具。利用这两个软件，<em>我们完成了 ALU 模块的仿真和验证</em>。</p><p>此外，我还推荐了一款轻量级开源综合工具 Yosys。通过这个工具，我们把上面设计的 ALU 模块综合出了具体的门级电路。</p><p>感谢你耐心看到这里，我还给你准备了一张知识导图，总结今天所学的内容。</p><figure><img src="'+d+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="扩展阅读" tabindex="-1"><a class="header-anchor" href="#扩展阅读" aria-hidden="true">#</a> 扩展阅读</h2><p>仅仅一两节课的内容，就想要把所有 Verilog 的相关知识学完是不可能的。因此，在课程之外，需要你去多搜索，多阅读，多动手编写 Verilg 代码，才能更好地掌握 Verilog 的相关知识，这里我精心为你整理了一些参考资料，供你按需取用：</p><ol><li>首先是<code>硬件描述语言 Verilog HDL 的语言标准文件</code>《IEEE Standard Verilog Hardware Description Language (1364-2001)》。</li><li>如果你对底层的基本电路还不熟悉，不妨复习一下大学所学的教材。这里我推荐由童诗白和华成英编写的《<code>模拟电子技术基础</code>》第四版，以及阎石编写的《<code>数字电子技术基础</code>》。</li><li>你要是想全面学习数字集成电路的设计、仿真验证、逻辑综合等相关知识，可以看看电子工业出版社出版的《<code>Verilog HDL 高级数字设计</code>》。</li><li>最后，你要是真的想学芯片设计，从更深层次去理解数字电路设计，推荐阅读这本 Mohit Arora 撰写、李海东等人翻译的图书——《<code>硬件架构的艺术——数字电路的设计方法与技术</code>》。</li></ol><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题" aria-hidden="true">#</a> 思考题</h2><p>既然用 Verilog 很容易就可以设计出芯片的数字电路，为什么我们国家还没有完全自主可控的高端 CPU 呢？</p><p>期待你在留言区记录自己的学习收获或者疑问。如果这节课对你有帮助，也推荐你分享给更多朋友，我们一起来手写迷你 CPU。</p>',15),h={href:"https://notes.singee.me/#/page/verilog%20%E7%94%9F%E6%88%90%E5%85%B7%E4%BD%93%E7%94%B5%E8%B7%AF",target:"_blank",rel:"noopener noreferrer"},g=n("br",null,null,-1),y=n("br",null,null,-1),_={href:"https://gitee.com/peterjxl/geek-time-computer-foundation-peterjxl%E4%B9%9F%E6%84%9F%E8%B0%A2Bryan%E5%90%8C%E5%AD%A6%E7%9A%84%E5%BC%80%E6%BA%90",target:"_blank",rel:"noopener noreferrer"},w=n("br",null,null,-1),f=n("p",null,[s("如何理解“阻塞赋值”和“非阻塞赋值”"),n("br"),s(" 作者回复: 同步和异步")],-1),x=n("p",null,[s("Verilog设计逻辑电路是纯逻辑理论层面的，不需要太复杂的设备，相对容易做，但是做成实体CPU需要逻辑综合布线，需要生产，这两个有极高的难度，是我们目前没有掌握的。"),n("br"),s(" 作者回复: 还有很多设备我们也没有")],-1),A={href:"https://zhuanlan.zhihu.com/p/550710744",target:"_blank",rel:"noopener noreferrer"},V=n("br",null,null,-1),U=n("p",null,[s("verilog只能设计出微架构，而不能设计出isa，更不能培育出生态"),n("br"),s(" 作者回复: 培养生态 要用商业")],-1),L=n("p",null,[s("有设计，也需要有制造，制造工艺跟不上是一方面，再加上芯片设计的专利保护等，我们没有一完整的生态。"),n("br"),s(" 作者回复: 是的 这是实情")],-1),E=n("p",null,[s("答：CPU作为承载电子万物的通用器件，需要的是完整的产业链和良好的生态。"),n("br"),s(" （1）完整的产业链不仅仅包含前端设计，还有EDA设计工具和完整的产业制造，而我国仅仅只有前端设计站在了世界前沿，后面两个关键步骤远远达不到行业前沿水平"),n("br"),s(" （2）另外芯片强是一个方面，而往往决定芯片能否广泛商用关键更多看好不好用。这里就牵扯到良好的生态了，没有相应完整的配套软件和售后技术支持，客户很难放心使用。这就像为啥各种NPU论PPA吊打NVIDIA，但是最后大家还是买了NVIDIA的GPU做模型训练。生态需要时间积累口碑和持续性努力，吾辈需加油")],-1),C=n("br",null,null,-1),T={href:"https://www.freesion.com/article/4575335248/",target:"_blank",rel:"noopener noreferrer"},B=n("br",null,null,-1),D=n("p",null,[s("思考题："),n("br"),s(" 1、没有自主硬件描述语言规范，目前工业级可用的硬件描述语言都国外设计制定的规范，如：Verilog, VHDL, SystemVerilog等；"),n("br"),s(" 2、没有工业级自主可控的EDA工具，目前市面上可用的工业级EDA工具都是国外三大EDA厂商的(Synopsys，Cadence，Mentor Graphics)；"),n("br"),s(" 3、半导体制造设备还不能完全自主可控；"),n("br"),s(" 4、半导体原材料的份额也不足；"),n("br"),s(" 5、没有成熟生态的指令集架构；"),n("br"),s(" 作者回复: 对啊")],-1);function I(P,S){const a=o("ExternalLinkIcon");return l(),c("div",null,[v,n("p",null,[s("当然，Yosys 功能还不只这些，这里我只是做个简易的演示。更多其它功能，如果你感兴趣的话可以到"),n("a",b,[s("官网"),e(a)]),s("上学习。")]),m,n("blockquote",null,[n("p",null,[s("写了下在 Mac 下怎么编译运行整个代码 "),n("a",h,[s("https://notes.singee.me/#/page/verilog 生成具体电路"),e(a)]),g,s(" 作者回复: 6666")]),n("p",null,[s("老师和同学们好，我也写了下如何运行本次课程里的代码（类似实验手册）：在Gitee上，欢迎各位PR"),y,n("a",_,[s("https://gitee.com/peterjxl/geek-time-computer-foundation-peterjxl也感谢Bryan同学的开源"),e(a)]),w,s(" 作者回复: 66666")]),f,x,n("p",null,[s("感觉大家很吃力，做了一个关于Verilog的初学者笔记，里面包含在线学习网站"),n("a",A,[s("https://zhuanlan.zhihu.com/p/550710744"),e(a)]),V,s(" 编辑回复: 赞分享精神～")]),U,L,E,n("p",null,[s("在CentOS上执行命令：gtkwave wave.vcd，报错：Could not initialize GTK! Is DISPLAY env var/xhost set?"),C,s(" 解决方案可参考："),n("a",T,[s("https://www.freesion.com/article/4575335248/"),e(a)]),B,s(" 作者回复: 6666")]),D])])}const z=t(k,[["render",I],["__file","F04-硬件编程语言（二）.html.vue"]]);export{z as default};
