import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{r as p,o as t,c as o,a as n,b as s,e as l,d as c}from"./app-cdabc73c.js";const i="/assets/622a15b75c71667b81b71a328bc98d32-be84f190.jpg",r="/assets/edb0932e626b436a923a30d7756c58ae-2f048271.jpg",u="/assets/ea6ba162417462ae1797abc3e89b70cf-719ed7e6.jpg",k="/assets/1e593yy8c0627efb9b0809de38aeb7e6-1bf3a83a.jpg",d={},m=n("h1",{id:"_10-手写cpu-五-cpu流水线的写回模块如何实现",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_10-手写cpu-五-cpu流水线的写回模块如何实现","aria-hidden":"true"},"#"),s(" 10｜手写CPU（五）：CPU流水线的写回模块如何实现？")],-1),v=n("p",null,"你好，我是 LMOS。",-1),b=n("em",null,"写回相关模块的设计",-1),_={href:"https://gitee.com/lmos/Geek-time-computer-foundation/tree/master/lesson06~11/mini_cpu",target:"_blank",rel:"noopener noreferrer"},g=c('<p>简单回顾一下，上节课我们完成了 CPU 流水线的访存相关模块的设计。在设计访存模块之前，我们发现流水线中存在数据冒险的问题。为了解决这个问题，我们设计了数据前递模块。</p><p>但是我们采用的数据前递模块，只局限于解决算术操作和数据传输中的冒险问题。在 CPU 流水线中还可能存在结构冒险和控制冒险的问题，我们在进行流水线规划时，<em>已经合理地避免了结构冒险。但是，控制冒险还可能出现</em>，下面我们就来探讨一下流水线的控制冒险问题。</p><h2 id="流水线控制冒险" tabindex="-1"><a class="header-anchor" href="#流水线控制冒险" aria-hidden="true">#</a> 流水线控制冒险</h2><p>还记得前面我们说过的条件分支指令吗？就是根据指令设置的数值比较结果，改变并控制跳转的方向，比如 beq 和 bne 指令。</p><p>假如在流水线取出分支指令后，紧跟着在下一个时钟周期就会取下一条指令。但是，流水线并不知道下一条指令应该从哪里取，因为它刚从存储器中取出分支指令，还不能确定上一条分支指令是否会发生跳转。</p><p>上面这种**流水线需要根据上一条指令的执行结果决定下一步行为的情况，就是流水线中的控制冒险。**这时候该怎么办呢？</p><figure><img src="'+i+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>控制冒险可以使用流水线停顿的方法解决，就是在取出分支指令后，流水线马上停下来，等到分支指令的结果出来，确定下一条指令从哪个地址取之后，流水线再继续。</p><figure><img src="'+r+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>如上图所示，每当遇到条件分支指令时，流水线就停顿以避免控制冒险。但是这种方法对性能的影响是很大的。因为条件分支指令要等到执行之后的访存阶段，才能决定分支跳转是否发生，这就相当于流水线停顿了 2 个时钟周期。我们 MiniCPU 只有五级流水线，就停顿了这么久，像 intel 的酷睿 i7 处理器流水线，它的深度有十几级，如果也用停顿的方法，那延时损失就更大了。</p><p>既然阻塞流水线直到分支指令执行完成的方法非常耗时，浪费了太多流水线的时钟周期。那么，有没有一种方法既能解决控制冒险问题，又不影响流水线的性能呢？</p><p>很遗憾，答案是否定的。到目前为止，我们还没有找到根本性的解决控制冒险问题的方法。</p><figure><img src="'+u+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>但是，这并不代表我们没有办法去优化它，我们可以采用<strong>分支预测</strong>的方法提升分支阻塞的效率。</p><p>具体思路是这样的，当每次遇到条件分支指令时，预测分支会发生跳转，直接在分支指令的下一条取跳转后相应地址的指令。如果分支发生跳转的概率是 50%，那么这种优化方式就可以减少一半由控制冒险带来的性能损失。</p><p>其实我们第六节课取指阶段设计的预读取模块（if_pre.v），实现的就是这个功能，相关代码如下：</p><div class="language-verilog line-numbers-mode" data-ext="verilog"><pre class="language-verilog"><code>    <span class="token keyword">wire</span> is_bxx <span class="token operator">=</span> <span class="token punctuation">(</span>instr<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">\`OPCODE_BRANCH</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//条件挑转指令的操作码</span>
    <span class="token keyword">wire</span> is_jal <span class="token operator">=</span> <span class="token punctuation">(</span>instr<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">\`OPCODE_JAL</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>     <span class="token comment">//无条件跳转指令的操作码</span>
    
    <span class="token comment">//B型指令的立即数拼接</span>
    <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> bimm  <span class="token operator">=</span> <span class="token operator">{{</span><span class="token number">20</span><span class="token operator">{</span>instr<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token operator">}}</span><span class="token punctuation">,</span> instr<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> instr<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">:</span><span class="token number">25</span><span class="token punctuation">]</span><span class="token punctuation">,</span> instr<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1&#39;b0</span><span class="token operator">}</span><span class="token punctuation">;</span>
    <span class="token comment">//J型指令的立即数拼接</span>
    <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> jimm  <span class="token operator">=</span> <span class="token operator">{{</span><span class="token number">12</span><span class="token operator">{</span>instr<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token operator">}}</span><span class="token punctuation">,</span> instr<span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">:</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">,</span> instr<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">,</span> instr<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">:</span><span class="token number">21</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1&#39;b0</span><span class="token operator">}</span><span class="token punctuation">;</span>
    <span class="token comment">//指令地址的偏移量</span>
    <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> adder <span class="token operator">=</span> is_jal <span class="token operator">?</span> jimm <span class="token punctuation">:</span> <span class="token punctuation">(</span>is_bxx <span class="token operator">&amp;</span> bimm<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> bimm <span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token keyword">assign</span> pre_pc <span class="token operator">=</span> pc <span class="token operator">+</span> adder<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看到这你可能还有疑问，如果条件分支不发生跳转的话又会怎么样呢？这种情况下，已经被读取和译码的指令就会被丢弃，流水线继续从不分支的地址取指令。</p><p>要想丢弃指令也不难，只需要把流水线中的控制信号和数据清“0”即可，也就是当预测失败的分支指令执行之后，到达访存阶段时，需要将流水线中处于取指、译码和执行阶段的指令清除。</p><p>我先展示一下控制冒险模块的整体代码，之后再详细解读。代码如下所示：</p><div class="language-verilog line-numbers-mode" data-ext="verilog"><pre class="language-verilog"><code><span class="token keyword">module</span> hazard <span class="token punctuation">(</span>
  <span class="token keyword">input</span>  <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>  rs1<span class="token punctuation">,</span>
  <span class="token keyword">input</span>  <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>  rs2<span class="token punctuation">,</span>
  <span class="token keyword">input</span>         alu_result_0<span class="token punctuation">,</span>
  <span class="token keyword">input</span>  <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>  id_ex_jump<span class="token punctuation">,</span>
  <span class="token keyword">input</span>         id_ex_branch<span class="token punctuation">,</span>
  <span class="token keyword">input</span>         id_ex_imm_31<span class="token punctuation">,</span>
  <span class="token keyword">input</span>         id_ex_memRead<span class="token punctuation">,</span>
  <span class="token keyword">input</span>         id_ex_memWrite<span class="token punctuation">,</span>
  <span class="token keyword">input</span>  <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>  id_ex_rd<span class="token punctuation">,</span>
  <span class="token keyword">input</span>  <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>  ex_mem_maskMode<span class="token punctuation">,</span>
  <span class="token keyword">input</span>         ex_mem_memWrite<span class="token punctuation">,</span>
  <span class="token keyword">output</span> <span class="token keyword">reg</span>    pcFromTaken<span class="token punctuation">,</span>
  <span class="token keyword">output</span> <span class="token keyword">reg</span>    pcStall<span class="token punctuation">,</span>
  <span class="token keyword">output</span> <span class="token keyword">reg</span>    IF_ID_stall<span class="token punctuation">,</span>
  <span class="token keyword">output</span> <span class="token keyword">reg</span>    ID_EX_stall<span class="token punctuation">,</span>
  <span class="token keyword">output</span> <span class="token keyword">reg</span>    ID_EX_flush<span class="token punctuation">,</span>
  <span class="token keyword">output</span> <span class="token keyword">reg</span>    EX_MEM_flush<span class="token punctuation">,</span>
  <span class="token keyword">output</span> <span class="token keyword">reg</span>    IF_ID_flush
<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">wire</span> branch_do <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>alu_result_0 <span class="token operator">&amp;</span> <span class="token operator">~</span>id_ex_imm_31<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token operator">~</span>alu_result_0 <span class="token operator">&amp;</span> id_ex_imm_31<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">wire</span> ex_mem_taken <span class="token operator">=</span> id_ex_jump<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token punctuation">(</span>id_ex_branch <span class="token operator">&amp;</span> branch_do<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">wire</span> id_ex_memAccess <span class="token operator">=</span> id_ex_memRead <span class="token operator">|</span> id_ex_memWrite<span class="token punctuation">;</span> 
  <span class="token keyword">wire</span> ex_mem_need_stall <span class="token operator">=</span> ex_mem_memWrite <span class="token operator">&amp;</span> <span class="token punctuation">(</span>ex_mem_maskMode <span class="token operator">==</span> <span class="token number">2&#39;h0</span> <span class="token operator">|</span> ex_mem_maskMode <span class="token operator">==</span> <span class="token number">2&#39;h1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>
    <span class="token function">if</span><span class="token punctuation">(</span>id_ex_memAccess <span class="token operator">&amp;&amp;</span> ex_mem_need_stall<span class="token punctuation">)</span> <span class="token keyword">begin</span>
      pcFromTaken  <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      pcStall      <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
      IF_ID_stall  <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
      IF_ID_flush  <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      ID_EX_stall  <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
      ID_EX_flush  <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      EX_MEM_flush <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">end</span>
    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>ex_mem_taken<span class="token punctuation">)</span> <span class="token keyword">begin</span> 
      pcFromTaken  <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
      pcStall      <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
      IF_ID_flush  <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
      ID_EX_flush  <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
      EX_MEM_flush <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">end</span>
    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>id_ex_memRead <span class="token operator">&amp;</span> <span class="token punctuation">(</span>id_ex_rd <span class="token operator">==</span> rs1 <span class="token operator">||</span> id_ex_rd <span class="token operator">==</span> rs2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>
      pcFromTaken <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      pcStall     <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
      IF_ID_stall <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
      ID_EX_flush <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">end</span>
    <span class="token keyword">else</span> <span class="token keyword">begin</span>
      pcFromTaken    <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
      pcStall        <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
      IF_ID_stall    <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      ID_EX_stall    <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      ID_EX_flush    <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      EX_MEM_flush   <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
      IF_ID_flush    <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">end</span>
  <span class="token keyword">end</span>
<span class="token keyword">endmodule</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先我们来看看在控制冒险模块中，内部产生的几个信号都起到了怎样的作用。</p><p>branch_do 信号就是条件分支指令的条件比较结果，由 ALU 运算结果和立即数的最高位（符合位）通过“与”操作得到；ex_mem_taken 是确认分支指令跳转的信号，由无条件跳转（jump）“或”条件分支指令（branch）产生。</p><p>id_ex_memAccess 是存储器的选通信号，当对存储器的“读”或者“写”控制信号有效时产生；ex_mem_need_stall 信号表示流水线需要停顿，当执行 sb 或者 sh 指令时就会出现这样的情况。</p><p>然后，再来看看我们这个模块要输出的几个信号。</p><div class="language-verilog line-numbers-mode" data-ext="verilog"><pre class="language-verilog"><code>  <span class="token keyword">wire</span> branch_do <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>alu_result_0 <span class="token operator">&amp;</span> <span class="token operator">~</span>id_ex_imm_31<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token operator">~</span>alu_result_0 <span class="token operator">&amp;</span> id_ex_imm_31<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">wire</span> ex_mem_taken <span class="token operator">=</span> id_ex_jump<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token punctuation">(</span>id_ex_branch <span class="token operator">&amp;</span> branch_do<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">wire</span> id_ex_memAccess <span class="token operator">=</span> id_ex_memRead <span class="token operator">|</span> id_ex_memWrite<span class="token punctuation">;</span> 
  <span class="token keyword">wire</span> ex_mem_need_stall <span class="token operator">=</span> ex_mem_memWrite <span class="token operator">&amp;</span> <span class="token punctuation">(</span>ex_mem_maskMode <span class="token operator">==</span> <span class="token number">2&#39;h0</span> <span class="token operator">|</span> ex_mem_maskMode <span class="token operator">==</span> <span class="token number">2&#39;h1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>pcFromTaken 是分支指令执行之后，判断和分支预测方向是否一致的信号。pcStall 是控制程序计数器停止的信号，如果程序计数器停止，那么流水线将不会读取新的指令。IF_ID_stall 是流水线中从取指到译码的阶段的停止信号。ID_EX_stall 是流水线从译码到执行阶段的停止信号。</p><p>此外，当流水线需要冲刷时，就会产生取指、译码、执行、访存阶段的清零信号，分别对应着 ID_EX_flush、EX_MEM_flush 和 IF_ID_flush 信号。</p><div class="language-verilog line-numbers-mode" data-ext="verilog"><pre class="language-verilog"><code>  <span class="token keyword">output</span> <span class="token keyword">reg</span>    pcFromTaken<span class="token punctuation">,</span>  <span class="token comment">//分支指令执行结果，判断是否与预测方向一样</span>
  <span class="token keyword">output</span> <span class="token keyword">reg</span>    pcStall<span class="token punctuation">,</span>    <span class="token comment">//程序计数器停止信号</span>
  <span class="token keyword">output</span> <span class="token keyword">reg</span>    IF_ID_stall<span class="token punctuation">,</span>  <span class="token comment">//流水线IF_ID段停止信号</span>
  <span class="token keyword">output</span> <span class="token keyword">reg</span>    ID_EX_stall<span class="token punctuation">,</span>  <span class="token comment">//流水线ID_EX段停止信号</span>
  <span class="token keyword">output</span> <span class="token keyword">reg</span>    ID_EX_flush<span class="token punctuation">,</span>  <span class="token comment">//流水线ID_EX段清零信号</span>
  <span class="token keyword">output</span> <span class="token keyword">reg</span>    EX_MEM_flush<span class="token punctuation">,</span>   <span class="token comment">//流水线EX_MEM段清零信号</span>
  <span class="token keyword">output</span> <span class="token keyword">reg</span>    IF_ID_flush    <span class="token comment">//流水线IF_ID段清零信号</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>什么情况下才会产生上面的控制信号呢？一共有三种情况，我这就带你依次分析一下。</p><p>**第一种情况是解决数据相关性问题。**数据相关指的是指令之间存在的依赖关系。当两条指令之间存在相关关系时，它们就不能在流水线中重叠执行。</p><p>例如，前一条指令是访存指令 Store，后一条也是 Load 或者 Store 指令，因为我们采用的是同步 RAM，需要先读出再写入，占用两个时钟周期，所以这时要把之后的指令停一个时钟周期。</p><div class="language-verilog line-numbers-mode" data-ext="verilog"><pre class="language-verilog"><code>    <span class="token function">if</span><span class="token punctuation">(</span>ID_EX_memAccess <span class="token operator">&amp;&amp;</span> EX_MEM_need_stall<span class="token punctuation">)</span> <span class="token keyword">begin</span>
      pcFromTaken  <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      pcStall      <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
      IF_ID_stall  <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
      IF_ID_flush  <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      ID_EX_stall  <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
      ID_EX_flush  <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      EX_MEM_flush <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">end</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>**第二种情况是分支预测失败的问题，**当分支指令执行之后，如果发现分支跳转的方向与预测方向不一致。这时就需要冲刷流水线，清除处于取指、译码阶段的指令数据，更新 PC 值。</p><div class="language-verilog line-numbers-mode" data-ext="verilog"><pre class="language-verilog"><code> <span class="token comment">// 分支预测失败，需要冲刷流水线，更新pc值</span>
    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>EX_MEM_taken<span class="token punctuation">)</span> <span class="token keyword">begin</span> 
      pcFromTaken  <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span> 
      pcStall      <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
      IF_ID_flush  <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
      ID_EX_flush  <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
      EX_MEM_flush <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
    <span class="token keyword">end</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第三种情况就是解决上一节课提到的<strong>数据冒险问题</strong>。当前一条指令是 Load，后一条指令的源寄存器 rs1 和 rs2 依赖于前一条从存储器中读出来的值，需要把 Load 指令之后的指令停顿一个时钟周期，而且还要冲刷 ID _EX 阶段的指令数据。</p><div class="language-verilog line-numbers-mode" data-ext="verilog"><pre class="language-verilog"><code>    <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>ID_EX_memRead <span class="token operator">&amp;</span> <span class="token punctuation">(</span>ID_EX_rd <span class="token operator">==</span> rs1 <span class="token operator">||</span> ID_EX_rd <span class="token operator">==</span> rs2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">begin</span>
      pcFromTaken <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      pcStall     <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
      IF_ID_stall <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
      ID_EX_flush <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">end</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解决了流水线的冒险问题，我们才能确保指令经过流水线执行后，得到的结果是正确的，这时候才能把执行结果写回到寄存器。接下来，让我们来继续完成写回阶段的模块设计。</p><h2 id="写回控制模块设计" tabindex="-1"><a class="header-anchor" href="#写回控制模块设计" aria-hidden="true">#</a> 写回控制模块设计</h2><p>现在我们来到了流水线的最后一级——结果写回。先来看看写回控制模块，这个模块实现起来就非常简单了，它的作用就是选择存储器读取回来的数据作为写回的结果，还是选择流水线执行运算之后产生的数据作为写回结果。</p><p>具体代码如下：</p><div class="language-verilog line-numbers-mode" data-ext="verilog"><pre class="language-verilog"><code><span class="token keyword">module</span> <span class="token function">mem_wb_ctrl</span><span class="token punctuation">(</span>
  <span class="token keyword">input</span>   clk<span class="token punctuation">,</span>
  <span class="token keyword">input</span>   reset<span class="token punctuation">,</span>
  <span class="token keyword">input</span>   in_wb_ctrl_toReg<span class="token punctuation">,</span>
  <span class="token keyword">input</span>   in_wb_ctrl_regWrite<span class="token punctuation">,</span>
  
  <span class="token keyword">output</span>  data_wb_ctrl_toReg<span class="token punctuation">,</span>
  <span class="token keyword">output</span>  data_wb_ctrl_regWrite
<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">reg</span>  reg_wb_ctrl_toReg<span class="token punctuation">;</span> 
  <span class="token keyword">reg</span>  reg_wb_ctrl_regWrite<span class="token punctuation">;</span> 
  <span class="token keyword">assign</span> data_wb_ctrl_toReg <span class="token operator">=</span> reg_wb_ctrl_toReg<span class="token punctuation">;</span> 
  <span class="token keyword">assign</span> data_wb_ctrl_regWrite <span class="token operator">=</span> reg_wb_ctrl_regWrite<span class="token punctuation">;</span> 
  <span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">posedge</span> reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span> 
      reg_wb_ctrl_toReg <span class="token operator">&lt;=</span> <span class="token number">1&#39;h0</span><span class="token punctuation">;</span> 
    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span> 
      reg_wb_ctrl_toReg <span class="token operator">&lt;=</span> in_wb_ctrl_toReg<span class="token punctuation">;</span> 
    <span class="token keyword">end</span>
  <span class="token keyword">end</span>
  <span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">posedge</span> reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span> 
      reg_wb_ctrl_regWrite <span class="token operator">&lt;=</span> <span class="token number">1&#39;h0</span><span class="token punctuation">;</span> 
    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span> 
      reg_wb_ctrl_regWrite <span class="token operator">&lt;=</span> in_wb_ctrl_regWrite<span class="token punctuation">;</span> 
    <span class="token keyword">end</span>
  <span class="token keyword">end</span>
<span class="token keyword">endmodule</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码里有两个重要的信号需要你留意。一个是写回寄存器的数据选择信号 wb_ctrl_toReg，当这个信号为“1”时，选择从存储器读取的数值作为写回数据，否则把流水线的运算结果作为写回数据。另一个是寄存器的写控制信号 wb_ctrl_regWrite，当这个信号为“1”时，开始往目标寄存器写回指令执行的结果。</p><h2 id="写回数据通路模块设计" tabindex="-1"><a class="header-anchor" href="#写回数据通路模块设计" aria-hidden="true">#</a> 写回数据通路模块设计</h2><p>和写回的控制模块一样，流水线的最后一级的写回数据通路上的信号也变得比较少了。</p><p>写回数据通路模块产生的信号主要包括写回目标寄存器的地址 reg_WAddr，流水线执行运算后的结果数据 result，从存储器读取的数据 readData。</p><p>写回数据通路的模块代码如下：</p><div class="language-verilog line-numbers-mode" data-ext="verilog"><pre class="language-verilog"><code><span class="token keyword">module</span> <span class="token function">mem_wb</span><span class="token punctuation">(</span>
  <span class="token keyword">input</span>         clk<span class="token punctuation">,</span>
  <span class="token keyword">input</span>         reset<span class="token punctuation">,</span>
  <span class="token keyword">input</span>  <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>  in_regWAddr<span class="token punctuation">,</span>
  <span class="token keyword">input</span>  <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> in_result<span class="token punctuation">,</span>
  <span class="token keyword">input</span>  <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> in_readData<span class="token punctuation">,</span>
  <span class="token keyword">input</span>  <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> in_pc<span class="token punctuation">,</span>
  <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>  data_regWAddr<span class="token punctuation">,</span>
  <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> data_result<span class="token punctuation">,</span>
  <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> data_readData<span class="token punctuation">,</span>
  <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> data_pc
<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>  reg_regWAddr<span class="token punctuation">;</span> 
  <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> reg_result<span class="token punctuation">;</span> 
  <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> reg_readData<span class="token punctuation">;</span> 
  <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> reg_pc<span class="token punctuation">;</span> 
  <span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">posedge</span> reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span> 
      reg_regWAddr <span class="token operator">&lt;=</span> <span class="token number">5&#39;h0</span><span class="token punctuation">;</span> 
    <span class="token keyword">end</span> <span class="token keyword">else</span>  <span class="token keyword">begin</span> 
      reg_regWAddr <span class="token operator">&lt;=</span> in_regWAddr<span class="token punctuation">;</span> 
    <span class="token keyword">end</span>
  <span class="token keyword">end</span>
  <span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">posedge</span> reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span> 
      reg_result <span class="token operator">&lt;=</span> <span class="token number">32&#39;h0</span><span class="token punctuation">;</span> 
    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span> 
      reg_result <span class="token operator">&lt;=</span> in_result<span class="token punctuation">;</span> 
    <span class="token keyword">end</span>
  <span class="token keyword">end</span>
  <span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">posedge</span> reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span> 
      reg_readData <span class="token operator">&lt;=</span> <span class="token number">32&#39;h0</span><span class="token punctuation">;</span> 
    <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span> 
      reg_readData <span class="token operator">&lt;=</span> in_readData<span class="token punctuation">;</span> 
    <span class="token keyword">end</span>
  <span class="token keyword">end</span>
  <span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">posedge</span> reset<span class="token punctuation">)</span> <span class="token keyword">begin</span>    
    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token keyword">begin</span> 
      reg_pc <span class="token operator">&lt;=</span> <span class="token number">32&#39;h0</span><span class="token punctuation">;</span> 
    <span class="token keyword">end</span> <span class="token keyword">else</span>  <span class="token keyword">begin</span> 
      reg_pc <span class="token operator">&lt;=</span> in_pc<span class="token punctuation">;</span> 
    <span class="token keyword">end</span>
  <span class="token keyword">end</span>
  <span class="token keyword">assign</span> data_regWAddr <span class="token operator">=</span> reg_regWAddr<span class="token punctuation">;</span> 
  <span class="token keyword">assign</span> data_result <span class="token operator">=</span> reg_result<span class="token punctuation">;</span> 
  <span class="token keyword">assign</span> data_readData <span class="token operator">=</span> reg_readData<span class="token punctuation">;</span> 
  <span class="token keyword">assign</span> data_pc <span class="token operator">=</span> reg_pc<span class="token punctuation">;</span> 
  
<span class="token keyword">endmodule</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>仔细观察代码，你是否发现和流水线的前面几级的数据通路模块相比，少了两个控制信号呢？</p><p>是的，写回阶段的模块没有了流水线的停止控制信号 stall 和流水线的冲刷控制信号 flush。这是因为写回阶段的数据经过了数据冒险和控制冒险模块的处理，已经可以确保流水线产生的结果无误了，所以写回阶段的数据不受停止信号 stall 和清零信号 flush 的控制。</p><p>到这里，我们要设计的迷你 CPU 的五级流水线就基本完成啦。</p><h2 id="重点回顾" tabindex="-1"><a class="header-anchor" href="#重点回顾" aria-hidden="true">#</a> 重点回顾</h2><p>最后我给你做个总结吧。</p><p>这节课我们先分析了流水线中存在的控制冒险问题，也就是当流水线中出现条件分支指令时，下一条指令还不确定从哪里取的问题。<em>最容易想到的解决方案</em>，就是在取出分支指令后，流水线马上停下来，等到分支指令的结果出来，确定下一条指令从哪个地址获取之后，流水线再继续。但是，这里流水线停顿的方式缺点很明显，<em>它会带来很多 CPU 的性能损失</em>。</p><p>于是，<em>我们采用了分支预测的方法</em>，预测每一条分支指令都会发生跳转，直接在分支指令的下一条取跳转后相应地址的指令。如果分支发生跳转的概率是 50%，<em>那么这种优化方式就可以减少一半由控制冒险带来的性能损失</em>。</p><p>最后，根据整个流水线执行后的数据，我们完成了流水线的最后一级，也就是<mark>写回控制模块</mark>和<mark>数据通路模块</mark>的设计。写回控制模块要么选择存储器读取回来的数据作为写回结果，要么选择流水线执行运算之后产生的数据作为写回结果。数据通路模块则包含了写回目标寄存器的地址、ALU 的运算结果以及访存阶段读存储器得到的数据。</p><figure><img src="`+k+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>到这里，我们终于把 CPU 的五级流水线的最后一级设计完成了，这代表基于指令集 RV32I 的迷你 CPU 核心代码设计已经完成。很快就可以让它跑程序了，你是不是很期待呢？下一节课我们就可以看到效果了！</p><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题" aria-hidden="true">#</a> 思考题</h2><p>除了流水线停顿和分支预测方法，是否还有其他解决控制冒险问题的办法？</p><p>欢迎你在留言区跟我交流互动，或者记录下你的思考与收获。如果觉得这节课还不错，别忘了分享给身边的朋友，我们一起来手写 CPU！</p><blockquote><p>缩减单次指令程序流执行规模（比如执行三次，假如分支预测概率为50%，第一次下去，后面两次预测一次性对的概率为0.25。执行六次则预测对的概率更低）<br> 还有一个方法增加晶体管的规模，假如分支预测的概率为50%，增加晶体管规模，也能提高分支预测命中率（就好比，把所有的可能在同一时间利用不同的晶体管组走一遍）！<br> 作者回复: 66666 有见解</p><p>还有其他的办法，第一种，延迟分支，在分支指令之后插入一条一定会执行的指令（根据编译器和系统来确定），这样可以充分利用时钟周期；第二种，多分支执行，跳转和不跳转并行取指，哪条不执行就丢掉<br> 作者回复: 66666</p><p>老师，请问要跑仿真的话，是还需要assembler的代码吗？谢谢<br> 作者回复: 需要</p></blockquote>',62);function w(y,h){const a=p("ExternalLinkIcon");return t(),o("div",null,[m,v,n("p",null,[s("今天我们一起来完成迷你 CPU 的最后一个部分——"),b,s("（"),n("a",_,[s("课程代码在这里"),l(a)]),s("）。")]),g])}const I=e(d,[["render",w],["__file","F10-手写CPU（五）.html.vue"]]);export{I as default};
