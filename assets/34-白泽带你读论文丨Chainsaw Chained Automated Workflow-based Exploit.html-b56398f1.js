import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o as n,c as r,a,b as e,e as s,d as p}from"./app-cdabc73c.js";const l="/assets/640-1691475315464-312-a61d7082.png",d="/assets/640-1691475315464-313-bb1fd2a2.png",h="/assets/640-1691475315465-314-30c2b060.png",c="/assets/640-1691475315465-315-a8982726.png",g="/assets/640-1691475315465-316-b108ba6b.png",f="/assets/640-1691475315465-317-ed258b37.png",_="/assets/640-1691475315465-318-7a397a45.png",u="/assets/640-1691475315465-319-8ea0d842.png",m={},S=a("h1",{id:"_34-白泽带你读论文丨chainsaw-chained-automated-workflow-based-exploit",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#_34-白泽带你读论文丨chainsaw-chained-automated-workflow-based-exploit","aria-hidden":"true"},"#"),e(" 34-白泽带你读论文丨Chainsaw: Chained Automated Workflow-based Exploit")],-1),x=a("p",null,[a("strong",null,"Chainsaw: Chained Automated Workflow-based Exploit Generation")],-1),b={href:"https://sisl.rites.uic.edu/static/pics/fp0612-alhuzali.pdf",target:"_blank",rel:"noopener noreferrer"},w=p('<p>本文发表在CCS 2016，第一作者是来自伊利诺伊大学芝加哥分校的Abeer Alhuzali</p><h2 id="_1-主要内容" tabindex="-1"><a class="header-anchor" href="#_1-主要内容" aria-hidden="true">#</a> <strong>1 主要内容</strong></h2><p>在Web应用中漏洞挖掘有两个主要的思路，一种是静态分析，另外一种是动态分析。本文主要基于静态分析，并在结合动态分析的基础上对<mark>SQL注入</mark>以及<mark>XSS注入</mark>这两类漏洞进行分析和处理。这两类注入漏洞的成因都是类似的，均是由过度信任用户输入导入，程序正常运行逻辑被用户的输入数据所篡改，形成的非预期行为。</p><p>针对以上的这两种漏洞，也有<em>常见的扫描器</em>例如SQLMAP可以针对SQL注入进行扫描，但SQLMAP能扫描到的SQL漏洞大多都是直接反馈交互的，即在同一个页面或者Module上，用户给定的输入，输出就会及时地反馈回来，<em>如果存在模块之间跨越传递的行为</em>，SQLMAP就无法准确地捕获输出也就没办法判定这种漏洞了，同样针对XSS的扫描器也是类似的思路。</p><p>作者在文中提出，首先通过静态分析的方法，先找到一个潜在的可利用的SQL注入和XSS注入点，构造一个Exploit Seed值，这个Seed中保存了可以触发这个Sink的操作值，并同时分析出Module之间的跳转关系，然后构造一个Module之间的一个路径图，从这个图中确定一个从Public Page到Sink的模块间的转移路径。然后在这个图的基础上，根据一个作者提出的Global Execution Paths 概念，构造一个包含超全局变量的Module执行路径。至此，就可以找到模块执行路径以及需要的变量参数和漏洞利用点，将这些值作为约束条件来求解，如果存在有解，那么就可以生成相应的HTTP请求来触发Exploit。</p><h2 id="_2-设计与实现" tabindex="-1"><a class="header-anchor" href="#_2-设计与实现" aria-hidden="true">#</a> <strong>2 设计与实现</strong></h2><figure><img src="'+l+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>Chainsaw的整体工作流程如上图所示，具体的工作可以分为以下三个阶段：</p><h3 id="a-seed-generation" tabindex="-1"><a class="header-anchor" href="#a-seed-generation" aria-hidden="true">#</a> a. Seed Generation</h3><figure><img src="'+d+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>在Pixy和TAPS的工作基础上，Chainsaw首先分析生成Seeds。Seed是一对值(S, I )，S是一个可利用点，即上图中红色标记部分的SQL注入点，I是一个集合，表示了触发S所要执行的数值操作I = {(i1 , v1 ), ...(in , vn )}。根据红色处的Sink点关键变量$cat_desc，向上回溯找到与之相关的变量值，并用黄色块标记，最终生成如下表达式：</p><figure><img src="'+h+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>Fa是分析找到的可利用漏洞点的payload，Fp是指根据如上的分析与触发S这个漏洞点相关的操作，通过约束求解，判定该Sink点是否可以被触发。</p><h3 id="b-the-general-workflow-graph" tabindex="-1"><a class="header-anchor" href="#b-the-general-workflow-graph" aria-hidden="true">#</a> b. The General Workflow Graph</h3><figure><img src="'+c+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>根据静态分析过程，生成The General Workflow Graph，该图中每个Node表示一个PHP文件，边的权值是前向模块可以向后向模块跳转的路径数。假定Sink点在create.php文件，Public Page为room.php文件，从room.php转移到create.php主要有两条路径：</p><ol><li>从(room.php-&gt;dashboard.php-&gt;create.php)，此时转移方式共有10种，路径组合方式有2^10种</li><li>从(room.php-&gt;check.php-&gt;create.php) 此时转移方式共有12种，路径组合方式有2^12种</li></ol><p>根据最小原则，优先选择组合少的路径，越小的路径组合数可以有效减少状态分析的时间开销，此时就已经找到了可行的模块跳转路径。</p><h3 id="c-refined-workflow-graph" tabindex="-1"><a class="header-anchor" href="#c-refined-workflow-graph" aria-hidden="true">#</a> c. Refined Workflow Graph</h3><figure><img src="'+g+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>根据以上结果，重定义Refined Workflow Graph，在该图中，会根据The General Workflow Graph图中选定的模块路径，将每个模块可行的转移方式都罗列出来，并同时形成右图所示表格，右表表示每一个选择的Node节点，以及相对应的Preconditions和Summary。Preconditions是指转移到这个状态所需要的一些变量的先决条件，Summary指的是在此状态中会进行赋值操作的超全局变量。例如针对room_name变量，如果存在像图中黄色标记所示路径，即先判定room_name存在，同时仅对$_SESSION[&#39;room_name&#39;]有一次修改，并且随后的模块中都存在将这个超全局变量作为先决条件，那么room_name的超全局路径就可作为一个约束条件来求解最后的约束值。</p><p>针对二次注入的问题，作者提出了两种方法来解决：</p><ol><li>静态方法，构建一个map映射表，map表中记录对数据库的write操作，约束求解时会从map表中去查询需要的值。</li><li>动态方法，根据需要的值Chainsaw能动态地从从数据库中去查询相应的值（但仅支持MySQL在内几款主流数据库）。</li></ol><p>通过利用Exploit Seed，以及从Public Module到Sink的Module执行路径和执行路径上所需要的超全局变量和二次注入所需变量，进行约束求解，生成对应的HTTP请求序列。</p><h2 id="_3-实验评估" tabindex="-1"><a class="header-anchor" href="#_3-实验评估" aria-hidden="true">#</a> <strong>3 实验评估</strong></h2><figure><img src="'+f+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>作者将Chainsaw部署在一台双核的Ubuntu12.04操作系统上，针对9个PHP常见的系统应用进行测试，项目规模涉及大中小项目，项目代码中也存在一定数量的潜在SQL注入点和XSS注入点。</p><figure><img src="'+_+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>Chainsaw总共生成了181个Exploit Seeds ，求解得到了总共199可用的Exploit，其中包括149个SQL注入Exploit约占75%，50个XSS漏洞，约占25%，同时从另一个角度来看，199个Exploit中发现了30个可利用的二次注入Exploit，13个是SQL二次注入，17个存储型XSS，同时作者也强调Chainsaw所有生成的可用的Exploit是没有误报的，误报率是0。针对误报率是0的情况，前文静态分析指出潜在的可利用的XSS点和SQL注入点还是很多的，但分析生成的Seed只有181个，总体上认为Chainsaw判定生成Seed整体还是采用的一种相对保守的策略，对有较大把握的漏洞点才将其作为Seed来进行处理，这也是最后误报率比较低的一个原因。</p><figure><img src="'+u+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>同时在和其他同类型的exp生成软件的对比中也发现，在发现可利用的exp方面也较其他软件Ardilla和CraxWeb有较大的优势。</p><h2 id="_4-总体评价" tabindex="-1"><a class="header-anchor" href="#_4-总体评价" aria-hidden="true">#</a> <strong>4 总体评价</strong></h2><p>这篇文章主要的贡献有以下几点：</p><ul><li>一个是提出了一种基于漏洞点sink，正向构造一组HTTP请求，自动化完成对漏洞点exp的生成；</li><li>二是实现了Chainsaw系统，检测系统中的SQL注入和XSS漏洞（包括二次注入漏洞），并可以比较快速地生成可利用的exp；</li><li>最后Chainsaw对9个PHP Web应用自动化地生成了199可利用的Exploit，其中包括30难以发现的二次注入漏洞，并且没有误报。</li></ul><p>Chainsaw也存在一些设计上的不足，针对一些由JavaScript处理的逻辑部分，Chainsaw不能做好有效的识别和处理，同样地对PHP中面向对象的一些编程特性，Chainsaw在寻找约束时，不能做到有效识别并会出现一些超时的情况。但总体说来还是提供了一种新的构造可用exp的思路，并且准确率也是符合预期的。</p>',35);function k(C,P){const i=t("ExternalLinkIcon");return n(),r("div",null,[S,x,a("p",null,[e("原文链接："),a("a",b,[e("https://sisl.rites.uic.edu/static/pics/fp0612-alhuzali.pdf"),s(i)])]),w])}const Q=o(m,[["render",k],["__file","34-白泽带你读论文丨Chainsaw Chained Automated Workflow-based Exploit.html.vue"]]);export{Q as default};
