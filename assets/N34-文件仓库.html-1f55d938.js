import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{r as p,o as t,c as o,a as n,b as a,e as i,d as c}from"./app-cdabc73c.js";const r="/assets/38eac4fa5da3c13c080053e888b3976e-711ee942.jpg",l="/assets/a5ae613cff6e4ec5ce28b94642e09020-ec291cc8.jpg",d="/assets/0ed799de30956c5d556c454129738302-9dbcac00.jpg",u="/assets/1d5972af98579e1bdc03084fc194210f-38cb832d.jpg",k="/assets/2e9a33a77986838421195dc8185af40e-bb024e85.jpg",m="/assets/d9420e493a7292d801cda1ba6c57e9c7-267ff23b.jpg",h="/assets/2cdd7fe0120e47043c6b11441b1b0293-ae1a6ece.jpg",f={},b=n("h1",{id:"_34-文件仓库-初识文件与文件系统",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_34-文件仓库-初识文件与文件系统","aria-hidden":"true"},"#"),a(" 34｜文件仓库：初识文件与文件系统")],-1),g=n("p",null,"你好，我是 LMOS。",-1),v=n("p",null,"通过之前的学习，相信你或多或少都体会到“Linux 之下一切皆文件”的思想了。",-1),_=n("p",null,"数据是以文件的形式储存下来的，而文件数量一多，就需要文件系统来管理文件，而文件系统正是建立在之前我们学过的 IO 块设备之上，今天我就带你了解一下什么是文件，什么是文件系统。",-1),x={href:"https://gitee.com/lmos/Geek-time-computer-foundation/tree/master/lesson34",target:"_blank",rel:"noopener noreferrer"},S=c(`<h2 id="什么是文件" tabindex="-1"><a class="header-anchor" href="#什么是文件" aria-hidden="true">#</a> 什么是文件</h2><p>在日常生活中，我们提到的文件通常是指公文、信件，而计算机中的文件与日常见到的文件载体不同，是以计算机硬盘为载体、存储在计算机上的信息集合。</p><p>这些信息集合的呈现形式非常多样，可以是<strong>文本文档、图片、音乐、视频、应用程序</strong>等。文件通常由文件名进行标识和索引。</p><p>只说个概念的话，你很难对文件是什么有更深的理解，所以下面我们写代码建立一个文件感受一下。Linux 把建立文件的操作包含在了 open 调用中，open 调用既可以打开一个已经存在的文件，又可以建立一个新文件，代码如下所示：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">// 打开并建立文件,所有用户可读写</span>
    fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">&quot;empty.file&quot;</span><span class="token punctuation">,</span> O_RDWR<span class="token operator">|</span>O_CREAT<span class="token punctuation">,</span> S_IRWXU<span class="token operator">|</span>S_IRWXO<span class="token operator">|</span>S_IRWXG<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;建立文件失败\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 关闭文件</span>
    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码很简单，我们建立一个名为 empty.file 的文件。但是你需要注意的是，我们并没向该文件中写入任何数据，并且你可以在当前目录下看到，该文件的大小为 0。</p><h3 id="_1-标识-数据-设备-接口" tabindex="-1"><a class="header-anchor" href="#_1-标识-数据-设备-接口" aria-hidden="true">#</a> 1 标识：数据/设备/接口</h3><p>这说明了文件不一定要有数据，<em>它只是一个标识</em>，这个标识可以既标识<mark>数据</mark>、<mark>设备</mark>，还可以标识<mark>接口</mark>。</p><blockquote><p>（如 /proc 目录下的那些文件，<u>其实<em>内核</em>提供给<em>进程</em>的、用来访问特殊数据的<em>接口</em></u>）。</p></blockquote><p>现在我们再给文件下个定义，就可以说<strong>文件从广义上就是一种<code>资源标识</code>或者<code>对象标识</code></strong>。</p><p>我们继续基于前面的代码，完善一下，给向程序里写三个字节的数据，并且获取一下文件大小，代码如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">stat</span> filestat<span class="token punctuation">;</span>
    <span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> ch<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0xff</span><span class="token punctuation">,</span> <span class="token char">&#39;L&#39;</span><span class="token punctuation">,</span> <span class="token char">&#39;M&#39;</span><span class="token punctuation">,</span> <span class="token char">&#39;O&#39;</span><span class="token punctuation">,</span> <span class="token char">&#39;S&#39;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">// 打开并建立文件,所有用户可读写</span>
    fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">&quot;empty.file&quot;</span><span class="token punctuation">,</span> O_RDWR<span class="token operator">|</span>O_CREAT<span class="token punctuation">,</span> S_IRWXU<span class="token operator">|</span>S_IRWXO<span class="token operator">|</span>S_IRWXG<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;建立文件失败\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 向文件中写入3个字节，0，1，0xff，它们来源于ch数组</span>
    <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> ch<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取文件信息，比如文件大小</span>
    <span class="token function">fstat</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>filestat<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;文件大小:%ld\\n&quot;</span><span class="token punctuation">,</span> filestat<span class="token punctuation">.</span>st_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 关闭文件</span>
    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来，我们运行代码看看运行结果，如下图所示：</p><figure><img src="`+r+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="_2-信息集合-单位是字节" tabindex="-1"><a class="header-anchor" href="#_2-信息集合-单位是字节" aria-hidden="true">#</a> 2 信息集合：单位是字节</h3><p>从截图里我们看到了文件大小为 3，同时我们打开 empty.file 文件，观察里面的内容，也会发现是三个字节，与我们在代码中定义的一样。看到这个现象我们应该明白了：<strong>从狭义说，常规文件是<code>一个信息数据集合</code>，单位是<code>字节</code></strong>。</p><p>我们继续修改代码，写入 7 个字节，看看是什么情况。这里我们只需要修改 write 调用里的第三个参数，把它改为 7 就行了。代码我已经为你改写好了，我们直接看运行结果，如下所示：</p><figure><img src="'+l+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>同样地，我们看到了文件大小为 7，再次打开 empty.file 文件，同样也是七个字节，与代码中定义完全一样，对字符数据是存储它对应的 ASCII 码。</p><h3 id="_3-动态增长的字节数组" tabindex="-1"><a class="header-anchor" href="#_3-动态增长的字节数组" aria-hidden="true">#</a> 3 动态增长的字节数组</h3><p>看到这里，你有没有对文件产生什么新的思考呢？有没有发现，所谓<em>普通文件的结构</em>，本质上是<em>一个可以动态增长的线性字节数组</em>。无论文件是什么类型或者多大的数据，都会映射到对应的字节，占用一个或者多个字节空间。</p><h3 id="_4-文件元信息" tabindex="-1"><a class="header-anchor" href="#_4-文件元信息" aria-hidden="true">#</a> 4 文件元信息</h3><p>我们现在理解了文件是一种<mark>标识</mark>，也推理解出了文件储存数据的结构是什么样子，但是我不知道你有没有想过，<u>描述一个文件自身也需要很多信息</u>，我们可以把这些信息称为<mark>文件元信息</mark>。</p><p>比如上面用来表示文件大小的信息，就是文件的元信息。不过，文件不光有大小的信息，还有其它别的元信息。</p><p>我们继续来修改代码，试着获取文件的部分元信息。为什么是“部分“元信息呢？<em>因为在应用层有些元信息我们是获取不到的，操作系统也不会提供相应接口</em>。修改后的代码运行情况如下所示：</p><figure><img src="'+d+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>上图中，<mark>dev</mark> 表示文件所在的设备号，而 <mark>rdev</mark> 则是当文件是设备类型时的设备号。<mark>文件模式</mark>能表示文件或者目录，<mark>文件节点</mark>则表示该文件在文件系统中对应的 inode 号码。</p><h3 id="_5-inode节点-存储文件元信息" tabindex="-1"><a class="header-anchor" href="#_5-inode节点-存储文件元信息" aria-hidden="true">#</a> 5 inode节点：存储文件元信息</h3><p>inode 是文件系统中标识<mark>一个文件的元信息</mark>，上面这些信息大多都来自 inode 结构，<em>这些信息访问、修改、状态改变的时间是以秒为单位的</em>。上面的数据相同，是因为我们在一瞬间完成了文件的创建和修改。用户 id 和用户组 id 则表示该文件是哪个用户建立的，属于哪个用户组。</p><h3 id="_6-文件系统管理单位-块" tabindex="-1"><a class="header-anchor" href="#_6-文件系统管理单位-块" aria-hidden="true">#</a> 6 文件系统管理单位：块</h3><blockquote><p>所有块设备，也因此，能够安装文件系统。</p></blockquote><p>文件除了本身大小，在<mark>文件系统</mark>中还分成了<mark>块</mark>来存储，所以文件有块大小和文件占用了多少块这些信息。下面我们通过一幅逻辑结构图总结一下什么是文件：</p><img src="'+u+'" alt="img" style="zoom:25%;"><p>由上图可知普通文件的元信息中，不仅仅保存了文件相关的设备、时间、创建者、大小等相关信息，还保存了<em>文件数据块的索引信息</em>，这样才能找到这些数据块。这也从侧面证明了，一个普通文件必须有两个部分组成：一个部分为<strong>文件元数据</strong>，一部分为<strong>文件储存的数据</strong>。</p><h3 id="_7-文件储存的数据" tabindex="-1"><a class="header-anchor" href="#_7-文件储存的数据" aria-hidden="true">#</a> 7 文件储存的数据</h3><p><mark>文件</mark>在<mark>硬盘（一种块设备）<mark>上以</mark>块</mark>为单位储存，这些块的<mark>块号</mark>在==元信息（inode节点？）==中按照顺序索引起来，<em>就是整个文件的数据，这就是一个普通的数据文件</em>。普通数据文件的信息都存在储存设备上，这个设备通常是硬盘或硬盘分区（硬盘的一部分）。</p><p>如果只有一个软件，我们只要确定元数据和文件数据分别放在哪些扇区就可以，无论是查找、读写、删除，怎么处理都很容易。不幸的是，文件不可能只有一个，而是有成千上万甚至更多，所以这就必须要设计出<em>一套系统方案，来解决多个文件的操作管理</em>。</p><p>接下来，我们就聊聊文件管理系统，它是操作系统中一个巨大的功能模块。</p><h2 id="文件系统" tabindex="-1"><a class="header-anchor" href="#文件系统" aria-hidden="true">#</a> 文件系统</h2><p>我们先来搞清楚文件系统概念，文件系统是操作系统在<mark>存储设备（块设备）</mark>（常见的是硬盘、U 盘、CD，或者其分区）上构建的 <strong>储存文件方法 和 数据结构</strong>，也就是在存储设备上组织文件的方法。由于这个功能模块规模很大，操作系统专门起了一个名称，把负责管理和存储文件的功能模块称为<mark>文件管理系统</mark>，简称文件系统。</p><h3 id="三部分组成" tabindex="-1"><a class="header-anchor" href="#三部分组成" aria-hidden="true">#</a> ##三部分组成</h3><p>文件系统由三部分组成，分别是<mark>文件系统的接口</mark>、<mark>对文件操作和管理的功能集</mark>、<mark>文件及其属性</mark>。</p><p>从操作系统角度来看，文件系统的职责是组织和分配存储设备的空间、文件存储，以及对存入的文件进行保护和检索。具体点来说，文件系统给用户提供了文件相关操作的一条龙服务，包括为用户建立、存入、读出、修改、转储文件，控制文件的存取读取文件，当用户不再使用时还会删除文件。</p><h3 id="不同文件系统-格式化-不同数据结构" tabindex="-1"><a class="header-anchor" href="#不同文件系统-格式化-不同数据结构" aria-hidden="true">#</a> ##不同文件系统/格式化/不同数据结构</h3><p><em>一个硬盘中的<u>各个分区</u>上可以使用<u>不同的文件系统</u>，但是在使用之前，我们要对该分区进行<mark>格式化</mark></em>。所谓格式化，就是向该分区写入文件系统相关的信息，以及分配分区中相关扇区的<mark>数据结构</mark>。有了这些数据结构和信息，用户应用才能在文件系统里存放文件。</p><h3 id="逻辑视图-目录结构" tabindex="-1"><a class="header-anchor" href="#逻辑视图-目录结构" aria-hidden="true">#</a> ##逻辑视图：目录结构</h3><p>虽然文件系统的核心数据结构，现在我们还没法直观地感受到，但是它在上层为用户或者进程提供了<strong>一个逻辑视图</strong>，也就是<strong>目录结构，这是一个倒置的树形结构</strong>。</p><p>树的分支结构上是目录或者文件。从最上层的 /（根）目录开始，就能找到每个文件、每个目录和每个目录下的所有文件。目录对文件进行分层分类，目的是方便用户对众多文件做管理。我为你画了一幅图来展示这个结构，如下图所示：</p><img src="'+k+'" alt="img" style="zoom:25%;"><p>如上图所示，这是一棵倒树，根据上图中的各种路径，就可以找到其中的任意文件或者目录。例如我们在系统中输入:/home/user1/file1，这就表示其根“/”目录下“home”目录里的“file1”文件。</p><h2 id="文件系统规定各种数据结构" tabindex="-1"><a class="header-anchor" href="#文件系统规定各种数据结构" aria-hidden="true">#</a> ##文件系统规定各种数据结构</h2><p>了解了文件系统的逻辑结构之后，我们不妨进一步思考一下，假如让你来设计实现一个文件系统，你会怎样梳理它的结构呢？</p><p>我们先得设计<mark>描述整个文件系统信息的结构</mark>，其次要有<mark>描述目录的信息结构</mark>，然后是<mark>描述文件元信息结构</mark>，最后别忘了<mark>文件数据块结构</mark>。其实，Linux 上众多文件系统都是这么实现的，即使各文件系统在细节上有些变化，但是都具有类似的通用结构，其中心概念离不开超级块、目录结构、inode 节点以及数据块。下面我们分别进行讨论。</p><h3 id="_1-数据块-即文件存储的数据" tabindex="-1"><a class="header-anchor" href="#_1-数据块-即文件存储的数据" aria-hidden="true">#</a> 1 数据块：即文件存储的数据</h3><p>让我们从<strong>数据块说起</strong>，由于文件系统数据结构也是存放在数据块中的，所以第一个就要把它搞清楚。</p><p>对于这么多文件系统设计，文件系统首先会把硬盘或者硬盘分区划分为一个个数据块，每个数据块大小是硬盘扇区的整数倍，典型的数据块大小是 1024 字节或者 4096 字节。</p><p>这个大小，既可以在格式化硬盘或者硬盘分区创建文件系统的时候决定，也可以由管理员手动指定，还可以在文件系统的创建时根据硬盘分区的大小，动态选择一个较合理的值。</p><h3 id="_2-超级块-文件系统的控制信息" tabindex="-1"><a class="header-anchor" href="#_2-超级块-文件系统的控制信息" aria-hidden="true">#</a> 2 超级块：文件系统的控制信息</h3><p>我们再来看看<strong>超级块</strong>。超级块一般会放在硬盘分区的第一个或者第二个数据块中。超级块中的数据是<mark>描述文件系统的控制信息</mark>。</p><p>有关该文件系统的大部分信息都保存在超级块中，比如</p><ol><li>硬盘分区中有多少个数据块，</li><li>每个数据块的大小、</li><li>有多少个空闲数据块、</li><li>文件系统状态、</li><li>有多少目录或者文件、</li><li>文件系统名称、</li><li>UUID、</li><li>位图信息等。</li></ol><p>这些信息可以用来控制和描述一个可正常工作的文件系统。</p><h3 id="_3-目录结构-文件-文件夹" tabindex="-1"><a class="header-anchor" href="#_3-目录结构-文件-文件夹" aria-hidden="true">#</a> 3 目录结构：文件 + 文件夹</h3><p>接下来要说的是<strong>目录结构</strong>。目录结构很简单，里面就是文件名称和 inode 号组成的目录项，一个目录项可以是另一个目录，也可以是一个文件，所有的目录项共同组成了目录文件（特殊的文件）。根据目录项的 inode 节点号，我们就可以找到对应的文件的 inode。那 inode 是什么呢？我们接着往下看。</p><h3 id="_4-inode节点-文件元信息-地址可索引" tabindex="-1"><a class="header-anchor" href="#_4-inode节点-文件元信息-地址可索引" aria-hidden="true">#</a> 4 inode节点：文件元信息/地址可索引</h3><p>之前的课程里已经讲过文件数据都存放在数据块中，我们还必须使用一个数据结构来存储<mark>文件的元信息</mark>，这种存储文件元信息的数据结构叫做 <strong>inode</strong>（即索引节点，也经常叫作 inode 节点）。其实刚刚我们讲文件的时候就提过 inode，记不清的话你自己再回顾一下。</p><p>每一个文件都有对应的 inode，inode 包含了文件的元信息。也就是说，<em>除了文件名以外的所有文件信息</em>，都保存在 inode 之中，（文件名称在目录条目中），主要有<em>文件的字节数、文件的所属 uid、文件的所属组 GID、文件的读、写、执行权限，以及文件的创建、修改时间</em>等。</p><p>最重要的是，inode 节点中<strong>包括数据块的地址，用于索引文件对应的数据</strong>。但 inode 节点中只有少量数据块数的地址，如果需要更多，就需要动态分配指向数据块的地址空间。这些动态分配的数据块是间接地址数据块，为了找到数据块，必须先找到间接地址数据块的，然后从里面找到文件的数据块地址。</p><h2 id="vfs-以上数据结构打包管理" tabindex="-1"><a class="header-anchor" href="#vfs-以上数据结构打包管理" aria-hidden="true">#</a> VFS：以上数据结构打包管理</h2><p>有了上述四大核心结构，就可以表示一个文件系统了。其实 Linux 对<mark>超级块结构</mark>、<mark>目录结构</mark>，<mark>inode 结构</mark>以及<mark>数据块</mark>，还做了进一步抽象，<strong>把这些结构加入了操作函数集合</strong>，形成了 <mark>VFS，即虚拟文件系统</mark>。</p><p>只要软件模块能提供上述四大核心结构的操作函数集合，生成超级块结构，就可以形成一个文件系统实例，安装到 VFS 中。有了 VFS 层就可以向上<em>为应用程序提供统一的接口</em>，向下<em>兼容不同的文件系统</em>，让 Linux 能够同时安装不同的文件系统。</p><p>我为你画了一幅图，表示其架构，如下所示：</p><img src="'+m+'" alt="img" style="zoom:33%;"><p>你有没有发现？在计算机科学领域的很多问题，都可以通过增加一个中间的抽象层来解决，上图中 Linux 的 VFS 层就是应用和许多文件系统之间的抽象层。</p><p>VFS ，<em>向下规范了一个文件系统要接入 VFS 必需要实现的机制</em>。为此，VFS 提供了一系列数据结构，如 <mark>files</mark>、<mark>superblock</mark>、<mark>dentry</mark>、<mark>inode</mark> 结构，还规定了具体文件系统应该实现<mark>生成这些数据结构的 回调函数</mark>。这样，一个文件系统模块就可以被安装到 VFS 中了。操作具体文件时，VFS 会根据需要调用具体文件系统的函数。</p><p>从此文件系统的细节就被 VFS 屏蔽了，<em>应用程序只需要调用标准的接口就行了</em>。也正因如此，Linux 可以支持 <mark>EXT</mark>、<mark>XFS</mark>、<mark>BTRFS</mark>、<mark>FAT</mark>、<mark>NTFS</mark> 等多达十几种不同的文件系统，但不管在什么储存设备上使用什么文件系统，也不管访问什么文件，都可以统一地使用一套类似 <em>open()、read()、write()、close() 的接口</em>。</p><p>关于 VFS，我们就介绍到这里，更详细的 VFS 讲解，你可以参考我的另一门课程：《操作系统实战 45 讲》中第三十五节课《瞧一瞧 Linux：虚拟文件系统如何管理文件？》。</p><h2 id="重点回顾" tabindex="-1"><a class="header-anchor" href="#重点回顾" aria-hidden="true">#</a> 重点回顾</h2><p>这节课我带你了解了文件和文件系统。</p><p>文件是一种资源对象的标识，可以标识最简单常见的数据文件，也可以标识一个设备或者一种访问内核的数据接口。普通文件有许多元信息和数据块组成，它们通常保存硬盘中的扇区中。</p><p>而文件数量一多，就需要文件系统来管理。文件系统为应用程序提供了一个逻辑视图，具体是一棵倒立的树结构，方便用户管理众多文件。</p><p>为了把众多文件存储到硬盘中，文件系统用一棵倒立的目录树来存放各种类型的文件，从根目录开始就可以找到所有的目录和文件。其次我们还了解到了文件系统的内部概念，如超级块，目录结构，inode 节点，数据块等。</p><p>Linux 系统为了支持多种类型的文件系统，还进一步抽象出了 VFS。任何文件系统模块只要符合 VFS 对数据结构和操作函数集合的要求，都可以安装到 VFS 层中。VFS 的出现使得 Linux 支持多种文件系统成为可能。</p><p>我还给你准备了一张导图，你可以做个参考。</p><figure><img src="'+h+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>看到这里，我知道你意犹未尽或者还有许多疑问，我们将在下一节课深入探讨 EXT 文件系统的内部实现细节，相信那时你会对文件系统是怎么一回事，有个更深的理解。</p><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题" aria-hidden="true">#</a> 思考题</h2><p>一般的 Linux 上的文件系统都有哪些内部结构？</p><p>期待你在留言区分享你的学习收获或疑问，如果这节课对你有帮助，别忘了分享给更多朋友，说不定就能让他对文件系统有个新认识。</p><blockquote><p>请教老师一个问题：<br> 对inode的理解：<br> 假如一个文件需要100个数据块，但inode中不会保存全部100个数据块的地址，只会保存部分（比如10个）数据块，是这样吗？</p><p>另外，什么时候会需要动态分配指向数据块的内存空间？会动态分配全部100个数据块的地址空间吗？<br> 作者回复: 是这样 根据文件大小动态分配的</p><hr><p>ext4和ntfs文件系统有哪些区别呀？为啥win系统不能直接识别ext4文件，是因为缺钱像vfs这样的虚拟文件管理吗？<br> 作者回复: 那区别很大 完全不同的</p><hr><p>思考，数据块，超级块，目录结构，inode节点<br> 作者回复: 是的</p></blockquote>',90);function y(F,V){const s=p("ExternalLinkIcon");return t(),o("div",null,[b,g,v,_,n("p",null,[a("还是延续之前的风格，学习过程中有动手实践的部分。这节课的配套代码，"),n("a",x,[a("你可以从这里下载"),i(s)]),a("。让我们正式开始今天的探索之旅吧！")]),S])}const L=e(f,[["render",y],["__file","N34-文件仓库.html.vue"]]);export{L as default};
